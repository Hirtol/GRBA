<HTML><HEAD>
  <TITLE>GBATEK - GBA/NDS Technical Info</TITLE>
  <META NAME="GENERATOR" CONTENT="nocash help engine">
</HEAD><BODY bgcolor="#ffffff" text="#000000" link="#0033cc" vlink="#0033cc" alink="#0033cc">

<!--------------------------------------->

<CENTER>
<A NAME="gbatek"></A><FONT SIZE=+3>GBATEK</FONT><BR>
Gameboy Advance / Nintendo DS / DSi - Technical Info - Extracted from no$gba version 2.8a<BR>
<A HREF="#aboutthisdocument">About this Document</A><BR>
<BR>
</CENTER>

<!--------------------------------------->

        <TABLE WIDTH=100%><TR><TD WIDTH=33% VALIGN=TOP>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>&nbsp;GBA Reference</FONT></TD></TR></TABLE><BR>
<B>Overview</B><BR>
<A HREF="#gbatechnicaldata">GBA Technical Data</A><BR>
<A HREF="#gbamemorymap">GBA Memory Map</A><BR>
<A HREF="#gbaiomap">GBA I/O Map</A><BR>
<BR>
<B>Hardware Programming</B><BR>
<A HREF="#gbalcdvideocontroller">GBA LCD Video Controller</A><BR>
<A HREF="#gbasoundcontroller">GBA Sound Controller</A><BR>
<A HREF="#gbatimers">GBA Timers</A><BR>
<A HREF="#gbadmatransfers">GBA DMA Transfers</A><BR>
<A HREF="#gbacommunicationports">GBA Communication Ports</A><BR>
<A HREF="#gbakeypadinput">GBA Keypad Input</A><BR>
<A HREF="#gbainterruptcontrol">GBA Interrupt Control</A><BR>
<A HREF="#gbasystemcontrol">GBA System Control</A><BR>
<A HREF="#gbacartridges">GBA Cartridges</A><BR>
<A HREF="#gbaunpredictablethings">GBA Unpredictable Things</A><BR>
<BR>
<B>Other</B><BR>
<A HREF="#armcpureference">ARM CPU Reference</A><BR>
<A HREF="#biosfunctions">BIOS Functions</A><BR>
<A HREF="#externalconnectors">External Connectors</A><BR>
        </TD><TD WIDTH=33% VALIGN=TOP>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>&nbsp;NDS Reference</FONT></TD></TR></TABLE><BR>
<B>Overview</B><BR>
<A HREF="#dstechnicaldata">DS Technical Data</A><BR>
<A HREF="#dsiomaps">DS I/O Maps</A><BR>
<A HREF="#dsmemorymaps">DS Memory Maps</A><BR>
<BR>
<B>Hardware Programming</B><BR>
<A HREF="#dsmemorycontrol">DS Memory Control</A><BR>
<A HREF="#dsvideo">DS Video</A><BR>
<A HREF="#ds3dvideo">DS 3D Video</A><BR>
<A HREF="#dssound">DS Sound</A><BR>
<A HREF="#dssystemandbuiltinperipherals">DS System and Built-in Peripherals</A><BR>
<A HREF="#dscartridgesencryptionfirmware">DS Cartridges, Encryption, Firmware</A><BR>
<A HREF="#dsxboo">DS Xboo</A><BR>
<A HREF="#dswirelesscommunications">DS Wireless Communications</A><BR>
<BR>
<B>Other</B><BR>
<A HREF="#biosfunctions">BIOS Functions</A><BR>
<A HREF="#armcpureference">ARM CPU Reference</A><BR>
<A HREF="#externalconnectors">External Connectors</A><BR>
        </TD><TD WIDTH=33% VALIGN=TOP>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>&nbsp;DSi Reference</FONT></TD></TR></TABLE><BR>
<A HREF="#dsibasicdifferencestonds">DSi Basic Differences to NDS</A><BR>
<BR>
<B>New Hardware Features</B><BR>
<A HREF="#dsiiomap">DSi I/O Map</A><BR>
<A HREF="#dsicontrolregistersscfg">DSi Control Registers (SCFG)</A><BR>
<A HREF="#dsixpertteakdsp">DSi XpertTeak (DSP)</A><BR>
<A HREF="#dsinewsharedwramforarm7arm9dsp">DSi New Shared WRAM (for ARM7, ARM9, DSP)</A><BR>
<A HREF="#dsinewdma">DSi New DMA</A><BR>
<A HREF="#dsisoundext">DSi SoundExt</A><BR>
<A HREF="#dsiadvancedencryptionstandardaes">DSi Advanced Encryption Standard (AES)</A><BR>
<A HREF="#dsicartridgeheader">DSi Cartridge Header</A><BR>
<A HREF="#dsitouchscreensoundcontroller">DSi Touchscreen/Sound Controller</A><BR>
<A HREF="#dsii2cbus">DSi I2C Bus</A><BR>
<A HREF="#dsicameras">DSi Cameras</A><BR>
<A HREF="#dsisdmmcprotocolandioports">DSi SD/MMC Protocol and I/O Ports</A><BR>
<A HREF="#dsisdmmcfilesystem">DSi SD/MMC Filesystem</A><BR>
<A HREF="#dsigpioregisters">DSi GPIO Registers</A><BR>
<A HREF="#dsiconsoleids">DSi Console IDs</A><BR>
<A HREF="#dsiunknownregisters">DSi Unknown Registers</A><BR>
<A HREF="#dsinotes">DSi Notes</A><BR>
<A HREF="#dsiexploits">DSi Exploits</A><BR>
<A HREF="#dsiregions">DSi Regions</A><BR>
        </TD></TR></TABLE>
<BR>
<BR>
        <TABLE WIDTH=100%><TR><TD WIDTH=33% VALIGN=TOP>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>&nbsp;CPU Reference</FONT></TD></TR></TABLE><BR>
<B>General ARM7TDMI Information</B><BR>
<A HREF="#armcpuoverview">ARM CPU Overview</A><BR>
<A HREF="#armcpuregisterset">ARM CPU Register Set</A><BR>
<A HREF="#armcpuflagsconditionfieldcond">ARM CPU Flags &amp; Condition Field (cond)</A><BR>
<A HREF="#armcpu26bitmemoryinterface">ARM CPU 26bit Memory Interface</A><BR>
<A HREF="#armcpuexceptions">ARM CPU Exceptions</A><BR>
<A HREF="#armcpumemoryalignments">ARM CPU Memory Alignments</A><BR>
<BR>
<B>Further Information</B><BR>
<A HREF="#armpseudoinstructionsanddirectives">ARM Pseudo Instructions and Directives</A><BR>
<A HREF="#armcp15systemcontrolcoprocessor">ARM CP15 System Control Coprocessor</A><BR>
<A HREF="#armcpuinstructioncycletimes">ARM CPU Instruction Cycle Times</A><BR>
<A HREF="#armcpuversions">ARM CPU Versions</A><BR>
<A HREF="#armcpudatasheet">ARM CPU Data Sheet</A><BR>
<BR>
        </TD><TD WIDTH=33% VALIGN=TOP>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>&nbsp;CPU 32bit ARM Mode</FONT></TD></TR></TABLE><BR>
<B>ARM 32bit Opcodes (ARM Code)</B><BR>
<A HREF="#arminstructionsummary">ARM Instruction Summary</A><BR>
<A HREF="#armopcodesbranchandbranchwithlinkbblbxblxswibkpt">ARM Branch and Branch with Link (B, BL, BX, BLX, SWI, BKPT)</A><BR>
<A HREF="#armopcodesdataprocessingalu">ARM Data Processing (ALU)</A><BR>
<A HREF="#armopcodesmultiplyandmultiplyaccumulatemulmla">ARM Multiply and Multiply-Accumulate (MUL, MLA)</A><BR>
<A HREF="#armopcodesspecialarm9instructionsclzqaddqsub">ARM Special ARM9 Instructions (CLZ, QADD/QSUB)</A><BR>
<A HREF="#armopcodespsrtransfermrsmsr">ARM PSR Transfer (MRS, MSR)</A><BR>
<A HREF="#armopcodesmemorysingledatatransferldrstrpld">ARM Memory: Single Data Transfer (LDR, STR, PLD)</A><BR>
<A HREF="#armopcodesmemoryhalfworddoublewordandsigneddatatransfer">ARM Memory: Halfword, Doubleword, and Signed Data Transfer</A><BR>
<A HREF="#armopcodesmemoryblockdatatransferldmstm">ARM Memory: Block Data Transfer (LDM, STM)</A><BR>
<A HREF="#armopcodesmemorysingledataswapswp">ARM Memory: Single Data Swap (SWP)</A><BR>
<A HREF="#armopcodescoprocessorinstructionsmrcmcrldcstccdpmcrrmrrc">ARM Coprocessor (MRC/MCR, LDC/STC, CDP, MCRR/MRRC)</A><BR>
<BR>
        </TD><TD WIDTH=33% VALIGN=TOP>
<TABLE WIDTH=100%><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>&nbsp;CPU 16bit THUMB Mode</FONT></TD></TR></TABLE><BR>
<B>ARM 16bit Opcodes (THUMB Code)</B><BR>
When operating in THUMB state, cut-down 16bit opcodes are used.<BR>
THUMB is supported on T-variants of ARMv4 and up, ie. ARMv4T, ARMv5T, etc.<BR>
<A HREF="#thumbinstructionsummary">THUMB Instruction Summary</A><BR>
<A HREF="#thumbopcodesregisteroperationsalubx">THUMB Register Operations (ALU, BX)</A><BR>
<A HREF="#thumbopcodesmemoryloadstoreldrstr">THUMB Memory Load/Store (LDR/STR)</A><BR>
<A HREF="#thumbopcodesmemoryaddressingaddpcsp">THUMB Memory Addressing (ADD PC/SP)</A><BR>
<A HREF="#thumbopcodesmemorymultipleloadstorepushpopandldmstm">THUMB Memory Multiple Load/Store (PUSH/POP and LDM/STM)</A><BR>
<A HREF="#thumbopcodesjumpsandcalls">THUMB Jumps and Calls</A><BR>
        </TD></TR></TABLE>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbareference"></A>&nbsp;
  GBA Reference
</FONT></TD></TR></TABLE><BR>
<B>Overview</B><BR>
<A HREF="#gbatechnicaldata">GBA Technical Data</A><BR>
<A HREF="#gbamemorymap">GBA Memory Map</A><BR>
<A HREF="#gbaiomap">GBA I/O Map</A><BR>
<BR>
<B>Hardware Programming</B><BR>
<A HREF="#gbalcdvideocontroller">GBA LCD Video Controller</A><BR>
<A HREF="#gbasoundcontroller">GBA Sound Controller</A><BR>
<A HREF="#gbatimers">GBA Timers</A><BR>
<A HREF="#gbadmatransfers">GBA DMA Transfers</A><BR>
<A HREF="#gbacommunicationports">GBA Communication Ports</A><BR>
<A HREF="#gbakeypadinput">GBA Keypad Input</A><BR>
<A HREF="#gbainterruptcontrol">GBA Interrupt Control</A><BR>
<A HREF="#gbasystemcontrol">GBA System Control</A><BR>
<A HREF="#gbacartridges">GBA Cartridges</A><BR>
<A HREF="#gbaunpredictablethings">GBA Unpredictable Things</A><BR>
<BR>
<B>Other</B><BR>
<A HREF="#armcpureference">ARM CPU Reference</A><BR>
<A HREF="#biosfunctions">BIOS Functions</A><BR>
<A HREF="#externalconnectors">External Connectors</A><BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbatechnicaldata"></A>&nbsp;
  GBA Technical Data
</FONT></TD></TR></TABLE><BR>
<B>CPU Modes</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ARM Mode     ARM7TDMI 32bit RISC CPU, 16.78MHz, 32bit opcodes (GBA)
  THUMB Mode   ARM7TDMI 32bit RISC CPU, 16.78MHz, 16bit opcodes (GBA)
  CGB Mode     Z80/8080-style 8bit CPU, 4.2MHz or 8.4MHz  (CGB compatibility)
  DMG Mode     Z80/8080-style 8bit CPU, 4.2MHz (monochrome gameboy compatib.)
</TD></TR></TABLE>
<B>Internal Memory</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  BIOS ROM     16 KBytes
  Work RAM     288 KBytes (Fast 32K on-chip, plus Slow 256K on-board)
  VRAM         96 KBytes
  OAM          1 KByte (128 OBJs 3x16bit, 32 OBJ-Rotation/Scalings 4x16bit)
  Palette RAM  1 KByte (256 BG colors, 256 OBJ colors)
</TD></TR></TABLE>
<B>Video</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Display      240x160 pixels (2.9 inch TFT color LCD display)
  BG layers    4 background layers
  BG types     Tile/map based, or Bitmap based
  BG colors    256 colors, or 16 colors/16 palettes, or 32768 colors
  OBJ colors   256 colors, or 16 colors/16 palettes
  OBJ size     12 types (in range 8x8 up to 64x64 dots)
  OBJs/Screen  max. 128 OBJs of any size (up to 64x64 dots each)
  OBJs/Line    max. 128 OBJs of 8x8 dots size (under best circumstances)
  Priorities   OBJ/OBJ: 0-127, OBJ/BG: 0-3, BG/BG: 0-3
  Effects      Rotation/Scaling, alpha blending, fade-in/out, mosaic, window
  Backlight    GBA SP only (optionally by light on/off toggle button)
</TD></TR></TABLE>
<B>Sound</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Analogue     4 channel CGB compatible (3x square wave, 1x noise)
  Digital      2 DMA sound channels
  Output       Built-in speaker (mono), or headphones socket (stereo)
</TD></TR></TABLE>
<B>Controls</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Gamepad      4 Direction Keys, 6 Buttons
</TD></TR></TABLE>
<B>Communication Ports</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Serial Port  Various transfer modes, 4-Player Link, Single Game Pak play
</TD></TR></TABLE>
<B>External Memory</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  GBA Game Pak max. 32MB ROM or flash ROM + max 64K SRAM
  CGB Game Pak max. 32KB ROM + 8KB SRAM (more memory requires banking)
</TD></TR></TABLE>
<B>Case Dimensions</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Size (mm)    GBA: 145x81x25 - GBA SP: 82x82x24 (closed), 155x82x24 (stretch)
</TD></TR></TABLE>
<B>Power Supply</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Battery GBA  GBA: 2x1.5V DC (AA), Life-time approx. 15 hours
  Battery SP   GBA SP: Built-in rechargeable Lithium ion battery, 3.7V 600mAh
  External     GBA: 3.3V DC 350mA - GBA SP: 5.2V DC 320mA
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 ----------------------------------------------------------------------------
</TD></TR></TABLE>
<BR>
<B>Original Gameboy Advance (GBA)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
        ____._____________...___.____
   ____/    :  CARTRIDGE  SIO   :    \____
  | L       _____________________  LED  R |
  |        |                     |        |
  |  _||_  |   2.9" TFT SCREEN   |    (A) |
  | |_  _| | 240x160pix  61x40mm | (B)    |
  |   ||   |    NO BACKLIGHT     |  ::::  |
  |        |                     | SPEAKR |
  | STRT() |_____________________|  ::::  |
  | SLCT()     GAME BOY ADVANCE    VOLUME |
  |____  OFF-ON  BATTERY 2xAA PHONES  _==_|
       \__.##.__________________,,___/
</TD></TR></TABLE>
<BR>
<B>GBA SP (GBA SP)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
   _______________________                                 _
  | _____________________ |                               / /
  ||                     ||                              / /
  ||   2.9" TFT SCREEN   ||                             / /
  || 240x160pix  61x40mm ||                            / /
  ||   WITH BACKLIGHT    ||                           / /
  ||                     ||     GBA SP SIDE VIEWS    / /
  ||_____________________||                         / /
  |  GAME BOY ADVANCE SP  |   _____________________(_)
  |_______________________|  |. . . . . . . .'.'.   _|
  |_|________|________|_|_|  |_CARTRIDGE_:_BATT._:_|_| &lt;-- EXT1/EXT2
  |L    EXT1     EXT2    R|
  |          (*)      LEDSo   _____________________ _
  (VOL_||_           (A)  o  |_____________________(_)
  |  |_  _| ,,,,,(B)      |  |. . . . . . . .'.'.   _|
  |    ||   ;SPK;         |  |_CARTRIDGE_:_BATT._:_|_| &lt;-- EXT1/EXT2
  |         '''''      ON #                         _ _____________________
  |       SLCT STRT    OFF#   _____________________(_)_____________________|
  | CART.  ()   ()        |  |. . . . . . . .'.'.   _|
  |_:___________________:_|  |_CARTRIDGE_:_BATT._:_|_| &lt;-- EXT1/EXT2
</TD></TR></TABLE>
<BR>
<B>Gameboy Micro (GBA Micro)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
      ________________SIO_______________
     | L      __________________      R |
     |       |     GBA-MICRO    |       |
     | _||_  |  2.0" TFT SCREEN |    (A)| +
     ||_  _| |240x160pix 42x28mm| (B)   |VOL
     |  ||   |     BACKLIGHT    |       | -
     |       |__________________|  ...  |
     |___________SELECT__START__________|
       PWR   &lt;--- CARTRIDGE SLOT ---&gt; PHONES
</TD></TR></TABLE>
<BR>
<B>Nintendo DS (NDS)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
     _____________________________________
    |        _____________________        |
    |       |                     |       |
    |       |    3" TFT SCREEN    |       |
    |       | 256x192pix  61x46mm |       |
    |       |      BACKLIGHT      |       |
    | ::::: |    Original NDS     | ::::: |
    | ::::: |_____________________| ::::: |
   _|        _          ______   _        |_  &lt;-- gap between screens: 22mm
  |L|_______| |________|      |_| |_______|R|     (equivalent to 90 pixels)
  |_______   _____________________   _______|
  |  PWR  | |                     | |SEL STA|
  |   _   | |    3" TFT SCREEN    | |       |
  | _| |_ | | 256x192pix  61x46mm | |   X   |
  ||_   _|| |      BACKLIGHT      | | Y   A |
  |  |_|  | |    TOUCH SCREEN     | |   B   |
  |       | |_____________________| |       |
  |_______|             NintendoDS  |_______|
  |         MIC                LEDS         |
  |_________________________________________|
       VOL        SLOT2(GBA)     MIC/PHONES
</TD></TR></TABLE>
<BR>
<B>Nintendo DS Lite (NDS-Lite)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
     _____________________________________
    |        _____________________        |
    |       |                     |       |
    |       |    3" TFT SCREEN    |       |
    |  ...  | 256x192pix  61x46mm |  ...  |
    |  ...  |      BACKLIGHT      |  ...  |
    |       |      NDS-LITE       |       |
    |       |_____________________|       |
    |___  _ _ _ _ _ _ _ _ _ _ _ _ _ _ ____|   &lt;-- gap between screens: 23mm
   L| _ |_____________MIC____________|LEDS|R
    |   _    _____________________        |
    | _| |_ |                     |   X   |
    ||_   _||    3" TFT SCREEN    | Y   A |PWR
    |  |_|  | 256x192pix  61x46mm |   B   |
    |       |      BACKLIGHT      |       |
    |       |    TOUCH SCREEN     |oSTART |
    |       |_____________________|oSELECT|
    |_____________________________________|
       VOL        SLOT2(GBA)     MIC/PHONES
</TD></TR></TABLE>
<BR>
<B>Nintendo DSi (DSi)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
     _____________________________________
    |        _____________________        |
    |       |                     |   O o | &lt;-- CAM (O) and LED (o)
    |       |   3.25" TFT SCREEN  |       |     (on backside)
    |       | 256x192pix  66x50mm |       |
    |       |      BACKLIGHT      |       |
    |  __   |         DSi         |   __  |
    | (__)  |_____________________|  (__) |
    |___  _ _ _ _ _ _ _ _ _ _ _ _ _ _ ____|  &lt;-- gap between screens: 23mm
   L|LEDS|__________CAM__MIC_________| __ |R                   (88 pixels)
  + |   _    _____________________        |
 VOL| _| |_ |                     |   X   | &lt;-- SD Card Slot
  - ||_   _||   3.25" TFT SCREEN  | Y   A |
    |  |_|  | 256x192pix  66x50mm |   B   |
    |       |      BACKLIGHT      |       |
    |       |    TOUCH SCREEN     |oSTART |
    | POWERo|_____________________|oSELECT|
    |_____________________________________|
                                 MIC/PHONES
</TD></TR></TABLE>
<BR>
<B>Nintendo DSi XL</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  As DSi, but bigger case, and bigger 4.2" screens
</TD></TR></TABLE>
<BR>
<B>Gameboy Player (Gamecube Joypad) (GBA Player)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
                   _________
       L____-------         -------____R
       /   ___   \           /   (Y)   \Z
      /   / O \   | (START) |        (X)\   Z      = Gameboy Player Menu
     |    \___/    \_______/      (A)    |  X or Y = Select button
     |\         _   \     /    (B)      /|
     | \___   _| |_  \   /   ___    ___/ |  optionally X/Y can be
     |    |\ |_   _| /   \  / C \  /|    |  swapped with L/R (?)
     |    | \  |_|  /     \ \___/ / |    |
     |    |  \_____/       \_____/  |    |  analogue sticks = ?
      \__/                           \__/
</TD></TR></TABLE>
<BR>
<B>Gameboy Player (Gamecube Bongos) (GBA Player)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
       _______     _______
      /   Y   \   /   X   \   Y/B = left bongo rear/front side
     | . . . . |_| . . . . |  X/A = right bongo rear/front side
     |    B    |R|    A    |  S   = start/pause button
     |\_______/|_|\_______/|  R   = microphone (triggers R button)
     |\_______/|S|\_______/|
     |         |_|         |  (the X/Y inputs can be assigned to
     |\_______/| |\_______/|  GBA R/L inputs in GBA player setup)
      \_______/   \_______/
</TD></TR></TABLE>
<BR>
The GBA's separate 8bit/32bit CPU modes cannot be operated simultaneously.
Switching is allowed between ARM and THUMB modes only (that are the two GBA
modes).<BR>
This manual does not describe CGB and DMG modes, both are completely different
than GBA modes, and both cannot be accessed from inside of GBA modes anyways.<BR>
<BR>
<B>Gameboy Player</B><BR>
An GBA Adapter for the Gamecube console; allowing to play GBA games on a
television set.<BR>
<A HREF="#gbagameboyplayer">GBA Gameboy Player</A><BR>
<BR>
<B>GBA SP Notes</B><BR>
Deluxe version of the original GBA. With backlight, new folded laptop-style
case, and built-in rechargeable battery. Appears to be 100% compatible with
GBA, there seems to be no way to detect SPs by software.<BR>
<BR>
<B>Gameboy Micro (GBA Micro)</B><BR>
Minituarized GBA. Supports 32bit GBA games only (no 8bit DMG/CGB games). The
256K Main RAM is a bit slower than usually (cannot be "overclocked via port
4000800h).<BR>
<BR>
<B>Nintendo DS (Dual Screen) Notes</B><BR>
New handheld with two screens, backwards compatible with GBA games, it is NOT
backwards compatible with older 8bit games (mono/color gameboys) though..<BR>
Also, the DS has no link port, so that GBA games will thus work only in single
player mode, link-port accessoires like printers cannot be used, and most
unfortunately multiboot won't work (trying to press Select+Start at powerup
will just lock up the DS).<BR>
<BR>
<B>iQue Notes</B><BR>
iQue is a brand name used by Nintendo in China, iQue GBA and iQue DS are
essentially same as Nintendo GBA and Nintendo DS.<BR>
The iQue DS contains a larger firmware chip (the charset additionally contains
about 6700 simplified chinese characters), the bootmenu still allows to select
(only) six languages (japanese has been replaced by chinese). The iQue DS can
play normal international NDS games, plus chinese dedicated games. The latter
ones won't work on normal NDS consoles (that, reportedly simply due to a
firmware-version check contained in chinese dedicated games, aside from that
check, the games should be fully compatible with NDS consoles).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbamemorymap"></A>&nbsp;
  GBA Memory Map
</FONT></TD></TR></TABLE><BR>
<B>General Internal Memory</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00000000-00003FFF   BIOS - System ROM         (16 KBytes)
  00004000-01FFFFFF   Not used
  02000000-0203FFFF   WRAM - On-board Work RAM  (256 KBytes) 2 Wait
  02040000-02FFFFFF   Not used
  03000000-03007FFF   WRAM - On-chip Work RAM   (32 KBytes)
  03008000-03FFFFFF   Not used
  04000000-040003FE   I/O Registers
  04000400-04FFFFFF   Not used
</TD></TR></TABLE>
<B>Internal Display Memory</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  05000000-050003FF   BG/OBJ Palette RAM        (1 Kbyte)
  05000400-05FFFFFF   Not used
  06000000-06017FFF   VRAM - Video RAM          (96 KBytes)
  06018000-06FFFFFF   Not used
  07000000-070003FF   OAM - OBJ Attributes      (1 Kbyte)
  07000400-07FFFFFF   Not used
</TD></TR></TABLE>
<B>External Memory (Game Pak)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  08000000-09FFFFFF   Game Pak ROM/FlashROM (max 32MB) - Wait State 0
  0A000000-0BFFFFFF   Game Pak ROM/FlashROM (max 32MB) - Wait State 1
  0C000000-0DFFFFFF   Game Pak ROM/FlashROM (max 32MB) - Wait State 2
  0E000000-0E00FFFF   Game Pak SRAM    (max 64 KBytes) - 8bit Bus width
  0E010000-0FFFFFFF   Not used
</TD></TR></TABLE>
<B>Unused Memory Area</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  10000000-FFFFFFFF   Not used (upper 4bits of address bus unused)
</TD></TR></TABLE>
<BR>
<B>Default WRAM Usage</B><BR>
By default, the 256 bytes at 03007F00h-03007FFFh in Work RAM are reserved for
Interrupt vector, Interrupt Stack, and BIOS Call Stack. The remaining WRAM is
free for whatever use (including User Stack, which is initially located at
03007F00h).<BR>
<BR>
<B>Address Bus Width and CPU Read/Write Access Widths</B><BR>
Shows the Bus-Width, supported read and write widths, and the clock cycles for
8/16/32bit accesses.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Region        Bus   Read      Write     Cycles
  BIOS ROM      32    8/16/32   -         1/1/1
  Work RAM 32K  32    8/16/32   8/16/32   1/1/1
  I/O           32    8/16/32   8/16/32   1/1/1
  OAM           32    8/16/32   16/32     1/1/1 *
  Work RAM 256K 16    8/16/32   8/16/32   3/3/6 **
  Palette RAM   16    8/16/32   16/32     1/1/2 *
  VRAM          16    8/16/32   16/32     1/1/2 *
  GamePak ROM   16    8/16/32   -         5/5/8 **/***
  GamePak Flash 16    8/16/32   16/32     5/5/8 **/***
  GamePak SRAM  8     8         8         5     **
</TD></TR></TABLE>
Timing Notes:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  *   Plus 1 cycle if GBA accesses video memory at the same time.
  **  Default waitstate settings, see System Control chapter.
  *** Separate timings for sequential, and non-sequential accesses.
  One cycle equals approx. 59.59ns (ie. 16.78MHz clock).
</TD></TR></TABLE>
All memory (except GamePak SRAM) can be accessed by 16bit and 32bit DMA.<BR>
<BR>
<B>GamePak Memory</B><BR>
Only DMA3 (and the CPU of course) may access GamePak ROM. GamePak SRAM can be
accessed by the CPU only - restricted to bytewise 8bit transfers. The SRAM
region is supposed for as external FLASH backup memory, or for battery-backed
SRAM.<BR>
For details about configuration of GamePak Waitstates, see:<BR>
<A HREF="#gbasystemcontrol">GBA System Control</A><BR>
<BR>
<B>VRAM, OAM, and Palette RAM Access</B><BR>
These memory regions can be accessed during H-Blank or V-Blank only (unless
display is disabled by Forced Blank bit in DISPCNT register).<BR>
There is an additional restriction for OAM memory: Accesses during H-Blank are
allowed only if 'H-Blank Interval Free' in DISPCNT is set (which'd reduce
number of display-able OBJs though).<BR>
The CPU appears to be able to access VRAM/OAM/Palette at any time, a waitstate
(one clock cycle) being inserted automatically in case that the display
controller was accessing memory simultaneously. (Ie. unlike as in old 8bit
gameboy, the data will not get lost.)<BR>
<BR>
<B>CPU Mode Performance</B><BR>
Note that the GamePak ROM bus is limited to 16bits, thus executing ARM
instructions (32bit opcodes) from inside of GamePak ROM would result in a not
so good performance. So, it'd be more recommended to use THUMB instruction
(16bit opcodes) which'd allow each opcode to be read at once.<BR>
(ARM instructions can be used at best performance by copying code from GamePak
ROM into internal Work RAM)<BR>
<BR>
<B>Data Format</B><BR>
Even though the ARM CPU itself would allow to select between Little-Endian and
Big-Endian format by using an external circuit, in the GBA no such circuit
exists, and the data format is always Little-Endian. That is, when accessing
16bit or 32bit data in memory, the least significant bits are stored in the
first byte (smallest address), and the most significant bits in the last byte.
(Ie. same as for 80x86 and Z80 CPUs.)<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbaiomap"></A>&nbsp;
  GBA I/O Map
</FONT></TD></TR></TABLE><BR>
<B>LCD I/O Registers</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4000000h  2    R/W  DISPCNT   LCD Control
  4000002h  2    R/W  -         Undocumented - Green Swap
  4000004h  2    R/W  DISPSTAT  General LCD Status (STAT,LYC)
  4000006h  2    R    VCOUNT    Vertical Counter (LY)
  4000008h  2    R/W  BG0CNT    BG0 Control
  400000Ah  2    R/W  BG1CNT    BG1 Control
  400000Ch  2    R/W  BG2CNT    BG2 Control
  400000Eh  2    R/W  BG3CNT    BG3 Control
  4000010h  2    W    BG0HOFS   BG0 X-Offset
  4000012h  2    W    BG0VOFS   BG0 Y-Offset
  4000014h  2    W    BG1HOFS   BG1 X-Offset
  4000016h  2    W    BG1VOFS   BG1 Y-Offset
  4000018h  2    W    BG2HOFS   BG2 X-Offset
  400001Ah  2    W    BG2VOFS   BG2 Y-Offset
  400001Ch  2    W    BG3HOFS   BG3 X-Offset
  400001Eh  2    W    BG3VOFS   BG3 Y-Offset
  4000020h  2    W    BG2PA     BG2 Rotation/Scaling Parameter A (dx)
  4000022h  2    W    BG2PB     BG2 Rotation/Scaling Parameter B (dmx)
  4000024h  2    W    BG2PC     BG2 Rotation/Scaling Parameter C (dy)
  4000026h  2    W    BG2PD     BG2 Rotation/Scaling Parameter D (dmy)
  4000028h  4    W    BG2X      BG2 Reference Point X-Coordinate
  400002Ch  4    W    BG2Y      BG2 Reference Point Y-Coordinate
  4000030h  2    W    BG3PA     BG3 Rotation/Scaling Parameter A (dx)
  4000032h  2    W    BG3PB     BG3 Rotation/Scaling Parameter B (dmx)
  4000034h  2    W    BG3PC     BG3 Rotation/Scaling Parameter C (dy)
  4000036h  2    W    BG3PD     BG3 Rotation/Scaling Parameter D (dmy)
  4000038h  4    W    BG3X      BG3 Reference Point X-Coordinate
  400003Ch  4    W    BG3Y      BG3 Reference Point Y-Coordinate
  4000040h  2    W    WIN0H     Window 0 Horizontal Dimensions
  4000042h  2    W    WIN1H     Window 1 Horizontal Dimensions
  4000044h  2    W    WIN0V     Window 0 Vertical Dimensions
  4000046h  2    W    WIN1V     Window 1 Vertical Dimensions
  4000048h  2    R/W  WININ     Inside of Window 0 and 1
  400004Ah  2    R/W  WINOUT    Inside of OBJ Window &amp; Outside of Windows
  400004Ch  2    W    MOSAIC    Mosaic Size
  400004Eh       -    -         Not used
  4000050h  2    R/W  BLDCNT    Color Special Effects Selection
  4000052h  2    W    BLDALPHA  Alpha Blending Coefficients
  4000054h  2    W    BLDY      Brightness (Fade-In/Out) Coefficient
  4000056h       -    -         Not used
</TD></TR></TABLE>
<B>Sound Registers</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4000060h  2  R/W  SOUND1CNT_L Channel 1 Sweep register       (NR10)
  4000062h  2  R/W  SOUND1CNT_H Channel 1 Duty/Length/Envelope (NR11, NR12)
  4000064h  2  R/W  SOUND1CNT_X Channel 1 Frequency/Control    (NR13, NR14)
  4000066h     -    -           Not used
  4000068h  2  R/W  SOUND2CNT_L Channel 2 Duty/Length/Envelope (NR21, NR22)
  400006Ah     -    -           Not used
  400006Ch  2  R/W  SOUND2CNT_H Channel 2 Frequency/Control    (NR23, NR24)
  400006Eh     -    -           Not used
  4000070h  2  R/W  SOUND3CNT_L Channel 3 Stop/Wave RAM select (NR30)
  4000072h  2  R/W  SOUND3CNT_H Channel 3 Length/Volume        (NR31, NR32)
  4000074h  2  R/W  SOUND3CNT_X Channel 3 Frequency/Control    (NR33, NR34)
  4000076h     -    -           Not used
  4000078h  2  R/W  SOUND4CNT_L Channel 4 Length/Envelope      (NR41, NR42)
  400007Ah     -    -           Not used
  400007Ch  2  R/W  SOUND4CNT_H Channel 4 Frequency/Control    (NR43, NR44)
  400007Eh     -    -           Not used
  4000080h  2  R/W  SOUNDCNT_L  Control Stereo/Volume/Enable   (NR50, NR51)
  4000082h  2  R/W  SOUNDCNT_H  Control Mixing/DMA Control
  4000084h  2  R/W  SOUNDCNT_X  Control Sound on/off           (NR52)
  4000086h     -    -           Not used
  4000088h  2  BIOS SOUNDBIAS   Sound PWM Control
  400008Ah  ..   -    -         Not used
  4000090h 2x10h R/W  WAVE_RAM  Channel 3 Wave Pattern RAM (2 banks!!)
  40000A0h  4    W    FIFO_A    Channel A FIFO, Data 0-3
  40000A4h  4    W    FIFO_B    Channel B FIFO, Data 0-3
  40000A8h       -    -         Not used
</TD></TR></TABLE>
<B>DMA Transfer Channels</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  40000B0h  4    W    DMA0SAD   DMA 0 Source Address
  40000B4h  4    W    DMA0DAD   DMA 0 Destination Address
  40000B8h  2    W    DMA0CNT_L DMA 0 Word Count
  40000BAh  2    R/W  DMA0CNT_H DMA 0 Control
  40000BCh  4    W    DMA1SAD   DMA 1 Source Address
  40000C0h  4    W    DMA1DAD   DMA 1 Destination Address
  40000C4h  2    W    DMA1CNT_L DMA 1 Word Count
  40000C6h  2    R/W  DMA1CNT_H DMA 1 Control
  40000C8h  4    W    DMA2SAD   DMA 2 Source Address
  40000CCh  4    W    DMA2DAD   DMA 2 Destination Address
  40000D0h  2    W    DMA2CNT_L DMA 2 Word Count
  40000D2h  2    R/W  DMA2CNT_H DMA 2 Control
  40000D4h  4    W    DMA3SAD   DMA 3 Source Address
  40000D8h  4    W    DMA3DAD   DMA 3 Destination Address
  40000DCh  2    W    DMA3CNT_L DMA 3 Word Count
  40000DEh  2    R/W  DMA3CNT_H DMA 3 Control
  40000E0h       -    -         Not used
</TD></TR></TABLE>
<B>Timer Registers</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4000100h  2    R/W  TM0CNT_L  Timer 0 Counter/Reload
  4000102h  2    R/W  TM0CNT_H  Timer 0 Control
  4000104h  2    R/W  TM1CNT_L  Timer 1 Counter/Reload
  4000106h  2    R/W  TM1CNT_H  Timer 1 Control
  4000108h  2    R/W  TM2CNT_L  Timer 2 Counter/Reload
  400010Ah  2    R/W  TM2CNT_H  Timer 2 Control
  400010Ch  2    R/W  TM3CNT_L  Timer 3 Counter/Reload
  400010Eh  2    R/W  TM3CNT_H  Timer 3 Control
  4000110h       -    -         Not used
</TD></TR></TABLE>
<B>Serial Communication (1)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4000120h  4    R/W  SIODATA32 SIO Data (Normal-32bit Mode; shared with below)
  4000120h  2    R/W  SIOMULTI0 SIO Data 0 (Parent)    (Multi-Player Mode)
  4000122h  2    R/W  SIOMULTI1 SIO Data 1 (1st Child) (Multi-Player Mode)
  4000124h  2    R/W  SIOMULTI2 SIO Data 2 (2nd Child) (Multi-Player Mode)
  4000126h  2    R/W  SIOMULTI3 SIO Data 3 (3rd Child) (Multi-Player Mode)
  4000128h  2    R/W  SIOCNT    SIO Control Register
  400012Ah  2    R/W  SIOMLT_SEND SIO Data (Local of MultiPlayer; shared below)
  400012Ah  2    R/W  SIODATA8  SIO Data (Normal-8bit and UART Mode)
  400012Ch       -    -         Not used
</TD></TR></TABLE>
<B>Keypad Input</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4000130h  2    R    KEYINPUT  Key Status
  4000132h  2    R/W  KEYCNT    Key Interrupt Control
</TD></TR></TABLE>
<B>Serial Communication (2)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4000134h  2    R/W  RCNT      SIO Mode Select/General Purpose Data
  4000136h  -    -    IR        Ancient - Infrared Register (Prototypes only)
  4000138h       -    -         Not used
  4000140h  2    R/W  JOYCNT    SIO JOY Bus Control
  4000142h       -    -         Not used
  4000150h  4    R/W  JOY_RECV  SIO JOY Bus Receive Data
  4000154h  4    R/W  JOY_TRANS SIO JOY Bus Transmit Data
  4000158h  2    R/?  JOYSTAT   SIO JOY Bus Receive Status
  400015Ah       -    -         Not used
</TD></TR></TABLE>
<B>Interrupt, Waitstate, and Power-Down Control</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4000200h  2    R/W  IE        Interrupt Enable Register
  4000202h  2    R/W  IF        Interrupt Request Flags / IRQ Acknowledge
  4000204h  2    R/W  WAITCNT   Game Pak Waitstate Control
  4000206h       -    -         Not used
  4000208h  2    R/W  IME       Interrupt Master Enable Register
  400020Ah       -    -         Not used
  4000300h  1    R/W  POSTFLG   Undocumented - Post Boot Flag
  4000301h  1    W    HALTCNT   Undocumented - Power Down Control
  4000302h       -    -         Not used
  4000410h  ?    ?    ?         Undocumented - Purpose Unknown / Bug ??? 0FFh
  4000411h       -    -         Not used
  4000800h  4    R/W  ?         Undocumented - Internal Memory Control (R/W)
  4000804h       -    -         Not used
  4xx0800h  4    R/W  ?         Mirrors of 4000800h (repeated each 64K)
</TD></TR></TABLE>
<BR>
All further addresses at 4XXXXXXh are unused and do not contain mirrors of the
I/O area, with the only exception that 4000800h is repeated each 64K (ie.
mirrored at 4010800h, 4020800h, etc.)<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbalcdvideocontroller"></A>&nbsp;
  GBA LCD Video Controller
</FONT></TD></TR></TABLE><BR>
<B>Registers</B><BR>
<A HREF="#lcdiodisplaycontrol">LCD I/O Display Control</A><BR>
<A HREF="#lcdiointerruptsandstatus">LCD I/O Interrupts and Status</A><BR>
<A HREF="#lcdiobgcontrol">LCD I/O BG Control</A><BR>
<A HREF="#lcdiobgscrolling">LCD I/O BG Scrolling</A><BR>
<A HREF="#lcdiobgrotationscaling">LCD I/O BG Rotation/Scaling</A><BR>
<A HREF="#lcdiowindowfeature">LCD I/O Window Feature</A><BR>
<A HREF="#lcdiomosaicfunction">LCD I/O Mosaic Function</A><BR>
<A HREF="#lcdiocolorspecialeffects">LCD I/O Color Special Effects</A><BR>
<BR>
<B>VRAM</B><BR>
<A HREF="#lcdvramoverview">LCD VRAM Overview</A><BR>
<A HREF="#lcdvramcharacterdata">LCD VRAM Character Data</A><BR>
<A HREF="#lcdvrambgscreendataformatbgmap">LCD VRAM BG Screen Data Format (BG Map)</A><BR>
<A HREF="#lcdvrambitmapbgmodes">LCD VRAM Bitmap BG Modes</A><BR>
<BR>
<B>Sprites</B><BR>
<A HREF="#lcdobjoverview">LCD OBJ - Overview</A><BR>
<A HREF="#lcdobjoamattributes">LCD OBJ - OAM Attributes</A><BR>
<A HREF="#lcdobjoamrotationscalingparameters">LCD OBJ - OAM Rotation/Scaling Parameters</A><BR>
<A HREF="#lcdobjvramcharactertilemapping">LCD OBJ - VRAM Character (Tile) Mapping</A><BR>
<BR>
<B>Other</B><BR>
<A HREF="#lcdcolorpalettes">LCD Color Palettes</A><BR>
<A HREF="#lcddimensionsandtimings">LCD Dimensions and Timings</A><BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="lcdiodisplaycontrol"></A>&nbsp;
  LCD I/O Display Control
</FONT></TD></TR></TABLE><BR>
<B>4000000h - DISPCNT - LCD Control (Read/Write)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-2   BG Mode                (0-5=Video Mode 0-5, 6-7=Prohibited)
  3     Reserved / CGB Mode    (0=GBA, 1=CGB; can be set only by BIOS opcodes)
  4     Display Frame Select   (0-1=Frame 0-1) (for BG Modes 4,5 only)
  5     H-Blank Interval Free  (1=Allow access to OAM during H-Blank)
  6     OBJ Character VRAM Mapping (0=Two dimensional, 1=One dimensional)
  7     Forced Blank           (1=Allow FAST access to VRAM,Palette,OAM)
  8     Screen Display BG0  (0=Off, 1=On)
  9     Screen Display BG1  (0=Off, 1=On)
  10    Screen Display BG2  (0=Off, 1=On)
  11    Screen Display BG3  (0=Off, 1=On)
  12    Screen Display OBJ  (0=Off, 1=On)
  13    Window 0 Display Flag   (0=Off, 1=On)
  14    Window 1 Display Flag   (0=Off, 1=On)
  15    OBJ Window Display Flag (0=Off, 1=On)
</TD></TR></TABLE>
<BR>
The table summarizes the facilities of the separate BG modes (video modes).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
<B>  Mode  Rot/Scal Layers Size               Tiles Colors       Features</B>
  0     No       0123   256x256..512x515   1024  16/16..256/1 SFMABP
  1     Mixed    012-   (BG0,BG1 as above Mode 0, BG2 as below Mode 2)
  2     Yes      --23   128x128..1024x1024 256   256/1        S-MABP
  3     Yes      --2-   240x160            1     32768        --MABP
  4     Yes      --2-   240x160            2     256/1        --MABP
  5     Yes      --2-   160x128            2     32768        --MABP
</TD></TR></TABLE>
Features: S)crolling, F)lip, M)osaic, A)lphaBlending, B)rightness, P)riority.<BR>
<BR>
BG Modes 0-2 are Tile/Map-based. BG Modes 3-5 are Bitmap-based, in these modes
1 or 2 Frames (ie. bitmaps, or 'full screen tiles') exists, if two frames
exist, either one can be displayed, and the other one can be redrawn in
background.<BR>
<BR>
<B>Blanking Bits</B><BR>
Setting Forced Blank (Bit 7) causes the video controller to display white
lines, and all VRAM, Palette RAM, and OAM may be accessed.<BR>
"When the internal HV synchronous counter cancels a forced blank during a
display period, the display begins from the beginning, following the display of
two vertical lines." What ?<BR>
Setting H-Blank Interval Free (Bit 5) allows to access OAM during H-Blank time
- using this feature reduces the number of sprites that can be displayed per
line.<BR>
<BR>
<B>Display Enable Bits</B><BR>
By default, BG0-3 and OBJ Display Flags (Bit 8-12) are used to enable/disable
BGs and OBJ. When enabling Window 0 and/or 1 (Bit 13-14), color special effects
may be used, and BG0-3 and OBJ are controlled by the window(s).<BR>
<BR>
<B>Frame Selection</B><BR>
In BG Modes 4 and 5 (Bitmap modes), either one of the two bitmaps/frames may be
displayed (Bit 4), allowing the user to update the other (invisible) frame in
background. In BG Mode 3, only one frame exists.<BR>
In BG Modes 0-2 (Tile/Map based modes), a similar effect may be gained by
altering the base address(es) of BG Map and/or BG Character data.<BR>
<BR>
<B>4000002h - Undocumented - Green Swap (R/W)</B><BR>
Normally, red green blue intensities for a group of two pixels is output as
BGRbgr (uppercase for left pixel at even xloc, lowercase for right pixel at odd
xloc). When the Green Swap bit is set, each pixel group is output as BgRbGr
(ie. green intensity of each two pixels exchanged).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0     Green Swap  (0=Normal, 1=Swap)
  1-15  Not used
</TD></TR></TABLE>
This feature appears to be applied to the final picture (ie. after mixing the
separate BG and OBJ layers). Eventually intended for other display types (with
other pin-outs). With normal GBA hardware it is just producing an interesting
dirt effect.<BR>
The NDS DISPCNT registers are 32bit (4000000h..4000003h), so Green Swap doesn't
exist in NDS mode, however, the NDS does support Green Swap in GBA mode.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="lcdiointerruptsandstatus"></A>&nbsp;
  LCD I/O Interrupts and Status
</FONT></TD></TR></TABLE><BR>
<B>4000004h - DISPSTAT - General LCD Status (Read/Write)</B><BR>
Display status and Interrupt control. The H-Blank conditions are generated once
per scanline, including for the 'hidden' scanlines during V-Blank.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0     V-Blank flag   (Read only) (1=VBlank) (set in line 160..226; not 227)
  1     H-Blank flag   (Read only) (1=HBlank) (toggled in all lines, 0..227)
  2     V-Counter flag (Read only) (1=Match)  (set in selected line)     (R)
  3     V-Blank IRQ Enable         (1=Enable)                          (R/W)
  4     H-Blank IRQ Enable         (1=Enable)                          (R/W)
  5     V-Counter IRQ Enable       (1=Enable)                          (R/W)
  6     Not used (0) / DSi: LCD Initialization Ready (0=Busy, 1=Ready)   (R)
  7     Not used (0) / NDS: MSB of V-Vcount Setting (LYC.Bit8) (0..262)(R/W)
  8-15  V-Count Setting (LYC)      (0..227)                            (R/W)
</TD></TR></TABLE>
The V-Count-Setting value is much the same as LYC of older gameboys, when its
value is identical to the content of the VCOUNT register then the V-Counter
flag is set (Bit 2), and (if enabled in Bit 5) an interrupt is requested.<BR>
Although the drawing time is only 960 cycles (240*4), the H-Blank flag is "0"
for a total of 1006 cycles.<BR>
<BR>
<B>4000006h - VCOUNT - Vertical Counter (Read only)</B><BR>
Indicates the currently drawn scanline, values in range from 160..227 indicate
'hidden' scanlines within VBlank area.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-7   Current Scanline (LY)      (0..227)                              (R)
  8     Not used (0) / NDS: MSB of Current Scanline (LY.Bit8) (0..262)   (R)
  9-15  Not Used (0)
</TD></TR></TABLE>
Note: This is much the same than the 'LY' register of older gameboys.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="lcdiobgcontrol"></A>&nbsp;
  LCD I/O BG Control
</FONT></TD></TR></TABLE><BR>
<B>4000008h - BG0CNT - BG0 Control (R/W) (BG Modes 0,1 only)</B><BR>
<B>400000Ah - BG1CNT - BG1 Control (R/W) (BG Modes 0,1 only)</B><BR>
<B>400000Ch - BG2CNT - BG2 Control (R/W) (BG Modes 0,1,2 only)</B><BR>
<B>400000Eh - BG3CNT - BG3 Control (R/W) (BG Modes 0,2 only)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-1   BG Priority           (0-3, 0=Highest)
  2-3   Character Base Block  (0-3, in units of 16 KBytes) (=BG Tile Data)
  4-5   Not used (must be zero)
  6     Mosaic                (0=Disable, 1=Enable)
  7     Colors/Palettes       (0=16/16, 1=256/1)
  8-12  Screen Base Block     (0-31, in units of 2 KBytes) (=BG Map Data)
  13    Display Area Overflow (0=Transparent, 1=Wraparound; BG2CNT/BG3CNT only)
  14-15 Screen Size (0-3)
</TD></TR></TABLE>
Internal Screen Size (dots) and size of BG Map (bytes):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Value  Text Mode      Rotation/Scaling Mode
  0      256x256 (2K)   128x128   (256 bytes)
  1      512x256 (4K)   256x256   (1K)
  2      256x512 (4K)   512x512   (4K)
  3      512x512 (8K)   1024x1024 (16K)
</TD></TR></TABLE>
In case that some or all BGs are set to same priority then BG0 is having the
highest, and BG3 the lowest priority.<BR>
<BR>
In 'Text Modes', the screen size is organized as follows: The screen consists
of one or more 256x256 pixel (32x32 tiles) areas. When Size=0: only 1 area
(SC0), when Size=1 or Size=2: two areas (SC0,SC1 either horizontally or
vertically arranged next to each other), when Size=3: four areas (SC0,SC1 in
upper row, SC2,SC3 in lower row). Whereas SC0 is defined by the normal BG Map
base address (Bit 8-12 of BG#CNT), SC1 uses same address +2K, SC2 address +4K,
SC3 address +6K. When the screen is scrolled it'll always wraparound.<BR>
<BR>
In 'Rotation/Scaling Modes', the screen size is organized as follows, only one
area (SC0) of variable size 128x128..1024x1024 pixels (16x16..128x128 tiles)
exists. When the screen is rotated/scaled (or scrolled?) so that the LCD
viewport reaches outside of the background/screen area, then BG may be either
displayed as transparent or wraparound (Bit 13 of BG#CNT).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="lcdiobgscrolling"></A>&nbsp;
  LCD I/O BG Scrolling
</FONT></TD></TR></TABLE><BR>
<B>4000010h - BG0HOFS - BG0 X-Offset (W)</B><BR>
<B>4000012h - BG0VOFS - BG0 Y-Offset (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-8   Offset (0-511)
  9-15  Not used
</TD></TR></TABLE>
Specifies the coordinate of the upperleft first visible dot of BG0 background
layer, ie. used to scroll the BG0 area.<BR>
<BR>
<B>4000014h - BG1HOFS - BG1 X-Offset (W)</B><BR>
<B>4000016h - BG1VOFS - BG1 Y-Offset (W)</B><BR>
Same as above BG0HOFS and BG0VOFS for BG1 respectively.<BR>
<BR>
<B>4000018h - BG2HOFS - BG2 X-Offset (W)</B><BR>
<B>400001Ah - BG2VOFS - BG2 Y-Offset (W)</B><BR>
Same as above BG0HOFS and BG0VOFS for BG2 respectively.<BR>
<BR>
<B>400001Ch - BG3HOFS - BG3 X-Offset (W)</B><BR>
<B>400001Eh - BG3VOFS - BG3 Y-Offset (W)</B><BR>
Same as above BG0HOFS and BG0VOFS for BG3 respectively.<BR>
<BR>
The above BG scrolling registers are exclusively used in Text modes, ie. for
all layers in BG Mode 0, and for the first two layers in BG mode 1.<BR>
In other BG modes (Rotation/Scaling and Bitmap modes) above registers are
ignored. Instead, the screen may be scrolled by modifying the BG
Rotation/Scaling Reference Point registers.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="lcdiobgrotationscaling"></A>&nbsp;
  LCD I/O BG Rotation/Scaling
</FONT></TD></TR></TABLE><BR>
<B>4000028h - BG2X_L - BG2 Reference Point X-Coordinate, lower 16 bit (W)</B><BR>
<B>400002Ah - BG2X_H - BG2 Reference Point X-Coordinate, upper 12 bit (W)</B><BR>
<B>400002Ch - BG2Y_L - BG2 Reference Point Y-Coordinate, lower 16 bit (W)</B><BR>
<B>400002Eh - BG2Y_H - BG2 Reference Point Y-Coordinate, upper 12 bit (W)</B><BR>
These registers are replacing the BG scrolling registers which are used for
Text mode, ie. the X/Y coordinates specify the source position from inside of
the BG Map/Bitmap of the pixel to be displayed at upper left of the GBA
display. The normal BG scrolling registers are ignored in Rotation/Scaling and
Bitmap modes.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-7   Fractional portion (8 bits)
  8-26  Integer portion    (19 bits)
  27    Sign               (1 bit)
  28-31 Not used
</TD></TR></TABLE>
Because values are shifted left by eight, fractional portions may be specified
in steps of 1/256 pixels (this would be relevant only if the screen is actually
rotated or scaled). Normal signed 32bit values may be written to above
registers (the most significant bits will be ignored and the value will be
cut-down to 28bits, but this is no actual problem because signed values have
set all MSBs to the same value).<BR>
<BR>
<B>Internal Reference Point Registers</B><BR>
The above reference points are automatically copied to internal registers
during each vblank, specifying the origin for the first scanline. The internal
registers are then incremented by dmx and dmy after each scanline.<BR>
Caution: Writing to a reference point register by software outside of the
Vblank period does immediately copy the new value to the corresponding internal
register, that means: in the current frame, the new value specifies the origin
of the &lt;current&gt; scanline (instead of the topmost scanline).<BR>
<BR>
<B>4000020h - BG2PA - BG2 Rotation/Scaling Parameter A (alias dx) (W)</B><BR>
<B>4000022h - BG2PB - BG2 Rotation/Scaling Parameter B (alias dmx) (W)</B><BR>
<B>4000024h - BG2PC - BG2 Rotation/Scaling Parameter C (alias dy)  (W)</B><BR>
<B>4000026h - BG2PD - BG2 Rotation/Scaling Parameter D (alias dmy) (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-7   Fractional portion (8 bits)
  8-14  Integer portion    (7 bits)
  15    Sign               (1 bit)
</TD></TR></TABLE>
See below for details.<BR>
<BR>
<B>400003Xh - BG3X_L/H, BG3Y_L/H, BG3PA-D - BG3 Rotation/Scaling Parameters</B><BR>
Same as above BG2 Reference Point, and Rotation/Scaling Parameters, for BG3
respectively.<BR>
<BR>
<B>dx (PA) and dy (PC)</B><BR>
When transforming a horizontal line, dx and dy specify the resulting gradient
and magnification for that line. For example:<BR>
Horizontal line, length=100, dx=1, and dy=1. The resulting line would be drawn
at 45 degrees, f(y)=1/1*x. Note that this would involve that line is magnified,
the new length is SQR(100^2+100^2)=141.42. Yup, exactly - that's the old a^2 +
b^2 = c^2 formula.<BR>
<BR>
<B>dmx (PB) and dmy (PD)</B><BR>
These values define the resulting gradient and magnification for transformation
of vertical lines. However, when rotating a square area (which is surrounded by
horizontal and vertical lines), then the desired result should be usually a
rotated &lt;square&gt; area (ie. not a parallelogram, for example).<BR>
Thus, dmx and dmy must be defined in direct relationship to dx and dy, taking
the example above, we'd have to set dmx=-1, and dmy=1, f(x)=-1/1*y.<BR>
<BR>
<B>Area Overflow</B><BR>
In result of rotation/scaling it may often happen that areas outside of the
actual BG area become moved into the LCD viewport. Depending of the Area
Overflow bit (BG2CNT and BG3CNT, Bit 13) these areas may be either displayed
(by wrapping the BG area), or may be displayed transparent.<BR>
This works only in BG modes 1 and 2. The area overflow is ignored in Bitmap
modes (BG modes 3-5), the outside of the Bitmaps is always transparent.<BR>
<BR>
--- more details and confusing or helpful formulas ---<BR>
<BR>
<B>The following parameters are required for Rotation/Scaling</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Rotation Center X and Y Coordinates (x0,y0)
  Rotation Angle                      (alpha)
  Magnification X and Y Values        (xMag,yMag)
</TD></TR></TABLE>
The display is rotated by 'alpha' degrees around the center.<BR>
The displayed picture is magnified by 'xMag' along x-Axis (Y=y0) and 'yMag'
along y-Axis (X=x0).<BR>
<BR>
<B>Calculating Rotation/Scaling Parameters A-D</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  A = Cos (alpha) / xMag    ;distance moved in direction x, same line
  B = Sin (alpha) / xMag    ;distance moved in direction x, next line
  C = Sin (alpha) / yMag    ;distance moved in direction y, same line
  D = Cos (alpha) / yMag    ;distance moved in direction y, next line
</TD></TR></TABLE>
<BR>
<B>Calculating the position of a rotated/scaled dot</B><BR>
Using the following expressions,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  x0,y0    Rotation Center
  x1,y1    Old Position of a pixel (before rotation/scaling)
  x2,y2    New position of above pixel (after rotation scaling)
  A,B,C,D  BG2PA-BG2PD Parameters (as calculated above)
</TD></TR></TABLE>
the following formula can be used to calculate x2,y2:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  x2 = A(x1-x0) + B(y1-y0) + x0
  y2 = C(x1-x0) + D(y1-y0) + y0
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="lcdiowindowfeature"></A>&nbsp;
  LCD I/O Window Feature
</FONT></TD></TR></TABLE><BR>
The Window Feature may be used to split the screen into four regions. The
BG0-3,OBJ layers and Color Special Effects can be separately enabled or
disabled in each of these regions.<BR>
<BR>
<B>The DISPCNT Register</B><BR>
DISPCNT Bits 13-15 are used to enable Window 0, Window 1, and/or OBJ Window
regions, if any of these regions is enabled then the "Outside of Windows"
region is automatically enabled, too.<BR>
DISPCNT Bits 8-12 are kept used as master enable bits for the BG0-3,OBJ layers,
a layer is displayed only if both DISPCNT and WININ/OUT enable bits are set.<BR>
<BR>
<B>4000040h - WIN0H - Window 0 Horizontal Dimensions (W)</B><BR>
<B>4000042h - WIN1H - Window 1 Horizontal Dimensions (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-7   X2, Rightmost coordinate of window, plus 1
  8-15  X1, Leftmost coordinate of window
</TD></TR></TABLE>
Garbage values of X2&gt;240 or X1&gt;X2 are interpreted as X2=240.<BR>
<BR>
<B>4000044h - WIN0V - Window 0 Vertical Dimensions (W)</B><BR>
<B>4000046h - WIN1V - Window 1 Vertical Dimensions (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-7   Y2, Bottom-most coordinate of window, plus 1
  8-15  Y1, Top-most coordinate of window
</TD></TR></TABLE>
Garbage values of Y2&gt;160 or Y1&gt;Y2 are interpreted as Y2=160.<BR>
<BR>
<B>4000048h - WININ - Control of Inside of Window(s) (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-3   Window 0 BG0-BG3 Enable Bits     (0=No Display, 1=Display)
  4     Window 0 OBJ Enable Bit          (0=No Display, 1=Display)
  5     Window 0 Color Special Effect    (0=Disable, 1=Enable)
  6-7   Not used
  8-11  Window 1 BG0-BG3 Enable Bits     (0=No Display, 1=Display)
  12    Window 1 OBJ Enable Bit          (0=No Display, 1=Display)
  13    Window 1 Color Special Effect    (0=Disable, 1=Enable)
  14-15 Not used
</TD></TR></TABLE>
<BR>
<B>400004Ah - WINOUT - Control of Outside of Windows &amp; Inside of OBJ Window (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-3   Outside BG0-BG3 Enable Bits      (0=No Display, 1=Display)
  4     Outside OBJ Enable Bit           (0=No Display, 1=Display)
  5     Outside Color Special Effect     (0=Disable, 1=Enable)
  6-7   Not used
  8-11  OBJ Window BG0-BG3 Enable Bits   (0=No Display, 1=Display)
  12    OBJ Window OBJ Enable Bit        (0=No Display, 1=Display)
  13    OBJ Window Color Special Effect  (0=Disable, 1=Enable)
  14-15 Not used
</TD></TR></TABLE>
<BR>
<B>The OBJ Window</B><BR>
The dimension of the OBJ Window is specified by OBJs which are having the "OBJ
Mode" attribute being set to "OBJ Window". Any non-transparent dots of any such
OBJs are marked as OBJ Window area. The OBJ itself is not displayed.<BR>
The color, palette, and display priority of these OBJs are ignored. Both
DISPCNT Bits 12 and 15 must be set when defining OBJ Window region(s).<BR>
<BR>
<B>Window Priority</B><BR>
In case that more than one window is enabled, and that these windows do
overlap, Window 0 is having highest priority, Window 1 medium, and Obj Window
lowest priority. Outside of Window is having zero priority, it is used for all
dots which are not inside of any window region.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="lcdiomosaicfunction"></A>&nbsp;
  LCD I/O Mosaic Function
</FONT></TD></TR></TABLE><BR>
<B>400004Ch - MOSAIC - Mosaic Size (W)</B><BR>
The Mosaic function can be separately enabled/disabled for BG0-BG3 by
BG0CNT-BG3CNT Registers, as well as for each OBJ0-127 by OBJ attributes in OAM
memory. Also, setting all of the bits below to zero effectively disables the
mosaic function.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-3   BG Mosaic H-Size  (minus 1)
  4-7   BG Mosaic V-Size  (minus 1)
  8-11  OBJ Mosaic H-Size (minus 1)
  12-15 OBJ Mosaic V-Size (minus 1)
  16-31 Not used
</TD></TR></TABLE>
Example: When setting H-Size to 5, then pixels 0-5 of each display row are
colorized as pixel 0, pixels 6-11 as pixel 6, pixels 12-17 as pixel 12, and so
on.<BR>
<BR>
Normally, a 'mosaic-pixel' is colorized by the color of the upperleft covered
pixel. In many cases it might be more desireful to use the color of the pixel
in the center of the covered area - this effect may be gained by scrolling the
background (or by adjusting the OBJ position, as far as upper/left rows/columns
of OBJ are transparent).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="lcdiocolorspecialeffects"></A>&nbsp;
  LCD I/O Color Special Effects
</FONT></TD></TR></TABLE><BR>
Two types of Special Effects are supported: Alpha Blending (Semi-Transparency)
allows to combine colors of two selected surfaces. Brightness Increase/Decrease
adjust the brightness of the selected surface.<BR>
<BR>
<B>4000050h - BLDCNT - Color Special Effects Selection (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0     BG0 1st Target Pixel (Background 0)
  1     BG1 1st Target Pixel (Background 1)
  2     BG2 1st Target Pixel (Background 2)
  3     BG3 1st Target Pixel (Background 3)
  4     OBJ 1st Target Pixel (Top-most OBJ pixel)
  5     BD  1st Target Pixel (Backdrop)
  6-7   Color Special Effect (0-3, see below)
         0 = None                (Special effects disabled)
         1 = Alpha Blending      (1st+2nd Target mixed)
         2 = Brightness Increase (1st Target becomes whiter)
         3 = Brightness Decrease (1st Target becomes blacker)
  8     BG0 2nd Target Pixel (Background 0)
  9     BG1 2nd Target Pixel (Background 1)
  10    BG2 2nd Target Pixel (Background 2)
  11    BG3 2nd Target Pixel (Background 3)
  12    OBJ 2nd Target Pixel (Top-most OBJ pixel)
  13    BD  2nd Target Pixel (Backdrop)
  14-15 Not used
</TD></TR></TABLE>
Selects the 1st Target layer(s) for special effects. For Alpha
Blending/Semi-Transparency, it does also select the 2nd Target layer(s), which
should have next lower display priority as the 1st Target.<BR>
However, any combinations are possible, including that all layers may be
selected as both 1st+2nd target, in that case the top-most pixel will be used
as 1st target, and the next lower pixel as 2nd target.<BR>
<BR>
<B>4000052h - BLDALPHA - Alpha Blending Coefficients (W)</B><BR>
Used for Color Special Effects Mode 1, and for Semi-Transparent OBJs.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-4   EVA Coefficient (1st Target) (0..16 = 0/16..16/16, 17..31=16/16)
  5-7   Not used
  8-12  EVB Coefficient (2nd Target) (0..16 = 0/16..16/16, 17..31=16/16)
  13-15 Not used
</TD></TR></TABLE>
For this effect, the top-most non-transparent pixel must be selected as 1st
Target, and the next-lower non-transparent pixel must be selected as 2nd
Target, if so - and only if so, then color intensities of 1st and 2nd Target
are mixed together by using the parameters in BLDALPHA register, for each pixel
each R, G, B intensities are calculated separately:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  I = MIN ( 31, I1st*EVA + I2nd*EVB )
</TD></TR></TABLE>
Otherwise - for example, if only one target exists, or if a non-transparent
non-2nd-target pixel is moved between the two targets, or if 2nd target has
higher display priority than 1st target - then only the top-most pixel is
displayed (at normal intensity, regardless of BLDALPHA).<BR>
<BR>
<B>4000054h - BLDY - Brightness (Fade-In/Out) Coefficient (W)</B><BR>
Used for Color Special Effects Modes 2 and 3.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-4   EVY Coefficient (Brightness) (0..16 = 0/16..16/16, 17..31=16/16)
  5-31  Not used
</TD></TR></TABLE>
For each pixel each R, G, B intensities are calculated separately:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  I = I1st + (31-I1st)*EVY   ;For Brightness Increase
  I = I1st - (I1st)*EVY      ;For Brightness Decrease
</TD></TR></TABLE>
The color intensities of any selected 1st target surface(s) are increased or
decreased by using the parameter in BLDY register.<BR>
<BR>
<B>Semi-Transparent OBJs</B><BR>
OBJs that are defined as 'Semi-Transparent' in OAM memory are always selected
as 1st Target (regardless of BLDCNT Bit 4), and are always using Alpha Blending
mode (regardless of BLDCNT Bit 6-7).<BR>
The BLDCNT register may be used to perform Brightness effects on the OBJ
(and/or other BG/BD layers). However, if a semi-transparent OBJ pixel does
overlap a 2nd target pixel, then semi-transparency becomes priority, and the
brightness effect will not take place (neither on 1st, nor 2nd target).<BR>
<BR>
<B>The OBJ Layer</B><BR>
Before special effects are applied, the display controller computes the OBJ
priority ordering, and isolates the top-most OBJ pixel. In result, only the
top-most OBJ pixel is recursed at the time when processing special effects. Ie.
alpha blending and semi-transparency can be used for OBJ-to-BG or BG-to-OBJ ,
but not for OBJ-to-OBJ.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="lcdvramoverview"></A>&nbsp;
  LCD VRAM Overview
</FONT></TD></TR></TABLE><BR>
The GBA contains 96 Kbytes VRAM built-in, located at address 06000000-06017FFF,
depending on the BG Mode used as follows:<BR>
<BR>
<B>BG Mode 0,1,2 (Tile/Map based Modes)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  06000000-0600FFFF  64 KBytes shared for BG Map and Tiles
  06010000-06017FFF  32 KBytes OBJ Tiles
</TD></TR></TABLE>
The shared 64K area can be split into BG Map area(s), and BG Tiles area(s), the
respective addresses for Map and Tile areas are set up by BG0CNT-BG3CNT
registers. The Map address may be specified in units of 2K (steps of 800h), the
Tile address in units of 16K (steps of 4000h).<BR>
<BR>
<B>BG Mode 0,1 (Tile/Map based Text mode)</B><BR>
The tiles may have 4bit or 8bit color depth, minimum map size is 32x32 tiles,
maximum is 64x64 tiles, up to 1024 tiles can be used per map.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Item        Depth     Required Memory
  One Tile    4bit      20h bytes
  One Tile    8bit      40h bytes
  1024 Tiles  4bit      8000h (32K)
  1024 Tiles  8bit      10000h (64K) - excluding some bytes for BG map
  BG Map      32x32     800h (2K)
  BG Map      64x64     2000h (8K)
</TD></TR></TABLE>
<BR>
<B>BG Mode 1,2 (Tile/Map based Rotation/Scaling mode)</B><BR>
The tiles may have 8bit color depth only, minimum map size is 16x16 tiles,
maximum is 128x128 tiles, up to 256 tiles can be used per map.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Item        Depth     Required Memory
  One Tile    8bit      40h bytes
  256  Tiles  8bit      4000h (16K)
  BG Map      16x16     100h bytes
  BG Map      128x128   4000h (16K)
</TD></TR></TABLE>
<BR>
<B>BG Mode 3 (Bitmap based Mode for still images)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  06000000-06013FFF  80 KBytes Frame 0 buffer (only 75K actually used)
  06014000-06017FFF  16 KBytes OBJ Tiles
</TD></TR></TABLE>
<BR>
<B>BG Mode 4,5 (Bitmap based Modes)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  06000000-06009FFF  40 KBytes Frame 0 buffer (only 37.5K used in Mode 4)
  0600A000-06013FFF  40 KBytes Frame 1 buffer (only 37.5K used in Mode 4)
  06014000-06017FFF  16 KBytes OBJ Tiles
</TD></TR></TABLE>
<BR>
<B>Note</B><BR>
Additionally to the above VRAM, the GBA also contains 1 KByte Palette RAM (at
05000000h) and 1 KByte OAM (at 07000000h) which are both used by the display
controller as well.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="lcdvramcharacterdata"></A>&nbsp;
  LCD VRAM Character Data
</FONT></TD></TR></TABLE><BR>
Each character (tile) consists of 8x8 dots (64 dots in total). The color depth
may be either 4bit or 8bit (see BG0CNT-BG3CNT).<BR>
<BR>
<B>4bit depth (16 colors, 16 palettes)</B><BR>
Each tile occupies 32 bytes of memory, the first 4 bytes for the topmost row of
the tile, and so on. Each byte representing two dots, the lower 4 bits define
the color for the left (!) dot, the upper 4 bits the color for the right dot.<BR>
<BR>
<B>8bit depth (256 colors, 1 palette)</B><BR>
Each tile occupies 64 bytes of memory, the first 8 bytes for the topmost row of
the tile, and so on. Each byte selects the palette entry for each dot.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="lcdvrambgscreendataformatbgmap"></A>&nbsp;
  LCD VRAM BG Screen Data Format (BG Map)
</FONT></TD></TR></TABLE><BR>
The display background consists of 8x8 dot tiles, the arrangement of these
tiles is specified by the BG Screen Data (BG Map). The separate entries in this
map are as follows:<BR>
<BR>
<B>Text BG Screen (2 bytes per entry)</B><BR>
Specifies the tile number and attributes. Note that BG tile numbers are always
specified in steps of 1 (unlike OBJ tile numbers which are using steps of two
in 256 color/1 palette mode).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-9   Tile Number     (0-1023) (a bit less in 256 color mode, because
                           there'd be otherwise no room for the bg map)
  10    Horizontal Flip (0=Normal, 1=Mirrored)
  11    Vertical Flip   (0=Normal, 1=Mirrored)
  12-15 Palette Number  (0-15)    (Not used in 256 color/1 palette mode)
</TD></TR></TABLE>
A Text BG Map always consists of 32x32 entries (256x256 pixels), 400h entries =
800h bytes. However, depending on the BG Size, one, two, or four of these Maps
may be used together, allowing to create backgrounds of 256x256, 512x256,
256x512, or 512x512 pixels, if so, the first map (SC0) is located at base+0,
the next map (SC1) at base+800h, and so on.<BR>
<BR>
<B>Rotation/Scaling BG Screen (1 byte per entry)</B><BR>
In this mode, only 256 tiles can be used. There are no x/y-flip attributes, the
color depth is always 256 colors/1 palette.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-7   Tile Number     (0-255)
</TD></TR></TABLE>
The dimensions of Rotation/Scaling BG Maps depend on the BG size. For size 0-3
that are: 16x16 tiles (128x128 pixels), 32x32 tiles (256x256 pixels), 64x64
tiles (512x512 pixels), or 128x128 tiles (1024x1024 pixels).<BR>
<BR>
The size and VRAM base address of the separate BG maps for BG0-3 are set up by
BG0CNT-BG3CNT registers.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="lcdvrambitmapbgmodes"></A>&nbsp;
  LCD VRAM Bitmap BG Modes
</FONT></TD></TR></TABLE><BR>
In BG Modes 3-5 the background is defined in form of a bitmap (unlike as for
Tile/Map based BG modes). Bitmaps are implemented as BG2, with Rotation/Scaling
support. As bitmap modes are occupying 80KBytes of BG memory, only 16KBytes of
VRAM can be used for OBJ tiles.<BR>
<BR>
<B>BG Mode 3 - 240x160 pixels, 32768 colors</B><BR>
Two bytes are associated to each pixel, directly defining one of the 32768
colors (without using palette data, and thus not supporting a 'transparent' BG
color).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-4   Red Intensity   (0-31)
  5-9   Green Intensity (0-31)
  10-14 Blue Intensity  (0-31)
  15    Not used in GBA Mode (in NDS Mode: Alpha=0=Transparent, Alpha=1=Normal)
</TD></TR></TABLE>
The first 480 bytes define the topmost line, the next 480 the next line, and so
on. The background occupies 75 KBytes (06000000-06012BFF), most of the 80
Kbytes BG area, not allowing to redraw an invisible second frame in background,
so this mode is mostly recommended for still images only.<BR>
<BR>
<B>BG Mode 4 - 240x160 pixels, 256 colors (out of 32768 colors)</B><BR>
One byte is associated to each pixel, selecting one of the 256 palette entries.
Color 0 (backdrop) is transparent, and OBJs may be displayed behind the bitmap.<BR>
The first 240 bytes define the topmost line, the next 240 the next line, and so
on. The background occupies 37.5 KBytes, allowing two frames to be used
(06000000-060095FF for Frame 0, and 0600A000-060135FF for Frame 1).<BR>
<BR>
<B>BG Mode 5 - 160x128 pixels, 32768 colors</B><BR>
Colors are defined as for Mode 3 (see above), but horizontal and vertical size
are cut down to 160x128 pixels only - smaller than the physical dimensions of
the LCD screen.<BR>
The background occupies exactly 40 KBytes, so that BG VRAM may be split into
two frames (06000000-06009FFF for Frame 0, and 0600A000-06013FFF for Frame 1).<BR>
<BR>
In BG modes 4,5, one Frame may be displayed (selected by DISPCNT Bit 4), the
other Frame is invisible and may be redrawn in background.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="lcdobjoverview"></A>&nbsp;
  LCD OBJ - Overview
</FONT></TD></TR></TABLE><BR>
<B>General</B><BR>
Objects (OBJs) are moveable sprites. Up to 128 OBJs (of any size, up to 64x64
dots each) can be displayed per screen, and under best circumstances up to 128
OBJs (of small 8x8 dots size) can be displayed per horizontal display line.<BR>
<BR>
<B>Maximum Number of Sprites per Line</B><BR>
The total available OBJ rendering cycles per line are<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1210  (=304*4-6)   If "H-Blank Interval Free" bit in DISPCNT register is 0
  954   (=240*4-6)   If "H-Blank Interval Free" bit in DISPCNT register is 1
</TD></TR></TABLE>
The required rendering cycles are (depending on horizontal OBJ size)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Cycles per &lt;n&gt; Pixels    OBJ Type              OBJ Type Screen Pixel Range
  n*1 cycles               Normal OBJs           8..64 pixels
  10+n*2 cycles            Rotation/Scaling OBJs 8..64 pixels   (area clipped)
  10+n*2 cycles            Rotation/Scaling OBJs 16..128 pixels (double size)
</TD></TR></TABLE>
Caution:<BR>
The maximum number of OBJs per line is also affected by undisplayed (offscreen)
OBJs which are having higher priority than displayed OBJs.<BR>
To avoid this, move displayed OBJs to the begin of OAM memory (ie. OBJ0 has
highest priority, OBJ127 lowest).<BR>
Otherwise (in case that the program logic expects OBJs at fixed positions in
OAM) at least take care to set the OBJ size of undisplayed OBJs to 8x8 with
Rotation/Scaling disabled (this reduces the overload).<BR>
Does the above also apply for VERTICALLY OFFSCREEN (or VERTICALLY not on
CURRENT LINE) sprites ?<BR>
<BR>
<B>VRAM - Character Data</B><BR>
OBJs are always combined of one or more 8x8 pixel Tiles (much like BG Tiles in
BG Modes 0-2). However, OBJ Tiles are stored in a separate area in VRAM:
06010000-06017FFF (32 KBytes) in BG Mode 0-2, or 06014000-06017FFF (16 KBytes)
in BG Mode 3-5.<BR>
Depending on the size of the above area (16K or 32K), and on the OBJ color
depth (4bit or 8bit), 256-1024 8x8 dots OBJ Tiles can be defined.<BR>
<BR>
<B>OAM - Object Attribute Memory</B><BR>
This memory area contains Attributes which specify position, size, color depth,
etc. appearance for each of the 128 OBJs. Additionally, it contains 32 OBJ
Rotation/Scaling Parameter groups. OAM is located at 07000000-070003FF (sized 1
KByte).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="lcdobjoamattributes"></A>&nbsp;
  LCD OBJ - OAM Attributes
</FONT></TD></TR></TABLE><BR>
<B>OBJ Attributes</B><BR>
There are 128 entries in OAM for each OBJ0-OBJ127. Each entry consists of 6
bytes (three 16bit Attributes). Attributes for OBJ0 are located at 07000000,
for OBJ1 at 07000008, OBJ2 at 07000010, and so on.<BR>
<BR>
As you can see, there are blank spaces at 07000006, 0700000E, 07000016, etc. -
these 16bit values are used for OBJ Rotation/Scaling (as described in the next
chapter) - they are not directly related to the separate OBJs.<BR>
<BR>
<B>OBJ Attribute 0 (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-7   Y-Coordinate           (0-255)
  8     Rotation/Scaling Flag  (0=Off, 1=On)
  When Rotation/Scaling used (Attribute 0, bit 8 set):
    9     Double-Size Flag     (0=Normal, 1=Double)
  When Rotation/Scaling not used (Attribute 0, bit 8 cleared):
    9     OBJ Disable          (0=Normal, 1=Not displayed)
  10-11 OBJ Mode  (0=Normal, 1=Semi-Transparent, 2=OBJ Window, 3=Prohibited)
  12    OBJ Mosaic             (0=Off, 1=On)
  13    Colors/Palettes        (0=16/16, 1=256/1)
  14-15 OBJ Shape              (0=Square,1=Horizontal,2=Vertical,3=Prohibited)
</TD></TR></TABLE>
Caution: A very large OBJ (of 128 pixels vertically, ie. a 64 pixels OBJ in a
Double Size area) located at Y&gt;128 will be treated as at Y&gt;-128, the OBJ
is then displayed parts offscreen at the TOP of the display, it is then NOT
displayed at the bottom.<BR>
<BR>
<B>OBJ Attribute 1 (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-8   X-Coordinate           (0-511)
  When Rotation/Scaling used (Attribute 0, bit 8 set):
    9-13  Rotation/Scaling Parameter Selection (0-31)
          (Selects one of the 32 Rotation/Scaling Parameters that
          can be defined in OAM, for details read next chapter.)
  When Rotation/Scaling not used (Attribute 0, bit 8 cleared):
    9-11  Not used
    12    Horizontal Flip      (0=Normal, 1=Mirrored)
    13    Vertical Flip        (0=Normal, 1=Mirrored)
  14-15 OBJ Size               (0..3, depends on OBJ Shape, see Attr 0)
          Size  Square   Horizontal  Vertical
          0     8x8      16x8        8x16
          1     16x16    32x8        8x32
          2     32x32    32x16       16x32
          3     64x64    64x32       32x64
</TD></TR></TABLE>
<BR>
<B>OBJ Attribute 2 (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-9   Character Name          (0-1023=Tile Number)
  10-11 Priority relative to BG (0-3; 0=Highest)
  12-15 Palette Number   (0-15) (Not used in 256 color/1 palette mode)
</TD></TR></TABLE>
<BR>
<B>Notes:</B><BR>
<BR>
<B>OBJ Mode</B><BR>
The OBJ Mode may be Normal, Semi-Transparent, or OBJ Window.<BR>
Semi-Transparent means that the OBJ is used as 'Alpha Blending 1st Target'
(regardless of BLDCNT register, for details see chapter about Color Special
Effects).<BR>
OBJ Window means that the OBJ is not displayed, instead, dots with non-zero
color are used as mask for the OBJ Window, see DISPCNT and WINOUT for details.<BR>
<BR>
<B>OBJ Tile Number</B><BR>
There are two situations which may divide the amount of available tiles by two
(by four if both situations apply):<BR>
<BR>
1. When using the 256 Colors/1 Palette mode, only each second tile may be used,
the lower bit of the tile number should be zero (in 2-dimensional mapping mode,
the bit is completely ignored).<BR>
<BR>
2. When using BG Mode 3-5 (Bitmap Modes), only tile numbers 512-1023 may be
used. That is because lower 16K of OBJ memory are used for BG. Attempts to use
tiles 0-511 are ignored (not displayed).<BR>
<BR>
<B>Priority</B><BR>
In case that the 'Priority relative to BG' is the same than the priority of one
of the background layers, then the OBJ becomes higher priority and is displayed
on top of that BG layer.<BR>
Caution: Take care not to mess up BG Priority and OBJ priority. For example,
the following would cause garbage to be displayed:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  OBJ No. 0 with Priority relative to BG=1   ;hi OBJ prio, lo BG prio
  OBJ No. 1 with Priority relative to BG=0   ;lo OBJ prio, hi BG prio
</TD></TR></TABLE>
That is, OBJ0 is always having priority above OBJ1-127, so assigning a lower BG
Priority to OBJ0 than for OBJ1-127 would be a bad idea.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="lcdobjoamrotationscalingparameters"></A>&nbsp;
  LCD OBJ - OAM Rotation/Scaling Parameters
</FONT></TD></TR></TABLE><BR>
As described in the previous chapter, there are blank spaces between each of
the 128 OBJ Attribute Fields in OAM memory. These 128 16bit gaps are used to
store OBJ Rotation/Scaling Parameters.<BR>
<BR>
<B>Location of Rotation/Scaling Parameters in OAM</B><BR>
Four 16bit parameters (PA,PB,PC,PD) are required to define a complete group of
Rotation/Scaling data. These are spread across OAM as such:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1st Group - PA=07000006, PB=0700000E, PC=07000016, PD=0700001E
  2nd Group - PA=07000026, PB=0700002E, PC=07000036, PD=0700003E
  etc.
</TD></TR></TABLE>
By using all blank space (128 x 16bit), up to 32 of these groups (4 x 16bit
each) can be defined in OAM.<BR>
<BR>
<B>OBJ Rotation/Scaling PA,PB,PC,PD Parameters (R/W)</B><BR>
Each OBJ that uses Rotation/Scaling may select between any of the above 32
parameter groups. For details, refer to the previous chapter about OBJ
Attributes.<BR>
The meaning of the separate PA,PB,PC,PD values is identical as for BG, for
details read the chapter about BG Rotation/Scaling.<BR>
<BR>
<B>OBJ Reference Point &amp; Rotation Center</B><BR>
The OBJ Reference Point is the upper left of the OBJ, ie. OBJ X/Y coordinates:
X+0, Y+0.<BR>
The OBJ Rotation Center is always (or should be usually?) in the middle of the
object, ie. for a 8x32 pixel OBJ, this would be at the OBJ X/Y coordinates:
X+4, and Y+16.<BR>
<BR>
<B>OBJ Double-Size Bit (for OBJs that use Rotation/Scaling)</B><BR>
When Double-Size is zero: The sprite is rotated, and then display inside of the
normal-sized (not rotated) rectangular area - the edges of the rotated sprite
will become invisible if they reach outside of that area.<BR>
When Double-Size is set: The sprite is rotated, and then display inside of the
double-sized (not rotated) rectangular area - this ensures that the edges of
the rotated sprite remain visible even if they would reach outside of the
normal-sized area. (Except that, for example, rotating a 8x32 pixel sprite by
90 degrees would still cut off parts of the sprite as the double-size area
isn't large enough.)<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="lcdobjvramcharactertilemapping"></A>&nbsp;
  LCD OBJ - VRAM Character (Tile) Mapping
</FONT></TD></TR></TABLE><BR>
Each OBJ tile consists of 8x8 dots, however, bigger OBJs can be displayed by
combining several 8x8 tiles. The horizontal and vertical size for each OBJ may
be separately defined in OAM, possible H/V sizes are 8,16,32,64 dots - allowing
'square' OBJs to be used (such like 8x8, 16x16, etc) as well as 'rectangular'
OBJs (such like 8x32, 64x16, etc.)<BR>
<BR>
When displaying an OBJ that contains of more than one 8x8 tile, one of the
following two mapping modes can be used. In either case, the tile number of the
upperleft tile must be specified in OAM memory.<BR>
<BR>
<B>Two Dimensional Character Mapping (DISPCNT Bit 6 cleared)</B><BR>
This mapping mode assumes that the 1024 OBJ tiles are arranged as a matrix of
32x32 tiles / 256x256 pixels (In 256 color mode: 16x32 tiles / 128x256 pixels).
Ie. the upper row of this matrix contains tiles 00h-1Fh, the next row tiles
20h-3Fh, and so on.<BR>
For example, when displaying a 16x16 pixel OBJ, with tile number set to 04h;
The upper row of the OBJ will consist of tile 04h and 05h, the next row of 24h
and 25h. (In 256 color mode: 04h and 06h, 24h and 26h.)<BR>
<BR>
<B>One Dimensional Character Mapping (DISPCNT Bit 6 set)</B><BR>
In this mode, tiles are mapped each after each other from 00h-3FFh.<BR>
Using the same example as above, the upper row of the OBJ will consist of tile
04h and 05h, the next row of tile 06h and 07h. (In 256 color mode: 04h and 06h,
08h and 0Ah.)<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="lcdcolorpalettes"></A>&nbsp;
  LCD Color Palettes
</FONT></TD></TR></TABLE><BR>
<B>Color Palette RAM</B><BR>
BG and OBJ palettes are using separate memory regions:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  05000000-050001FF - BG Palette RAM (512 bytes, 256 colors)
  05000200-050003FF - OBJ Palette RAM (512 bytes, 256 colors)
</TD></TR></TABLE>
Each BG and OBJ palette RAM may be either split into 16 palettes with 16 colors
each, or may be used as a single palette with 256 colors.<BR>
Note that some OBJs may access palette RAM in 16 color mode, while other OBJs
may use 256 color mode at the same time. Same for BG0-BG3 layers.<BR>
<BR>
<B>Transparent Colors</B><BR>
Color 0 of all BG and OBJ palettes is transparent. Even though palettes are
described as 16 (256) color palettes, only 15 (255) colors are actually
visible.<BR>
<BR>
<B>Backdrop Color</B><BR>
Color 0 of BG Palette 0 is used as backdrop color. This color is displayed if
an area of the screen is not covered by any non-transparent BG or OBJ dots.<BR>
<BR>
<B>Color Definitions</B><BR>
Each color occupies two bytes (same as for 32768 color BG modes):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-4   Red Intensity   (0-31)
  5-9   Green Intensity (0-31)
  10-14 Blue Intensity  (0-31)
  15    Not used
</TD></TR></TABLE>
<BR>
<B>Intensities</B><BR>
Under normal circumstances (light source/viewing angle), the intensities 0-14
are practically all black, and only intensities 15-31 are resulting in visible
medium..bright colors.<BR>
<BR>
Note: The intensity problem appears in the 8bit CGB "compatibility" mode
either. The original CGB display produced the opposite effect: Intensities 0-14
resulted in dark..medium colors, and intensities 15-31 resulted in bright
colors. Any "medium" colors of CGB games will appear invisible/black on GBA
hardware, and only very bright colors will be visible.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="lcddimensionsandtimings"></A>&nbsp;
  LCD Dimensions and Timings
</FONT></TD></TR></TABLE><BR>
<B>Horizontal Dimensions</B><BR>
The drawing time for each dot is 4 CPU cycles.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Visible     240 dots,  57.221 us,    960 cycles - 78% of h-time
  H-Blanking   68 dots,  16.212 us,    272 cycles - 22% of h-time
  Total       308 dots,  73.433 us,   1232 cycles - ca. 13.620 kHz
</TD></TR></TABLE>
VRAM and Palette RAM may be accessed during H-Blanking. OAM can accessed only
if "H-Blank Interval Free" bit in DISPCNT register is set.<BR>
<BR>
<B>Vertical Dimensions</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Visible (*) 160 lines, 11.749 ms, 197120 cycles - 70% of v-time
  V-Blanking   68 lines,  4.994 ms,  83776 cycles - 30% of v-time
  Total       228 lines, 16.743 ms, 280896 cycles - ca. 59.737 Hz
</TD></TR></TABLE>
All VRAM, OAM, and Palette RAM may be accessed during V-Blanking.<BR>
Note that no H-Blank interrupts are generated within V-Blank period.<BR>
<BR>
<B>System Clock</B><BR>
The system clock is 16.78MHz (16*1024*1024 Hz), one cycle is thus approx.
59.59ns.<BR>
<BR>
(*) Even though vertical screen size is 160 lines, the upper 8 lines are not
&lt;really&gt; visible, these lines are covered by a shadow when holding the
GBA orientated towards a light source, the lines are effectively black - and
should not be used to display important information.<BR>
<BR>
<B>Interlace</B><BR>
The LCD display is using some sort of interlace in which even scanlines are
dimmed in each second frame, and odd scanlines are dimmed in each other frame
(it does always render ALL lines in ALL frames, but half of them are dimmed).<BR>
The effect can be seen when displaying some horizontal lines in each second
frame, and hiding them in each other frame: the hardware will randomly show the
lines in dimmed or non-dimmed form (depending on whether the test was started
in an even or odd frame).<BR>
Unknown if it's possible to determine the even/off frame state by software (or
possibly to reset the hardware to this or that state by software).<BR>
Note: The NDS is applying some sort of frameskip to GBA games, about every 3
seconds there will by a missing (or maybe: inserted) frame, ie. a GBA game that
is updating the display in sync with GBA interlace will get offsync on NDS
consoles.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbasoundcontroller"></A>&nbsp;
  GBA Sound Controller
</FONT></TD></TR></TABLE><BR>
The GBA supplies four 'analogue' sound channels for Tone and Noise (mostly
compatible to CGB sound), as well as two 'digital' sound channels (which can be
used to replay 8bit DMA sample data).<BR>
<BR>
<A HREF="#gbasoundchannel1tonesweep">GBA Sound Channel 1 - Tone &amp; Sweep</A><BR>
<A HREF="#gbasoundchannel2tone">GBA Sound Channel 2 - Tone</A><BR>
<A HREF="#gbasoundchannel3waveoutput">GBA Sound Channel 3 - Wave Output</A><BR>
<A HREF="#gbasoundchannel4noise">GBA Sound Channel 4 - Noise</A><BR>
<A HREF="#gbasoundchannelaandbdmasound">GBA Sound Channel A and B - DMA Sound</A><BR>
<BR>
<A HREF="#gbasoundcontrolregisters">GBA Sound Control Registers</A><BR>
<A HREF="#gbacomparisonofcgbandgbasound">GBA Comparison of CGB and GBA Sound</A><BR>
<BR>
The GBA includes only a single (mono) speaker built-in, each channel may be
output to either left and/or right channels by using the external line-out
connector (for stereo headphones, etc).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbasoundchannel1tonesweep"></A>&nbsp;
  GBA Sound Channel 1 - Tone &amp; Sweep
</FONT></TD></TR></TABLE><BR>
<B>4000060h - SOUND1CNT_L (NR10) - Channel 1 Sweep register (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit        Expl.
  0-2   R/W  Number of sweep shift      (n=0-7)
  3     R/W  Sweep Frequency Direction  (0=Increase, 1=Decrease)
  4-6   R/W  Sweep Time; units of 7.8ms (0-7, min=7.8ms, max=54.7ms)
  7-15  -    Not used
</TD></TR></TABLE>
Sweep is disabled by setting Sweep Time to zero, if so, the direction bit
should be set.<BR>
The change of frequency (NR13,NR14) at each shift is calculated by the
following formula where X(0) is initial freq &amp; X(t-1) is last freq:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  X(t) = X(t-1) +/- X(t-1)/2^n
</TD></TR></TABLE>
<BR>
<B>4000062h - SOUND1CNT_H (NR11, NR12) - Channel 1 Duty/Len/Envelope (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit        Expl.
  0-5   W    Sound length; units of (64-n)/256s  (0-63)
  6-7   R/W  Wave Pattern Duty                   (0-3, see below)
  8-10  R/W  Envelope Step-Time; units of n/64s  (1-7, 0=No Envelope)
  11    R/W  Envelope Direction                  (0=Decrease, 1=Increase)
  12-15 R/W  Initial Volume of envelope          (1-15, 0=No Sound)
</TD></TR></TABLE>
Wave Duty:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0: 12.5% ( -_______-_______-_______ )
  1: 25%   ( --______--______--______ )
  2: 50%   ( ----____----____----____ ) (normal)
  3: 75%   ( ------__------__------__ )
</TD></TR></TABLE>
The Length value is used only if Bit 6 in NR14 is set.<BR>
<BR>
<B>4000064h - SOUND1CNT_X (NR13, NR14) - Channel 1 Frequency/Control (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit        Expl.
  0-10  W    Frequency; 131072/(2048-n)Hz  (0-2047)
  11-13 -    Not used
  14    R/W  Length Flag  (1=Stop output when length in NR11 expires)
  15    W    Initial      (1=Restart Sound)
  16-31 -    Not used
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbasoundchannel2tone"></A>&nbsp;
  GBA Sound Channel 2 - Tone
</FONT></TD></TR></TABLE><BR>
This sound channel works exactly as channel 1, except that it doesn't have a
Tone Envelope/Sweep Register.<BR>
<BR>
<B>4000068h - SOUND2CNT_L (NR21, NR22) - Channel 2 Duty/Length/Envelope (R/W)</B><BR>
<B>400006Ah - Not used</B><BR>
<B>400006Ch - SOUND2CNT_H (NR23, NR24) - Channel 2 Frequency/Control (R/W)</B><BR>
For details, refer to channel 1 description.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbasoundchannel3waveoutput"></A>&nbsp;
  GBA Sound Channel 3 - Wave Output
</FONT></TD></TR></TABLE><BR>
This channel can be used to output digital sound, the length of the sample
buffer (Wave RAM) can be either 32 or 64 digits (4bit samples). This sound
channel can be also used to output normal tones when initializing the Wave RAM
by a square wave. This channel doesn't have a volume envelope register.<BR>
<BR>
<B>4000070h - SOUND3CNT_L (NR30) - Channel 3 Stop/Wave RAM select (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit        Expl.
  0-4   -    Not used
  5     R/W  Wave RAM Dimension   (0=One bank/32 digits, 1=Two banks/64 digits)
  6     R/W  Wave RAM Bank Number (0-1, see below)
  7     R/W  Sound Channel 3 Off  (0=Stop, 1=Playback)
  8-15  -    Not used
</TD></TR></TABLE>
The currently selected Bank Number (Bit 6) will be played back, while
reading/writing to/from wave RAM will address the other (not selected) bank.
When dimension is set to two banks, output will start by replaying the
currently selected bank.<BR>
<BR>
<B>4000072h - SOUND3CNT_H (NR31, NR32) - Channel 3 Length/Volume (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit        Expl.
  0-7   W    Sound length; units of (256-n)/256s  (0-255)
  8-12  -    Not used.
  13-14 R/W  Sound Volume  (0=Mute/Zero, 1=100%, 2=50%, 3=25%)
  15    R/W  Force Volume  (0=Use above, 1=Force 75% regardless of above)
</TD></TR></TABLE>
The Length value is used only if Bit 6 in NR34 is set.<BR>
<BR>
<B>4000074h - SOUND3CNT_X (NR33, NR34) - Channel 3 Frequency/Control (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit        Expl.
  0-10  W    Sample Rate; 2097152/(2048-n) Hz   (0-2047)
  11-13 -    Not used
  14    R/W  Length Flag  (1=Stop output when length in NR31 expires)
  15    W    Initial      (1=Restart Sound)
  16-31 -    Not used
</TD></TR></TABLE>
The above sample rate specifies the number of wave RAM digits per second, the
actual tone frequency depends on the wave RAM content, for example:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Wave RAM, single bank 32 digits   Tone Frequency
  FFFFFFFFFFFFFFFF0000000000000000  65536/(2048-n) Hz
  FFFFFFFF00000000FFFFFFFF00000000  131072/(2048-n) Hz
  FFFF0000FFFF0000FFFF0000FFFF0000  262144/(2048-n) Hz
  FF00FF00FF00FF00FF00FF00FF00FF00  524288/(2048-n) Hz
  F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0  1048576/(2048-n) Hz
</TD></TR></TABLE>
<BR>
<B>4000090h - WAVE_RAM0_L - Channel 3 Wave Pattern RAM (W/R)</B><BR>
<B>4000092h - WAVE_RAM0_H - Channel 3 Wave Pattern RAM (W/R)</B><BR>
<B>4000094h - WAVE_RAM1_L - Channel 3 Wave Pattern RAM (W/R)</B><BR>
<B>4000096h - WAVE_RAM1_H - Channel 3 Wave Pattern RAM (W/R)</B><BR>
<B>4000098h - WAVE_RAM2_L - Channel 3 Wave Pattern RAM (W/R)</B><BR>
<B>400009Ah - WAVE_RAM2_H - Channel 3 Wave Pattern RAM (W/R)</B><BR>
<B>400009Ch - WAVE_RAM3_L - Channel 3 Wave Pattern RAM (W/R)</B><BR>
<B>400009Eh - WAVE_RAM3_H - Channel 3 Wave Pattern RAM (W/R)</B><BR>
This area contains 16 bytes (32 x 4bits) Wave Pattern data which is output by
channel 3. Data is played back ordered as follows: MSBs of 1st byte, followed
by LSBs of 1st byte, followed by MSBs of 2nd byte, and so on - this results in
a confusing ordering when filling Wave RAM in units of 16bit data - ie. samples
would be then located in Bits 4-7, 0-3, 12-15, 8-11.<BR>
<BR>
In the GBA, two Wave Patterns exists (each 32 x 4bits), either one may be
played (as selected in NR30 register), the other bank may be accessed by the
users. After all 32 samples have been played, output of the same bank (or other
bank, as specified in NR30) will be automatically restarted.<BR>
<BR>
Internally, Wave RAM is a giant shift-register, there is no pointer which is
addressing the currently played digit. Instead, the entire 128 bits are
shifted, and the 4 least significant bits are output.<BR>
Thus, when reading from Wave RAM, data might have changed its position. And,
when writing to Wave RAM all data should be updated (it'd be no good idea to
assume that old data is still located at the same position where it has been
written to previously).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbasoundchannel4noise"></A>&nbsp;
  GBA Sound Channel 4 - Noise
</FONT></TD></TR></TABLE><BR>
This channel is used to output white noise. This is done by randomly switching
the amplitude between high and low at a given frequency. Depending on the
frequency the noise will appear 'harder' or 'softer'.<BR>
<BR>
It is also possible to influence the function of the random generator, so the
that the output becomes more regular, resulting in a limited ability to output
Tone instead of Noise.<BR>
<BR>
<B>4000078h - SOUND4CNT_L (NR41, NR42) - Channel 4 Length/Envelope (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit        Expl.
  0-5   W    Sound length; units of (64-n)/256s  (0-63)
  6-7   -    Not used
  8-10  R/W  Envelope Step-Time; units of n/64s  (1-7, 0=No Envelope)
  11    R/W  Envelope Direction                  (0=Decrease, 1=Increase)
  12-15 R/W  Initial Volume of envelope          (1-15, 0=No Sound)
  16-31 -    Not used
</TD></TR></TABLE>
The Length value is used only if Bit 6 in NR44 is set.<BR>
<BR>
<B>400007Ch - SOUND4CNT_H (NR43, NR44) - Channel 4 Frequency/Control (R/W)</B><BR>
The amplitude is randomly switched between high and low at the given frequency.
A higher frequency will make the noise to appear 'softer'.<BR>
When Bit 3 is set, the output will become more regular, and some frequencies
will sound more like Tone than Noise.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit        Expl.
  0-2   R/W  Dividing Ratio of Frequencies (r)
  3     R/W  Counter Step/Width (0=15 bits, 1=7 bits)
  4-7   R/W  Shift Clock Frequency (s)
  8-13  -    Not used
  14    R/W  Length Flag  (1=Stop output when length in NR41 expires)
  15    W    Initial      (1=Restart Sound)
  16-31 -    Not used
</TD></TR></TABLE>
Frequency = 524288 Hz / r / 2^(s+1)     ;For r=0 assume r=0.5 instead<BR>
<BR>
<B>Noise Random Generator (aka Polynomial Counter)</B><BR>
Noise randomly switches between HIGH and LOW levels, the output levels are
calculated by a shift register (X), at the selected frequency, as such:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7bit:  X=X SHR 1, IF carry THEN Out=HIGH, X=X XOR 60h ELSE Out=LOW
  15bit: X=X SHR 1, IF carry THEN Out=HIGH, X=X XOR 6000h ELSE Out=LOW
</TD></TR></TABLE>
The initial value when (re-)starting the sound is X=40h (7bit) or X=4000h
(15bit). The data stream repeats after 7Fh (7bit) or 7FFFh (15bit) steps.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbasoundchannelaandbdmasound"></A>&nbsp;
  GBA Sound Channel A and B - DMA Sound
</FONT></TD></TR></TABLE><BR>
The GBA contains two DMA sound channels (A and B), each allowing to replay
digital sound (signed 8bit data, ie. -128..+127). Data can be transferred from
INTERNAL memory (not sure if EXTERNAL memory works also ?) to FIFO by using DMA
channel 1 or 2, the sample rate is generated by using one of the Timers.<BR>
<BR>
<B>40000A0h - FIFO_A_L - Sound A FIFO, Data 0 and Data 1 (W)</B><BR>
<B>40000A2h - FIFO_A_H - Sound A FIFO, Data 2 and Data 3 (W)</B><BR>
These two registers may receive 32bit (4 bytes) of audio data (Data 0-3, Data 0
being located in least significant byte which is replayed first).<BR>
Internally, the capacity of the FIFO is 8 x 32bit (32 bytes), allowing to
buffer a small amount of samples. As the name says (First In First Out), oldest
data is replayed first.<BR>
<BR>
<B>40000A4h - FIFO_B_L - Sound B FIFO, Data 0 and Data 1 (W)</B><BR>
<B>40000A6h - FIFO_B_H - Sound B FIFO, Data 2 and Data 3 (W)</B><BR>
Same as above, for Sound B.<BR>
<BR>
<B>Initializing DMA-Sound Playback</B><BR>
- Select Timer 0 or 1 in SOUNDCNT_H control register.<BR>
- Clear the FIFO.<BR>
- Manually write a sample byte to the FIFO.<BR>
- Initialize transfer mode for DMA 1 or 2.<BR>
- Initialize DMA Sound settings in sound control register.<BR>
- Start the timer.<BR>
<BR>
<B>DMA-Sound Playback Procedure</B><BR>
The pseudo-procedure below is automatically repeated.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  If Timer overflows then
    Move 8bit data from FIFO to sound circuit.
    If FIFO contains only 4 x 32bits (16 bytes) then
      Request more data per DMA
      Receive 4 x 32bit (16 bytes) per DMA
    Endif
  Endif
</TD></TR></TABLE>
This playback mechanism will be repeated forever, regardless of the actual
length of the sample buffer.<BR>
<BR>
<B>Synchronizing Sample Buffers</B><BR>
The buffer-end may be determined by counting sound Timer IRQs (each sample
byte), or sound DMA IRQs (each 16th sample byte). Both methods would require a
lot of CPU time (IRQ processing), and both would fail if interrupts are
disabled for a longer period.<BR>
Better solutions would be to synchronize the sample rate/buffer length with
V-blanks, or to use a second timer (in count up/slave mode) which produces an
IRQ after the desired number of samples.<BR>
<BR>
<B>The Sample Rate</B><BR>
The GBA hardware does internally re-sample all sound output to 32.768kHz
(default SOUNDBIAS setting). It'd thus do not make much sense to use higher
DMA/Timer rates. Best re-sampling accuracy can be gained by using DMA/Timer
rates of 32.768kHz, 16.384kHz, or 8.192kHz (ie. fragments of the physical
output rate).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbasoundcontrolregisters"></A>&nbsp;
  GBA Sound Control Registers
</FONT></TD></TR></TABLE><BR>
<B>4000080h - SOUNDCNT_L (NR50, NR51) - Channel L/R Volume/Enable (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-2   Sound 1-4 Master Volume RIGHT (0-7)
  3     Not used
  4-6   Sound 1-4 Master Volume LEFT (0-7)
  7     Not used
  8-11  Sound 1-4 Enable Flags RIGHT (each Bit 8-11, 0=Disable, 1=Enable)
  12-15 Sound 1-4 Enable Flags LEFT (each Bit 12-15, 0=Disable, 1=Enable)
</TD></TR></TABLE>
<BR>
<B>4000082h - SOUNDCNT_H (GBA only) - DMA Sound Control/Mixing (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-1   Sound # 1-4 Volume   (0=25%, 1=50%, 2=100%, 3=Prohibited)
  2     DMA Sound A Volume   (0=50%, 1=100%)
  3     DMA Sound B Volume   (0=50%, 1=100%)
  4-7   Not used
  8     DMA Sound A Enable RIGHT (0=Disable, 1=Enable)
  9     DMA Sound A Enable LEFT  (0=Disable, 1=Enable)
  10    DMA Sound A Timer Select (0=Timer 0, 1=Timer 1)
  11    DMA Sound A Reset FIFO   (1=Reset)
  12    DMA Sound B Enable RIGHT (0=Disable, 1=Enable)
  13    DMA Sound B Enable LEFT  (0=Disable, 1=Enable)
  14    DMA Sound B Timer Select (0=Timer 0, 1=Timer 1)
  15    DMA Sound B Reset FIFO   (1=Reset)
</TD></TR></TABLE>
<BR>
<B>4000084h - SOUNDCNT_X (NR52) - Sound on/off (R/W)</B><BR>
Bits 0-3 are automatically set when starting sound output, and are
automatically cleared when a sound ends. (Ie. when the length expires, as far
as length is enabled. The bits are NOT reset when an volume envelope ends.)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0     Sound 1 ON flag (Read Only)
  1     Sound 2 ON flag (Read Only)
  2     Sound 3 ON flag (Read Only)
  3     Sound 4 ON flag (Read Only)
  4-6   Not used
  7     PSG/FIFO Master Enable (0=Disable, 1=Enable) (Read/Write)
  8-31  Not used
</TD></TR></TABLE>
While Bit 7 is cleared, both PSG and FIFO sounds are disabled, and all PSG
registers (4000060h..4000081h) are reset to zero (and must be re-initialized
after re-enabling sound). However, registers 4000082h and 4000088h are kept
read/write-able (of which, 4000082h has no function when sound is off, whilst
4000088h does work even when sound is off).<BR>
<BR>
<B>4000088h - SOUNDBIAS - Sound PWM Control (R/W, see below)</B><BR>
This register controls the final sound output. The default setting is 0200h, it
is normally not required to change this value.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit    Expl.
  0-9    Bias Level     (Default=200h, converting signed samples into unsigned)
  10-13  Not used
  14-15  Amplitude Resolution/Sampling Cycle (Default=0, see below)
  16-31  Not used
</TD></TR></TABLE>
Amplitude Resolution/Sampling Cycle (0-3):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0  9bit / 32.768kHz   (Default, best for DMA channels A,B)
  1  8bit / 65.536kHz
  2  7bit / 131.072kHz
  3  6bit / 262.144kHz  (Best for PSG channels 1-4)
</TD></TR></TABLE>
For more information on this register, read the descriptions below.<BR>
<BR>
<B>400008Ch - Not used</B><BR>
<B>400008Eh - Not used</B><BR>
<BR>
<B>Max Output Levels (with max volume settings)</B><BR>
Each of the two FIFOs can span the FULL output range (+/-200h).<BR>
Each of the four PSGs can span one QUARTER of the output range (+/-80h).<BR>
The current output levels of all six channels are added together by hardware.<BR>
So together, the FIFOs and PSGs, could reach THRICE the range (+/-600h).<BR>
The BIAS value is added to that signed value. With default BIAS (200h), the
possible range becomes -400h..+800h, however, values that exceed the unsigned
10bit output range of 0..3FFh are clipped to MinMax(0,3FFh).<BR>
<BR>
<B>Resampling to 32.768kHz / 9bit (default)</B><BR>
The PSG channels 1-4 are internally generated at 262.144kHz, and DMA sound A-B
could be theoretically generated at timer rates up to 16.78MHz. However, the
final sound output is resampled to a rate of 32.768kHz, at 9bit depth (the
above 10bit value, divided by two). If necessary, rates higher than 32.768kHz
can be selected in the SOUNDBIAS register, that would result in a depth smaller
than 9bit though.<BR>
<BR>
<B>PWM (Pulse Width Modulation) Output 16.78MHz / 1bit</B><BR>
Okay, now comes the actual output. The GBA can output only two voltages (low
and high), these 'bits' are output at system clock speed (16.78MHz). If using
the default 32.768kHz sampling rate, then 512 bits are output per sample
(512*32K=16M). Each sample value (9bit range, N=0..511), would be then output
as N low bits, followed by 512-N high bits. The resulting 'noise' is smoothed
down by capacitors, by the speaker, and by human hearing, so that it will
effectively sound like clean D/A converted 9bit voltages at 32kHz sampling
rate.<BR>
<BR>
<B>Changing the BIAS Level</B><BR>
Normally use 200h for clean sound output. A value of 000h might make sense
during periods when no sound is output (causing the PWM circuit to output
low-bits only, which is eventually reducing the power consumption, and/or
preventing 32KHz noise). Note: Using the SoundBias function (SWI 19h) allows to
change the level by slowly incrementing or decrementing it (without hard
scratch noise).<BR>
<BR>
<B>Low Power Mode</B><BR>
When not using sound output, power consumption can be reduced by setting both
4000084h (PSG/FIFO) and 4000088h (BIAS) to zero.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbacomparisonofcgbandgbasound"></A>&nbsp;
  GBA Comparison of CGB and GBA Sound
</FONT></TD></TR></TABLE><BR>
The GBA sound controller is mostly the same than that of older monochrome
gameboy and CGB. The following changes have been done:<BR>
<BR>
<B>New Sound Channels</B><BR>
Two new sound channels have been added that may be used to replay 8bit digital
sound. Sample rate and sample data must be supplied by using a Timer and a DMA
channel.<BR>
<BR>
<B>New Control Registers</B><BR>
The SOUNDCNT_H register controls the new DMA channels - as well as mixing with
the four old channels. The SOUNDBIAS register controls the final sound output.<BR>
<BR>
<B>Sound Channel 3 Changes</B><BR>
The length of the Wave RAM is doubled by dividing it into two banks of 32
digits each, either one or both banks may be replayed (one after each other),
for details check NR30 Bit 5-6. Optionally, the sound may be output at 75%
volume, for details check NR32 Bit 7.<BR>
<BR>
<B>Changed Control Registers</B><BR>
NR50 is not supporting Vin signals (that's been an external sound input from
cartridge).<BR>
<BR>
<B>Changed I/O Addresses</B><BR>
The GBAs sound register are located at 04000060-040000AE instead of at
FF10-FF3F as in CGB and monochrome gameboy. However, note that there have been
new blank spaces inserted between some of the separate registers - therefore it
is NOT possible to port CGB software to GBA just by changing the sound base
address.<BR>
<BR>
<B>Accessing I/O Registers</B><BR>
In some cases two of the old 8bit registers are packed into a 16bit register
and may be accessed as such.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbatimers"></A>&nbsp;
  GBA Timers
</FONT></TD></TR></TABLE><BR>
The GBA includes four incrementing 16bit timers.<BR>
Timer 0 and 1 can be used to supply the sample rate for DMA sound channel A
and/or B.<BR>
<BR>
<B>4000100h - TM0CNT_L - Timer 0 Counter/Reload (R/W)</B><BR>
<B>4000104h - TM1CNT_L - Timer 1 Counter/Reload (R/W)</B><BR>
<B>4000108h - TM2CNT_L - Timer 2 Counter/Reload (R/W)</B><BR>
<B>400010Ch - TM3CNT_L - Timer 3 Counter/Reload (R/W)</B><BR>
Writing to these registers initializes the &lt;reload&gt; value (but does not
directly affect the current counter value). Reading returns the current
&lt;counter&gt; value (or the recent/frozen counter value if the timer has been
stopped).<BR>
The reload value is copied into the counter only upon following two situations:
Automatically upon timer overflows, or when the timer start bit becomes changed
from 0 to 1.<BR>
Note: When simultaneously changing the start bit from 0 to 1, and setting the
reload value at the same time (by a single 32bit I/O operation), then the newly
written reload value is recognized as new counter value.<BR>
<BR>
<B>4000102h - TM0CNT_H - Timer 0 Control (R/W)</B><BR>
<B>4000106h - TM1CNT_H - Timer 1 Control (R/W)</B><BR>
<B>400010Ah - TM2CNT_H - Timer 2 Control (R/W)</B><BR>
<B>400010Eh - TM3CNT_H - Timer 3 Control (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-1   Prescaler Selection (0=F/1, 1=F/64, 2=F/256, 3=F/1024)
  2     Count-up Timing   (0=Normal, 1=See below)
  3-5   Not used
  6     Timer IRQ Enable  (0=Disable, 1=IRQ on Timer overflow)
  7     Timer Start/Stop  (0=Stop, 1=Operate)
  8-15  Not used
</TD></TR></TABLE>
When Count-up Timing is enabled, the prescaler value is ignored, instead the
time is incremented each time when the previous counter overflows. This
function cannot be used for Timer 0 (as it is the first timer).<BR>
F = System Clock (16.78MHz).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbadmatransfers"></A>&nbsp;
  GBA DMA Transfers
</FONT></TD></TR></TABLE><BR>
<B>Overview</B><BR>
The GBA includes four DMA channels, the highest priority is assigned to DMA0,
followed by DMA1, DMA2, and DMA3. DMA Channels with lower priority are paused
until channels with higher priority have completed.<BR>
The CPU is paused when DMA transfers are active, however, the CPU is operating
during the periods when Sound/Blanking DMA transfers are paused.<BR>
<BR>
<B>Special features of the separate DMA channels</B><BR>
DMA0 - highest priority, best for timing critical transfers (eg. HBlank DMA).<BR>
DMA1 and DMA2 - can be used to feed digital sample data to the Sound FIFOs.<BR>
DMA3 - can be used to write to Game Pak ROM/FlashROM (but not GamePak SRAM).<BR>
Beside for that, each DMA 0-3 may be used for whatever general purposes.<BR>
<BR>
<B>40000B0h,0B2h - DMA0SAD - DMA 0 Source Address (W) (internal memory)</B><BR>
<B>40000BCh,0BEh - DMA1SAD - DMA 1 Source Address (W) (any memory)</B><BR>
<B>40000C8h,0CAh - DMA2SAD - DMA 2 Source Address (W) (any memory)</B><BR>
<B>40000D4h,0D6h - DMA3SAD - DMA 3 Source Address (W) (any memory)</B><BR>
The most significant address bits are ignored, only the least significant 27 or
28 bits are used (max 07FFFFFFh internal memory, or max 0FFFFFFFh any memory -
except SRAM ?!).<BR>
<BR>
<B>40000B4h,0B6h - DMA0DAD - DMA 0 Destination Address (W) (internal memory)</B><BR>
<B>40000C0h,0C2h - DMA1DAD - DMA 1 Destination Address (W) (internal memory)</B><BR>
<B>40000CCh,0CEh - DMA2DAD - DMA 2 Destination Address (W) (internal memory)</B><BR>
<B>40000D8h,0DAh - DMA3DAD - DMA 3 Destination Address (W) (any memory)</B><BR>
The most significant address bits are ignored, only the least significant 27 or
28 bits are used (max. 07FFFFFFh internal memory or 0FFFFFFFh any memory -
except SRAM ?!).<BR>
<BR>
<B>40000B8h - DMA0CNT_L - DMA 0 Word Count (W) (14 bit, 1..4000h)</B><BR>
<B>40000C4h - DMA1CNT_L - DMA 1 Word Count (W) (14 bit, 1..4000h)</B><BR>
<B>40000D0h - DMA2CNT_L - DMA 2 Word Count (W) (14 bit, 1..4000h)</B><BR>
<B>40000DCh - DMA3CNT_L - DMA 3 Word Count (W) (16 bit, 1..10000h)</B><BR>
Specifies the number of data units to be transferred, each unit is 16bit or
32bit depending on the transfer type, a value of zero is treated as max length
(ie. 4000h, or 10000h for DMA3).<BR>
<BR>
<B>40000BAh - DMA0CNT_H - DMA 0 Control (R/W)</B><BR>
<B>40000C6h - DMA1CNT_H - DMA 1 Control (R/W)</B><BR>
<B>40000D2h - DMA2CNT_H - DMA 2 Control (R/W)</B><BR>
<B>40000DEh - DMA3CNT_H - DMA 3 Control (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-4   Not used
  5-6   Dest Addr Control  (0=Increment,1=Decrement,2=Fixed,3=Increment/Reload)
  7-8   Source Adr Control (0=Increment,1=Decrement,2=Fixed,3=Prohibited)
  9     DMA Repeat                   (0=Off, 1=On) (Must be zero if Bit 11 set)
  10    DMA Transfer Type            (0=16bit, 1=32bit)
  11    Game Pak DRQ  - DMA3 only -  (0=Normal, 1=DRQ &lt;from&gt; Game Pak, DMA3)
  12-13 DMA Start Timing  (0=Immediately, 1=VBlank, 2=HBlank, 3=Special)
          The 'Special' setting (Start Timing=3) depends on the DMA channel:
          DMA0=Prohibited, DMA1/DMA2=Sound FIFO, DMA3=Video Capture
  14    IRQ upon end of Word Count   (0=Disable, 1=Enable)
  15    DMA Enable                   (0=Off, 1=On)
</TD></TR></TABLE>
After changing the Enable bit from 0 to 1, wait 2 clock cycles before accessing
any DMA related registers.<BR>
<BR>
When accessing OAM (7000000h) or OBJ VRAM (6010000h) by HBlank Timing, then the
"H-Blank Interval Free" bit in DISPCNT register must be set.<BR>
<BR>
<B>Source and Destination Address and Word Count Registers</B><BR>
The SAD, DAD, and CNT_L registers are holding the initial start addresses, and
initial length. The hardware does NOT change the content of these registers
during or after the transfer.<BR>
The actual transfer takes place by using internal pointer/counter registers.
The initial values are copied into internal regs under the following
circumstances:<BR>
Upon DMA Enable (Bit 15) changing from 0 to 1: Reloads SAD, DAD, CNT_L.<BR>
Upon Repeat: Reloads CNT_L, and optionally DAD (Increment+Reload).<BR>
<BR>
<B>DMA Repeat bit</B><BR>
If the Repeat bit is cleared: The Enable bit is automatically cleared after the
specified number of data units has been transferred.<BR>
If the Repeat bit is set: The Enable bit remains set after the transfer, and
the transfer will be restarted each time when the Start condition (eg. HBlank,
Fifo) becomes true. The specified number of data units is transferred
&lt;each&gt; time when the transfer is (re-)started. The transfer will be
repeated forever, until it gets stopped by software.<BR>
<BR>
<B>Sound DMA (FIFO Timing Mode) (DMA1 and DMA2 only)</B><BR>
In this mode, the DMA Repeat bit must be set, and the destination address must
be FIFO_A (040000A0h) or FIFO_B (040000A4h).<BR>
Upon DMA request from sound controller, 4 units of 32bits (16 bytes) are
transferred (both Word Count register and DMA Transfer Type bit are ignored).
The destination address will not be incremented in FIFO mode.<BR>
Keep in mind that DMA channels of higher priority may offhold sound DMA. For
example, when using a 64 kHz sample rate, 16 bytes of sound DMA data are
requested each 0.25ms (4 kHz), at this time another 16 bytes are still in the
FIFO so that there's still 0.25ms time to satisfy the DMA request. Thus DMAs
with higher priority should not be operated for longer than 0.25ms. (This
problem does not arise for HBlank transfers as HBlank time is limited to
16.212us.)<BR>
<BR>
<B>Game Pak DMA</B><BR>
Only DMA 3 may be used to transfer data to/from Game Pak ROM or Flash ROM - it
cannot access Game Pak SRAM though (as SRAM data bus is limited to 8bit units).
In normal mode, DMA is requested as long until Word Count becomes zero. When
setting the 'Game Pack DRQ' bit, then the cartridge must contain an external
circuit which outputs a /DREQ signal. Note that there is only one pin for /DREQ
and /IREQ, thus the cartridge may not supply /IREQs while using DRQ mode.<BR>
<BR>
<B>Video Capture Mode (DMA3 only)</B><BR>
Intended to copy a bitmap from memory (or from external hardware/camera) to
VRAM. When using this transfer mode, set the repeat bit, and write the number
of data units (per scanline) to the word count register. Capture works similar
like HBlank DMA, however, the transfer is started when VCOUNT=2, it is then
repeated each scanline, and it gets stopped when VCOUNT=162.<BR>
<BR>
<B>Transfer End</B><BR>
The DMA Enable flag (Bit 15) is automatically cleared upon completion of the
transfer. The user may also clear this bit manually in order to stop the
transfer (obviously this is possible for Sound/Blanking DMAs only, in all other
cases the CPU is stopped until the transfer completes by itself).<BR>
<BR>
<B>Transfer Rate/Timing</B><BR>
Except for the first data unit, all units are transferred by sequential reads
and writes. For n data units, the DMA transfer time is:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  2N+2(n-1)S+xI
</TD></TR></TABLE>
Of which, 1N+(n-1)S are read cycles, and the other 1N+(n-1)S are write cycles,
actual number of cycles depends on the waitstates and bus-width of the source
and destination areas (as described in CPU Instruction Cycle Times chapter).
Internal time for DMA processing is 2I (normally), or 4I (if both source and
destination are in gamepak memory area).<BR>
<BR>
DMA lockup when stopping while starting ???<BR>
Capture delayed, Capture Enable=AutoCleared ???<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbacommunicationports"></A>&nbsp;
  GBA Communication Ports
</FONT></TD></TR></TABLE><BR>
The GBAs Serial Port may be used in various different communication modes.
Normal mode may exchange data between two GBAs (or to transfer data from master
GBA to several slave GBAs in one-way direction).<BR>
Multi-player mode may exchange data between up to four GBAs. UART mode works
much like a RS232 interface. JOY Bus mode uses a standardized Nintendo
protocol. And General Purpose mode allows to mis-use the 'serial' port as
bi-directional 4bit parallel port.<BR>
Note: The Nintendo DS does not include a Serial Port.<BR>
<BR>
<A HREF="#sionormalmode">SIO Normal Mode</A><BR>
<A HREF="#siomultiplayermode">SIO Multi-Player Mode</A><BR>
<A HREF="#siouartmode">SIO UART Mode</A><BR>
<A HREF="#siojoybusmode">SIO JOY BUS Mode</A><BR>
<A HREF="#siogeneralpurposemode">SIO General-Purpose Mode</A><BR>
<A HREF="#siocontrolregisterssummary">SIO Control Registers Summary</A><BR>
<BR>
<B>Wireless Adapter</B><BR>
<A HREF="#gbawirelessadapter">GBA Wireless Adapter</A><BR>
<BR>
<B>Infrared Communication Adapters</B><BR>
Even though early GBA prototypes have been intended to support IR
communication, this feature has been removed.<BR>
However, Nintendo is apparently considering to provide an external IR adapter
(to be connected to the SIO connector, being accessed in General Purpose mode).<BR>
Also, it'd be theoretically possible to include IR ports built-in in game
cartridges (as done for some older 8bit/monochrome Hudson games).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="sionormalmode"></A>&nbsp;
  SIO Normal Mode
</FONT></TD></TR></TABLE><BR>
This mode is used to communicate between two units.<BR>
Transfer rates of 256Kbit/s or 2Mbit/s can be selected, however, the fast
2Mbit/s is intended ONLY for special hardware expansions that are DIRECTLY
connected to the GBA link port (ie. without a cable being located between the
GBA and expansion hardware). In normal cases, always use 256Kbit/s transfer
rate which provides stable results.<BR>
Transfer lengths of 8bit or 32bit may be used, the 8bit mode is the same as for
older DMG/CGB gameboys, however, the voltages for "GBA cartridges in GBAs" are
different as for "DMG/CGB cartridges in DMG/CGB/GBAs", ie. it is not possible
to communicate between DMG/CGB games and GBA games.<BR>
<BR>
<B>4000134h - RCNT (R) - Mode Selection, in Normal/Multiplayer/UART modes (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-3   Undocumented (current SC,SD,SI,SO state, as for General Purpose mode)
  4-8   Not used     (Should be 0, bits are read/write-able though)
  9-13  Not used     (Always 0, read only)
  14    Not used     (Should be 0, bit is read/write-able though)
  15    Must be zero (0) for Normal/Multiplayer/UART modes
</TD></TR></TABLE>
<BR>
<B>4000128h - SIOCNT - SIO Control, usage in NORMAL Mode (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0     Shift Clock (SC)        (0=External, 1=Internal)
  1     Internal Shift Clock    (0=256KHz, 1=2MHz)
  2     SI State (opponents SO) (0=Low, 1=High/None) --- (Read Only)
  3     SO during inactivity    (0=Low, 1=High) (applied ONLY when Bit7=0)
  4-6   Not used                (Read only, always 0 ?)
  7     Start Bit               (0=Inactive/Ready, 1=Start/Active)
  8-11  Not used                (R/W, should be 0)
  12    Transfer Length         (0=8bit, 1=32bit)
  13    Must be "0" for Normal Mode
  14    IRQ Enable              (0=Disable, 1=Want IRQ upon completion)
  15    Not used                (Read only, always 0)
</TD></TR></TABLE>
The Start bit is automatically reset when the transfer completes, ie. when all
8 or 32 bits are transferred, at that time an IRQ may be generated.<BR>
<BR>
<B>400012Ah - SIODATA8 - SIO Normal Communication 8bit Data (R/W)</B><BR>
For 8bit normal mode. Contains 8bit data (only lower 8bit are used). Outgoing
data should be written to this register before starting the transfer. During
transfer, transmitted bits are shifted-out (MSB first), and received bits are
shifted-in simultaneously. Upon transfer completion, the register contains the
received 8bit value.<BR>
<BR>
<B>4000120h - SIODATA32_L - SIO Normal Communication lower 16bit data (R/W)</B><BR>
<B>4000122h - SIODATA32_H - SIO Normal Communication upper 16bit data (R/W)</B><BR>
Same as above SIODATA8, for 32bit normal transfer mode respectively.<BR>
SIOCNT/RCNT must be set to 32bit normal mode &lt;before&gt; writing to
SIODATA32.<BR>
<BR>
<B>Initialization</B><BR>
First, initialize RCNT register. Second, set mode/clock bits in SIOCNT with
startbit cleared. For master: select internal clock, and (in most cases)
specify 256KHz as transfer rate. For slave: select external clock, the local
transfer rate selection is then ignored, as the transfer rate is supplied by
the remote GBA (or other computer, which might supply custom transfer rates).<BR>
Third, set the startbit in SIOCNT with mode/clock bits unchanged.<BR>
<BR>
<B>Recommended Communication Procedure for SLAVE unit (external clock)</B><BR>
- Initialize data which is to be sent to master.<BR>
- Set Start flag.<BR>
- Set SO to LOW to indicate that master may start now.<BR>
- Wait for IRQ (or for Start bit to become zero). (Check timeout here!)<BR>
- Set SO to HIGH to indicate that we are not ready.<BR>
- Process received data.<BR>
- Repeat procedure if more data is to be transferred.<BR>
(or is so=high done automatically? would be fine - more stable - otherwise
master may still need delay)<BR>
<BR>
<B>Recommended Communication Procedure for SLAVE unit (external clock)</B><BR>
- Initialize data which is to be sent to master.<BR>
- Set Start=0 and SO=0 (SO=LOW indicates that slave is (almost) ready).<BR>
- Set Start=1 and SO=1 (SO=HIGH indicates not ready, applied after transfer).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  (Expl. Old SO=LOW kept output until 1st clock bit received).
  (Expl. New SO=HIGH is automatically output at transfer completion).
</TD></TR></TABLE>
- Set SO to LOW to indicate that master may start now.<BR>
- Wait for IRQ (or for Start bit to become zero). (Check timeout here!)<BR>
- Process received data.<BR>
- Repeat procedure if more data is to be transferred.<BR>
<BR>
<B>Recommended Communication Procedure for MASTER unit (internal clock)</B><BR>
- Initialize data which is to be sent to slave.<BR>
- Wait for SI to become LOW (slave ready). (Check timeout here!)<BR>
- Set Start flag.<BR>
- Wait for IRQ (or for Start bit to become zero).<BR>
- Process received data.<BR>
- Repeat procedure if more data is to be transferred.<BR>
<BR>
<B>Cable Protocol</B><BR>
During inactive transfer, the shift clock (SC) is high. The transmit (SO) and
receive (SI) data lines may be manually controlled as described above.<BR>
When master sends SC=LOW, each master and slave must output the next outgoing
data bit to SO. When master sends SC=HIGH, each master and slave must read out
the opponents data bit from SI. This is repeated for each of the 8 or 32 bits,
and when completed SC will be kept high again.<BR>
<BR>
<B>Transfer Rates</B><BR>
Either 256KHz or 2MHz rates can be selected for SC, so max 32KBytes (256Kbit)
or 128KBytes (2Mbit) can be transferred per second. However, the software must
process each 8bit or 32bit of transmitted data separately, so the actual
transfer rate will be reduced by the time spent on handling each data unit.<BR>
Only 256KHz provides stable results in most cases (such like when linking
between two GBAs). The 2MHz rate is intended for special expansion hardware
(with very short wires) only.<BR>
<BR>
<B>Using Normal mode for One-Way Multiplayer communication</B><BR>
When using normal mode with multiplay-cables, data isn't exchanged between
first and second GBA as usually. Instead, data is shifted from first to last
GBA (the first GBA receives zero, because master SI is shortcut to GND).<BR>
This behaviour may be used for fast ONE-WAY data transfer from master to all
other GBAs. For example (3 GBAs linked):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Step         Sender      1st Recipient   2nd Recipient
  Transfer 1:  DATA #0 --&gt; UNDEF      --&gt;  UNDEF     --&gt;
  Transfer 2:  DATA #1 --&gt; DATA #0    --&gt;  UNDEF     --&gt;
  Transfer 3:  DATA #2 --&gt; DATA #1    --&gt;  DATA #0   --&gt;
  Transfer 4:  DATA #3 --&gt; DATA #2    --&gt;  DATA #1   --&gt;
</TD></TR></TABLE>
The recipients should not output any own data, instead they should forward the
previously received data to the next recipient during next transfer (just keep
the incoming data unmodified in the data register).<BR>
Due to the delayed forwarding, 2nd recipient should ignore the first incoming
data. After the last transfer, the sender must send one (or more) dummy data
unit(s), so that the last data is forwarded to the 2nd (or further)
recipient(s).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="siomultiplayermode"></A>&nbsp;
  SIO Multi-Player Mode
</FONT></TD></TR></TABLE><BR>
Multi-Player mode can be used to communicate between up to 4 units.<BR>
<BR>
<B>4000134h - RCNT (R) - Mode Selection, in Normal/Multiplayer/UART modes (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-3   Undocumented (current SC,SD,SI,SO state, as for General Purpose mode)
  4-8   Not used     (Should be 0, bits are read/write-able though)
  9-13  Not used     (Always 0, read only)
  14    Not used     (Should be 0, bit is read/write-able though)
  15    Must be zero (0) for Normal/Multiplayer/UART modes
</TD></TR></TABLE>
Note: Even though undocumented, many Nintendo games are using Bit 0 to test
current SC state in multiplay mode.<BR>
<BR>
<B>4000128h - SIOCNT - SIO Control, usage in MULTI-PLAYER Mode (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-1   Baud Rate     (0-3: 9600,38400,57600,115200 bps)
  2     SI-Terminal   (0=Parent, 1=Child)                  (Read Only)
  3     SD-Terminal   (0=Bad connection, 1=All GBAs Ready) (Read Only)
  4-5   Multi-Player ID     (0=Parent, 1-3=1st-3rd child)  (Read Only)
  6     Multi-Player Error  (0=Normal, 1=Error)            (Read Only)
  7     Start/Busy Bit      (0=Inactive, 1=Start/Busy) (Read Only for Slaves)
  8-11  Not used            (R/W, should be 0)
  12    Must be "0" for Multi-Player mode
  13    Must be "1" for Multi-Player mode
  14    IRQ Enable          (0=Disable, 1=Want IRQ upon completion)
  15    Not used            (Read only, always 0)
</TD></TR></TABLE>
The ID Bits are undefined until the first transfer has completed.<BR>
<BR>
<B>400012Ah - SIOMLT_SEND - Data Send Register (R/W)</B><BR>
Outgoing data (16 bit) which is to be sent to the other GBAs.<BR>
<BR>
<B>4000120h - SIOMULTI0 - SIO Multi-Player Data 0 (Parent) (R/W)</B><BR>
<B>4000122h - SIOMULTI1 - SIO Multi-Player Data 1 (1st child) (R/W)</B><BR>
<B>4000124h - SIOMULTI2 - SIO Multi-Player Data 2 (2nd child) (R/W)</B><BR>
<B>4000126h - SIOMULTI3 - SIO Multi-Player Data 3 (3rd child) (R/W)</B><BR>
These registers are automatically reset to FFFFh upon transfer start.<BR>
After transfer, these registers contain incoming data (16bit each) from all
remote GBAs (if any / otherwise still FFFFh), as well as the local outgoing
SIOMLT_SEND data.<BR>
Ie. after the transfer, all connected GBAs will contain the same values in
their SIOMULTI0-3 registers.<BR>
<BR>
<B>Initialization</B><BR>
- Initialize RCNT Bit 14-15 and SIOCNT Bit 12-13 to select Multi-Player mode.<BR>
- Read SIOCNT Bit 3 to verify that all GBAs are in Multi-Player mode.<BR>
- Read SIOCNT Bit 2 to detect whether this is the Parent/Master unit.<BR>
<BR>
<B>Recommended Transmission Procedure</B><BR>
- Write outgoing data to SIODATA_SEND.<BR>
- Master must set Start bit.<BR>
- All units must process received data in SIOMULTI0-3 when transfer completed.<BR>
- After the first successful transfer, ID Bits in SIOCNT are valid.<BR>
- If more data is to be transferred, repeat procedure.<BR>
The parent unit blindly sends data regardless of whether childs have already
processed old data/supplied new data. So, parent unit might be required to
insert delays between each transfer, and/or perform error checking.<BR>
Also, slave units may signalize that they are not ready by temporarily
switching into another communication mode (which does not output SD High, as
Multi-Player mode does during inactivity).<BR>
<BR>
<B>Transfer Protocol</B><BR>
Beginning<BR>
- The masters SI pin is always LOW.<BR>
- When all GBAs are in Multiplayer mode (ready) SD is HIGH.<BR>
- When master starts the transfer, it sets SC=LOW, slaves receive Busy bit.<BR>
Step A<BR>
- ID Bits in master unit are set to 0.<BR>
- Master outputs Startbit (LOW), 16bit Data, Stopbit (HIGH) through SD.<BR>
- This data is written to SIOMULTI0 of all GBAs (including master).<BR>
- Master forwards LOW from its SO to 1st childs SI.<BR>
- Transfer ends if next child does not output data after certain time.<BR>
Step B<BR>
- ID Bits in 1st child unit are set to 1.<BR>
- 1st Child outputs Startbit (LOW), 16bit Data, Stopbit (HIGH) through SD.<BR>
- This data is written to SIOMULTI1 of all GBAs (including 1st child).<BR>
- 1st child forwards LOW from its SO to 2nd childs SI.<BR>
- Transfer ends if next child does not output data after certain time.<BR>
Step C<BR>
- ID Bits in 2nd child unit are set to 2.<BR>
- 2nd Child outputs Startbit (LOW), 16bit Data, Stopbit (HIGH) through SD.<BR>
- This data is written to SIOMULTI2 of all GBAs (including 2nd child).<BR>
- 2nd child forwards LOW from its SO to 3rd childs SI.<BR>
- Transfer ends if next child does not output data after certain time.<BR>
Step D<BR>
- ID Bits in 3rd child unit are set to 3.<BR>
- 3rd Child outputs Startbit (LOW), 16bit Data, Stopbit (HIGH) through SD.<BR>
- This data is written to SIOMULTI3 of all GBAs (including 3rd child).<BR>
- Transfer ends (this was the last child).<BR>
Transfer end<BR>
- Master sets SC=HIGH, all GBAs set SO=HIGH.<BR>
- The Start/Busy bits of all GBAs are automatically cleared.<BR>
- Interrupts are requested in all GBAs (as far as enabled).<BR>
<BR>
<B>Error Bit</B><BR>
This bit is set when a slave did not receive SI=LOW even though SC=LOW
signalized a transfer (this might happen when connecting more than 4 GBAs, or
when the previous child is not connected). Also, the bit is set when a Stopbit
wasn't HIGH.<BR>
The error bit may be undefined during active transfer - read only after
transfer completion (the transfer continues and completes as normal even if
errors have occurred for some or all GBAs).<BR>
Don't know: The bit is automatically reset/initialized with each transfer, or
must be manually reset?<BR>
<BR>
<B>Transmission Time</B><BR>
The transmission time depends on the selected Baud rate. And on the amount of
Bits (16 data bits plus start/stop bits for each GBA), delays between data for
each GBA, plus final timeout (if less than 4 GBAs). That is, depending on the
number of connected GBAs:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  GBAs    Bits    Delays   Timeout
  1       18      None     Yes
  2       36      1        Yes
  3       54      2        Yes
  4       72      3        None
</TD></TR></TABLE>
(The average Delay and Timeout periods are unknown?)<BR>
Above is not counting the additional CPU time that must be spent on initiating
and processing each transfer.<BR>
<BR>
<B>Fast One-Way Transmission</B><BR>
Beside for the actual SIO Multiplayer mode, you can also use SIO Normal mode
for fast one-way data transfer from Master unit to all Child unit(s). See
chapter about SIO Normal mode for details.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="siouartmode"></A>&nbsp;
  SIO UART Mode
</FONT></TD></TR></TABLE><BR>
This mode works much like a RS232 port, however, the voltages are unknown,
probably 0/3V rather than +/-12V ?. SI and SO are data lines (with crossed
wires), SC and SD signalize Clear to Send (with crossed wires also, which
requires special cable when linking between two GBAs ?)<BR>
<BR>
<B>4000134h - RCNT (R) - Mode Selection, in Normal/Multiplayer/UART modes (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-3   Undocumented (current SC,SD,SI,SO state, as for General Purpose mode)
  4-8   Not used     (Should be 0, bits are read/write-able though)
  9-13  Not used     (Always 0, read only)
  14    Not used     (Should be 0, bit is read/write-able though)
  15    Must be zero (0) for Normal/Multiplayer/UART modes
</TD></TR></TABLE>
<BR>
<B>4000128h - SCCNT_L - SIO Control, usage in UART Mode (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-1   Baud Rate  (0-3: 9600,38400,57600,115200 bps)
  2     CTS Flag   (0=Send always/blindly, 1=Send only when SC=LOW)
  3     Parity Control (0=Even, 1=Odd)
  4     Send Data Flag      (0=Not Full,  1=Full)    (Read Only)
  5     Receive Data Flag   (0=Not Empty, 1=Empty)   (Read Only)
  6     Error Flag          (0=No Error,  1=Error)   (Read Only)
  7     Data Length         (0=7bits,   1=8bits)
  8     FIFO Enable Flag    (0=Disable, 1=Enable)
  9     Parity Enable Flag  (0=Disable, 1=Enable)
  10    Send Enable Flag    (0=Disable, 1=Enable)
  11    Receive Enable Flag (0=Disable, 1=Enable)
  12    Must be "1" for UART mode
  13    Must be "1" for UART mode
  14    IRQ Enable          (0=Disable, 1=IRQ when any Bit 4/5/6 become set)
  15    Not used            (Read only, always 0)
</TD></TR></TABLE>
<BR>
<B>400012Ah - SIODATA8 - usage in UART Mode (R/W)</B><BR>
Addresses the send/receive shift register, or (when FIFO is used) the
send/receive FIFO. In either case only the lower 8bit of SIODATA8 are used, the
upper 8bit are not used.<BR>
The send/receive FIFO may store up to four 8bit data units each. For example,
while 1 unit is still transferred from the send shift register, it is possible
to deposit another 4 units in the send FIFO, which are then automatically moved
to the send shift register one after each other.<BR>
<BR>
<B>Send/Receive Enable, CTS Feedback</B><BR>
The receiver outputs SD=LOW (which is input as SC=LOW at the remote side) when
it is ready to receive data (that is, when Receive Enable is set, and the
Receive shift register (or receive FIFO) isn't full.<BR>
When CTS flag is set to always/blindly, then the sender transmits data
immediately when Send Enable is set, otherwise data is transmitted only when
Send Enable is set and SC is LOW.<BR>
<BR>
<B>Error Flag</B><BR>
The error flag is set when a bad stop bit has been received (stop bit must be
0), when a parity error has occurred (if enabled), or when new data has been
completely received while the receive data register (or receive FIFO) is
already full.<BR>
The error flag is automatically reset when reading from SIOCNT register.<BR>
<BR>
<B>Init &amp; Initback</B><BR>
The content of the FIFO is reset when FIFO is disabled in UART mode, thus, when
entering UART mode initially set FIFO=disabled.<BR>
The Send/Receive enable bits must be reset before switching from UART mode into
another SIO mode!<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="siojoybusmode"></A>&nbsp;
  SIO JOY BUS Mode
</FONT></TD></TR></TABLE><BR>
This communication mode uses Nintendo's standardized JOY Bus protocol. When
using this communication mode, the GBA is always operated as SLAVE!<BR>
<BR>
In this mode, SI and SO pins are data lines (apparently synchronized by
Start/Stop bits?), SC and SD are set to low (including during active
transfer?), the transfer rate is unknown?<BR>
<BR>
<B>4000134h - RCNT (R) - Mode Selection, in JOY BUS mode (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-3   Undocumented (current SC,SD,SI,SO state, as for General Purpose mode)
  4-8   Not used     (Should be 0, bits are read/write-able though)
  9-13  Not used     (Always 0, read only)
  14    Must be "1" for JOY BUS Mode
  15    Must be "1" for JOY BUS Mode
</TD></TR></TABLE>
<BR>
<B>4000128h - SIOCNT - SIO Control, not used in JOY BUS Mode</B><BR>
This register is not used in JOY BUS mode.<BR>
<BR>
<B>4000140h - JOYCNT - JOY BUS Control Register (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0     Device Reset Flag     (Command FFh)          (Read/Acknowledge)
  1     Receive Complete Flag (Command 14h or 15h?)  (Read/Acknowledge)
  2     Send Complete Flag    (Command 15h or 14h?)  (Read/Acknowledge)
  3-5   Not used
  6     IRQ when receiving a Device Reset Command  (0=Disable, 1=Enable)
  7-31  Not used
</TD></TR></TABLE>
Bit 0-2 are working much like the bits in the IF register: Write a "1" bit to
reset (acknowledge) the respective bit.<BR>
UNCLEAR: Interrupts can be requested for Send/Receive commands also?<BR>
<BR>
<B>4000150h - JOY_RECV_L - Receive Data Register low (R/W)</B><BR>
<B>4000152h - JOY_RECV_H - Receive Data Register high (R/W)</B><BR>
<B>4000154h - JOY_TRANS_L - Send Data Register low (R/W)</B><BR>
<B>4000156h - JOY_TRANS_H - Send Data Register high (R/W)</B><BR>
Send/receive data registers.<BR>
<BR>
<B>4000158h - JOYSTAT - Receive Status Register (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0     Not used
  1     Receive Status Flag   (0=Remote GBA is/was receiving) (Read Only?)
  2     Not used
  3     Send Status Flag      (1=Remote GBA is/was sending)   (Read Only?)
  4-5   General Purpose Flag  (Not assigned, may be used for whatever purpose)
  6-31  Not used
</TD></TR></TABLE>
Bit 1 is automatically set when writing to local JOY_TRANS.<BR>
Bit 3 is automatically reset when reading from local JOY_RECV.<BR>
<BR>
Below are the four possible commands which can be received by the GBA. Note
that the GBA (slave) cannot send any commands itself, all it can do is to read
incoming data, and to provide 'reply' data which may (or may not) be read out
by the master unit.<BR>
<BR>
<B>Command FFh - Device Reset</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Receive FFh (Command)
  Send    00h (GBA Type number LSB (or MSB?))
  Send    04h (GBA Type number MSB (or LSB?))
  Send    XXh (lower 8bits of SIOSTAT register)
</TD></TR></TABLE>
<BR>
<B>Command 00h - Type/Status Data Request</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Receive 00h (Command)
  Send    00h (GBA Type number LSB (or MSB?))
  Send    04h (GBA Type number MSB (or LSB?))
  Send    XXh (lower 8bits of SIOSTAT register)
</TD></TR></TABLE>
<BR>
<B>Command 15h - GBA Data Write (to GBA)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Receive 15h (Command)
  Receive XXh (Lower 8bits of JOY_RECV_L)
  Receive XXh (Upper 8bits of JOY_RECV_L)
  Receive XXh (Lower 8bits of JOY_RECV_H)
  Receive XXh (Upper 8bits of JOY_RECV_H)
  Send    XXh (lower 8bits of SIOSTAT register)
</TD></TR></TABLE>
<BR>
<B>Command 14h - GBA Data Read (from GBA)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Receive 14h (Command)
  Send    XXh (Lower 8bits of JOY_TRANS_L)
  Send    XXh (Upper 8bits of JOY_TRANS_L)
  Send    XXh (Lower 8bits of JOY_TRANS_H)
  Send    XXh (Upper 8bits of JOY_TRANS_H)
  Send    XXh (lower 8bits of SIOSTAT register)
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="siogeneralpurposemode"></A>&nbsp;
  SIO General-Purpose Mode
</FONT></TD></TR></TABLE><BR>
In this mode, the SIO is 'misused' as a 4bit bi-directional parallel port, each
of the SI,SO,SC,SD pins may be directly controlled, each can be separately
declared as input (with internal pull-up) or as output signal.<BR>
<BR>
<B>4000134h - RCNT (R) - SIO Mode, usage in GENERAL-PURPOSE Mode (R/W)</B><BR>
Interrupts can be requested when SI changes from HIGH to LOW, as General
Purpose mode does not require a serial shift clock, this interrupt may be
produced even when the GBA is in Stop (low power standby) state.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0     SC Data Bit         (0=Low, 1=High)
  1     SD Data Bit         (0=Low, 1=High)
  2     SI Data Bit         (0=Low, 1=High)
  3     SO Data Bit         (0=Low, 1=High)
  4     SC Direction        (0=Input, 1=Output)
  5     SD Direction        (0=Input, 1=Output)
  6     SI Direction        (0=Input, 1=Output, but see below)
  7     SO Direction        (0=Input, 1=Output)
  8     SI Interrupt Enable (0=Disable, 1=Enable)
  9-13  Not used
  14    Must be "0" for General-Purpose Mode
  15    Must be "1" for General-Purpose or JOYBUS Mode
</TD></TR></TABLE>
SI should be always used as Input to avoid problems with other hardware which
does not expect data to be output there.<BR>
<BR>
<B>4000128h - SIOCNT - SIO Control, not used in GENERAL-PURPOSE Mode</B><BR>
This register is not used in general purpose mode. That is, the separate bits
of SIOCNT still exist and are read- and/or write-able in the same manner as for
Normal, Multiplay, or UART mode (depending on SIOCNT Bit 12,13), but are having
no effect on data being output to the link port.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="siocontrolregisterssummary"></A>&nbsp;
  SIO Control Registers Summary
</FONT></TD></TR></TABLE><BR>
<B>Mode Selection (by RCNT.15-14 and SIOCNT.13-12)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  R.15 R.14 S.13 S.12 Mode
  0    x    0    0    Normal 8bit
  0    x    0    1    Normal 32bit
  0    x    1    0    Multiplay 16bit
  0    x    1    1    UART (RS232)
  1    0    x    x    General Purpose
  1    1    x    x    JOY BUS
</TD></TR></TABLE>
<BR>
<B>SIOCNT</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit    0      1    2     3      4 5 6   7     8    9      10   11
  Normal Master Rate SI/In SO/Out - - -   Start -    -      -    -
  Multi  Baud   Baud SI/In SD/In  ID# Err Start -    -      -    -
  UART   Baud   Baud CTS   Parity S R Err Bits  FIFO Parity Send Recv
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbawirelessadapter"></A>&nbsp;
  GBA Wireless Adapter
</FONT></TD></TR></TABLE><BR>
<B>GBA Wireless Adapter (AGB-015 or OXY-004)</B><BR>
<A HREF="#gbawirelessadaptergames">GBA Wireless Adapter Games</A><BR>
<A HREF="#gbawirelessadapterlogin">GBA Wireless Adapter Login</A><BR>
<A HREF="#gbawirelessadaptercommands">GBA Wireless Adapter Commands</A><BR>
<A HREF="#gbawirelessadaptercomponentlists">GBA Wireless Adapter Component Lists</A><BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbawirelessadaptergames"></A>&nbsp;
  GBA Wireless Adapter Games
</FONT></TD></TR></TABLE><BR>
<B>GBA Wireless Adapter compatible Games</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  bit Generations series (Japan only)
  Boktai 2: Solar Boy Django (Konami)
  Boktai 3: Sabata's Counterattack
  Classic NES Series: Donkey Kong
  Classic NES Series: Dr. Mario
  Classic NES Series: Ice Climber
  Classic NES Series: Pac-Man
  Classic NES Series: Super Mario Bros.
  Classic NES Series: Xevious
  Digimon Racing (Bandai) (No Wireless Adapter support in European release)
  Dragon Ball Z: Buu's Fury (Atari)
  Famicom Mini Series: #13 Balloon Fight
  Famicom Mini Series: #12 Clu Clu Land
  Famicom Mini Series: #16 Dig Dug
  Famicom Mini Series: #02 Donkey Kong
  Famicom Mini Series: #15 Dr. Mario
  Famicom Mini Series: #03 Ice Climber
  Famicom Mini Series: #18 Makaimura
  Famicom Mini Series: #08 Mappy
  Famicom Mini Series: #11 Mario Bros.
  Famicom Mini Series: #06 Pac-Man
  Famicom Mini Series: #30 SD Gundam World Scramble Wars
  Famicom Mini Series: #01 Super Mario Bros.
  Famicom Mini Series: #21 Super Mario Bros.
  Famicom Mini Series: #19 Twin Bee
  Famicom Mini Series: #14 Wrecking Crew
  Famicom Mini Series: #07 Xevious
  Hamtaro: Ham-Ham Games (Nintendo)
  Lord of the Rings: The Third Age, The (EA Games)
  Mario Golf: Advance Tour (Nintendo)
  Mario Tennis: Power Tour (Nintendo)
  Mega Man Battle Network 5: Team Protoman (Capcom)
  Mega Man Battle Network 5: Team Colonel (Capcom)
  Mega Man Battle Network 6: Cybeast Falzar
  Mega Man Battle Network 6: Cybeast Gregar
  Momotaro Dentetsu G: Make a Gold Deck! (Japan only)
  Pokemon Emerald (Nintendo)
  Pokemon FireRed (Nintendo)
  Pokemon LeafGreen (Nintendo)
  Sennen Kazoku (Japan only)
  Shrek SuperSlam
  Sonic Advance 3
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbawirelessadapterlogin"></A>&nbsp;
  GBA Wireless Adapter Login
</FONT></TD></TR></TABLE><BR>
<B>GBA Wireless Adapter Login</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  rcnt=8000h    ;\
  rcnt=80A0h    ;
  rcnt=80A2h    ; reset adapter or so
  wait          ;
  rcnt=80A0h    ;/
  siocnt=5003h  ;\set 32bit normal mode, 2MHz internal clock
  rcnt=0000h    ;/
  passes=0, index=0
 @@lop:
  passes=passes+1, if passes&gt;32 then ERROR  ;give up (usually only 10 passses)
  recv.lo=siodata AND FFFFh    ;response from adapter
  recv.hi=siodata/10000h       ;adapter's own "NI" data
  if send.hi&lt;&gt;recv.lo then index=0, goto @@stuck  ;&lt;-- fallback to index=0
  if (send.lo XOR FFFFh)&lt;&gt;recv.lo then goto @@stuck
  if (send.hi XOR FFFFh)&lt;&gt;recv.hi then goto @@stuck
  index=index+1
 @@stuck:
  send.lo=halfword[@@key_string+index*2]
  send.hi=recv.hi XOR FFFFh
  siodata=send.lo+(send.hi*10000h)
  siocnt.bit7=1                        ;&lt;-- start transmission
  if index&lt;4 then goto @@lop
  ret
 @@key_string db 'NINTENDO',01h,80h    ;10 bytes (5 halfwords; index=0..4)
</TD></TR></TABLE>
<BR>
<B>Data exchanged during Login</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
               GBA                         ADAPTER
               xxxx494E ;\     &lt;--&gt;        xxxxxxxx
               xxxx494E ; "NI" &lt;--&gt; "NI"/; 494EB6B1 ;\
  NOT("NI") /; B6B1494E ;/     &lt;--&gt;     \; 494EB6B1 ; NOT("NI")
            \; B6B1544E ;\"NT" &lt;--&gt; "NT"/; 544EB6B1 ;/
  NOT("NT") /; ABB1544E ;/     &lt;--&gt;     \; 544EABB1 ;\NOT("NT")
            \; ABB14E45 ;\"EN" &lt;--&gt; "EN"/; 4E45ABB1 ;/
  NOT("EN") /; B1BA4E45 ;/     &lt;--&gt;     \; 4E45B1BA ;\NOT("EN")
            \; B1BA4F44 ;\"DO" &lt;--&gt; "DO"/; 4F44B1BA ;/
  NOT("DO") /; B0BB4F44 ;/     &lt;--&gt;     \; 4F44B0BB ;\NOT("DO")
            \; B0BB8001 ;-fin  &lt;--&gt;  fin-; 8001B0BB ;/
                 \   \                      \   \
                  \   LSBs=Own               \   LSBs=Inverse of
                   \   Data.From.Gba          \   Prev.Data.From.Gba
                    \                          \
                     MSBs=Inverse of            MSBs=Own
                      Prev.Data.From.Adapter     Data.From.Adapter
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbawirelessadaptercommands"></A>&nbsp;
  GBA Wireless Adapter Commands
</FONT></TD></TR></TABLE><BR>
<B>Wireless Command/Parameter Transmission</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  GBA       Adapter
  9966ppcch 80000000h   ;-send command (cc), and num param_words (pp)
  &lt;param01&gt; 80000000h   ;\
  &lt;param02&gt; 80000000h   ; send "pp" parameter word(s), if any
  ...       ...         ;/
  80000000h 9966rraah   ;-recv ack (aa=cc+80h), and num response_words (rr)
  80000000? &lt;reply01&gt;   ;\
  80000000? &lt;reply02&gt;   ; recv "rr" response word(s), if any
  ...       ...         ;/
</TD></TR></TABLE>
Wireless 32bit Transfers<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  wait until [4000128h].Bit2=0  ;want SI=0
  set [4000128h].Bit3=1         ;set SO=1
  wait until [4000128h].Bit2=1  ;want SI=1
  set [4000128h].Bit3=0,Bit7=1  ;set SO=0 and start 32bit transfer
</TD></TR></TABLE>
All command/param/reply transfers should be done at Internal Clock (except,
Response Words for command 25h,27h,35h,37h should use External Clock).<BR>
<BR>
<B>Wireless Commands</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Cmd Para Reply Name
  10h -    -     Hello (send immediately after login)
  11h -    1     Good/Bad response to cmd 16h ?
  12h
  13h -    1
  14h
  15h
  16h 6    -     Introduce (send game/user name)
  17h 1    -     Config (send after Hello) (eg. param=003C0420h or 003C043Ch)
  18h
  19h
  1Ah
  1Bh
  1Ch -    -
  1Dh -    NN    Get Directory? (receive list of game/user names?)
  1Eh -    NN    Get Directory? (receive list of game/user names?)
  1Fh 1    -     Select Game for Download (send 16bit Game_ID)
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  20h -    1
  21h -    1     Good/Bad response to cmd 1Fh ?
  22h
  23h
  24h -    -
  25h                                       ;use EXT clock!
  26h -    -
  27h -    -     Begin Download ?           ;use EXT clock!
  28h
  29h
  2Ah
  2Bh
  2Ch
  2Dh
  2Eh
  2Fh
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  30h 1    -
  31h
  32h
  33h
  34h
  35h                                       ;use EXT clock!
  36h
  37h                                       ;use EXT clock!
  38h
  39h
  3Ah
  3Bh
  3Ch
  3Dh -    -     Bye (return to language select)
  3Eh
  3Fh
</TD></TR></TABLE>
Special Response 996601EEh for error or so? (only at software side?)<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbawirelessadaptercomponentlists"></A>&nbsp;
  GBA Wireless Adapter Component Lists
</FONT></TD></TR></TABLE><BR>
Main Chipset<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  U1 32pin Freescale MC13190 (2.4 GHz ISM band transceiver)
  U2 48pin Freescale CT3000 or CT3001 (depending on adapter version)
  X3  2pin 9.5MHz crystal
</TD></TR></TABLE>
The MC13190 is a Short-Range, Low-Power 2.4 GHz ISM band transceiver.<BR>
The processor is Motorola's 32-bit M-Core RISC engine. (?) MCT3000 (?)<BR>
See also: http://www.eetimes.com/document.asp?doc_id=1271943<BR>
<BR>
Version with GERMAN Postal Code on sticker:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Sticker on Case:
    "GAME BOY advance, WIRELESS ADAPTER"
    "Pat.Pend.Made in Philipines, CE0125(!)B"
    "MODEL NO./MODELE NO.AGB-015 D-63760 Grossosteim P/AGB-A-WA-EUR-2 E3"
  PCB: "19-C046-04, A-7" (top side) and "B-7" and Microchip ",\\" (bottom side)
  PCB: white stamp "3104, 94V-0, RU, TW-15"
  PCB: black stamp "22FDE"
  U1 32pin "Freescale 13190, 4WFQ" (MC13190) (2.4 GHz ISM band transceiver)
  U2 48pin "Freescale CT3001, XAC0445"  (bottom side)
  X3  2pin "D959L4I" (9.5MHz)           (top side) (ca. 19 clks per 2us)
</TD></TR></TABLE>
Further components... top side (A-7)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  D1   5pin "D6F, 44"   (top side, below X3)
  U71  6pin ".., () 2"  (top side, right of X3, tiny black chip)
  B71  6pin "[]"        (top side, right of X3, small white chip)
  ANT  2pin on-board copper wings
  Q?   3pin             (top side, above CN1)
  Q?   3pin             (top side, above CN1)
  D?   2pin "72"        (top side, above CN1)
  D3   2pin "F2"        (top side, above CN1)
  U200 4pin "MSV"       (top side, above CN1)
  U202 5pin "LXKA"      (top side, right of CN1)
  U203 4pin "M6H"       (top side, right of CN1)
  CN1  6pin connector to GBA link port (top side)
</TD></TR></TABLE>
Further components... bottom side (B-7)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  U201 5pin "LXVB"      (bottom side, near CN1)
  U72  4pin "BMs"       (bottom side, near ANT, tiny black chip)
  FL70 ?pin "[] o26"    (bottom side, near ANT, bigger white chip)
  B70  6pin "[]"        (bottom side, near ANT, small white chip)
</TD></TR></TABLE>
Plus, resistors and capacitors (without any markings).<BR>
<BR>
Version WITHOUT sticker:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Sticker on Case: N/A
  PCB: "19-C046-03, A-1" (top side) and "B-1" and Microchip ",\\" (bottom side)
  PCB: white stamp "3204, TW-15, RU, 94V-0"
  PCB: black stamp "23MN" or "23NH" or so (smeared)
  U1 32pin "Freescale 13190, 4FGD"      (top side)
  U2 48pin "Freescale CT3000, XAB0425"  (bottom side) ;CT3000 (not CT3001)
  X3  2pin "9.5SKSS4GT"                 (top side)
</TD></TR></TABLE>
Further components... top side (A-1)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  D1   5pin "D6F, 31"   (top side, below X3)
  U71  6pin "P3, () 2"  (top side, right of X3, tiny black chip)
  B71  6pin "[]"        (top side, right of X3, small white chip)
  ANT  2pin on-board copper wings
  Q70  3pin             (top side, above CN1)
  D?   2pin "72"        (top side, above CN1)
  D3   2pin "F2"        (top side, above CN1)
  U200 4pin "MSV"       (top side, above CN1)
  U202 5pin "LXKH"      (top side, right of CN1)
  U203 4pin "M6H"       (top side, right of CN1)
  CN1  6pin connector to GBA link port (top side)
</TD></TR></TABLE>
Further components... bottom side (B-1)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  U201 5pin "LXV2"      (bottom side, near CN1)
  U70  6pin "AAG"       (bottom side, near ANT, tiny black chip)
  FL70 ?pin "[] o26"    (bottom side, near ANT, bigger white chip)
  B70  6pin "[]"        (bottom side, near ANT, small white chip)
</TD></TR></TABLE>
Plus, resistors and capacitors (without any markings).<BR>
<BR>
Major Differences<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Sticker      "N/A"                     vs "Grossosteim P/AGB-A-WA-EUR-2 E3"
  PCB-markings "19-C046-03, A-1, 3204"   vs "19-C046-04, A-7, 3104"
  U1           "CT3000, XAB0425"         vs "CT3001, XAC0445"
  Transistors  One transistor (Q70)      vs Two transistors (both nameless)
  U70/U72      U70 "AAG" (6pin)          vs U72 "BMs" (4pin)
</TD></TR></TABLE>
Purpose of the changes is unknown (either older/newer revisions, or different
regions with different FCC regulations).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbainfraredcommunication"></A>&nbsp;
  GBA Infrared Communication
</FONT></TD></TR></TABLE><BR>
Early GBA prototypes have been intended to include a built-in IR port for
sending and receiving IR signals. Among others, this port could have been used
to communicate with other GBAs, or older CGB models, or TV Remote Controls,
etc.<BR>
<BR>
[ THE INFRARED COMMUNICATION FEATURE IS -NOT- SUPPORTED ANYMORE ]<BR>
Anyways, the prototype specifications have been as shown below...<BR>
<BR>
Keep in mind that the IR signal may be interrupted by whatever objects moved
between sender and receiver - the IR port isn't recommended for programs that
require realtime data exchange (such like action games).<BR>
<BR>
<B>4000136h - IR - Infrared Register (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0     Transmission Data  (0=LED Off, 1=LED On)
  1     READ Enable        (0=Disable, 1=Enable)
  2     Reception Data     (0=None, 1=Signal received) (Read only)
  3     AMP Operation      (0=Off, 1=On)
  4     IRQ Enable Flag    (0=Disable, 1=Enable)
  5-15  Not used
</TD></TR></TABLE>
When IRQ is enabled, an interrupt is requested if the incoming signal was
0.119us Off (2 cycles), followed by 0.536us On (9 cycles) - minimum timing
periods each.<BR>
<BR>
<B>Transmission Notes</B><BR>
When transmitting an IR signal, note that it'd be not a good idea to keep the
LED turned On for a very long period (such like sending a 1 second
synchronization pulse). The recipient's circuit would treat such a long signal
as "normal IR pollution which is in the air" after a while, and thus ignore the
signal.<BR>
<BR>
<B>Reception Notes</B><BR>
Received data is internally latched. Latched data may be read out by setting
both READ and AMP bits.<BR>
Note: Provided that you don't want to receive your own IR signal, be sure to
set Bit 0 to zero before attempting to receive data.<BR>
<BR>
<B>Power-consumption</B><BR>
After using the IR port, be sure to reset the register to zero in order to
reduce battery power consumption.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbakeypadinput"></A>&nbsp;
  GBA Keypad Input
</FONT></TD></TR></TABLE><BR>
The built-in GBA gamepad has 4 direction keys, and 6 buttons.<BR>
<BR>
<B>4000130h - KEYINPUT - Key Status (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0     Button A        (0=Pressed, 1=Released)
  1     Button B        (etc.)
  2     Select          (etc.)
  3     Start           (etc.)
  4     Right           (etc.)
  5     Left            (etc.)
  6     Up              (etc.)
  7     Down            (etc.)
  8     Button R        (etc.)
  9     Button L        (etc.)
  10-15 Not used
</TD></TR></TABLE>
It'd be usually recommended to read-out this register only once per frame, and
to store the current state in memory. As a side effect, this method avoids
problems caused by switch bounce when a key is newly released or pressed.<BR>
<BR>
<B>4000132h - KEYCNT - Key Interrupt Control (R/W)</B><BR>
The keypad IRQ function is intended to terminate the very-low-power Stop mode,
it is not suitable for processing normal user input, to do this, most programs
are invoking their keypad handlers from within VBlank IRQ.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0     Button A        (0=Ignore, 1=Select)
  1     Button B        (etc.)
  2     Select          (etc.)
  3     Start           (etc.)
  4     Right           (etc.)
  5     Left            (etc.)
  6     Up              (etc.)
  7     Down            (etc.)
  8     Button R        (etc.)
  9     Button L        (etc.)
  10-13 Not used
  14    IRQ Enable Flag (0=Disable, 1=Enable)
  15    IRQ Condition   (0=Logical OR, 1=Logical AND)
</TD></TR></TABLE>
In logical OR mode, an interrupt is requested when at least one of the selected
buttons is pressed.<BR>
In logical AND mode, an interrupt is requested when ALL of the selected buttons
are pressed.<BR>
<BR>
<B>Notes</B><BR>
In 8bit gameboy compatibility mode, L and R Buttons are used to toggle the
screen size between normal 160x144 pixels and stretched 240x144 pixels.<BR>
The GBA SP is additionally having a * Button used to toggle the backlight on
and off (controlled by separate hardware logic, there's no way to detect or
change the current backlight state by software).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbainterruptcontrol"></A>&nbsp;
  GBA Interrupt Control
</FONT></TD></TR></TABLE><BR>
<B>4000208h - IME - Interrupt Master Enable Register (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0     Disable all interrupts         (0=Disable All, 1=See IE register)
  1-31  Not used
</TD></TR></TABLE>
<BR>
<B>4000200h - IE - Interrupt Enable Register (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0     LCD V-Blank                    (0=Disable)
  1     LCD H-Blank                    (etc.)
  2     LCD V-Counter Match            (etc.)
  3     Timer 0 Overflow               (etc.)
  4     Timer 1 Overflow               (etc.)
  5     Timer 2 Overflow               (etc.)
  6     Timer 3 Overflow               (etc.)
  7     Serial Communication           (etc.)
  8     DMA 0                          (etc.)
  9     DMA 1                          (etc.)
  10    DMA 2                          (etc.)
  11    DMA 3                          (etc.)
  12    Keypad                         (etc.)
  13    Game Pak (external IRQ source) (etc.)
  14-15 Not used
</TD></TR></TABLE>
Note that there is another 'master enable flag' directly in the CPUs Status
Register (CPSR) accessible in privileged modes, see CPU reference for details.<BR>
<BR>
<B>4000202h - IF - Interrupt Request Flags / IRQ Acknowledge (R/W, see below)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0     LCD V-Blank                    (1=Request Interrupt)
  1     LCD H-Blank                    (etc.)
  2     LCD V-Counter Match            (etc.)
  3     Timer 0 Overflow               (etc.)
  4     Timer 1 Overflow               (etc.)
  5     Timer 2 Overflow               (etc.)
  6     Timer 3 Overflow               (etc.)
  7     Serial Communication           (etc.)
  8     DMA 0                          (etc.)
  9     DMA 1                          (etc.)
  10    DMA 2                          (etc.)
  11    DMA 3                          (etc.)
  12    Keypad                         (etc.)
  13    Game Pak (external IRQ source) (etc.)
  14-15 Not used
</TD></TR></TABLE>
Interrupts must be manually acknowledged by writing a "1" to one of the IRQ
bits, the IRQ bit will then be cleared.<BR>
<BR>
"[Cautions regarding clearing IME and IE]<BR>
A corresponding interrupt could occur even while a command to clear IME or each
flag of the IE register is being executed. When clearing a flag of IE, you need
to clear IME in advance so that mismatching of interrupt checks will not
occur." ?<BR>
<BR>
"[When multiple interrupts are used]<BR>
When the timing of clearing of IME and the timing of an interrupt agree,
multiple interrupts will not occur during that interrupt. Therefore, set
(enable) IME after saving IME during the interrupt routine." ?<BR>
<BR>
<B>BIOS Interrupt handling</B><BR>
Upon interrupt execution, the CPU is switched into IRQ mode, and the physical
interrupt vector is called - as this address is located in BIOS ROM, the BIOS
will always execute the following code before it forwards control to the user
handler:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00000018  b      128h                ;IRQ vector: jump to actual BIOS handler
  00000128  stmfd  r13!,r0-r3,r12,r14  ;save registers to SP_irq
  0000012C  mov    r0,4000000h         ;ptr+4 to 03FFFFFC (mirror of 03007FFC)
  00000130  add    r14,r15,0h          ;retadr for USER handler $+8=138h
  00000134  ldr    r15,[r0,-4h]        ;jump to [03FFFFFC] USER handler
  00000138  ldmfd  r13!,r0-r3,r12,r14  ;restore registers from SP_irq
  0000013C  subs   r15,r14,4h          ;return from IRQ (PC=LR-4, CPSR=SPSR)
</TD></TR></TABLE>
As shown above, a pointer to the 32bit/ARM-code user handler must be setup in
[03007FFCh]. By default, 160 bytes of memory are reserved for interrupt stack
at 03007F00h-03007F9Fh.<BR>
<BR>
<B>Recommended User Interrupt handling</B><BR>
- If necessary switch to THUMB state manually (handler is called in ARM state)<BR>
- Determine reason(s) of interrupt by examining IF register<BR>
- User program may freely assign priority to each reason by own logic<BR>
- Process the most important reason of your choice<BR>
- User MUST manually acknowledge by writing to IF register<BR>
- If user wants to allow nested interrupts, save SPSR_irq, then enable IRQs.<BR>
- If using other registers than BIOS-pushed R0-R3, manually save R4-R11 also.<BR>
- Note that Interrupt Stack is used (which may have limited size)<BR>
- So, for memory consuming stack operations use system mode (=user stack).<BR>
- When calling subroutines in system mode, save LSR_usr also.<BR>
- Restore SPSR_irq and/or R4-R11 if you've saved them above.<BR>
- Finally, return to BIOS handler by BX LR (R14_irq) instruction.<BR>
<BR>
<B>Default memory usage at 03007FXX (and mirrored to 03FFFFXX)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Addr.    Size Expl.
  3007FFCh 4    Pointer to user IRQ handler (32bit ARM code)
  3007FF8h 2    Interrupt Check Flag (for IntrWait/VBlankIntrWait functions)
  3007FF4h 4    Allocated Area
  3007FF0h 4    Pointer to Sound Buffer
  3007FE0h 16   Allocated Area
  3007FA0h 64   Default area for SP_svc Supervisor Stack (4 words/time)
  3007F00h 160  Default area for SP_irq Interrupt Stack (6 words/time)
</TD></TR></TABLE>
Memory below 7F00h is free for User Stack and user data. The three stack
pointers are initially initialized at the TOP of the respective areas:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  SP_svc=03007FE0h
  SP_irq=03007FA0h
  SP_usr=03007F00h
</TD></TR></TABLE>
The user may redefine these addresses and move stacks into other locations,
however, the addresses for system data at 7FE0h-7FFFh are fixed.<BR>
<BR>
<B>Not sure, is following free for user ?</B><BR>
Registers R8-R12_fiq, R13_fiq, R14_fiq, SPSR_fiq<BR>
Registers R13-R14_abt, SPSR_abt<BR>
Registers R13-R14_und, SPSR_und<BR>
<BR>
<B>Fast Interrupt (FIQ)</B><BR>
The ARM CPU provides two interrupt sources, IRQ and FIQ. In the GBA only IRQ is
used. In normal GBAs, the FIQ signal is shortcut to VDD35, ie. the signal is
always high, and there is no way to generate a FIQ by hardware. The registers
R8..12_fiq could be used by software (when switching into FIQ mode by writing
to CPSR) - however, this might make the game incompatible with hardware
debuggers (which are reportedly using FIQs for debugging purposes).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbasystemcontrol"></A>&nbsp;
  GBA System Control
</FONT></TD></TR></TABLE><BR>
<B>4000204h - WAITCNT - Waitstate Control (R/W)</B><BR>
This register is used to configure game pak access timings. The game pak ROM is
mirrored to three address regions at 08000000h, 0A000000h, and 0C000000h, these
areas are called Wait State 0-2. Different access timings may be assigned to
each area (this might be useful in case that a game pak contains several ROM
chips with different access times each).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-1   SRAM Wait Control          (0..3 = 4,3,2,8 cycles)
  2-3   Wait State 0 First Access  (0..3 = 4,3,2,8 cycles)
  4     Wait State 0 Second Access (0..1 = 2,1 cycles)
  5-6   Wait State 1 First Access  (0..3 = 4,3,2,8 cycles)
  7     Wait State 1 Second Access (0..1 = 4,1 cycles; unlike above WS0)
  8-9   Wait State 2 First Access  (0..3 = 4,3,2,8 cycles)
  10    Wait State 2 Second Access (0..1 = 8,1 cycles; unlike above WS0,WS1)
  11-12 PHI Terminal Output        (0..3 = Disable, 4.19MHz, 8.38MHz, 16.78MHz)
  13    Not used
  14    Game Pak Prefetch Buffer (Pipe) (0=Disable, 1=Enable)
  15    Game Pak Type Flag  (Read Only) (0=GBA, 1=CGB) (IN35 signal)
  16-31 Not used
</TD></TR></TABLE>
At startup, the default setting is 0000h. Currently manufactured cartridges are
using the following settings: WS0/ROM=3,1 clks; SRAM=8 clks; WS2/EEPROM: 8,8
clks; prefetch enabled; that is, WAITCNT=4317h, for more info see "GBA
Cartridges" chapter.<BR>
<BR>
First Access (Non-sequential) and Second Access (Sequential) define the
waitstates for N and S cycles, the actual access time is 1 clock cycle PLUS the
number of waitstates.<BR>
GamePak uses 16bit data bus, so that a 32bit access is split into TWO 16bit
accesses (of which, the second fragment is always sequential, even if the first
fragment was non-sequential).<BR>
<BR>
<A HREF="#gbagamepakprefetch">GBA GamePak Prefetch</A><BR>
<BR>
NOTES:<BR>
The GBA forcefully uses non-sequential timing at the beginning of each
128K-block of gamepak ROM, eg. "LDMIA [801fff8h],r0-r7" will have
non-sequential timing at 8020000h.<BR>
The PHI Terminal output (PHI Pin of Gamepak Bus) should be disabled.<BR>
<BR>
<B>4000300h - POSTFLG - BYTE - Undocumented - Post Boot / Debug Control (R/W)</B><BR>
After initial reset, the GBA BIOS initializes the register to 01h, and any
further execution of the Reset vector (00000000h) will pass control to the
Debug vector (0000001Ch) when sensing the register to be still set to 01h.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0     Undocumented. First Boot Flag  (0=First, 1=Further)
  1-7   Undocumented. Not used.
</TD></TR></TABLE>
Normally the debug handler rejects control unless it detects Debug flags in
cartridge header, in that case it may redirect to a cut-down boot procedure
(bypassing Nintendo logo and boot delays, much like nocash burst boot for
multiboot software). I am not sure if it is possible to reset the GBA
externally without automatically resetting register 300h though.<BR>
<BR>
<B>4000301h - HALTCNT - BYTE - Undocumented - Low Power Mode Control (W)</B><BR>
Writing to this register switches the GBA into battery saving mode.<BR>
In Halt mode, the CPU is paused as long as (IE AND IF)=0, this should be used
to reduce power-consumption during periods when the CPU is waiting for
interrupt events.<BR>
In Stop mode, most of the hardware including sound and video are paused, this
very-low-power mode could be used much like a screensaver.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-6   Undocumented. Not used.
  7     Undocumented. Power Down Mode  (0=Halt, 1=Stop)
</TD></TR></TABLE>
The current GBA BIOS addresses only the upper eight bits of this register (by
writing 00h or 80h to address 04000301h), however, as the register isn't
officially documented, some or all of the bits might have different meanings in
future GBA models.<BR>
For best forwards compatibility, it'd generally be more recommended to use the
BIOS Functions SWI 2 (Halt) or SWI 3 (Stop) rather than writing to this
register directly.<BR>
<BR>
<B>4000410h - Undocumented - Purpose Unknown ? 8bit (W)</B><BR>
The BIOS writes the 8bit value 0FFh to this address. Purpose Unknown.<BR>
Probably just another bug in the BIOS.<BR>
<BR>
<B>4000800h - 32bit - Undocumented - Internal Memory Control (R/W)</B><BR>
Supported by GBA and GBA SP only - NOT supported by DS (even in GBA mode).<BR>
Also supported by GBA Micro - but crashes on "overclocked" WRAM setting.<BR>
Initialized to 0D000020h (by hardware). Unlike all other I/O registers, this
register is mirrored across the whole I/O area (in increments of 64K, ie. at
4000800h, 4010800h, 4020800h, ..., 4FF0800h)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0     Disable 32K+256K WRAM (0=Normal, 1=Disable) (when off: empty/prefetch)
  1-3   Unknown          (Read/Write-able)
  4     Unknown          (Always zero, not used or write only)
  5     Enable 256K WRAM (0=Disable, 1=Normal) (when off: mirror of 32K WRAM)
  6-23  Unknown          (Always zero, not used or write only)
  24-27 Wait Control WRAM 256K (0-14 = 15..1 Waitstates, 15=Lockup)
  28-31 Unknown          (Read/Write-able)
</TD></TR></TABLE>
The default value 0Dh in Bits 24-27 selects 2 waitstates for 256K WRAM (ie.
3/3/6 cycles 8/16/32bit accesses). The fastest possible setting would be 0Eh (1
waitstate, 2/2/4 cycles for 8/16/32bit), that works on GBA and GBA SP only, the
GBA Micro locks up with that setting (it's on-chip RAM is too slow, and works
only with 2 or more waitstates).<BR>
<BR>
Note: One cycle equals approx. 59.59ns (ie. 16.78MHz clock).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbagamepakprefetch"></A>&nbsp;
  GBA GamePak Prefetch
</FONT></TD></TR></TABLE><BR>
GamePak Prefetch can be enabled in WAITCNT register. When prefetch buffer is
enabled, the GBA attempts to read opcodes from Game Pak ROM during periods when
the CPU is not using the bus (if any). Memory access is then performed with 0
Waits if the CPU requests data which is already stored in the buffer. The
prefetch buffer stores up to eight 16bit values.<BR>
<BR>
<B>GamePak ROM Opcodes</B><BR>
The prefetch feature works only with &lt;opcodes&gt; fetched from GamePak ROM.
Opcodes executed in RAM or BIOS are not affected by the prefetch feature (even
if that opcodes read &lt;data&gt; from GamePak ROM).<BR>
<BR>
<B>Prefetch Enable</B><BR>
For GamePak ROM opcodes, prefetch may occur in two situations:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1) opcodes with internal cycles (I) which do not change R15, shift/rotate
     register-by-register, load opcodes (ldr,ldm,pop,swp), multiply opcodes
  2) opcodes that load/store memory (ldr,str,ldm,stm,etc.)
</TD></TR></TABLE>
<BR>
<B>Prefetch Disable Bug</B><BR>
When Prefetch is disabled, the Prefetch Disable Bug will occur for all<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  "Opcodes in GamePak ROM with Internal Cycles which do not change R15"
</TD></TR></TABLE>
for those opcodes, the bug changes the opcode fetch time from 1S to 1N.<BR>
Note: Affected opcodes (with I cycles) are: Shift/rotate register-by-register
opcodes, multiply opcodes, and load opcodes (ldr,ldm,pop,swp).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbacartridges"></A>&nbsp;
  GBA Cartridges
</FONT></TD></TR></TABLE><BR>
<B>ROM</B><BR>
<A HREF="#gbacartridgeheader">GBA Cartridge Header</A><BR>
<A HREF="#gbacartridgerom">GBA Cartridge ROM</A><BR>
<BR>
<B>Backup Media</B><BR>
Aside from ROM, cartridges may also include one of the following backup medias,
used to store game positions, highscore tables, options, or other data.<BR>
<A HREF="#gbacartbackupids">GBA Cart Backup IDs</A><BR>
<A HREF="#gbacartbackupsramfram">GBA Cart Backup SRAM/FRAM</A><BR>
<A HREF="#gbacartbackupeeprom">GBA Cart Backup EEPROM</A><BR>
<A HREF="#gbacartbackupflashrom">GBA Cart Backup Flash ROM</A><BR>
<A HREF="#gbacartbackupdacs">GBA Cart Backup DACS</A><BR>
<BR>
<B>Add-Ons</B><BR>
<A HREF="#gbacartioportgpio">GBA Cart I/O Port (GPIO)</A><BR>
<A HREF="#gbacartrealtimeclockrtc">GBA Cart Real-Time Clock (RTC)</A><BR>
<A HREF="#gbacartsolarsensor">GBA Cart Solar Sensor</A><BR>
<A HREF="#gbacarttiltsensor">GBA Cart Tilt Sensor</A><BR>
<A HREF="#gbacartgyrosensor">GBA Cart Gyro Sensor</A><BR>
<A HREF="#gbacartrumble">GBA Cart Rumble</A><BR>
<A HREF="#gbacartereader">GBA Cart e-Reader</A><BR>
<A HREF="#gbacartunknowndevices">GBA Cart Unknown Devices</A><BR>
<A HREF="#gbacartprotections">GBA Cart Protections</A><BR>
<BR>
<B>Other Accessoires</B><BR>
<A HREF="#gbaflashcards">GBA Flashcards</A><BR>
<A HREF="#gbacheatdevices">GBA Cheat Devices</A><BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbacartridgeheader"></A>&nbsp;
  GBA Cartridge Header
</FONT></TD></TR></TABLE><BR>
The first 192 bytes at 8000000h-80000BFh in ROM are used as cartridge header.
The same header is also used for Multiboot images at 2000000h-20000BFh (plus
some additional multiboot entries at 20000C0h and up).<BR>
<BR>
<B>Header Overview</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Address Bytes Expl.
  000h    4     ROM Entry Point  (32bit ARM branch opcode, eg. "B rom_start")
  004h    156   Nintendo Logo    (compressed bitmap, required!)
  0A0h    12    Game Title       (uppercase ascii, max 12 characters)
  0ACh    4     Game Code        (uppercase ascii, 4 characters)
  0B0h    2     Maker Code       (uppercase ascii, 2 characters)
  0B2h    1     Fixed value      (must be 96h, required!)
  0B3h    1     Main unit code   (00h for current GBA models)
  0B4h    1     Device type      (usually 00h) (bit7=DACS/debug related)
  0B5h    7     Reserved Area    (should be zero filled)
  0BCh    1     Software version (usually 00h)
  0BDh    1     Complement check (header checksum, required!)
  0BEh    2     Reserved Area    (should be zero filled)
  --- Additional Multiboot Header Entries ---
  0C0h    4     RAM Entry Point  (32bit ARM branch opcode, eg. "B ram_start")
  0C4h    1     Boot mode        (init as 00h - BIOS overwrites this value!)
  0C5h    1     Slave ID Number  (init as 00h - BIOS overwrites this value!)
  0C6h    26    Not used         (seems to be unused)
  0E0h    4     JOYBUS Entry Pt. (32bit ARM branch opcode, eg. "B joy_start")
</TD></TR></TABLE>
Note: With all entry points, the CPU is initially set into system mode.<BR>
<BR>
<B>000h - Entry Point, 4 Bytes</B><BR>
Space for a single 32bit ARM opcode that redirects to the actual startaddress
of the cartridge, this should be usually a "B &lt;start&gt;" instruction.<BR>
Note: This entry is ignored by Multiboot slave GBAs (in fact, the entry is then
overwritten and redirected to a separate Multiboot Entry Point, as described
below).<BR>
<BR>
<B>004h..09Fh - Nintendo Logo, 156 Bytes</B><BR>
Contains the Nintendo logo which is displayed during the boot procedure.
Cartridge won't work if this data is missing or modified.<BR>
In detail: This area contains Huffman compression data (but excluding the
compression header which is hardcoded in the BIOS, so that it'd be probably not
possible to hack the GBA by producing de-compression buffer overflows).<BR>
A copy of the compression data is stored in the BIOS, the GBA will compare this
data and lock-up itself if the BIOS data isn't exactly the same as in the
cartridge (or multiboot header). The only exception are the two entries below
which are allowed to have variable settings in some bits.<BR>
<BR>
<B>09Ch Bit 2,7 - Debugging Enable</B><BR>
This is part of the above Nintendo Logo area, and must be commonly set to 21h,
however, Bit 2 and Bit 7 may be set to other values.<BR>
When both bits are set (ie. A5h), the FIQ/Undefined Instruction handler in the
BIOS becomes unlocked, the handler then forwards these exceptions to the user
handler in cartridge ROM (entry point defined in 80000B4h, see below).<BR>
Other bit combinations currently do not seem to have special functions.<BR>
<BR>
<B>09Eh Bit 0,1 - Cartridge Key Number MSBs</B><BR>
This is part of the above Nintendo Logo area, and must be commonly set to F8h,
however, Bit 0-1 may be set to other values.<BR>
During startup, the BIOS performs some dummy-reads from a stream of pre-defined
addresses, even though these reads seem to be meaningless, they might be
intended to unlock a read-protection inside of commercial cartridge. There are
16 pre-defined address streams - selected by a 4bit key number - of which the
upper two bits are gained from 800009Eh Bit 0-1, and the lower two bits from a
checksum across header bytes 09Dh..0B7h (bytewise XORed, divided by 40h).<BR>
<BR>
<B>0A0h - Game Title, Uppercase Ascii, max 12 characters</B><BR>
Space for the game title, padded with 00h (if less than 12 chars).<BR>
<BR>
<B>0ACh - Game Code, Uppercase Ascii, 4 characters</B><BR>
This is the same code as the AGB-UTTD code which is printed on the package and
sticker on (commercial) cartridges (excluding the leading "AGB-" part).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  U  Unique Code          (usually "A" or "B" or special meaning)
  TT Short Title          (eg. "PM" for Pac Man)
  D  Destination/Language (usually "J" or "E" or "P" or specific language)
</TD></TR></TABLE>
The first character (U) is usually "A" or "B", in detail:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  A  Normal game; Older titles (mainly 2001..2003)
  B  Normal game; Newer titles (2003..)
  C  Normal game; Not used yet, but might be used for even newer titles
  F  Famicom/Classic NES Series (software emulated NES games)
  K  Yoshi and Koro Koro Puzzle (acceleration sensor)
  P  e-Reader (dot-code scanner)
  R  Warioware Twisted (cartridge with rumble and z-axis gyro sensor)
  U  Boktai 1 and 2 (cartridge with RTC and solar sensor)
  V  Drill Dozer (cartridge with rumble)
</TD></TR></TABLE>
The second/third characters (TT) are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Usually an abbreviation of the game title (eg. "PM" for "Pac Man") (unless
  that gamecode was already used for another game, then TT is just random)
</TD></TR></TABLE>
The fourth character (D) indicates Destination/Language:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  J  Japan             P  Europe/Elsewhere   F  French          S  Spanish
  E  USA/English       D  German             I  Italian
</TD></TR></TABLE>
<BR>
<B>0B0h - Maker code, Uppercase Ascii, 2 characters</B><BR>
Identifies the (commercial) developer. For example, "01"=Nintendo.<BR>
<BR>
<B>0B2h - Fixed value, 1 Byte</B><BR>
Must be 96h.<BR>
<BR>
<B>0B3h - Main unit code, 1 Byte</B><BR>
Identifies the required hardware. Should be 00h for current GBA models.<BR>
<BR>
<B>0B4h - Device type, 1 Byte</B><BR>
Normally, this entry should be zero. With Nintendo's hardware debugger Bit 7
identifies the debugging handlers entry point and size of DACS (Debugging And
Communication System) memory: Bit7=0: 9FFC000h/8MBIT DACS, Bit7=1:
9FE2000h/1MBIT DACS. The debugging handler can be enabled in 800009Ch (see
above), normal cartridges do not have any memory (nor any mirrors) at these
addresses though.<BR>
<BR>
<B>0B5h - Reserved Area, 7 Bytes</B><BR>
Reserved, zero filled.<BR>
<BR>
<B>0BCh - Software version number</B><BR>
Version number of the game. Usually zero.<BR>
<BR>
<B>0BDh - Complement check, 1 Byte</B><BR>
Header checksum, cartridge won't work if incorrect. Calculate as such:<BR>
chk=0:for i=0A0h to 0BCh:chk=chk-[i]:next:chk=(chk-19h) and 0FFh<BR>
<BR>
<B>0BEh - Reserved Area, 2 Bytes</B><BR>
Reserved, zero filled.<BR>
<BR>
Below required for Multiboot/slave programs only. For Multiboot, the above 192
bytes are required to be transferred as header-block (loaded to
2000000h-20000BFh), and some additional header-information must be located at
the beginning of the actual program/data-block (loaded to 20000C0h and up).
This extended header consists of Multiboot Entry point(s) which must be set up
correctly, and of two reserved bytes which are overwritten by the boot
procedure:<BR>
<BR>
<B>0C0h - Normal/Multiplay mode Entry Point</B><BR>
This entry is used only if the GBA has been booted by using Normal or Multiplay
transfer mode (but not by Joybus mode).<BR>
Typically deposit a ARM-32bit "B &lt;start&gt;" branch opcode at this location,
which is pointing to your actual initialization procedure.<BR>
<BR>
<B>0C4h (BYTE) - Boot mode</B><BR>
The slave GBA download procedure overwrites this byte by a value which is
indicating the used multiboot transfer mode.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Value  Expl.
  01h    Joybus mode
  02h    Normal mode
  03h    Multiplay mode
</TD></TR></TABLE>
Typically set this byte to zero by inserting DCB 00h in your source.<BR>
Be sure that your uploaded program does not contain important program code or
data at this location, or at the ID-byte location below.<BR>
<BR>
<B>0C5h (BYTE) - Slave ID Number</B><BR>
If the GBA has been booted in Normal or Multiplay mode, this byte becomes
overwritten by the slave ID number of the local GBA (that'd be always 01h for
normal mode).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Value  Expl.
  01h    Slave #1
  02h    Slave #2
  03h    Slave #3
</TD></TR></TABLE>
Typically set this byte to zero by inserting DCB 00h in your source.<BR>
When booted in Joybus mode, the value is NOT changed and remains the same as
uploaded from the master GBA.<BR>
<BR>
<B>0C6h..0DFh - Not used</B><BR>
Appears to be unused.<BR>
<BR>
<B>0E0h - Joybus mode Entry Point</B><BR>
If the GBA has been booted by using Joybus transfer mode, then the entry point
is located at this address rather than at 20000C0h. Either put your
initialization procedure directly at this address, or redirect to the actual
boot procedure by depositing a "B &lt;start&gt;" opcode here (either one using
32bit ARM code). Or, if you are not intending to support joybus mode (which is
probably rarely used), ignore this entry.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbacartridgerom"></A>&nbsp;
  GBA Cartridge ROM
</FONT></TD></TR></TABLE><BR>
<B>ROM Size</B><BR>
The games F-ZERO and Super Mario Advance use ROMs of 4 MBytes each. Zelda uses
8 MBytes. Not sure if other sizes are manufactured.<BR>
<BR>
<B>ROM Waitstates</B><BR>
The GBA starts the cartridge with 4,2 waitstates (N,S) and prefetch disabled.
The program may change these settings by writing to WAITCNT, the games F-ZERO
and Super Mario Advance use 3,1 waitstates (N,S) each, with prefetch enabled.<BR>
Third-party flashcards are reportedly running unstable with these settings.
Also, prefetch and shorter waitstates are allowing to read more data and
opcodes from ROM is less time, the downside is that it increases the power
consumption.<BR>
<BR>
<B>ROM Chip</B><BR>
Because of how 24bit addresses are squeezed through the Gampak bus, the
cartridge must include a circuit that latches the lower 16 address bits on
non-sequential access, and that increments these bits on sequential access.
Nintendo includes this circuit directly in the ROM chip.<BR>
Also, the ROM must have 16bit data bus (or a circuit which converts two 8bit
data units into one 16bit unit - by not exceeding the waitstate timings).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbacartbackupids"></A>&nbsp;
  GBA Cart Backup IDs
</FONT></TD></TR></TABLE><BR>
Nintendo didn't include a backup-type entry in the ROM header, however, the
required type can be detected by ID strings in the ROM-image. Nintendo's tools
are automatically inserting these strings (as part of their library headers).
When using other tools, you may insert ID strings by hand.<BR>
<BR>
<B>ID Strings</B><BR>
The ID string must be located at a word-aligned memory location, the string
length should be a multiple of 4 bytes (padded with zero's).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  EEPROM_Vnnn    EEPROM 512 bytes or 8 Kbytes (4Kbit or 64Kbit)
  SRAM_Vnnn      SRAM 32 Kbytes (256Kbit)
  FLASH_Vnnn     FLASH 64 Kbytes (512Kbit) (ID used in older files)
  FLASH512_Vnnn  FLASH 64 Kbytes (512Kbit) (ID used in newer files)
  FLASH1M_Vnnn   FLASH 128 Kbytes (1Mbit)
</TD></TR></TABLE>
For Nintendo's tools, "nnn" is a 3-digit library version number. When using
other tools, best keep it set to "nnn" rather than inserting numeric digits.<BR>
<BR>
<B>Notes</B><BR>
No$gba does auto-detect most backup types, even without ID strings, except for
128K FLASH (without ID "FLASH1M_Vnnn", the FLASH size defaults to 64K).
Ideally, for faster detection, the ID should be put into the first some bytes
of the ROM-image (ie. somewhere right after the ROM header).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbacartbackupsramfram"></A>&nbsp;
  GBA Cart Backup SRAM/FRAM
</FONT></TD></TR></TABLE><BR>
SRAM - 32 KBytes (256Kbit) Lifetime: Depends on back-up battery<BR>
FRAM - 32 KBytes (256Kbit) Lifetime: 10,000,000,000 read/write per bit<BR>
<BR>
Hyundai GM76V256CLLFW10 SRAM (Static RAM) (eg. F-Zero)<BR>
Fujitsu MB85R256 FRAM (Ferroelectric RAM) (eg. Warioware Twisted)<BR>
<BR>
<B>Addressing and Waitstates</B><BR>
SRAM/FRAM is mapped to E000000h-E007FFFh, it should be accessed with 8
waitstates (write a value of 3 into Bit0-1 of WAITCNT).<BR>
<BR>
<B>Databus Width</B><BR>
The SRAM/FRAM databus is restricted to 8 bits, it should be accessed by LDRB,
LDRSB, and STRB opcodes only.<BR>
<BR>
<B>Reading and Writing</B><BR>
Reading from SRAM/FRAM should be performed by code executed in WRAM only (but
not by code executed in ROM). There is no such restriction for writing.<BR>
<BR>
<B>Preventing Data Loss</B><BR>
The GBA SRAM/FRAM carts do not include a write-protect function (unlike older
8bit gameboy carts). This seems to be a problem and may cause data loss when a
cartridge is removed or inserted while the GBA is still turned on. As far as I
understand, this is not so much a hardware problem, but rather a software
problem, ie. theoretically you could remove/insert the cartridge as many times
as you want, but you should take care that your program does not crash (and
write blindly into memory).<BR>
<BR>
<B>Recommended Workaround</B><BR>
Enable the Gamepak Interrupt (it'll most likely get triggered when removing the
cartridge), and hang-up the GBA in an endless loop when your interrupt handler
senses a Gamepak IRQ. For obvious reason, your interrupt handler should be
located in WRAM, ie. not in the (removed) ROM cartridge. The handler should
process Gamepak IRQs at highest priority. Periods during which interrupts are
disabled should be kept as short as possible, if necessary allow nested
interrupts.<BR>
<BR>
<B>When to use the above Workaround</B><BR>
A program that relies wholly on code and data in WRAM, and that does not crash
even when ROM is removed, may keep operating without having to use the above
mechanism.<BR>
Do NOT use the workaround for programs that run without a cartridge inserted
(ie. single gamepak/multiboot slaves), or for programs that use Gamepak IRQ/DMA
for other purposes.<BR>
All other programs should use it. It'd be eventually a good idea to include it
even in programs that do not use SRAM/FRAM themselves (eg. otherwise removing a
SRAM/FRAM-less cartridge may lock up the GBA, and may cause it to destroy
backup data when inserting a SRAM/FRAM cartridge).<BR>
<BR>
<B>SRAM vs FRAM</B><BR>
FRAM (Ferroelectric RAM) is a newer technology, used in newer GBA carts, unlike
SRAM (Static RAM), it doesn't require a battery to hold the data. At software
side, it is accessed exactly like SRAM, ie. unlike EEPROM/FLASH, it doesn't
require any Write/Erase commands/delays.<BR>
<BR>
<B>Note</B><BR>
In SRAM/FRAM cartridges, the /REQ pin (Pin 31 of Gamepak bus) should be a
little bit shorter as than the other pins; when removing the cartridge, this
causes the gamepak IRQ signal to get triggered before the other pins are
disconnected.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbacartbackupeeprom"></A>&nbsp;
  GBA Cart Backup EEPROM
</FONT></TD></TR></TABLE><BR>
9853 - EEPROM 512 Bytes (0200h) (4Kbit) (eg. used by Super Mario Advance)<BR>
9854 - EEPROM 8 KBytes (2000h) (64Kbit) (eg. used by Boktai)<BR>
Lifetime: 100,000 writes per address<BR>
<BR>
<B>Addressing and Waitstates</B><BR>
The eeprom is connected to Bit0 of the data bus, and to the upper 1 bit (or
upper 17 bits in case of large 32MB ROM) of the cartridge ROM address bus,
communication with the chip takes place serially.<BR>
The eeprom must be used with 8 waitstates (set WAITCNT=X3XXh; 8,8 clks in WS2
area), the eeprom can be then addressed at DFFFF00h..DFFFFFFh.<BR>
Respectively, with eeprom, ROM is restricted to 8000000h-9FFFeFFh (max.
1FFFF00h bytes = 32MB minus 256 bytes). On carts with 16MB or smaller ROM,
eeprom can be alternately accessed anywhere at D000000h-DFFFFFFh.<BR>
<BR>
<B>Data and Address Width</B><BR>
Data can be read from (or written to) the EEPROM in units of 64bits (8 bytes).
Writing automatically erases the old 64bits of data. Addressing works in units
of 64bits respectively, that is, for 512 Bytes EEPROMS: an address range of
0-3Fh, 6bit bus width; and for 8KByte EEPROMs: a range of 0-3FFh, 14bit bus
width (only the lower 10 address bits are used, upper 4 bits should be zero).<BR>
<BR>
<B>Set Address (For Reading)</B><BR>
Prepare the following bitstream in memory:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  2 bits "11" (Read Request)
  n bits eeprom address (MSB first, 6 or 14 bits, depending on EEPROM)
  1 bit "0"
</TD></TR></TABLE>
Then transfer the stream to eeprom by using DMA.<BR>
<BR>
<B>Read Data</B><BR>
Read a stream of 68 bits from EEPROM by using DMA,<BR>
then decipher the received data as follows:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4 bits - ignore these
 64 bits - data (conventionally MSB first)
</TD></TR></TABLE>
<BR>
<B>Write Data to Address</B><BR>
Prepare the following bitstream in memory, then transfer the stream to eeprom
by using DMA, it'll take ca. 108368 clock cycles (ca. 6.5ms) until the old data
is erased and new data is programmed.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  2 bits "10" (Write Request)
  n bits eeprom address (MSB first, 6 or 14 bits, depending on EEPROM)
 64 bits data (conventionally MSB first)
  1 bit "0"
</TD></TR></TABLE>
After the DMA, keep reading from the chip, by normal LDRH [DFFFF00h], until Bit
0 of the returned data becomes "1" (Ready). To prevent your program from
locking up in case of malfunction, generate a timeout if the chip does not
reply after 10ms or longer.<BR>
<BR>
<B>Using DMA</B><BR>
Transferring a bitstream to/from the EEPROM by LDRH/STRH opcodes does not work,
this might be because of timing problems, or because how the GBA squeezes
non-sequential memory addresses through the external address/data bus.<BR>
For this reason, a buffer in memory must be used (that buffer would be
typically allocated temporarily on stack, one halfword for each bit, bit1-15 of
the halfwords are don't care, only bit0 is of interest).<BR>
The buffer must be transfered as a whole to/from EEPROM by using DMA3 (only DMA
3 is valid to read &amp; write external memory), use 16bit transfer mode, both
source and destination address incrementing (ie. DMA3CNT=80000000h+length).<BR>
DMA channels of higher priority should be disabled during the transfer (ie.
H/V-Blank or Sound FIFO DMAs). And, of course any interrupts that might mess
with DMA registers should be disabled.<BR>
<BR>
<B>Pin-Outs</B><BR>
The EEPROM chips are having only 8 pins, these are connected, Pin 1..8, to
ROMCS, RD, WR, AD0, GND, GND, A23, VDD of the GamePak bus. Carts with 32MB ROM
must have A7..A22 logically ANDed with A23.<BR>
<BR>
<B>Notes</B><BR>
There seems to be no autodection mechanism, so that a hardcoded bus width must
be used.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbacartbackupflashrom"></A>&nbsp;
  GBA Cart Backup Flash ROM
</FONT></TD></TR></TABLE><BR>
64 KBytes - 512Kbits Flash ROM - Lifetime: 10,000 writes per sector<BR>
128 KBytes - 1Mbit Flash ROM - Lifetime: ??? writes per sector<BR>
<BR>
<B>Chip Identification (all device types)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  [E005555h]=AAh, [E002AAAh]=55h, [E005555h]=90h  (enter ID mode)
  dev=[E000001h], man=[E000000h]                  (get device &amp; manufacturer)
  [E005555h]=AAh, [E002AAAh]=55h, [E005555h]=F0h  (terminate ID mode)
</TD></TR></TABLE>
Used to detect the type (and presence) of FLASH chips. See Device Types below.<BR>
<BR>
<B>Reading Data Bytes (all device types)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  dat=[E00xxxxh]                                  (read byte from address xxxx)
</TD></TR></TABLE>
<BR>
<B>Erase Entire Chip (all device types)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  [E005555h]=AAh, [E002AAAh]=55h, [E005555h]=80h  (erase command)
  [E005555h]=AAh, [E002AAAh]=55h, [E005555h]=10h  (erase entire chip)
  wait until [E000000h]=FFh (or timeout)
</TD></TR></TABLE>
Erases all memory in chip, erased memory is FFh-filled.<BR>
<BR>
<B>Erase 4Kbyte Sector (all device types, except Atmel)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  [E005555h]=AAh, [E002AAAh]=55h, [E005555h]=80h  (erase command)
  [E005555h]=AAh, [E002AAAh]=55h, [E00n000h]=30h  (erase sector n)
  wait until [E00n000h]=FFh (or timeout)
</TD></TR></TABLE>
Erases memory at E00n000h..E00nFFFh, erased memory is FFh-filled.<BR>
<BR>
<B>Erase-and-Write 128 Bytes Sector (only Atmel devices)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  old=IME, IME=0                                  (disable interrupts)
  [E005555h]=AAh, [E002AAAh]=55h, [E005555h]=A0h  (erase/write sector command)
  [E00xxxxh+00h..7Fh]=dat[00h..7Fh]               (write 128 bytes)
  IME=old                                         (restore old IME state)
  wait until [E00xxxxh+7Fh]=dat[7Fh] (or timeout)
</TD></TR></TABLE>
Interrupts (and DMAs) should be disabled during command/write phase. Target
address must be a multiple of 80h.<BR>
<BR>
<B>Write Single Data Byte (all device types, except Atmel)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  [E005555h]=AAh, [E002AAAh]=55h, [E005555h]=A0h  (write byte command)
  [E00xxxxh]=dat                                  (write byte to address xxxx)
  wait until [E00xxxxh]=dat (or timeout)
</TD></TR></TABLE>
The target memory location must have been previously erased.<BR>
<BR>
<B>Terminate Command after Timeout (only Macronix devices, ID=1CC2h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  [E005555h]=F0h                            (force end of write/erase command)
</TD></TR></TABLE>
Use if timeout occurred during "wait until" periods, for Macronix devices only.<BR>
<BR>
<B>Bank Switching (devices bigger than 64K only)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  [E005555h]=AAh, [E002AAAh]=55h, [E005555h]=B0h  (select bank command)
  [E000000h]=bnk                                  (write bank number 0..1)
</TD></TR></TABLE>
Specifies 64K bank number for read/write/erase operations.<BR>
Required because gamepak flash/sram addressbus is limited to 16bit width.<BR>
<BR>
<B>Device Types</B><BR>
Nintendo puts different FLASH chips in commercial game cartridges. Developers
should thus detect &amp; support all chip types. For Atmel chips it'd be
recommended to simulate 4K sectors by software, though reportedly Nintendo
doesn't use Atmel chips in newer games anymore. Also mind that different
timings should not disturb compatibility and performance.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ID     Name       Size  Sectors  AverageTimings  Timeouts/ms   Waits
  D4BFh  SST        64K   16x4K    20us?,?,?       10,  40, 200  3,2
  1CC2h  Macronix   64K   16x4K    ?,?,?           10,2000,2000  8,3
  1B32h  Panasonic  64K   16x4K    ?,?,?           10, 500, 500  4,2
  3D1Fh  Atmel      64K   512x128  ?,?,?           ...40..,  40  8,8
  1362h  Sanyo      128K  ?        ?,?,?           ?    ?    ?    ?
  09C2h  Macronix   128K  ?        ?,?,?           ?    ?    ?    ?
</TD></TR></TABLE>
Identification Codes MSB=Device Type, LSB=Manufacturer.<BR>
Size in bytes, and numbers of sectors * sector size in bytes.<BR>
Average medium Write, Erase Sector, Erase Chips timings are unknown?<BR>
Timeouts in milliseconds for Write, Erase Sector, Erase Chips.<BR>
Waitstates for Writes, and Reads in clock cycles.<BR>
<BR>
<B>Accessing FLASH Memory</B><BR>
FLASH memory is located in the "SRAM" area at E000000h..E00FFFFh, which is
restricted to 16bit address and 8bit data buswidths. Respectively, the memory
can be accessed &lt;only&gt; by 8bit read/write LDRB/STRB opcodes.<BR>
Also, reading anything (data or status/busy information) can be done
&lt;only&gt; by opcodes executed in WRAM (not from opcodes in ROM) (there's no
such restriction for writing).<BR>
<BR>
<B>FLASH Waitstates</B><BR>
Use 8 clk waitstates for initial detection (WAITCNT Bits 0,1 both set). After
detection of certain device types smaller wait values may be used for
write/erase, and even smaller wait values for raw reading, see Device Types
table.<BR>
In practice, games seem to use smaller values only for write/erase (even though
those operations are slow anyways), whilst raw reads are always done at 8 clk
waits (even though reads could actually benefit slightly from smaller wait
values).<BR>
<BR>
<B>Verify Write/Erase and Retry</B><BR>
Even though device signalizes the completion of write/erase operations, it'd be
recommended to read/confirm the content of the changed memory area by software.
In practice, Nintendo's "erase-write-verify-retry" function typically repeats
the operation up to three times in case of errors.<BR>
Also, for SST devices only, the "erase-write" and "erase-write-verify-retry"
functions repeat the erase command up to 80 times, additionally followed by one
further erase command if no retries were needed, otherwise followed by six
further erase commands.<BR>
<BR>
<B>Note</B><BR>
FLASH (64Kbytes) is used by the game Sonic Advance, and possibly others.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbacartbackupdacs"></A>&nbsp;
  GBA Cart Backup DACS
</FONT></TD></TR></TABLE><BR>
128 KBytes - 1Mbit DACS - Lifetime: 100,000 writes.<BR>
1024 KBytes - 8Mbit DACS - Lifetime: 100,000 writes.<BR>
<BR>
DACS (Debugging And Communication System) is used in Nintendo's hardware
debugger only, DACS is NOT used in normal game cartridges.<BR>
<BR>
Parts of DACS memory is used to store the debugging exception handlers (entry
point/size defined in cartridge header), the remaining memory could be used to
store game positions or other data. The address space is the upper end of the
32MB ROM area, the memory can be read directly by the CPU, including for
ability to execute program code in this area.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbacartioportgpio"></A>&nbsp;
  GBA Cart I/O Port (GPIO)
</FONT></TD></TR></TABLE><BR>
4bit General Purpose I/O Port (GPIO) - contained in the ROM-chip<BR>
<BR>
Used by Boktai for RTC and Solar Sensor:<BR>
<A HREF="#gbacartrealtimeclockrtc">GBA Cart Real-Time Clock (RTC)</A><BR>
<A HREF="#gbacartsolarsensor">GBA Cart Solar Sensor</A><BR>
And by Warioware Twisted for Rumble and Z-Axis Sensor:<BR>
<A HREF="#gbacartrumble">GBA Cart Rumble</A><BR>
<A HREF="#gbacartgyrosensor">GBA Cart Gyro Sensor</A><BR>
Might be also used by other games for other purposes, such like other sensors,
or SRAM bank switching, etc.<BR>
<BR>
The I/O registers are mapped to a 6-byte region in the ROM-area at 80000C4h,
the 6-byte region should be zero-filled in the ROM-image. In Boktai, the size
of the zero-filled region is 0E0h bytes - that probably due to an incorrect
definition (the additional bytes do not contain any extra ports, nor mirrors of
the ports in the 6-byte region). Observe that ROM-bus writes are limited to
16bit/32bit access (STRB opcodes are ignored; that, only in DS mode?).<BR>
<BR>
<B>80000C4h - I/O Port Data (selectable W or R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  bit0-3  Data Bits 0..3 (0=Low, 1=High)
  bit4-15 not used (0)
</TD></TR></TABLE>
<BR>
<B>80000C6h - I/O Port Direction (for above Data Port) (selectable W or R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  bit0-3  Direction for Data Port Bits 0..3 (0=In, 1=Out)
  bit4-15 not used (0)
</TD></TR></TABLE>
<BR>
<B>80000C8h - I/O Port Control (selectable W or R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  bit0    Register 80000C4h..80000C8h Control (0=Write-Only, 1=Read/Write)
  bit1-15 not used (0)
</TD></TR></TABLE>
In write-only mode, reads return 00h (or possible other data, if the rom
contains non-zero data at that location).<BR>
<BR>
<B>Connection Examples</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  GPIO       | Boktai  | Wario
  Bit Pin    | RTC SOL | GYR RBL
  -----------+---------+---------
  0   ROM.1  | SCK CLK | RES -
  1   ROM.2  | SIO RST | CLK -
  2   ROM.21 | CS  -   | DTA -
  3   ROM.22 | -   FLG | -   MOT
  -----------+---------+---------
  IRQ ROM.43 | IRQ -   | -   -
</TD></TR></TABLE>
<BR>
Aside from the I/O Port, the ROM-chip also includes an inverter (used for
inverting the RTC /IRQ signal), and some sort of an (unused) address decoder
output (which appears to be equal or related to A23 signal) (ie. reacting on
ROM A23, or SRAM D7, which share the same pin on GBA slot).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbacartrealtimeclockrtc"></A>&nbsp;
  GBA Cart Real-Time Clock (RTC)
</FONT></TD></TR></TABLE><BR>
S3511 - 8pin RTC with 3-wire serial bus (used in Boktai)<BR>
<BR>
The RTC chip is (almost) the same as used in NDS consoles:<BR>
<A HREF="#dsrealtimeclockrtc">DS Real-Time Clock (RTC)</A><BR>
The chip is accessed via 4bit I/O port (only 3bits are used for RTC):<BR>
<A HREF="#gbacartioportgpio">GBA Cart I/O Port (GPIO)</A><BR>
<BR>
<B>Comparision of RTC Registers</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  NDS_________GBA_________GBA/Params___
  stat2       control     (1-byte)
  datetime    datetime    (7-byte)
  time        time        (3-byte)
  stat1       force reset (0-byte)
  clkadjust   force irq   (0-byte)
  alarm1/int1 always FFh  (boktai contains code for writing 1-byte to it)
  alarm2      always FFh  (unused)
  free        always FFh  (unused)
</TD></TR></TABLE>
<BR>
<B>Control Register</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit Dir Expl.
  0   -   Not used
  1   R/W IRQ duty/hold related?
  2   -   Not used
  3   R/W Per Minute IRQ (30s duty)        (0=Disable, 1=Enable)
  4   -   Not used
  5   R/W Unknown?
  6   R/W 12/24-hour Mode                  (0=12h, 1=24h) (usually 1)
  7   R   Power-Off (auto cleared on read) (0=Normal, 1=Failure)
</TD></TR></TABLE>
Setting after Battery-Shortcut is 82h. Setting after Force-Reset is 00h.<BR>
Unused bits seem to be always zero, but might be read-only or write-only?<BR>
<BR>
<B>Datetime and Time Registers</B><BR>
Same as NDS, except AM/PM flag moved from hour.bit6 (NDS) to hour.bit7 (GBA).<BR>
<BR>
<B>Force Reset/Irq Registers</B><BR>
Used to reset all RTC registers (all used registers become 00h, except
day/month which become 01h), or to drag the IRQ output LOW for a short moment.
These registers are strobed by ANY access to them, ie. by both writing to, as
well as reading from these registers.<BR>
<BR>
<B>Pin-Outs / IRQ Signal</B><BR>
The package has identical pin-outs as in NDS, although it is slightly larger
than the miniature chip in the DS.<BR>
For whatever reason, the RTC's /IRQ output is passed through an inverter
(contained in the ROM-chip), the inverted signal is then passed to the /IRQ pin
on the cartridge slot. So, IRQ's will be triggered on the "wrong" edge -
possible somehow in relation with detecting cartridge-removal IRQs?<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbacartsolarsensor"></A>&nbsp;
  GBA Cart Solar Sensor
</FONT></TD></TR></TABLE><BR>
Uses a Photo Diode as Solar Sensor (used in Boktai, allowing to defeat vampires
when the cartridge is exposed to sunlight). The cartridge comes in transparent
case, and it's slightly longer than normal carts, so the sensor reaches out of
the cartridge slot. According to the manual, the sensor works only with
sunlight, but actually it works with any strong light source (eg. a 100 Watt
bulb at 1-2 centimeters distance). The sensor is accessed via 4bit I/O port
(only 3bits used), which is contained in the ROM-chip.<BR>
<A HREF="#gbacartioportgpio">GBA Cart I/O Port (GPIO)</A><BR>
<BR>
<B>A/D Conversion</B><BR>
The cartridge uses a self-made A/D converter, which is (eventually) better than
measuring a capacitor charge-up time, and/or less expensive than a real
ADC-chip:<BR>
It contains a 74LV4040 12bit binary counter (clocked by CPU via the I/O port),
of which only the lower 8bit are used, which are passed to a resistor
ladder-type D/A converter, which is generating a linear increasing voltage,
which is passed to a TLV272 voltage comparator, which is passing a signal to
the I/O port when the counter voltage becomes greater than the sensor voltage.<BR>
<BR>
<B>Example Code</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  strh  0001h,[80000c8h] ;-enable R/W mode
  strh  0007h,[80000c6h] ;-init I/O direction
  strh  0002h,[80000c4h] ;-reset counter to zero (high=reset) (I/O bit0)
  strh  0000h,[80000c4h] ;-clear reset (low=normal)
  mov   r0,0             ;-initial level
 @@lop:
  strh  0001h,[80000c4h] ;-clock high ;\increase counter      (I/O bit1)
  strh  0000h,[80000c4h] ;-clock low  ;/
  ldrh  r1,[80000c4h]    ;-read port                          (I/O bit3)
  tst   r1,08h           ;\
  addeq r0,1             ; loop until voltage match (exit with r0=00h..FFh),
  tsteq r0,100h          ; or until failure/timeout (exit with r0=100h)
  beq   @@lop            ;/
</TD></TR></TABLE>
The results vary depending on the clock rate used. In above example, ensure
that IRQs or DMAs do not interrupt the function. Alternately, use a super-slow
clock rate (eg. like 666Hz used in Boktai) so that additional small IRQ/DMA
delays have little effect on the overall timing. Results should be somewhat:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  E8h  total darkness (including daylight on rainy days)
  Dxh  close to a 100 Watt Bulb
  5xh  reaches max level in boktai's solar gauge
  00h  close to a tactical nuclear bomb dropped on your city
</TD></TR></TABLE>
The exact values may change from cartridge to cartridge, so it'd be recommened
to include a darkness calibration function, prompting the user to cover the
sensor for a moment.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbacarttiltsensor"></A>&nbsp;
  GBA Cart Tilt Sensor
</FONT></TD></TR></TABLE><BR>
Yoshi's Universal Gravitation / Yoshi Topsy Turvy (X/Y-Axis)<BR>
Koro Koro Puzzle (probably same as Yoshi, X/Y-Axis, too) (?)<BR>
<BR>
<B>Yoshi-Type (X/Y-Axis)</B><BR>
All of the registers are one byte wide, mapped into the top "half" of the SRAM
memory range.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  E008000h (W) Write 55h to start sampling
  E008100h (W) Write AAh to start sampling
  E008200h (R) Lower 8 bits of X axis
  E008300h (R) Upper 4 bits of X axis, and Bit7: ADC Status (0=Busy, 1=Ready)
  E008400h (R) Lower 8 bits of Y axis
  E008500h (R) Upper 4 bits of Y axis
</TD></TR></TABLE>
You must set SRAM wait control to 8 clocks to access it correctly.<BR>
You must also set the cartridge PHI terminal to 4 MHz to make it work.<BR>
Sampling routine (typically executed once a frame during VBlank):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  wait until [E008300h].Bit7=1 or until timeout ;wait ready
  x = ([E008300h] AND 0Fh)*100h + [E008200h]    ;get x
  y = ([E008500h] AND 0Fh)*100h + [E008400h]    ;get y
  [E008000h]=55h, [E008100h]=AAh                ;start next conversion
</TD></TR></TABLE>
Example values (may vary on different carts and on temperature, etc):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  X ranged between 0x2AF to 0x477, center at 0x392.    Huh?
  Y ranged between 0x2C3 to 0x480, center at 0x3A0.    Huh?
</TD></TR></TABLE>
Thanks to Flubba for Yoshi-Type information.<BR>
Unknown if the Yoshi-Type sensors are sensing rotation, or orientation, or
motion, or something else? In case of rotation, rotation around X-axis would
result in motion in Y-direction, so not too sure whether X and Y have which
meaning?<BR>
Most probably, the sensors are measuring (both) static acceleration (gravity),
and dynamic acceleration (eg. shaking the device left/right).<BR>
The X/Y values are likely to be mirrored depending on using a back-loading
cartridge slot (original GBA), or front-loading cartridge slot (newer GBA SP,
and NDS, and NDS-Lite).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbacartgyrosensor"></A>&nbsp;
  GBA Cart Gyro Sensor
</FONT></TD></TR></TABLE><BR>
Warioware Twisted (Z-Axis Gyro Sensor, plus Rumble)<BR>
<BR>
<B>Wario-Type (Z-Axis)</B><BR>
Uses a single-axis sensor, which senses rotation around the Z-axis. The sensor
is connected to an analogue-in, serial-out ADC chip, which is accessed via
lower 3 bits of the GPIO,<BR>
<A HREF="#gbacartioportgpio">GBA Cart I/O Port (GPIO)</A><BR>
The four I/O Lines are connected like so,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  GPIO.Bit0 (W) Start Conversion
  GPIO.Bit1 (W) Serial Clock
  GPIO.Bit2 (R) Serial Data
  GPIO.Bit3 (W) Used for Rumble (not gyro related)
</TD></TR></TABLE>
There should be at least &lt;three sequential 32bit ARM opcodes executed in WS0
region&gt; between the STRH opcodes which toggle the CLK signal. Wario uses
WAITCNT=45B7h (SRAM=8clks, WS0/WS1/WS2=3,1clks, Prefetch=On, PHI=Off).<BR>
The data stream consists of: 4 dummy bits (usually zero), followed by 12 data
bits, followed by endless unused bits (usually zero).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 read_gyro:
  mov  r1,8000000h      ;-cartridge base address
  mov  r0,01h           ;\enable R/W access
  strh r0,[r1,0c8h]     ;/
  mov  r0,0bh           ;\init direction (gpio2=input, others=output)
  strh r0,[r1,0c6h]     ;/
  ldrh r2,[r1,0c4h]     ;-get current state (for keeping gpio3=rumble)
  orr  r2,3                     ;\
  strh r2,[r1,0c4h] ;gpio0=1    ; start ADC conversion
  bic  r2,1                     ;
  strh r2,[r1,0c4h] ;gpio0=0    ;/
  mov  r0,00010000h ;stop-bit           ;\
  bic  r2,2                             ;
 @@lop:                                 ;
  ldrh r3,[r1,0c4h] ;get gpio2=data     ; read 16 bits
  strh r2,[r1,0c4h] ;gpio1=0=clk=low    ; (4 dummy bits, plus 12 data bits)
  movs r3,r3,lsr 3  ;gpio2 to cy=data   ;
  adcs r0,r0,r0     ;merge data, cy=done;
  orr  r3,r2,2      ;set bit1 and delay ;
  strh r3,[r1,0c4h] ;gpio1=1=clk=high   ;
  bcc  @@lop                            ;/
  bic  r0,0f000h                 ;-strip upper 4 dummy bits (isolate 12bit adc)
  bx   lr
</TD></TR></TABLE>
Example values (may vary on different carts, battery charge, temperature, etc):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  354h  rotated in anti-clockwise direction (shock-speed)
  64Dh  rotated in anti-clockwise direction (normal fast)
  6A3h  rotated in anti-clockwise direction (slow)
  6C0h  no rotation                         (stopped)
  6DAh  rotation in clockwise direction     (slow)
  73Ah  rotation in clockwise direction     (normal fast)
  9E3h  rotation in clockwise direction     (shock-speed)
</TD></TR></TABLE>
For detection, values 000h and FFFh would indicate that there's no sensor.<BR>
The Z-axis always points into same direction; no matter of frontloading or
backloading cartridge slots.<BR>
Thanks to Momo Vampire for contributing a Wario cartridge.<BR>
<BR>
<B>X/Y/Z-Axes</B><BR>
X-Axis and Y-Axis are meant to be following the screens X and Y coordinates, so
the Z-Axis would point into the screens depth direction.<BR>
<BR>
<B>DSi Cameras</B><BR>
DSi consoles can mis-use the built-in cameras as Gyro sensor (as done by the
System Flaw DSi game).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbacartrumble"></A>&nbsp;
  GBA Cart Rumble
</FONT></TD></TR></TABLE><BR>
Warioware Twisted (Rumble, plus Z-Axis Gyro Sensor)<BR>
Drill Dozer (Rumble only) &lt;-- and ALSO supports Gameboy Player rumble?<BR>
<BR>
GBA Rumble Carts are containing a small motor, which is causing some vibration
when/while it is switched on (that, unlike DS Rumble, which must be repeatedly
toggled on/off).<BR>
<BR>
In Warioware Twisted, rumble is controlled via GPIO.Bit3 (Data 0=Low=Off,
1=High=On) (and Direction 1=Output), the other GPIO Bits are used for the gyro
sensor.<BR>
<A HREF="#gbacartioportgpio">GBA Cart I/O Port (GPIO)</A><BR>
Note: GPIO3 is connected to an external pulldown resistor (so the HighZ level
gets dragged to Low=Off when direction is set to Input).<BR>
<BR>
Unknown if Drill Dozer is controlled via GPIO.Bit3, too?<BR>
<BR>
<B>DS Rumble Pak</B><BR>
Additionally, there's a Rumble Pak for the NDS, which connects to the GBA slot,
so it can be used also for GBA games (provided that the game doesn't require
the GBA slot, eg. GBA multiboot games).<BR>
<A HREF="#dscartrumblepak">DS Cart Rumble Pak</A><BR>
<BR>
<B>Gamecube Rumble</B><BR>
Moreover, GBA games that are running on a Gameboy Player are having access to
the Rumble function of Gamecube joypads.<BR>
<A HREF="#gbagameboyplayer">GBA Gameboy Player</A><BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbacartereader"></A>&nbsp;
  GBA Cart e-Reader
</FONT></TD></TR></TABLE><BR>
<A HREF="#gbacartereaderoverview">GBA Cart e-Reader Overview</A><BR>
<A HREF="#gbacartereaderioports">GBA Cart e-Reader I/O Ports</A><BR>
<A HREF="#gbacartereaderdotcodeformat">GBA Cart e-Reader Dotcode Format</A><BR>
<A HREF="#gbacartereaderdataformat">GBA Cart e-Reader Data Format</A><BR>
<A HREF="#gbacartereaderprogramcode">GBA Cart e-Reader Program Code</A><BR>
<A HREF="#gbacartereaderapifunctions">GBA Cart e-Reader API Functions</A><BR>
<A HREF="#gbacartereadervpkdecompression">GBA Cart e-Reader VPK Decompression</A><BR>
<A HREF="#gbacartereadererrorcorrection">GBA Cart e-Reader Error Correction</A><BR>
<A HREF="#gbacartereaderfileformats">GBA Cart e-Reader File Formats</A><BR>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
   ________________
  |   ShortStrip   |
  |L              L|
  |o    Center    o|
  |n    Region    n|
  |g              g|
  |  may contain   |
  |S   pictures,  S|
  |t instructions t|
  |r     etc.     r|
  |i              i|
  |p              p|
  |___ShortStrip___|
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbacartereaderoverview"></A>&nbsp;
  GBA Cart e-Reader Overview
</FONT></TD></TR></TABLE><BR>
The e-Reader is a large GBA cartridge (about as big as the GBA console), with
built-in dotcode scanning hardware. Dotcodes are tiny strips of black and white
pixels printed on the edges of cardboard cards. The cards have to be pulled
through a slot on the e-Reader, which is giving it a feeling like using a
magnet card reader. The binary data on the dotcodes contains small games,
either in native GBA code (ARM/THUMB), or in software emulated 8bit Z80 or
NES/Famicom (6502) code.<BR>
<BR>
<B>The e-Reader Hardware</B><BR>
The hardware consists of regular 8MByte ROM and 128KByte FLASH chips, two link
ports, a custom PGA chip, the camera module (with two red LEDs, used as light
source), and some analogue components for generating the LED voltages, etc. The
camera supports 402x302 pixels with 7bit monochrome color depth, but the PGA
clips it to max 320 pixels per scanline with 1bit color depth.<BR>
<BR>
<B>Link Port Plug/Socket</B><BR>
The e-Reader's two link ports are simply interconnected with each other;
without connection to the rest of the e-Reader hardware. These ports are used
only on the original GBA (where the large e-Reader cartridge would be covering
the GBA's link socket). When trying to insert the e-Reader into an original NDS
(or GBA-Micro), then the e-Reader's link plug will hit against the case of the
NDS, so it works only with some minor modification to the hardware. There's no
such problem with GBA-SP and NDS-Lite.<BR>
<BR>
<B>Region/Version</B><BR>
There are 3 different e-Reader's: Japanese/Original, Japanese/Plus, and
Non-Japanese. The Original version has only 64K FLASH, no Link Port, and
reportedly supports only Z80 code, but no NES/GBA code. The Plus and
Non-Japanese versions should be almost identical, except that they reject cards
from the wrong region, and that the title strings aren't ASCII in Japan, the
Plus version should be backwards compatible to the Original one.<BR>
<BR>
<B>The Problem</B><BR>
Nintendo's current programmers are definetly unable to squeeze a Pac-Man style
game into less than 4MBytes. Their solution has been: MORE memory. That is,
they've put a whopping 8MByte BIOS ROM into the e-Reader, which contains the
User Interface, and software emulation for running some of their 20 years old
8bit NES and Game&amp;Watch titles, which do fit on a few dotcode strips.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbacartereaderioports"></A>&nbsp;
  GBA Cart e-Reader I/O Ports
</FONT></TD></TR></TABLE><BR>
<B>DF80000h Useless Register (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Output to PGA.Pin93 (which seems to be not connected to anything)
  1-3   Unknown, read/write-able (not used by e-Reader BIOS)
  4-15  Always zero (0)
</TD></TR></TABLE>
<BR>
<B>DFA0000h Reset Register (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0    Always zero              (0)
  1    Reset Something?         (0=Normal, 1=Reset)
  2    Unknown, always set      (1)
  3    Unknown, read/write-able (not used by e-Reader BIOS)
  4-7  Always zero              (0)
  8    Unknown, read/write-able (not used by e-Reader BIOS)
  9-15 Always zero              (0)
</TD></TR></TABLE>
<BR>
<B>DFC0000h..DFC0027h Scanline Data (R)</B><BR>
Scanline data (40 bytes, for 320 pixels, 1bit per pixel, 0=black, 1=white).<BR>
The first (leftmost) pixel is located in the LSB of the LAST byte.<BR>
Port E00FFB1h.Bit1 (and [4000202h].Bit13) indicates when a new scanline is
present, the data should be then transferred to RAM via DMA3 (SAD=DFC0000h,
DAD=buf+y*28h, CNT=80000014h; a slower non-DMA transfer method would result in
missed scanlines). After the DMA, software must reset E00FFB1h.Bit1.<BR>
Note: The scanning resolution is 1000 DPI.<BR>
<BR>
<B>DFC0028h+(0..2Fh*2) Brightest Pixels of 8x6 Blocks (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-6  Max Brightness (00h..7Fh; 00h=All black, 7Fh=One or more white)
  7-15 Always zero
</TD></TR></TABLE>
Can be used to adjust the Port E00FF80h..E00FFAFh settings.<BR>
<BR>
<B>DFC0088h Darkest Pixel of whole Image (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-7  Max Darkness   (00h..7Fh; 00h=One or more black, 7Fh=All white)
  8-15 Always zero
</TD></TR></TABLE>
Can be used to adjust the Port E00FF80h..E00FFAFh settings.<BR>
<BR>
<B>E00FF80h..E00FFAFh Intensity Boundaries for 8x6 Blocks (R/W)</B><BR>
The 320x246 pixel camera input is split into 8x6 blocks (40x41 pixels each),
with Block00h=Upper-right, Block07h=Upper-left, ..., Block27h=Lower-left. The
boundary values for the separate blocks are used for 128-grayscale to 2-color
conversion, probably done like "IF Pixel&gt;Boundary THEN white ELSE black".<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-6  Block Intensity Boundaries (0..7Fh; 7Fh=Whole block gets black)
  7    Always zero
</TD></TR></TABLE>
The default boundary values are stored in FLASH memory, the values are
typically ranging from 28h (outer edges) to 34h (center image), that in respect
to the light source (the two LEDs are emitting more light to the center
region).<BR>
<BR>
<B>E00FFB0h Control Register 0 (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0    Serial Data       (Low/High)
  1    Serial Clock      (Low/High)
  2    Serial Direction  (0=Input, 1=Output)
  3    Led/Irq Enable    (0=Off, 1=On; Enable LED and Gamepak IRQ)
  4    Start Scan        (0=Off, 1=Start) (0-to-1 --&gt; Resync line 0)
  5    Phi 16MHz Output  (0=Off, 1=On; Enable Clock for Camera, and for LED)
  6    Power 3V Enable   (0=Off, 1=On; Enable 3V Supply for Camera)
  7    Not used          (always 0) (sometimes 1) (Read only)
</TD></TR></TABLE>
<BR>
<B>E00FFB1h Control Register 1 (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0    Not used          (always 0)
  1    Scanline Flag     (1=Scanline Received, 0=Acknowledge)
  2-3  Not used          (always 0)
  4    Strange Bit       (0=Normal, 1=Force Resync/Line0 on certain interval?)
  5    LED Anode Voltage (0=3.0V, 1=5.1V; requires E00FFB0h.Bit3+5 to be set)
  6    Not used          (always 0)
  7    Input from PGA.Pin22, always high (not used by e-Reader) (Read Only)
</TD></TR></TABLE>
Bit1 can be SET by hardware only, software can only RESET that bit, the Gamepak
IRQ flag (Port 4000202h.Bit13) becomes set on 0-to-1 transitions.<BR>
<BR>
<B>E00FFB2h Light Source LED Kathode Duration (LSB) (R/W)</B><BR>
<B>E00FFB3h Light Source LED Kathode Duration (MSB) (R/W)</B><BR>
Selects the LED Kathode=LOW Duration, aka the LED=ON Duration. That does act as
pulse width modulated LED brightness selection (the camera seems to react
slowly enough to view the light as being dimmed to medium, rather than seeing
the actual light ON and OFF states). The PWM timer seems to be clocked at 8MHz.
The hardware clips timer values 2000h..FFFFh to max 2000h (=1ms). Additionally,
the e-Reader BIOS clips values to max 11B3h. Default setting is found in FLASH
calibration data. A value of 0000h disables the LED.<BR>
<BR>
<B>Serial Port Registers (Camera Type 1) (DV488800) (calib_data[3Ch]=1)</B><BR>
All 16bit values are ordered MSB,LSB. All registers are whole 8bit
Read/Write-able, except 00h,57h-5Ah (read only), and 53h-55h (2bit only).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Port     Expl.               (e-Reader Setting)
  00h      Maybe Chip ID (12h) (not used by e-Reader BIOS) (Read Only)
  01h                          (05h)    ;-Bit0: 1=auto-repeat scanning?
  02h                          (0Eh)
  10h-11h  Vertical Scroll     (calib_data[30h]+7)
  12h-13h  Horizontal Scroll   (0030h)
  14h-15h  Vertical Size       (00F6h=246)
  16h-17h  Horizontal Size     (0140h=320)
  20h-21h  H-Blank Duration    (00C4h)
  22h-23h                      (0400h)  ;-Upper-Blanking in dot-clock units?
  25h                          (var)    ;-bit1: 0=enable [57h..5Ah] ?
  26h                          (var)    ;\maybe a 16bit value
  27h                          (var)    ;/
  28h                          (00h)
  30h      Brightness/contrast (calib_data[31h]+/-nn)
  31h-33h                      (014h,014h,014h)
  34h      Brightness/contrast (02h)
  50h-52h  8bit Read/Write     (not used by e-Reader BIOS)
  53h-55h  2bit Read/Write     (not used by e-Reader BIOS)
  56h      8bit Read/Write     (not used by e-Reader BIOS)
  57h-58h  16bit value, used to autodetect/adjust register[30h] (Read Only)
  59h-5Ah  16bit value, used to autodetect/adjust register[30h] (Read Only)
  80h-FFh  Mirrors of 00h..7Fh (not used by e-Reader BIOS)
</TD></TR></TABLE>
All other ports are unused, writes to those ports are ignored, and reads are
returning data mirrored from other ports; that is typically data from 2 or more
ports, ORed together.<BR>
<BR>
<B>Serial Port Registers (Camera Type 2) (calib_data[3Ch]=2)</B><BR>
All 16bit values are using more conventional LSB,MSB ordering, and port numbers
are arranged in a more reasonable way. The e-Reader BIOS doesn't support (or
doesn't require) brightness adjustment for this camera module.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Port     Expl.             (e-Reader Setting)
  00h                        (22h)
  01h                        (50h)
  02h-03h  Vertical Scroll   (calib_data[30h]+28h)
  04h-05h  Horizontal Scroll (001Eh)
  06h-07h  Vertical Size     (00F6h)    ;=246
  08h-09h  Horizontal Size   (0140h)    ;=320
  0Ah-0Ch                    (not used by e-Reader BIOS)
  0Dh                        (01h)
  0Eh-0Fh                    (01EAh)    ;=245*2
  10h-11h                    (00F5h)    ;=245
  12h-13h                    (20h,F0h)  ;maybe min/max values?
  14h-15h                    (31h,C0h)  ;maybe min/max values?
  16h                        (00h)
  17h-18h                    (77h,77h)
  19h-1Ch                    (30h,30h,30h,30h)
  1Dh-20h                    (80h,80h,80h,80h)
  21h-FFh                    (not used by e-Reader BIOS)
</TD></TR></TABLE>
This appears to be a Micron (aka Aptina) camera (resembling the DSi cameras).<BR>
My own e-Reader uses a Type 1 camera module. Not sure if Nintendo has ever
manufactured any e-Readers with Type 2 cameras?<BR>
<BR>
<B>Calibration Data in FLASH Memory (Bank 0, Sector 0Dh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  E00D000 14h  ID String ('Card-E Reader 2001',0,0)
  E00D014 2    Sector Checksum (NOT(x+x/10000h); x=sum of all other halfwords)
</TD></TR></TABLE>
Begin of actual data (40h bytes)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  E00D016 8x6  [00h] Intensity Boundaries for 8x6 blocks ;see E00FF80h..AFh
  E00D046 1    [30h] Vertical scroll (0..36h)  ;see type1.reg10h/type2.reg02h
  E00D047 1    [31h] Brightness or contrast    ;see type1.reg30h
  E00D048 2    [32h] LED Duration              ;see E00FFB2h..B3h
  E00D04A 2    [34h] Not used?   (0000h)
  E00D04C 2    [36h] Signed value, related to adjusting the 8x6 blocks
  E00D04E 4    [38h] Not used?   (00000077h)
  E00D052 4    [3Ch] Camera Type (0=none,1=DV488800,2=Whatever?)
</TD></TR></TABLE>
Remaining bytes in this Sector...<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  E00D056 FAAh Not used (zerofilled) (included in above checksum)
</TD></TR></TABLE>
<BR>
<B>Flowchart for Overall Camera Access</B><BR>
ereader_scan_camera:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 call ereader_power_on
 call ereader_initialize
 for z=1 to number_of_frames
  for y=0 to 245
   Wait until E00FFB1h.Bit1 gets set by hardware (can be handled by IRQ)
   Copy 14h halfwords from DFC0000h to buf+y*28h via DMA3
   Reset E00FFB1h.Bit1 by software
  next y
  ;(could now check DFC0028h..DFC0086h/DFC0088h for adjusting E00FF00h..2Fh)
  ;(could now show image on screen, that may require to stop/pause scanning)
 next z
 call ereader_power_off
 Ret
</TD></TR></TABLE>
ereader_power_on:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 [4000204h]=5803h   ;Init waitstates, and enable Phi 16MHz
 [DFA0000h].Bit1=1
 Wait(10ms)
 [E00FFB0h]=40h     ;Enable Power3V and reset other bits
 [DFA0000h].Bit1=0
 [E00FFB1h]=20h     ;Enable Power5V and reset other bits
 Wait(40ms)
 [E00FFB1h].Bit4=0  ;...should be already 0 ?
 [E00FFB0h]=40h+27h ;Phi16MHz=On, SioDtaClkDir=HighHighOut
 Ret
</TD></TR></TABLE>
ereader_power_off:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 [E00FFB0h]=04h    ;Power3V=Off, Disable Everything, SioDtaClkDir=LowLowOut
 [DFA0000h].Bit1=0 ;...should be already 0
 [E00FFB1h].Bit5=0 ;Power5V=Off
 Ret
</TD></TR></TABLE>
ereader_initialize:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 IF calib_data[3Ch] AND 03h = 1 THEN init_camera_type1
 [E00FFB0h].Bit4=1 ;ScanStart
 IF calib_data[3Ch] AND 03h = 2 THEN init_camera_type2
 Copy calib_data[00h..2Fh] to [E00FF80h+00h..2Fh]  ;Intensity Boundaries
 Copy calib_data[32h..33h] to [E00FFB2h+00h..01h]  ;LED Duration LSB,MSB
 [E00FFB0h].Bit3=1                                 ;LedIrqOn
 Ret
</TD></TR></TABLE>
init_camera_type1:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 x=MIN(0,calib_data[31h]-0Bh)
 Set Sio Registers (as shown for Camera Type 1, except below values...)
 Set Sio Registers [30h]=x [25h]=04h, [26h]=58h, [27h]=6Ch
 ;(could now detect/adjust &lt;x&gt; based on Sio Registers [57h..5Ah])
 Set Sio Registers [30h]=x [25h]=06h, [26h]=E8h, [27h]=6Ch
 Ret
</TD></TR></TABLE>
init_camera_type2:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 Wait(0.5ms)
 Set Sio Registers (as shown for Camera Type 2)
 Ret
</TD></TR></TABLE>
<BR>
<B>Accessing Serial Registers via E00FFB0h</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
      Begin   Write(A) Write(B) Read(C) Read(D) End     Idle    PwrOff
  Dir ooooooo ooooooo  ooooooo  iiiiiii iiiiiii ooooooo ooooooo ooooooo
  Dta ---____ AAAAAAA  BBBBBBB  xxxxxCx xxxxxDx ______- ------- _______
  Clk ------_ ___---_  ___---_  ___---_ ___---_ ___---- ------- _______
</TD></TR></TABLE>
<BR>
<B>Flowchart for accessing Serial Registers via E00FFB0h (looks like I2C bus)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 Delay:
  Wait circa 2.5us, Ret
 SioBegin:
  SioDta=1, SioDir=Out, SioClk=1, Delay, SioDta=0, Delay, SioClk=0, Ret
 SioEnd:
  SioDta=0, SioDir=Out, Delay, SioClk=1, Delay, SioDta=1, Ret
 SioRead1bit:   ;out: databit
  SioDir=In, Delay, SioClk=1, Delay, databit=SioDta, SioClk=0, Ret
 SioWrite1bit:  ;in: databit
  SioDta=databit, SioDir=Out, Delay, SioClk=1, Delay, SioClk=0, Ret
 SioReadByte:   ;in: endflag - out: data
  for i=7 to 0, data.bit&lt;i&gt;=SioRead1bit, next i, SioWrite1bit(endflag), Ret
 SioWriteByte:  ;in: data - out: errorflag
  for i=7 to 0, Delay(huh/why?), SioWrite1bit(data.bit&lt;i&gt;), next i
  errorflag=SioRead1bit, SioDir=Out(huh/why?), Ret
 SioWriteRegisters:  ;in: index, len, buffer
  SioBegin
  SioWriteByte(22h)        ;command (set_index) (and write_data)
  SioWriteByte(index)      ;index
  for i=0 to len-1
   SioWriteByte(buffer[i]) ;write data (and auto-increment index)
  next
  SioEnd
  ret
 SioReadRegisters:   ;in: index, len - out: buffer
  SioBegin
  SioWriteByte(22h)        ;command (set_index) (without any write_data here)
  SioWriteByte(index)      ;index
  SioBegin
  SioWriteByte(23h)        ;command (read_data) (using above index)
  for i=0 to len-1
   if i=len-1 then endflag=1 else endflag=0
   buffer[i]=SioReadByte(endflag)  ;read data (and auto-increment index)
  next
  SioEnd
  Ret
</TD></TR></TABLE>
Caution: Accessing the SIO registers appears highly unstable, and seems to
require error handling with retries. Not sure what is causing that problem,
possibly the registers cannot be accessed during camera-data-scans...?<BR>
<BR>
<B>WAITCNT</B><BR>
The e-Reader BIOS uses WAITCNT [4000204h]=5803h when accessing the PGA, that
is, gamepak 16.78MHz phi output (bit11-12=3), 8 waits for SRAM region
(bit0-1=3), gamepak prefetch enabled (bit14=1), also sets WS0 to 4,2 waits
(bit2-4=0), and sets WS2 to odd 4,8 waits (bit8-10=0). The WS2 (probably WS0
too) settings are nonsense, and should work with faster timings (the e-Reader
can be accessed in NDS mode, which doesn't support that slow timings).<BR>
<BR>
<B>e-Reader Memory and I/O Map (with all used/unused/mirrored regions)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  C000000h-C7FFFFFh  ROM (8MB)
  C800000h-DF7FFFFh  Open Bus
  DF80000h-DF80001h  Useless Register (R/W)
  DF80002h-DF9FFFFh  Mirrors of DF80000h-DF80001h
  DFA0000h-DFA0001h  Reset Register (R/W)
  DFA0002h-DFBFFFFh  Mirrors of DFA0000h-DFA0001h
  DFC0000h-DFC0027h  Scanline Data (320 Pixels) (R)
  DFC0028h-DFC0087h  Brightest Pixels of 8x6 Blocks (R)
  DFC0088h           Darkest Pixel of whole Image (R)
  DFC0089h-DFC00FFh  Always zero
  DFC0100h-DFDFFFFh  Mirrors of DFC0000h-DFC00FFh
  DFE0000h-DFFFFFFh  Open Bus
  E000000h-E00CFFFh  FLASH Bank 0 - Data
  E00D000h-E00DFFFh  FLASH Bank 0 - Calibration Data
  E00E000h-E00EFFFh  FLASH Bank 0 - Copy of Calibration Data
  E00F000h-E00FF7Fh  FLASH Bank 0 - Unused region
  E000000h-E00EFFFh  FLASH Bank 1 - Data
  E00F000h-E00FF7Fh  FLASH Bank 1 - Unused region
  E00FF80h-E00FFAFh  Intensity Boundaries for 8x6 Blocks (R/W)
  E00FFB0h           Control Register 0 (R/W)
  E00FFB1h           Control Register 1 (R/W)
  E00FFB2h-E00FFB3h  LED Duration (16bit) (R/W)
  E00FFB4h-E00FFBFh  Always zero
  E00FFC0h-E00FFFFh  Mirror of E00FF80h-E00FFBFh
</TD></TR></TABLE>
Mind that WS2 should be accessed by LDRH/STRH, and SRAM region by LDRB/STRB.<BR>
Additionally about 32 serial bus registers are contained in the camera module.<BR>
<BR>
<B>Camera Module Notes</B><BR>
The Type 1 initial setting on power-on is 402x302 pixels, the e-Reader uses
only 320x246 pixels. The full vertical resolution could be probably used
without problems. Port DFC0000h-DFC0027h are restricted to 320 pixels, so
larger horizontal resolutions could be probably obtained only by changing the
horizontal scroll offset on each 2nd scan.<BR>
The camera output is 128 grayscales (via parallel 7bit databus), but the PGA
converts it to 2 colors (1bit depth). For still images, it might be possible to
get 4 grayshades via 3 scans with different block intensity boundary settings.<BR>
No idea if the camera supports serial commands other than 22h and 23h. Namely,
it &lt;would&gt; be a quite obvious and basic feature to allow to receive the
bitmap via the 2-wire serial bus (alternately to the 7bit databus), if
supported, it'd allow to get 7bit images, bypassing 1bit PGA conversion.<BR>
When used as actual camera (by cutting an opening in the case), the main
problem is the 1bit color depth, which allows only black and white schemes,
when/if solving that problem, focusing might be also a problem.<BR>
<BR>
Either the camera or the PGA seem to have a problem on white-to-black
transitions in vertical direction, the upper some black pixels are sorts of
getting striped or dithered. For example, scanning the large sync marks appears
as:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Actual Shape    Scanned Shape
     XXXXX            X  X
    XXXXXXX           X  X X
   XXXXXXXXX        X X  X XX
   XXXXXXXXX        X X  X XX
    XXXXXXX          XXXXXXX
     XXXXX            XXXXX
</TD></TR></TABLE>
That appears only on large black shapes (the smaller data dots look better).
Probably the image is scanned from bottom upwards (and the camera senses only
the initial transition at the bottom, and then looses track of what it is
doing).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbacartereaderdotcodeformat"></A>&nbsp;
  GBA Cart e-Reader Dotcode Format
</FONT></TD></TR></TABLE><BR>
Resolution is 342.39 DPI (almost 10 blocks per inch).<BR>
Resolution is 134.8 dots/cm (almost 4 blocks per centimeter).<BR>
The width and height of each block, and the spacing to the bottom edge of the
card is ca. 1/10 inch, or ca. 4 millimeters.<BR>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
   XXX            BLOCK 1             XXX            BLOCK 2             XXX
  XXXXX                              XXXXX                              XXXXX
  XXXXX   X X X X X X  X X X X X X   XXXXX   X X X X X X  X X X X X X   XXXXX
  XXXXX                              XXXXX                              XXXXX
   XXX   HHHHHHHHHHHHHHHHHHHH......   XXX   HHHHHHHHHHHHHHHHHHHH......   XXX
         ..........................         ..........................
         ...... 3 short lines .....         ..........................
    A..................................A..................................A..
    A....      26 long lines       ....A........ X = Sync Marks   ........A..
    A....  (each 34 data dots)     ....A........ H = Block Header ........A..
    A....(not all lines shown here)....A........ . = Data Bits    ........A..
    A..................................A........ A = Address Bits ........A..
         ...... 3 short lines .....         ..........................
         ...(each 26 data dots)....         ..........................
   XXX   ..........................   XXX   ..........................   XXX
  XXXXX                              XXXXX                              XXXXX
  XXXXX   X X X X X X  X X X X X X   XXXXX   X X X X X X  X X X X X X   XXXXX
  XXXXX                              XXXXX                              XXXXX
   XXX                                XXX                                XXX
             &lt;ca. 35 blank lines&gt;
  ___Snip____________________________________________________________________
</TD></TR></TABLE>
<BR>
<B>Address Columns</B><BR>
Each Column consists of 26 dots. From top to bottom: 1 black dot, 8 blank dots,
16 address dots (MSB topmost), and 1 blank dot. The 16bit address values can be
calculated as:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  addr[0] = 03FFh
  for i = 1 to 53
    addr[i] = addr[i-1] xor ((i and (-i)) * 769h)
    if (i and 07h)=0 then addr[i] = addr[i] xor (769h)
    if (i and 0Fh)=0 then addr[i] = addr[i] xor (769h*2)
    if (i and 1Fh)=0 then addr[i] = addr[i] xor (769h*4) xor (769h)
  next i
</TD></TR></TABLE>
Short strips use addr[1..19], long strips use addr[25..53], left to right.<BR>
<BR>
<B>Block Header</B><BR>
The 18h-byte Block Header is taken from the 1st two bytes (20 dots) of the 1st
0Ch blocks (and is then repeated in the 1st two bytes of further blocks).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h      Unknown              (00h)
  01h      Dotcode type         (02h=Short, 03h=Long)
  02h      Unknown              (00h)
  03h      Address of 1st Block (01h=Short, 19h=Long)
  04h      Total Fragment Size  (40h) ;64 bytes per fragment, of which,
                                      ;48 bytes are actual data, the remaining
  05h      Error-Info Size      (10h) ;16 bytes are error-info
  06h      Unknown              (00h)
  07h      Interleave Value     (1Ch=Short, 2Ch=Long)
  08h..17h 16 bytes Reed-solomon error correction info for Block Header
</TD></TR></TABLE>
<BR>
<B>Data 4-Bit to 5-bit Conversion</B><BR>
In the Block Header (HHHHH), and Data Region (.....), each 4bit are expanded to
5bit, so one byte occupies 10 dots, and each block (1040 data dots) contains
104 bytes.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4bit  00h 01h 02h 03h 04h 05h 06h 07h 08h 09h 0Ah 0Bh 0Ch 0Dh 0Eh 0Fh
  5bit  00h 01h 02h 12h 04h 05h 06h 16h 08h 09h 0Ah 14h 0Ch 0Dh 11h 10h
</TD></TR></TABLE>
That formatting ensures that there are no more than two continous black dots
(in horizontal direction), neither inside of a 5bit value, nor between two 5bit
values, however, the address bars are violating that rule, and up to 5
continous black dots can appear at the (..A..) block boundaries.<BR>
<BR>
<B>Data Order</B><BR>
Data starts with the upper bit of the 5bit value for the upper 4bit of the
first byte, which is located at the leftmost dot of the upper line of the
leftmost block, it does then extend towards rightmost dot of that block, and
does then continue in the next line, until reaching the bottom of the block,
and does then continue in the next block. The 1st two bytes of each block
contain a portion of the Block Header, the remaining 102 bytes in each block
contain data.<BR>
<BR>
<B>Data Size</B><BR>
A long strip consists of 28 blocks (28*104 = 2912 bytes), a short strip of 18
blocks (18*104 = 1872 bytes). Of which, less than 75% can be actually used for
program code, the remaing data contains error correction info, and various
headers. See Data Format for more info.<BR>
<BR>
<B>Interleaved Fragments</B><BR>
The Interleave Value (I) specifies the number of fragments, and does also
specify the step to the next byte inside of a fragment; except that, at the
block boundaries (every 104 bytes), the step is 2 bigger (for skipping the next
two Block Header bytes).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  RAW Offset  Content
  000h..001h  1st 2 bytes of RAW Header
  002h        1st byte of 1st fragment
  003h        1st byte of 2nd fragment
  ...         ...
  002h+I-1    1st byte of last fragment
  002h+I      2nd byte of 1st fragment
  003h+I      2nd byte of 2nd fragment
  ...         ...
  002h+I*2-1  2nd byte of last fragment
  ...         ...
</TD></TR></TABLE>
Each fragment consists of 48 actual data bytes, followed by 16 error correction
bytes, followed by 0..2 unused bytes (since I*40h doesn't exactly match
num_blocks*102).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbacartereaderdataformat"></A>&nbsp;
  GBA Cart e-Reader Data Format
</FONT></TD></TR></TABLE><BR>
<B>Data Strip Format</B><BR>
The size of the data region is I*48 bytes (I=Interleave Value, see Dotcode
Format), the first 48-byte fragment contains the Data Header, the remaining
(I-1) fragments are Data Fragments (which contain title(s), and VPK compressed
program code).<BR>
<BR>
<B>First Strip</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Data Header  (48 bytes)
  Main-Title   (17 bytes, or 33 bytes)
  Sub-Title(s) (3+18 bytes, or 33 bytes) (for each strip) (optional)
  VPK Size     (2 byte value, total length of VPK Data in ALL strips)
  NULL Value   (4 bytes, contained ONLY in 1st strip of GBA strips)
  VPK Data     (length as defined in VPK Size entry, see above)
</TD></TR></TABLE>
<BR>
<B>Further Strip(s)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Data Header  (48 bytes)
  Main-Title   (17 bytes, or 33 bytes)
  Sub-Title(s) (3+18 bytes, or 33 bytes) (for each strip) (optional)
  VPK Data     (continued from previous strip)
</TD></TR></TABLE>
<BR>
<B>Data Header (30h bytes) (1st fragment)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h-01h  Fixed         (00h,30h)
  02h      Fixed         (01h)     ;01h="Do not calculate Global Checksum" ?
  03h      Primary Type  (see below)
  04h-05h  Fixed         (00h,01h) (don't care)
  06h-07h  Strip Size    (0510h=Short, 0810h=Long Strip) ((I-1)*30h) (MSB,LSB)
  08h-0Bh  Fixed         (00h,00h,10h,12h)
  0Ch-0Dh  Region/Type   (see below)
  0Eh      Strip Type    (02h=Short Strip, 01h=Long Strip) (don't care)
  0Fh      Fixed         (00h) (don't care)
  10h-11h  Unknown       (whatever) (don't care)
  12h      Fixed         (10h)     ;10h="Do calculate Data Checksum" ?
  13h-14h  Data Checksum (see below) (MSB,LSB)
  15h-19h  Fixed         (19h,00h,00h,00h,08h)
  1Ah-21h  ID String     ('NINTENDO')
  22h-25h  Fixed         (00h,22h,00h,09h)
  26h-29h  Size Info     (see below)
  2Ah-2Dh  Flags         (see below)
  2Eh      Header Checksum (entries [0Ch-0Dh,10h-11h,26h-2Dh] XORed together)
  2Fh      Global Checksum (see below)
</TD></TR></TABLE>
Primary Type [03h] is 8bit,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0      Card Type (upper bit) (see below)
  1      Unknown (usually opposite of Bit0) (don't care)
  2-7    Unknown (usually zero)
</TD></TR></TABLE>
Region/Type [0Ch..0Dh] is 16bit,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-3    Unknown (don't care)
  4-7    Card Type (lower bits) (see below)
  8-11   Region/Version (0=Japan/Original, 1=Non-japan, 2=Japan/Plus)
  12-15  Unknown (don't care)
</TD></TR></TABLE>
Size Info [26h-29h] is 32bit,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0      Unknown            (don't care)
  1-4    Strip Number       (01h..Number of strips)
  5-8    Number of Strips   (01h..0Ch) (01h..08h for Japan/Original version)
  9-23   Size of all Strips (excluding Headers and Main/Sub-Titles)
         (same as "VPK Size", but also including the 2-byte "VPK Size" value,
         plus the 4-byte NULL value; if it is present)
  24-31  Fixed              (02h) (don't care)
</TD></TR></TABLE>
Flags [2Ah-2Dh] is 32bit,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0      Permission to save (0=Start Immediately, 1=Prompt for FLASH Saving)
  1      Sub-Title Flag     (0=Yes, 1=None)    (Japan/Original: always 0=Yes)
  2      Application Type   (0=GBA/Z80, 1=NES) (Japan/Original: always 0=Z80)
  3-31   Zero (0) (don't care)
</TD></TR></TABLE>
Data Checksum [13h-14h] is the complement (NOT) of the sum of all halfwords in
all Data Fragments, however, it's all done in reversed byte order: checksum is
calculated with halfwords that are read in MSB,LSB order, and the resulting
checksum is stored in MSB,LSB order in the Header Fragment.<BR>
Global Checksum [2Fh] is the complement (NOT) of the sum of the first 2Fh bytes
in the Data Header plus the sum of all Data Fragment checksums; the Data
Fragment checksums are all 30h bytes in a fragment XORed with each other.<BR>
<BR>
<B>Titles (3+N bytes, or N bytes)</B><BR>
Titles can be 33 bytes for both Main and Sub (Format 0Eh), or Main=17 bytes and
Sub=3+18 bytes (Formats 02h..05h). In the 3+N bytes form, the first 3 bytes
(24bit) are are used to display "stats" information in form of "HP: h1 ID:
i1-i2-i3", defined as:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit    Expl.
  0-3    h1, values 1..15 shown as "10..150", value 0 is not displayed
  4-6    i3, values 0..7 shown as "A..G,#"
  7-13   i2, values 0..98 shown as "01..99" values 99..127 as "A0..C8"
  14-18  i1, values 0..31 shown as "A..Z,-,_,{HP},.,{ID?},:"
  19-22  Unknown
  23     Disable stats (0=Show as "HP: h1 ID: i1-i2-i3", 1=Don't show it)
</TD></TR></TABLE>
The N bytes portion contains the actual title, which must be terminated by 00h
(so the max length is N-1 characters, if it is shorter than N-1, then the
unused bytes are padded by further 00h's). The character set is normal ASCII
for non-Japan (see Region/Version entry in header), and 2-byte SHIFT-JIS for
Japanese long-titles (=max 16 2-byte chars) with values as so:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h          --&gt; end-byte
  81h,40h      --&gt; SPC
  81h,43h..97h --&gt; punctuation marks
  82h,4Fh..58h --&gt; "0..9"
  82h,60h..79h --&gt; "A..Z"
  82h,81h..9Ah --&gt; "a..z"
</TD></TR></TABLE>
And 1-byte chars for Japanese short-titles,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00     = end-byte
  01     = spc
  02..0B = 0..9
  0C..AF = japanese
  B0..B4 = dash, male, female, comma, round-dot
  B5..C0 = !"%&amp;~?/+-:.'
  C1..DA = A..Z
  DB..DF = unused (blank)
  E0..E5 = japanese
  E6..FF = a..z
  N/A    = #$()*;&lt;=&gt;@[\]^_`{|}
</TD></TR></TABLE>
Additionally to the Main-Title, optional Sub-Titles for each strip can be
included (see Sub-Title Flag in header). If enabled, then ALL strip titles are
included in each strip (allowing to show a preview of which strips have/haven't
been scanned yet).<BR>
The e-Reader can display maximum of 8 sub-titles, if the data consists of more
than 8 strips, then sub-titles aren't displayed (so it'd be waste of space to
include them in the dotcodes).<BR>
The Main Title gets clipped to 128 pixels width (that are, circa 22
characters), and, the e-Reader BIOS acts confused on multi-strip games with
Main Titles longer than 26 characters (so the full 33 bytes may be used only in
Japan; with 16bit charset).<BR>
If the title is empty (00h-filled), and there is only one card in the
application, then the application is started immediately. That, without
allowing the user to save it in FLASH memory.<BR>
Caution: Although shorter Titles do save memory, they do act unpleasant: the
text "(C) P-Letter" will be displayed at the bottom of the loading screen.<BR>
On Japanese/Original, 8bit sub-titles can be up to 18 characters (without any
end-byte) (or less when stats are enabled, due to limited screen width).<BR>
<BR>
<B>Card Types (Primary Type.Bit0 and Region/Type.Bit12-15)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h..01h  Blank Screen (?)
  02h..03h  Dotcode Application with 17byte-title, with stats, load music A
  04h..05h  Dotcode Application with 17byte-title, with stats, load music B
  06h..07h  P-Letter Attacks
  08h..09h  Construction Escape
  0Ah..0Bh  Construction Action
  0Ch..0Dh  Construction Melody Box
  0Eh       Dotcode Application with 33byte-title, without stats, load music A
  0Fh       Game specific cards
  10h..1Dh  P-Letter Viewer
  1Eh..1Fh  Same as 0Eh and 0Fh (see above)
</TD></TR></TABLE>
The 'Application' types are meant to be executable GBA/Z80/NES programs.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbacartereaderprogramcode"></A>&nbsp;
  GBA Cart e-Reader Program Code
</FONT></TD></TR></TABLE><BR>
The GBA/Z80/NES program code is stored in the VPK compressed area.<BR>
NES-type is indicated by header [2Ah].Bit2, GBA-type is indicated by the NULL
value inserted between VPK Size and VPK Data, otherwise Z80-type is used.<BR>
<BR>
<B>GBA Format</B><BR>
Load Address and Entrypoint are at 2000000h (in ARM state). The 32bit word at
2000008h is eventually destroyed by the e-Reader. Namely,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  IF e-Reader is Non-Japanese,
  AND [2000008h] is outside of range of 2000000h..20000E3h,
  AND only if booted from camera (not when booted from FLASH?),
  THEN [2000008h]=[2000008h]-0001610Ch ELSE [2000008h] kept intact
</TD></TR></TABLE>
Existing multiboot-able GBA binaries can be converted to e-Reader format by,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Store "B 20000C0h" at 2000000h   ;redirect to RAM-entrypoint
  Zerofill 2000004h..20000BFh      ;erase header (for better compression rate)
  Store 01h,01h at 20000C4h        ;indicate RAM boot
</TD></TR></TABLE>
The GBA code has full access to the GBA hardware, and may additionally use
whatever API functions contained in the e-Reader BIOS. With the incoming LR
register value, "mov r0,N, bx lr" returns to the e-Reader BIOS (with N being
0=Restart, or 2=To_Menu). No idea if it's necessary to preserve portions of RAM
when returning to the e-Reader BIOS?<BR>
Caution: Unlike for normal GBA cartridges/multiboot files, the hardware is left
uninitialized when booting dotcodes (among others: sound DMA is active, and
brightness is set to zero), use "mov r0,0feh, swi 010000h" to get the normal
settings.<BR>
<BR>
<B>NES Format</B><BR>
Emulates a NES (Nintendo Entertainment System) console (aka Family Computer).<BR>
The visible 240x224 pixel NES/NTSC screen resolution is resampled to 240x160 to
match the smaller vertical resolution of the GBA hardware. So, writing e-Reader
games in NES format will result in blurred screen output. The
screen/sound/joypad is accessed via emulated NES I/O ports, program code is
running on an emulated 6502 8bit CPU, for more info on the NES hardware, see
no$nes debugger specifications, or<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  http://problemkaputt.de/everynes.htm
</TD></TR></TABLE>
The e-Reader's NES emulator supports only 16K PRG ROM, followed by 8K VROM. The
emulation accuracy is very low, barely working with some of Nintendo's own NES
titles; running the no$nes diagnostics program on it has successfully failed on
ALL hardware tests ;-)<BR>
The load address for the 16K PRG-ROM is C000h, the 16bit NMI vector at [FFFAh]
is encrypted like so:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  for i=17h to 0
   for j=07h to 0, nmi = nmi shr 1, if carry then nmi = nmi xor 8646h, next j
   nmi = nmi xor (byte[dmca_data+i] shl 8)
  next i
  dmca_data: db 0,0,'DMCA NINTENDO E-READER'
</TD></TR></TABLE>
The 16bit reset vector at [FFFCh] contains:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-14  Lower bits of Entrypoint (0..7FFFh = Address 8000h..FFFFh)
  Bit15    Nametable Mode (0=Vertical Mirroring, 1=Horizontal Mirroring)
</TD></TR></TABLE>
reportedly,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
   (NES limitations, 1 16K program rom + 1-2 8K CHR rom, mapper 0 and 1)
   ines mapper 1 would be MMC1, rather than CNROM (ines mapper 3)?
   but, there are more or less NONE games that have 16K PRG ROM + 16K VROM?
</TD></TR></TABLE>
The L+R Button key-combination allows to reset the NES, however, there seems to
be no way to return to the e-Reader BIOS.<BR>
<BR>
<B>Z80/8080 Format</B><BR>
The e-Reader doesn't support the following Z80 opcodes:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  CB [Prefix]     E0 RET PO   E2 JP PO,nn   E4 CALL PO,nn   27 DAA    76 HALT
  ED [Prefix]     E8 RET PE   EA JP PE,nn   EC CALL PE,nn   D3 OUT (n),A
  DD [IX Prefix]  F3 DI       08 EX AF,AF'  F4 CALL P,nn    DB IN A,(n)
  FD [IY Prefix]  FB EI       D9 EXX        FC CALL M,nn    xx RST 00h..38h
</TD></TR></TABLE>
That is leaving not more than six supported Z80 opcodes (DJNZ, JR, JR
c/nc/z/nz), everything else are 8080 opcodes. Custom opcodes are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  76 WAIT A frames, D3 WAIT n frames, and C7/CF RST 0/8 used for API calls.
</TD></TR></TABLE>
The load address and entrypoint are at 0100h in the emulated Z80 address space.
The Z80 doesn't have direct access to the GBA hardware, instead
video/sound/joypad are accessed via API functions, invoked via RST 0 and RST 8
opcodes, followed by an 8bit data byte, and with parameters in the Z80 CPU
registers. For example, "ld a,02h, rst 8, db 00h" does return to the e-Reader
BIOS.<BR>
The Z80/8080 emulation is incredibly inefficient, written in HLL code,
developed by somebody whom knew nothing about emulation nor about ARM nor about
Z80/8080 processors.<BR>
<BR>
<B>Running GBA-code on Japanese/Original e-Reader</B><BR>
Original e-Reader supports Z80 code only, but can be tweaked to run GBA-code:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  retry:
   ld bc,data // ld hl,00c8h      ;src/dst
  lop:
   ld a,[bc] // inc bc // ld e,a  ;lsb
   ld a,[bc] // inc bc // ld d,a  ;msb
   dw 0bcfh ;aka rst 8 // db 0bh  ;[4000000h+hl]=de (DMA registers)
   inc hl // inc  hl // ld a,l
   cp a,0dch // jr nz,lop
  mod1 equ $+1
   dw 37cfh ;aka rst 8 // db 37h  ;bx 3E700F0h
  ;below executed only on jap/plus... on jap/plus, above 37cfh is hl=[400010Ch]
   ld a,3Ah // ld [mod1],a                  ;bx 3E700F0h (3Ah instead 37h)
   ld hl,1 // ld [mod2],hl // ld [mod3],hl  ;base (0200010Ch instead 0201610Ch)
   jr retry
  data:
  mod2 equ $+1
   dd loader         ;40000C8h dma2sad (loader)            ;\
   dd 030000F0h      ;40000CCh dma2dad (mirrored 3E700F0h) ; relocate loader
   dd 8000000ah      ;40000D0h dma2cnt (copy 0Ah x 16bit)  ;/
  mod3 equ $+1
   dd main           ;40000D4h dma3sad (main)              ;\prepare main reloc
   dd 02000000h      ;40000D8h dma3dad (2000000h)          ;/dma3cnt see loader
   .align 2          ;alignment for 16bit-halfword
  org $+201600ch     ;jap/plus: adjusted to org $+200000ch
  loader:
   mov r0,80000000h  ;(dma3cnt, copy 10000h x 16bit)
   mov r1,04000000h  ;i/o base
   strb r1,[r1,208h] ;ime=0 (better disable ime before moving ram)
   str r0,[r1,0DCh]  ;dma3cnt (relocate to 2000000h)
   mov r15,2000000h  ;start relocated code at 2000000h in ARM state
  main:
   ;...insert/append whatever ARM code here...
   end
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbacartereaderapifunctions"></A>&nbsp;
  GBA Cart e-Reader API Functions
</FONT></TD></TR></TABLE><BR>
<B>Z80 Interface (Special Opcodes)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  db 76h       ;Wait8bit A
  db D3h,xxh   ;Wait8bit xxh
  db C7h,xxh   ;RST0_xxh
  db CFh,xxh   ;RST8_xxh
  ld r,[00xxh]       ;get system values (addresses differ on jap/ori)
  ld r,[00C2h..C3h]  ;GetKeyStateSticky (jap/ori: 9F02h..9F03h)
  ld r,[00C4h..C5h]  ;GetKeyStateRaw    (jap/ori: 9F04h..9F05h)
  ld r,[00C0h..C1h]  ;see Exit and ExitRestart
  ld r,[00D0h..D3h]  ;see Mul16bit
</TD></TR></TABLE>
For jap/ori, 9Fxxh isn't forwards compatible with jap/plus, so it'd be better
to check joypad via IoRead.<BR>
<BR>
<B>GBA Interface</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  bx [30075FCh] ;ApiVector ;in: r0=func_no,r1,r2,r3,[sp+0],[sp+4],[sp+8]=params
  bx lr         ;Exit      ;in: r0 (0=Restart, 2=To_Menu)
</TD></TR></TABLE>
<BR>
<B>Wait8bit/Wait16bit</B><BR>
The various Wait opcodes and functions are waiting as many frames as specified.
Many API functions have no effect until the next Wait occurs.<BR>
<BR>
<B>Z80 RST0_xxh Functions / GBA Functions 02xxh</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  RST0_00h FadeIn, A speed, number of frames (0..x)
  RST0_01h FadeOut
  RST0_02h BlinkWhite
  RST0_03h  (?)
  RST0_04h  (?) blend_func_unk1
  RST0_05h  (?)
  RST0_06h  (?)
  RST0_07h  (?)
  RST0_08h  (?)
  RST0_09h  (?) _020264CC_check
  RST0_0Ah  (?) _020264CC_free
  RST0_0Bh N/A (bx 0)
  RST0_0Ch N/A (bx 0)
  RST0_0Dh N/A (bx 0)
  RST0_0Eh N/A (bx 0)
  RST0_0Fh N/A (bx 0)
  RST0_10h LoadSystemBackground, A number of background (1..101), E bg# (0..3)
  RST0_11h SetBackgroundOffset, A=bg# (0..3), DE=X, BC=Y
  RST0_12h SetBackgroundAutoScroll
  RST0_13h SetBackgroundMirrorToggle
  RST0_14h  (?)
  RST0_15h  (?)
  RST0_16h  (?) write_000000FF_to_02029494_
  RST0_17h  (?)
  RST0_18h  (?)
  RST0_19h SetBackgroundMode, A=mode (0..2)
  RST0_1Ah  (?)
  RST0_1Bh  (?)
  RST0_1Ch  (?)
  RST0_1Dh  (?)
  RST0_1Eh  (?)
  RST0_1Fh  (?)
  RST0_20h LayerShow
  RST0_21h LayerHide
  RST0_22h  (?)
  RST0_23h  (?)
  RST0_24h ... [20264DCh+A*20h+1Ah]=DE, [20264DCh+A*20h+1Ch]=BC
  RST0_25h  (?)
  RST0_26h  (?)
  RST0_27h  (?)
  RST0_28h  (?)
  RST0_29h  (?)
  RST0_2Ah  (?)
  RST0_2Bh  (?)
  RST0_2Ch  (?)
  RST0_2Dh LoadCustomBackground, A bg# (0..3), DE pointer to struct_background,
           max. tile data size = 3000h bytes, max. map data size = 1000h bytes
  RST0_2Eh GBA: N/A - Z80: (?)
  RST0_2Fh  (?)
  RST0_30h CreateSystemSprite, - -   (what "- -" ???)
  RST0_31h SpriteFree, HL sprite handle
  RST0_32h SetSpritePos, HL=sprite handle, DE=X, BC=Y
  RST0_33h  (?) sprite_unk2
  RST0_34h SpriteFrameNext
  RST0_35h SpriteFramePrev
  RST0_36h SetSpriteFrame, HL=sprite handle, E=frame number (0..x)
  RST0_37h  (?) sprite_unk3
  RST0_38h  (?) sprite_unk4
  RST0_39h SetSpriteAutoMove, HL=sprite handle, DE=X, BC=Y
  RST0_3Ah  (?) sprite_unk5
  RST0_3Bh  (?) sprite_unk6
  RST0_3Ch SpriteAutoAnimate
  RST0_3Dh  (?) sprite_unk7
  RST0_3Eh SpriteAutoRotateUntilAngle
  RST0_3Fh SpriteAutoRotateByAngle
  RST0_40h SpriteAutoRotateByTime
  RST0_41h  (?) sprite_unk8
  RST0_42h SetSpriteAutoMoveHorizontal
  RST0_43h SetSpriteAutoMoveVertical
  RST0_44h  (?) sprite_unk9
  RST0_45h SpriteDrawOnBackground
  RST0_46h SpriteShow, HL=sprite handle
  RST0_47h SpriteHide, HL=sprite handle
  RST0_48h SpriteMirrorToggle
  RST0_49h  (?) sprite_unk10
  RST0_4Ah  (?) sprite_unk11
  RST0_4Bh  (?) sprite_unk12
  RST0_4Ch GetSpritePos
  RST0_4Dh CreateCustomSprite
  RST0_4Eh  (?)
  RST0_4Fh  (?) sprite_unk14
  RST0_50h  (?) sprite_unk15
  RST0_51h  (?) sprite_unk16
  RST0_52h  (?) sprite_unk17
  RST0_53h  (?) sprite_unk18
  RST0_54h  (?)
  RST0_55h  (?) sprite_unk20
  RST0_56h  (?)
  RST0_57h SpriteMove
  RST0_58h  (?) sprite_unk22
  RST0_59h  (?) sprite_unk23
  RST0_5Ah  (?) sprite_unk24
  RST0_5Bh SpriteAutoScaleUntilSize, C=speed (higher value is slower),
           HL=sprite handle, DE=size (0100h = normal size,
           lower value = larger, higher value = smaller)
  RST0_5Ch SpriteAutoScaleBySize
  RST0_5Dh SpriteAutoScaleWidthUntilSize
  RST0_5Eh SpriteAutoScaleHeightBySize
  RST0_5Fh  (?)
  RST0_60h  (?)
  RST0_61h  (?)
  RST0_62h  (?)
  RST0_63h  (?)
  RST0_64h hl=[[2024D28h+a*4]+12h]
  RST0_65h  (?) sprite_unk25
  RST0_66h SetSpriteVisible, HL=sprite handle, E=(0=not visible, 1=visible)
  RST0_67h  (?) sprite_unk26
  RST0_68h  (?) set_sprite_unk27
  RST0_69h  (?) get_sprite_unk27
  RST0_6Ah  (?)
  RST0_6Bh  (?)
  RST0_6Ch  (?)
  RST0_6Dh  (?)
  RST0_6Eh hl=[hl+000Ah]  ;r0=[r1+0Ah]
  RST0_6Fh  (?)
  RST0_70h  (?)
  RST0_71h  (?)
  RST0_72h  (?)
  RST0_73h  (?)
  RST0_74h  (?)
  RST0_75h  (?)
  RST0_76h  (?)
  RST0_77h  (?)
  RST0_78h  (?)
  RST0_79h  (?)
  RST0_7Ah  (?)
  RST0_7Bh  (?)
  RST0_7Ch  (?) _0202FD2C_unk12
  RST0_7Dh Wait16bit ;HL=num_frames (16bit variant of Wait8bit opcode/function)
  RST0_7Eh SetBackgroundPalette, HL=src_addr, DE=offset, C=num_colors (1..x)
  RST0_7Fh GetBackgroundPalette(a,b,c)
  RST0_80h SetSpritePalette, HL=src_addr, DE=offset, C=num_colors (1..x)
  RST0_81h GetSpritePalette(a,b,c)
  RST0_82h ClearPalette
  RST0_83h  (?) _0202FD2C_unk11
  RST0_84h  (?)
  RST0_85h  (?)
  RST0_86h  (?)
  RST0_87h  (?) _0202FD2C_unk8
  RST0_88h  (?) _0202FD2C_unk7
  RST0_89h  (?)
  RST0_8Ah  (?) _0202FD2C_unk6
  RST0_8Bh  (?) _0202FD2C_unk5
  RST0_8Ch GBA: N/A - Z80: (?)
  RST0_8Dh GBA: N/A - Z80: (?)
  RST0_8Eh  (?)
  RST0_8Fh WindowHide
  RST0_90h CreateRegion, H=bg# (0..3), L=palbank# (0..15),
           D,E,B,C=x1,y1,cx,cy (in tiles), return: n/a (no$note: n/a ???)
  RST0_91h SetRegionColor
  RST0_92h ClearRegion
  RST0_93h SetPixel
  RST0_94h GetPixel
  RST0_95h DrawLine
  RST0_96h DrawRect
  RST0_97h  (?) _0202FD2C_unk4
  RST0_98h SetTextColor, A=region handle, D=color foreground (0..15),
           E=color background (0..15)
  RST0_99h DrawText, A=region handle, BC=pointer to text, D=X, E=Y
           (non-japan uses ASCII text, but japanese e-reader's use STH ELSE?)
  RST0_9Ah SetTextSize
  RST0_9Bh  (?) RegionUnk7
  RST0_9Ch  (?) _0202FD2C_unk3
  RST0_9Dh  (?) _0202FD2C_unk2
  RST0_9Eh  (?) _0202FD2C_unk1
  RST0_9Fh Z80: (?) - GBA: SetBackgroundModeRaw
  RST0_A0h  (?)
  RST0_A1h  (?)
  RST0_A2h  (?) RegionUnk6
  RST0_A3h GBA: N/A - Z80: (?)
  RST0_A4h GBA: N/A - Z80: (?)
  RST0_A5h  (?)
  RST0_A6h  (?)
  RST0_A7h  (?)
  RST0_A8h  (?)
  RST0_A9h  (?)
  RST0_AAh  (?)
  RST0_ABh  (?)
  RST0_ACh  (?)
  RST0_ADh  (?) RegionUnk5
  RST0_AEh [202FD2Ch+122h]=A
  RST0_AFh [202FD2Ch+123h]=A
  RST0_B0h [202FD2Ch+124h]=A
  RST0_B1h  (?)
  RST0_B2h  (?)
  RST0_B3h GBA: N/A - Z80: Sqrt   ;hl=sqrt(hl)
  RST0_B4h GBA: N/A - Z80: ArcTan ;hl=ArcTan2(hl,de)
  RST0_B5h Sine                   ;hl=sin(a)*de
  RST0_B6h Cosine                 ;hl=cos(a)*de
  RST0_B7h  (?)
  RST0_B8h  (?)
  RST0_B9h N/A (bx 0)
  RST0_BAh N/A (bx 0)
  RST0_BBh N/A (bx 0)
  RST0_BCh N/A (bx 0)
  RST0_BDh N/A (bx 0)
  RST0_BEh N/A (bx 0)
  RST0_BFh N/A (bx 0)
<B>  Below Non-Japan and Japan/Plus only (not Japan/Ori)</B>
  RST0_C0h GetTextWidth(a,b)
  RST0_C1h GetTextWidthEx(a,b,c)
  RST0_C2h  (?)
  RST0_C3h Z80: N/A (bx 0) - GBA: (?)
  RST0_C4h  (?)
  RST0_C5h  (?)
  RST0_C6h  (?)
  RST0_C7h  (?)
  RST0_C8h  (?)
  RST0_C9h  (?)
  RST0_CAh  (?)
  RST0_CBh  (?)
  RST0_CCh  (?)
  RST0_CDh N/A (bx lr)
  RST0_CEh ;same as RST0_3Bh, but with 16bit mask
  RST0_CFh ;same as RST0_3Eh, but with 16bit de
  RST0_D0h ;same as RST0_3Fh, but with 16bit de
  RST0_D1h ;same as RST0_5Bh, but with 16bit de
  RST0_D2h ;same as RST0_5Ch, but with 16bit de
  RST0_D3h ;same as RST0_5Dh, but with 16bit de
  RST0_D4h ;same as RST0_5Eh, but with 16bit de
  RST0_D5h  (?)
  RST0_D6h  (?)
  RST0_D7h ;[202FD2Ch+125h]=A
  RST0_D8h  (?)
  RST0_D9h  (?)
  RST0_DAh  (?)
  RST0_DBh ;A=[3003E51h]
  RST0_DCh ;[3004658h]=01h
  RST0_DDh DecompressVPKorNonVPK
  RST0_DEh FlashWriteSectorSingle(a,b)
  RST0_DFh FlashReadSectorSingle(a,b)
  RST0_E0h SoftReset
  RST0_E1h GetCartridgeHeader     ;[hl+0..BFh]=[8000000h..80000BFh]
  RST0_E2h GBA: N/A - Z80: bx hl  ;in: hl=addr, af,bc,de,sp=param, out: a
  RST0_E3h Z80: N/A (bx 0) - GBA: (?)
  RST0_E4h  (?)
  RST0_E5h  (?)
  RST0_E6h  (?)
  RST0_E7h  (?)
  RST0_E8h  (?)
  RST0_E9h ;[2029498h]=0000h
  RST0_EAh Z80: N/A (bx 0) - GBA: InitMemory(a)
  RST0_EBh  (?) BL_irq_sio_dma3
  RST0_ECh ;hl = [3003E30h]*100h + [3003E34h]
  RST0_EDh FlashWriteSectorMulti(a,b,c)
  RST0_EEh FlashReadPart(a,b,c)
  RST0_EFh ;A=((-([2029416h] xor 1)) OR (+([2029416h] xor 1))) SHR 31
  RST0_F0h  (?) _unk1
  RST0_F1h RandomInit     ;in: hl=random_seed
  RST0_F2h                         (?)
<B>  Below Japan/Plus only</B>
  RST0_F3h  (?)
  RST0_F4h  (?)
  RST0_F5h  (?)
  RST0_F6h  (?)
  RST0_F7h GBA: N/A - Z80: (?)
<B>  Below is undefined/garbage (values as so in Z80 mode)</B>
  Jap/Ori: RST0_C0h      N/A (bx 0)
  Jap/Ori: RST0_C1h..FFh Overlaps RST8 jump list
  Non-Jap: RST0_F3h..FFh Overlaps RST8 jump list
  Jap/Pls: RST0_F8h..FFh Overlaps RST8 jump list
</TD></TR></TABLE>
<BR>
<B>Z80 RST8_xxh Functions / GBA Functions 01xxh</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  RST8_00h GBA: N/A - Z80: Exit       ;[00C0h]=a ;(1=restart, 2=exit)
  RST8_01h GBA: N/A - Z80: Mul8bit    ;hl=a*e
  RST8_02h GBA: N/A - Z80: Mul16bit   ;hl=hl*de, s32[00D0h]=hl*de
  RST8_03h Div                        ;hl=hl/de
  RST8_04h DivRem                     ;hl=hl mod de
  RST8_05h PlaySystemSound            ;in: hl=sound_number
  RST8_06h  (?) sound_unk1
  RST8_07h Random8bit                 ;a=random(0..FFh)
  RST8_08h SetSoundVolume
  RST8_09h BcdTime                    ;[de+0..5]=hhmmss(hl*bc)
  RST8_0Ah BcdNumber                  ;[de+0..4]=BCD(hl), [de+5]=00h
  RST8_0Bh IoWrite                    ;[4000000h+hl]=de
  RST8_0Ch IoRead                     ;de=[4000000h+hl]
  RST8_0Dh GBA: N/A - Z80:  (?)
  RST8_0Eh GBA: N/A - Z80:  (?)
  RST8_0Fh GBA: N/A - Z80:  (?)
  RST8_10h GBA: N/A - Z80:  (?)
  RST8_11h DivSigned                  ;hl=hl/de, signed
  RST8_12h RandomMax                  ;a=random(0..a-1)
  RST8_13h SetSoundSpeed
  RST8_14h  hl=[202FD20h]=[2024CACh]
  RST8_15h  hl=[2024CACh]-[202FD20h]
  RST8_16h SoundPause
  RST8_17h SoundResume
  RST8_18h PlaySystemSoundEx
  RST8_19h IsSoundPlaying
  RST8_1Ah  (?)
  RST8_1Bh  (?)
  RST8_1Ch  (?)
  RST8_1Dh GetExitCount               ;a=[2032D34h]
  RST8_1Eh Permille                   ;hl=de*1000/hl
  RST8_1Fh GBA: N/A - Z80: ExitRestart;[2032D38h]=a, [00C0h]=0001h  ;a=?
  RST8_20h GBA: N/A - Z80: WaitJoypad ;wait until joypad&lt;&gt;0, set hl=joypad
  RST8_21h GBA: N/A - Z80:  (?)
  RST8_22h  (?) _sound_unk7
  RST8_23h  (?) _sound_unk8
  RST8_24h  (?) _sound_unk9
  RST8_25h  (?) _sound_unk10
  RST8_26h Mosaic     ;bg&lt;n&gt;cnt.bit6=a.bit&lt;n&gt;, [400004Ch]=de
  RST8_27h  (?)
  RST8_28h  (?)
  RST8_29h  (?)
  RST8_2Ah  (?) get_8bit_from_2030110h
  RST8_2Bh  (?)
  RST8_2Ch  (?) get_16bit_from_2030112h ;jap/ori: hl=[20077B2h]
  RST8_2Dh  (?) get_16bit_from_2030114h ;jap/ori: hl=[20077B4h]
  RST8_2Eh  (?)
  RST8_2Fh PlayCustomSound(a,b)
<B>  Below not for Japanese/Original</B>
  (the renumbered functions can be theoretically used on japanese/original)
  (but, doing so would blow forwards compatibility with japanese/plus)
  RST8_30h (ori: none)      GBA: N/A - Z80: (?)
  RST8_31h (ori: none)      PlayCustomSoundEx(a,b,c)
  RST8_32h (ori: RST8_30h)  BrightnessHalf   ;[4000050h]=00FFh,[4000054h]=0008h
  RST8_33h (ori: RST8_31h)  BrightnessNormal ;[4000050h]=0000h
  RST8_34h (ori: RST8_32h)  N/A (bx lr)
  RST8_35h (ori: RST8_33h)   (?)
  RST8_36h (ori: RST8_34h)  ResetTimer ;[400010Ch]=00000000h, [400010Eh]=A+80h
  RST8_37h (ori: RST8_35h)  GetTimer   ;hl=[400010Ch]
  RST8_38h (ori: none)      GBA: N/A - Z80:  (?)
<B>  Below is undefined/reserved/garbage (values as so in Z80 mode)</B>
  (can be used to tweak jap/ori to start GBA-code from inside of Z80-code)
  (that, after relocating code to 3000xxxh via DMA via IoWrite function)
  RST8_39h (ori: RST8_36h)  bx 0140014h
  RST8_3Ah (ori: RST8_37h)  bx 3E700F0h
  RST8_3Bh (ori: RST8_38h)  bx 3E70000h+1
  RST8_3Ch (ori: RST8_39h)  bx 3E703E6h+1
  RST8_3Dh (ori: RST8_3Ah)  bx 3E703E6h+1
  RST8_3Eh (ori: RST8_3Bh)  bx 3E703E6h+1
  RST8_3Fh (ori: RST8_3Ch)  bx 3E703E6h+1
  40h-FFh  (ori: 3Dh-FFh)   bx ...
</TD></TR></TABLE>
<BR>
<B>GBA Functions 03xxh (none such in Z80 mode)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  RSTX_00h Wait8bit  ;for 16bit: RST0_7Dh
  RSTX_01h GetKeyStateSticky()
  RSTX_02h GetKeyStateRaw()
  RSTX_03h  (?)
  RSTX_04h  (?)
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbacartereadervpkdecompression"></A>&nbsp;
  GBA Cart e-Reader VPK Decompression
</FONT></TD></TR></TABLE><BR>
<B>vpk_decompress(src,dest)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  collected32bit=80000000h  ;initially empty (endflag in bit31)
  for i=0 to 3, id[i]=read_bits(8), next i, if id[0..3]&lt;&gt;'vpk0' then error
  dest_end=dest+read_bits(32)     ;size of decompressed data (of all strips)
  method=read_bits(8), if method&gt;1 then error
  tree_index=0, read_huffman_tree, disproot=tree_index
  tree_index=tree_index+1, read_huffman_tree, lenroot=tree_index
  ;above stuff is contained only in the first strip. below loop starts at
  ;current location in first strip, and does then continue in further strips.
 decompress_loop:
  if read_bits(1)=0 then                   ;copy one uncompressed data byte,
    [dest]=read_bits(8), dest=dest+1       ;does work without huffman trees
  else
    if disproot=-1 or lenroot=-1 then error  ;compression does require trees
    disp=read_tree(disproot)
    if method=1   ;disp*4 is good for 32bit ARM opcodes
      if disp&gt;2 then disp=disp*4-8 else disp=disp+4*read_tree(disproot)-7
    len=read_tree(lenroot)
    if len=0 or disp&lt;=0 or dest+len-1&gt;dest_end then error ;whoops
    for j=1 to len, [dest]=[dest-disp], dest=dest+1, next j
  if dest&lt;dest_end then decompress_loop
  ret
</TD></TR></TABLE>
<BR>
<B>read_bits(num)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  mov  data=0
  for i=1 to num
    shl collected32bit,1   ;move next bit to carry, or set zeroflag if empty
    if zeroflag
      collected32bit=[src+0]*1000000h+[src+1]*10000h+[src+2]*100h+[src+3]
      src=src+4            ;read data in 32bit units, in reversed byte-order
      carryflag=1          ;endbit
      rcl collected32bit,1 ;move bit31 to carry (and endbit to bit0)
    rcl data,1             ;move carry to data
  next i
  ret(data)
</TD></TR></TABLE>
<BR>
<B>read_tree(root_index)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  i=root_index
  while node[i].right&lt;&gt;-1  ;loop until reaching data node
    if read_bits(1)=1 then i=node[i].right else i=node[i].left
  i=node[i].left           ;get number of bits
  i=read_bits(i)           ;read that number of bits
  ret(i)                   ;return that value
</TD></TR></TABLE>
<BR>
<B>load_huffman_tree</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  stacktop=sp
  if read_bits(1)=1 then tree_index=-1, ret  ;exit (empty)
  node[tree_index].right=-1                  ;indicate data node
  node[tree_index].left=read_bits(8)         ;store data value
  if read_bits(1)=1 then ret                 ;exit (only 1 data node at root)
  push tree_index                     ;save previous (child) node
  tree_index=tree_index+1
  jmp data_injump
 load_loop:
  push tree_index                     ;save previous (child) node
  tree_index=tree_index+1
  if read_bits(1)=1 then parent_node
 data_injump:
  node[tree_index].right=-1           ;indicate data node
  node[tree_index].left=read_bits(8)  ;store data value
  jmp load_loop
 parent_node:
  pop node[tree_index].right          ;store 1st child
  pop node[tree_index].left           ;store 2nd child
  if sp&lt;&gt;stacktop then jmp load_loop
  if read_bits(1)=0 then error        ;end bit (must be 1)
  ret
</TD></TR></TABLE>
The best values for the huffman trees that I've found are 6,9,12-bit
displacements for method 0 (best for NES/Z80 code), and two less for method 1,
ie. 4,7,10-bit (best for GBA code). And 2,4,10-bit for the length values. The
smallest value in node 0, and the other values in node 10 and 11.<BR>
<BR>
<B>Notes</B><BR>
The decompression works similar to the GBA BIOS'es LZ77 decompression function,
but without using fixed bit-widths of length=4bit and displacement=12bit,
instead, the bit-widths are read from huffman trees (which can also define
fixed bit-widths; if data is located directly in the root node).<BR>
Unlike the GBA BIOS'es Huffman decompression function, the trees are starting
with data entries, end are ending with the root entry. The above load function
deciphers the data, and returns the root index.<BR>
With the variable bit-widths, the VPK compression rate is quite good, only,
it's a pity that the length/disp values are zero-based, eg. for 2bit and 4bit
lengths, it'd be much better to assign 2bit as 2..5, and 4bit as 6..21.<BR>
<BR>
<B>Non-VPK</B><BR>
The e-Reader additionally supports an alternate decompression function,
indicated by the absence of the "vpk0" ID, which supports compression of
increasing byte-values, which isn't useful for program code.<BR>
Bit15 of the VPK Size value seems to disable (de-)compression, the VPK Data
field is then containing plain uncompressed data.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbacartereadererrorcorrection"></A>&nbsp;
  GBA Cart e-Reader Error Correction
</FONT></TD></TR></TABLE><BR>
The Error Correction Information that is appended at the end of the Block
Header &amp; Data Fragments consists of standard Reed-Solomon codes, which are
also used for CD/DVD disks, DSL modems, and digital DVB television signals.
That info allows to locate and repair a number of invalid data bytes.<BR>
<BR>
Below code shows how to create and verify error-info (but not how to do the
actual error correction). The dtalen,errlen values should be 18h,10h for the
Block Header, and 40h,10h for Data Fragments; the latter settings might be
possible to get changed to other values though?<BR>
<BR>
<B>append_error_info(data,dtalen,errlen)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  reverse_byte_order(data,dtalen)
  zerofill_error_bytes(data,errlen)
  for i=dtalen-1 to errlen  ;loop across data portion
    z = rev[ data[i] xor data[errlen-1] ] ;
    for j=errlen-1 to 0     ;loop across error-info portion
    if j=0 then x=00h else x=data[j-1]
      if z&lt;&gt;FFh then
        y=gg[j], if y&lt;&gt;FFh then
          y=y+z, if y&gt;=FFh then y=y-FFh
          x=x xor pow[y]
      data[j]=x
    next j
  next i
  invert_error_bytes(data,errlen)
  reverse_byte_order(data,dtalen)
</TD></TR></TABLE>
<BR>
<B>verify_error_info(data,dtalen,errlen)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  reverse_byte_order(data,dtalen)
  invert_error_bytes(data,errlen)
  make_rev(data,dtalen)
  for i=78h to 78h+errlen-1
    x=0, z=0
    for j=0 to dtalen-1
      y=data[j]
      if y&lt;&gt;FFh then
        y=y+z, if y&gt;=FFh then y=y-FFh
        x=x xor pow[y]
      z=z+i, if z&gt;=FFh then z=z-FFh
    next j
    if x&lt;&gt;0 then error
  next i
  ;(if errors occured, could correct them now)
  make_pow(data,dtalen)
  invert_error_bytes(data,errlen)
  reverse_byte_order(data,dtalen)
</TD></TR></TABLE>
<BR>
<B>make_rev(data,len)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  for i=0 to len-1, data[i]=rev[data[i]], next i
</TD></TR></TABLE>
<BR>
<B>make_pow(data,len)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  for i=0 to len-1, data[i]=pow[data[i]], next i
</TD></TR></TABLE>
<BR>
<B>invert_error_bytes(data,len)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  for i=0 to len-1, data[i]=data[i] xor FFh, next i
</TD></TR></TABLE>
<BR>
<B>zerofill_error_bytes(data,len)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  for i=0 to len-1, data[i]=00h, next i
</TD></TR></TABLE>
<BR>
<B>reverse_byte_order(data,len)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  for i=0 to (len-1)/2, x=data[i], data[i]=data[len-i], data[len-i]=x, next i
</TD></TR></TABLE>
<BR>
<B>create_pow_and_rev_tables</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  x=01h, pow[FFh]=00h, rev[00h]=FFh
  for i=00h to FEh
    pow[i]=x, rev[x]=i, x=x*2, if x&gt;=100h then x=x xor 187h
  next i
</TD></TR></TABLE>
<BR>
<B>create_gg_table</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  gg[0]=pow[78h]
  for i=1 to errlen-1
    gg[i]=01h
    for j=i downto 0
      if j=0 then y=00h else y=gg[j-1]
      x=gg[j], if x&lt;&gt;00h then
        x=rev[x]+78h+i, if x&gt;=FFh then x=x-FFh
        y=y xor pow[x]
      gg[j]=y
    next j
  next i
  make_rev(gg,errlen)
</TD></TR></TABLE>
With above value of 78h, and errlen=10h, gg[00h..0Fh] will be always:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h,4Bh,EBh,D5h,EFh,4Ch,71h,00h,F4h,00h,71h,4Ch,EFh,D5h,EBh,4Bh
</TD></TR></TABLE>
So using a hardcoded table should take up less memory than calculating it.<BR>
<BR>
<B>Notes</B><BR>
The actual error correction should be able to fix up to "errlen" errors at
known locations (eg. data from blocks that haven't been scanned, or whose
5bit-to-4bit conversion had failed due to an invalid 5bit value), or up to
"errlen/2" errors at unknown locations. The corrected data isn't guaranteed to
be correct (even if it looks okay to the "verify" function), so the Data Header
checksums should be checked, too.<BR>
<BR>
<B>More Info</B><BR>
For more info, I've found Reed-Solomon source code from Simon Rockliff, and an
updated version from Robert Morelos-Zaragoza and Hari Thirumoorthy to be
useful. For getting started with that source, some important relationships
&amp; differences are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  pow = alpha_to, but generated as shown above
  rev = index_of, dito
  b0  = 78h
  nn  = dtalen
  kk  = dtalen-errlen
  %nn = MOD FFh (for the ereader that isn't MOD dtalen)
  -1  = FFh
</TD></TR></TABLE>
And, the ereader processes data/errinfo backwards, starting at the last byte.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbacartereaderfileformats"></A>&nbsp;
  GBA Cart e-Reader File Formats
</FONT></TD></TR></TABLE><BR>
<B>.BMP Files (homebrew 300 DPI strips)</B><BR>
Contains a picture of the whole dotcode strip with address bars and sync marks
(see Dotcode chapter) in Microsoft's Bitmap format. The image is conventionally
surrounded by a blank 2-pixel border, resulting in a size of 989x44 pixels for
long strips. The file should should have 1bit color depth. The pixels per meter
entry should match the desired printing resolution, either 300 DPI or 360 DPI.
But, resolution of printer hardware is typically specified in inch rather than
in meters, so an exact match isn't supported by Microsoft. Most homebrew .BMP
files contain nonsense resolutions like 200 DPI, or 300 dots per meter (ca. 8
DPI).<BR>
<BR>
<B>.JPG Files (scanned 1200 DPI strips)</B><BR>
Same as BMP, but should contain a dotcode scanned at 1200 DPI, with correct
orientation (the card-edge side at the bottom of the image), and containing
only the dotcode (not the whole card), so the JPG size should be about 3450x155
pixels for long strips.<BR>
No$gba currently doesn't work with progressive JPGs. Scans with white
background can be saved as monochrome JPG. Scans with red/yellow background
should contain a correct RED layer (due to the red LED light source) (the
brightness of the green/blue layers can be set to zero for better compression).<BR>
<BR>
<B>.RAW Files</B><BR>
Contains the "raw" information from the BMP format, that is, 2-byte block
header, 102-byte data, 2-byte block header, 102-byte data, etc. The data
portion is interleaved, and includes the full 48-byte data header, titles, vpk
compressed data, error-info, and unused bytes. RAW files are excluding Address
Bars, Sync Marks, and 4bit-to-5bit encoding.<BR>
Each RAW file contains one or more strip(s), so the RAW filesize is either
18*104 bytes (short strip), or 28*104 bytes (long strip), or a multiple thereof
(if it contains more than one strip) (although multi-strip games are often
stored in separate files for each strip; named file1.raw, file2.raw, etc).<BR>
<BR>
<B>.BIN Files</B><BR>
Filesize should be I*30h, with I=1Ch for short strips, and I=2Ch for long
strips, or a multiple thereof (if it contains more than one strip). Each strip
consists of the 48-byte Data Header, followed by title(s), and vpk compressed
data. Unlike .RAW files, .BIN files aren't interleaved, and do not contain
Block Headers, nor error-info, nor unused bytes (in last block). The files do
contain padding bytes to match a full strip-size of I*30h.<BR>
Caution: Older .BIN files have been using a size-reduced 12-byte header (taken
from entries 0Dh, 0Ch, 10h-11h, 26h-2Dh of the 48-byte Data Header; in that
order), that files have never contained more than one strip per file, so the
filesize should be exactly I*30h-36, the size-reduced header doesn't contain a
Primary Type entry, so it's everyone's bet which Card Type is to be used (hint:
the 12-byte headers were based on the assumption that Primary Type would be
always 01h on Short Strips, and 02h on Long Strips).<BR>
<BR>
<B>.SAV Files</B><BR>
Contains a copy of the e-Reader's 128Kbyte FLASH memory. With the saved
e-Reader application being located in the 2nd 64K-bank, the data consists of a
header with title and gba/nes/z80 format info, followed by the vpk compressed
data. The FLASH memory does also contain e-Reader calibration settings, the
remaining 100Kbytes are typically FFh-filled.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbacartunknowndevices"></A>&nbsp;
  GBA Cart Unknown Devices
</FONT></TD></TR></TABLE><BR>
<B>GBA Infra-Red Port (AGB-006)</B><BR>
No info?<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbacartprotections"></A>&nbsp;
  GBA Cart Protections
</FONT></TD></TR></TABLE><BR>
<B>Classic NES Series</B><BR>
These are some NES/Famicom games ported or emulated to work on GBA. The games
are doing some uncommon stuff that can cause compatibility problems when not
using original GBA consoles or cartridges.<BR>
- CPU pipeline (selfmodifying code that shall NOT affect prefetched opcodes)<BR>
- STMDA write to I/O ports (writes in INCREASING order, not DECREASING order)<BR>
- SRAM detection (refuses to run if SRAM exists; the games do contain EEPROM)<BR>
- ROM mirrors (instead of the usual increasing numbers in unused ROM area)<BR>
- RAM mirrors (eg. main RAM accessed at 2F00000h instead of 2000000h)<BR>
Note: These games can be detected by checking [80000ACh]="F" (ie. game
code="Fxxx").<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbaflashcards"></A>&nbsp;
  GBA Flashcards
</FONT></TD></TR></TABLE><BR>
Flashcards are re-writable cartridges using FLASH memory, allowing to test even
multiboot-incompatible GBA software on real hardware, providing a good
development environment when used in combination with a reasonable software
debugger.<BR>
<BR>
The carts can be written to from external tools, or directly from GBA programs.<BR>
Below are pseudo code flowcharts for detect, erase, and write operations.<BR>
All flash reads/writes are meant to be 16bit (ldrh/strh) memory accesses.<BR>
<BR>
<B>detect_flashcard:</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 configure_flashcard(9E2468Ah,9413h)    ;unlock flash advance cards
 turbo=1, send_command(8000000h,90h)    ;enter ID mode (both chips, if any)
 maker=[8000000h], device=[8000000h+2]
 IF maker=device THEN device=[8000000h+4] ELSE turbo=0
 flashcard_read_mode                    ;exit ID mode
 search (maker+device*10000h) in device_list
 total/erase/write_block_size = list_entry SHL turbo
</TD></TR></TABLE>
<BR>
<B>flashcard_erase(dest,len):</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 FOR x=1 to len/erase_block_size
  send_command(dest,20h)        ;erase sector command
  send_command(dest,D0h)        ;confirm erase sector
  dest=dest+erase_block_size
 IF wait_busy=okay THEN NEXT x
 enter_read_mode                ;exit erase/status mode
</TD></TR></TABLE>
<BR>
<B>flashcard_write(src,dest,len):</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 siz=write_block_size
 FOR x=1 to len/siz
  IF siz=2 THEN send_command(dest,10h)  ;write halfword command
  IF siz&gt;2 THEN send_command(dest,E8h)  ;write to buffer command
  IF siz&gt;2 THEN send_command(dest,16-1) ;buffer size 16 halfwords (per chip)
  FOR y=1 TO siz/2
   [dest]=[src], dest=dest+2, src=src+2 ;write data to buffer
  NEXT y
  IF siz&gt;2 THEN send_command(dest,D0h)  ;confirm write to buffer
 IF wait_busy=okay THEN NEXT x
 enter_read_mode                        ;exit write/status mode
</TD></TR></TABLE>
<BR>
<B>send_command(adr,val):</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 [adr]=val
 IF turbo THEN [adr+2]=val
</TD></TR></TABLE>
<BR>
<B>enter_read_mode:</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 send_command(8000000h,FFh)     ;exit status mode
 send_command(8000000h,FFh)     ;again maybe more stable (as in jeff's source)
</TD></TR></TABLE>
<BR>
<B>flashcard_wait_busy:</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 start=time
 REPEAT
  stat=[8000000h] XOR 80h
  IF turbo THEN stat=stat OR ([8000000h+2] XOR 80h)
  IF (stat AND 7Fh)&gt;0 THEN error
  IF (stat AND 80h)=0 THEN ready
  IF time-start&gt;5secs THEN timeout
 UNTIL ready OR error OR timeout
 IF error OR timeout THEN send_command(8000000h,50h)    ;clear status
</TD></TR></TABLE>
<BR>
<B>configure_flashcard(adr,val):   ;required for Flash Advance cards only</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 [930ECA8h]=5354h
 [802468Ah]=1234h, repeated 500 times
 [800ECA8h]=5354h
 [802468Ah]=5354h
 [802468Ah]=5678h, repeated 500 times
 [930ECA8h]=5354h
 [802468Ah]=5354h
 [8ECA800h]=5678h
 [80268A0h]=1234h
 [802468Ah]=ABCDh, repeated 500 times
 [930ECA8h]=5354h
 [adr]=val
</TD></TR></TABLE>
<BR>
<B>init_backup:  ;no info how to use that exactly</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 configure_flashcard(942468Ah,???)
</TD></TR></TABLE>
<BR>
<B>device_list:  (id code, total/erase/write sizes in bytes)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ID Code    Total   Erase  Write  Name
  -??-00DCh      ?       ?      ?  Hudson Cart (???)
  00160089h     4M    128K     32  Intel i28F320J3A (Flash Advance)
  00170089h     8M    128K     32  Intel i28F640J3A (Flash Advance)
  00180089h    16M    128K     32  Intel i28F128J3A (Flash Advance)
  00E200B0h      ?     64K      2  Sharp LH28F320BJE ? (Nintendo)
</TD></TR></TABLE>
<BR>
<B>Notes</B><BR>
All flashcards should work at 4,2 waitstates (power on default), most
commercial games change waits to 3,1 which may work unstable with some/older FA
flashcards. Intel FLASH specified to have a lifetime of 100,000 erases, and
average block erase time 1 second (up to 5 second in worst cases).<BR>
Aside from the main FLASH memory, Flash Advance (FA) (aka Visoly) cards
additionally contain battery buffered SRAM backup, and FLASH backup, and in
some cases also EEPROM backup.<BR>
Turbo FA cards are containing two chips interlaced (at odd/even halfword
addresses), allowing to write/erase both chips simultaneously, resulting in
twice as fast programming time.<BR>
Standard Nintendo flash carts have to be modified before you can actually write
to them. This is done by removing resistor R7 and putting it at empty location
R8.<BR>
Mind that write/erase/detect modes output status information in ROM area, so
that in that modes all GBA program code (and any interrupt handlers) must be
executed in WRAM, not in ROM.<BR>
<BR>
Thanks to Jeff Frohwein for his FAQ and CARTLIB sample in FLGBA at devrs.com<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbacheatdevices"></A>&nbsp;
  GBA Cheat Devices
</FONT></TD></TR></TABLE><BR>
Codebreaker (US) aka Xploder (EUR).<BR>
Gameshark (US) aka Action Replay (EUR).<BR>
<BR>
<A HREF="#gbacheatcodesgeneralinfo">GBA Cheat Codes - General Info</A><BR>
<A HREF="#gbacheatcodescodebreakerxploder">GBA Cheat Codes - Codebreaker/Xploder</A><BR>
<A HREF="#gbacheatcodesgamesharkactionreplayv1v2">GBA Cheat Codes - Gameshark/Action Replay V1/V2</A><BR>
<A HREF="#gbacheatcodesproactionreplayv3">GBA Cheat Codes - Pro Action Replay V3</A><BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbacheatcodesgeneralinfo"></A>&nbsp;
  GBA Cheat Codes - General Info
</FONT></TD></TR></TABLE><BR>
Cheat devices are external adapters, connected between the GBA and the game
cartridge. The devices include a BIOS ROM which is, among others, used to
prompt the user to enter cheat codes.<BR>
These codes are used to patch specified memory locations for a certain GBA
game, allowing the user to gain goodies such like Infinite sex, 255 Cigarettes,
etc.<BR>
<BR>
<B>ROM and RAM Patches</B><BR>
For ROM Patches, the device watches the address bus, if it matches a specified
address then it outputs a patched value to the data bus, that mechanism is
implemented by hardware, aside from the Hook Enable Code some devices also
allow a limited number of cheats to use ROM patches.<BR>
Most cheat codes are RAM patches, each time when the hook procedure is executed
it will process all codes and overwrite the specified addresses in RAM (or VRAM
or I/O area) by the desired values.<BR>
<BR>
<B>Enable Codes (Must Be On)</B><BR>
Enable codes usually consist of the Game ID, Hook Address, and eventually a
third code used to encrypt all following codes. The Game ID is used to confirm
that the correct cartridge is inserted, just a verification, though the device
may insist on the ID code.<BR>
The Hook Address specifies an address in cartridge ROM, and should point to an
opcode which is executed several times per second (eg. once per frame, many
codes place the hook in the joypad handler). At the hook address, the device
redirects to its own BIOS, processes the RAM patches, and does then return
control to the game cartridge.<BR>
Note: The hook address should not point to opcodes with relative addressing
(eg. B, BL, LDR Rd,=Imm, ADD Rd,=Imm opcodes - which are all relative to PC
program counter register).<BR>
<BR>
<B>Alignment</B><BR>
Addresses for 16bit or 32bit values should be properly aligned.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbacheatcodescodebreakerxploder"></A>&nbsp;
  GBA Cheat Codes - Codebreaker/Xploder
</FONT></TD></TR></TABLE><BR>
<B>Codebreaker Codes</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0000xxxx 000y  Enable Code 1 - Game ID
  1aaaaaaa 000z  Enable Code 2 - Hook Address
  2aaaaaaa yyyy  [aaaaaaa]=[aaaaaaa] OR yyyy
  3aaaaaaa 00yy  [aaaaaaa]=yy
  4aaaaaaa yyyy  [aaaaaaa+0..(cccc-1)*ssss]=yyyy+0..(cccc-1)*ssss
  iiiicccc ssss  parameters for above code
  5aaaaaaa cccc  [aaaaaaa+0..(cccc-1)]=11,22,33,44,etc.
  11223344 5566  parameter bytes 1..6 for above code (example)
  77880000 0000  parameter bytes 7..8 for above code (padded with zero)
  6aaaaaaa yyyy  [aaaaaaa]=[aaaaaaa] AND yyyy
  7aaaaaaa yyyy  IF [aaaaaaa]=yyyy THEN (next code)
  8aaaaaaa yyyy  [aaaaaaa]=yyyy
  9xyyxxxx xxxx  Enable Code 0 - Encrypt all following codes (optional)
  Aaaaaaaa yyyy  IF [aaaaaaa]&lt;&gt;yyyy THEN (next code)
  Baaaaaaa yyyy  IF [aaaaaaa]&gt;yyyy THEN (next code) (signed comparison)
  Caaaaaaa yyyy  IF [aaaaaaa]&lt;yyyy THEN (next code) (signed comparison)
  D0000020 yyyy  IF [joypad] AND yyyy = 0 THEN (next code)
  Eaaaaaaa yyyy  [aaaaaaa]=[aaaaaaa]+yyyy
  Faaaaaaa yyyy  IF [aaaaaaa] AND yyyy THEN (next code)
</TD></TR></TABLE>
<BR>
<B>Codebreaker Enable Codes</B><BR>
Hook Address 'aaaaaaa' is a 25bit offset in ROM-image (0-1FFFFFFh).<BR>
Flag byte 'y' (usually 0Ah), Bit1=Disable IRQs, Bit3=CRC Exists.<BR>
Code Handler Store Address 'z' (0-7, usually 7) (8000100h+z*400000h).<BR>
Checksum 'xxxx' for first 64Kbytes of cartridge (no$gba pads by FFh if ROM is
smaller than 64K). Calculated, by using unsigned 16bit values, as such:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  crc=FFFFh
  for i=0 to FFFFh
   x=byte[i] xor (crc/100h)
   x=x xor (x/10h)
   crc=(crc*100h) xor (x*1001h) xor (x*20h)
  next i
</TD></TR></TABLE>
<BR>
<B>Codebreaker Encryption</B><BR>
codebreaker_change_encryption:<BR>
Encryption can be (optionally) activated by code "9xyyxxxx xxxx",<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  for i=0 to 2Fh, swaplist[i]=i, next i
  randomizer = 1111h xor byte[code+4]                              ;LSB value
  for i=0 to 4Fh
    exchange swaplist[random MOD 30h] with swaplist[random MOD 30h]
  next i
  halfword[seedlist+0] = halfword[code+0]                          ;LSW address
  randomizer = 4EFAD1C3h
  for i=0 to byte[code+3]-91h, randomizer=random, next i           ;MSB address
  word[seedlist+2]=random, halfword[seedlist+6]=random
  randomizer = F254h xor byte[code+5]                              ;MSB value
  for i=0 to byte[code+5]-01h, randomizer=random, next i           ;MSB value
  word[seedlist+8]=random, halfword[seedlist+12]=random
  ;note: byte[code+2] = don't care
  ret
</TD></TR></TABLE>
The above random function works like so:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  randomizer=randomizer*41C64E6Dh+3039h, x=(randomizer SHL 14 AND C0000000h)
  randomizer=randomizer*41C64E6Dh+3039h, x=(randomizer SHR 1  AND 3FFF8000h)+x
  randomizer=randomizer*41C64E6Dh+3039h, x=(randomizer SHR 16 AND 00007FFFh)+x
  return(x)
</TD></TR></TABLE>
Once when encryption is activated, all following codes are decrypted like so:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  for i=2Fh to 0
    j=swaplist[i]
    bitno1=(i AND 7), index1=xlatlist[i/8]
    bitno2=(j AND 7), index2=xlatlist[j/8]
    exchange [code+index1].bitno1 with [code+index2].bitno2
  next i
  word[code+0] = word[code+0] xor word[seedlist+8]
  i = (byte[code+3]*1010000h + byte[code+0]*100h + byte[code+5])
  i = (halfword[code+1]*10001h) xor (word[seedlist+2]) xor i
  i = (byte[seedlist+0]*1010101h) xor (byte[seedlist+1]*1000000h) xor i
  j = (byte[code+5] + (byte[code+0] xor byte[code+4])*100h)
  j = (byte[seedlist+0]*101h) xor halfword[seedlist+6] xor j
  word[code+0] = i, halfword[code+4] = j
</TD></TR></TABLE>
The above xlatlist is fixed: xlatlist[0..5] = 3,2,1,0,5,4<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbacheatcodesgamesharkactionreplayv1v2"></A>&nbsp;
  GBA Cheat Codes - Gameshark/Action Replay V1/V2
</FONT></TD></TR></TABLE><BR>
<B>Gameshark RAW Codes (These codes must be encrypted before using them)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0aaaaaaa 000000xx  [aaaaaaa]=xx
  1aaaaaaa 0000xxxx  [aaaaaaa]=xxxx
  2aaaaaaa xxxxxxxx  [aaaaaaa]=xxxxxxxx
  3000cccc xxxxxxxx  write xxxxxxxx to (cccc-1) addresses (list in next codes)
  aaaaaaaa aaaaaaaa  parameter for above code, containing two addresses each
  aaaaaaaa 00000000  last parameter for above, zero-padded if only one address
  60aaaaaa y000xxxx  [8000000h+aaaaaa*2]=xxxx (ROM Patch)
  8a1aaaaa 000000xx  IF GS_Button_Down THEN [a0aaaaa]=xx
  8a2aaaaa 0000xxxx  IF GS_Button_Down THEN [a0aaaaa]=xxxx
  80F00000 0000xxxx  IF GS_Button_Down THEN slowdown xxxx * ? cycles per hook
  Daaaaaaa 0000xxxx  IF [aaaaaaa]=xxxx THEN (next code)
  E0zzxxxx 0aaaaaaa  IF [aaaaaaa]=xxxx THEN (next 'zz' codes)
  Faaaaaaa 00000x0y  Enable Code - Hook Routine
  xxxxxxxx 001DC0DE  Enable Code - Game Code ID (value at [0ACh] in cartridge)
  DEADFACE 0000xxyy  Change Encryption Seeds
</TD></TR></TABLE>
<BR>
<B>Enable Code - Hook Routine</B><BR>
Hook Address 'aaaaaaa' is a 28bit ROM address (8FFFFFFh-9FFFFFFh).<BR>
Used to insert the GS code handler routine where it will be executed at<BR>
least 20 times per second. Without this code, GSA can not write to RAM.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 y=1 - Executes code handler without backing up the LR register.
 y=2 - Executes code handler and backs up the LR register.
 y=3 - Replaces a 32-bit pointer used for long-branches.
 x=0 - Must turn GSA off before loading game.
 x=1 - Must not do that.
</TD></TR></TABLE>
<BR>
<B>ROM Patch</B><BR>
This type allows GSA to intercept ROM reads and returns the value xxxx.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 y=0 wait for the code handler to enable the patch
 y=1 patch is enabled before the game starts
 y=2 unknown ?
</TD></TR></TABLE>
Note: V1/V2 hardware can only have up to 1 user-defined rom patch max. V3 can
have up to 4. Some enable code types can shorten the amount of user-defined rom
patches available.<BR>
<BR>
<B>Gameshark Encryption</B><BR>
A=Left half, and V=Right half of code.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  FOR I=1 TO 32
    A=A + (V*16+S0) XOR (V+I*9E3779B9h) XOR (V/32+S1)
    V=V + (A*16+S2) XOR (A+I*9E3779B9h) XOR (A/32+S3)
  NEXT I
</TD></TR></TABLE>
Upon startup, the initial encryption seeds are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  S0=09F4FBBDh S1=9681884Ah S2=352027E9h S3=F3DEE5A7h
</TD></TR></TABLE>
Upon DEADFACE 0000xxyy, the S0..S3 seeds are changed like so:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  FOR y=0 TO 3
   FOR x=0 TO 3
    z = T1[(xx+x) AND FFh] + T2[(yy+y) AND FFh]
    Sy = Sy*100h + (z AND FFh)
   NEXT x
  NEXT y
</TD></TR></TABLE>
All calculations truncated to unsigned 32bit integer values.<BR>
T1 and T2 are translation tables contained in the gameshark cartridge.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbacheatcodesproactionreplayv3"></A>&nbsp;
  GBA Cheat Codes - Pro Action Replay V3
</FONT></TD></TR></TABLE><BR>
<B>Pro Action Replay V3 - RAW Codes</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  C4aaaaaa 0000yyyy  Enable Code - Hook Routine at [8aaaaaa]
  xxxxxxxx 001DC0DE  Enable Code - ID Code [080000AC]
  DEADFACE 0000xxxx  Enable Code - Change Encryption Seeds
  00aaaaaa xxxxxxyy  [a0aaaaa..a0aaaaa+xxxxxx]=yy
  02aaaaaa xxxxyyyy  [a0aaaaa..a0aaaaa+xxxx*2]=yyyy
  04aaaaaa yyyyyyyy  [a0aaaaa]=yyyyyyyy
  40aaaaaa xxxxxxyy  [ [a0aaaaa] + xxxxxx ]=yy   (Indirect)
  42aaaaaa xxxxyyyy  [ [a0aaaaa] + xxxx*2 ]=yyyy (Indirect)
  44aaaaaa yyyyyyyy  [ [a0aaaaa] ]=yyyyyyyy      (Indirect)
  80aaaaaa 000000yy  [a0aaaaa]=[a0aaaaa]+yy
  82aaaaaa 0000yyyy  [a0aaaaa]=[a0aaaaa]+yyyy
  84aaaaaa yyyyyyyy  [a0aaaaa]=[a0aaaaa]+yyyyyyyy
  C6aaaaaa 0000yyyy  [4aaaaaa]=yyyy              (I/O Area)
  C7aaaaaa yyyyyyyy  [4aaaaaa]=yyyyyyyy          (I/O Area)
  iiaaaaaa yyyyyyyy  IF [a0aaaaa] &lt;cond&gt; &lt;value&gt; THEN &lt;action&gt;
  00000000 60000000  ELSE (?)
  00000000 40000000  ENDIF (?)
  00000000 0800xx00  AR Slowdown : loops the AR xx times
  00000000 00000000  End of the code list
  00000000 10aaaaaa 000000zz 00000000  IF AR_BUTTON THEN [a0aaaaa]=zz
  00000000 12aaaaaa 0000zzzz 00000000  IF AR_BUTTON THEN [a0aaaaa]=zzzz
  00000000 14aaaaaa zzzzzzzz 00000000  IF AR_BUTTON THEN [a0aaaaa]=zzzzzzzz
  00000000 18aaaaaa 0000zzzz 00000000  [8000000+aaaaaa*2]=zzzz  (ROM Patch 1)
  00000000 1Aaaaaaa 0000zzzz 00000000  [8000000+aaaaaa*2]=zzzz  (ROM Patch 2)
  00000000 1Caaaaaa 0000zzzz 00000000  [8000000+aaaaaa*2]=zzzz  (ROM Patch 3)
  00000000 1Eaaaaaa 0000zzzz 00000000  [8000000+aaaaaa*2]=zzzz  (ROM Patch 4)
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00000000 80aaaaaa 000000yy ssccssss  repeat cc times [a0aaaaa]=yy
   (with yy=yy+ss, a0aaaaa=a0aaaaa+ssss after each step)
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00000000 82aaaaaa 0000yyyy ssccssss  repeat cc times [a0aaaaa]=yyyy
   (with yyyy=yyyy+ss, a0aaaaa=a0aaaaa+ssss*2 after each step)
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00000000 84aaaaaa yyyyyyyy ssccssss  repeat cc times [a0aaaaa]=yyyyyyyy
   (with yyyy=yyyy+ss, a0aaaaa=a0aaaaa+ssss*4 after each step)
</TD></TR></TABLE>
<BR>
Warning: There is a bug on the real AR (v2 upgraded to v3, and maybe on real
v3) with the 32bit Increment Slide code. You HAVE to add a code (best choice is
80000000 00000000 : add 0 to value at address 0) right after it, else the AR
will erase the 2 last 8 digits lines of the 32 Bits Inc. Slide code when you
enter it !!!<BR>
<BR>
Final Notes<BR>
The 'turn off all codes' makes an infinite loop (that can't be broken, unless
the condition becomes True). - How? By Interrupt? Huh?<BR>
ROM Patch1 works on real V3 and, on V1/V2 upgraded to V3.<BR>
ROM Patch2,3,4 work on real V3 hardware only.<BR>
<BR>
<B>Pro Action Replay V3 Conditional Codes - iiaaaaaa yyyyyyyy</B><BR>
The 'ii' is composed of &lt;cond&gt; + &lt;value&gt; + &lt;action&gt;.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  &lt;cond&gt;           &lt;value&gt;            &lt;action&gt;
  08 Equal =       00 8bit zz         00 execute next code
  10 Not equal &lt;&gt;  02 16bit zzzz      40 execute next two codes
  18 Signed &lt;      04 32bit zzzzzzzz  80 execute all following
  20 Signed &gt;      06 (always false)     codes until ELSE or ENDIF
  28 Unsigned &lt;                       C0 normal ELSE turn off all codes
  30 Unsigned &gt;
  38 Logical AND
</TD></TR></TABLE>
For example, ii=18h+02h+40h=5Ah, produces IF [a0aaaaa]&lt;zzzz THEN next 2
codes.<BR>
<BR>
Always... Codes<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  For the "Always..." codes:
  - XXXXXXXX can be any authorised address except 00000000 (eg. use 02000000).
  - ZZZZZZZZ can be anything.
  - The "y" in the code data must be in the [1-7] range (which means not 0).
  typ=y,sub=0,siz=3   Always skip next line.
  typ=y,sub=1,siz=3   Always skip next 2 lines.
  typ=y,sub=2,siz=3   Always Stops executing all the codes below.
  typ=y,sub=3,siz=3   Always turn off all codes.
</TD></TR></TABLE>
<BR>
<B>Code Format (ttaaaaaa xxxxyyzz)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 adr mask = 003FFFFF
 n/a mask = 00C00000 ;not used
 xtr mask = 01000000 ;used only by I/O write, and MSB of Hook
 siz mask = 06000000
 typ mask = 38000000 ;0=normal, other=conditional
 sub mask = C0000000
</TD></TR></TABLE>
<BR>
<B>Pro Action Replay V3 Encryption</B><BR>
Works exactly as for Gameshark Encryption, but with different initial seeds,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  S0=7AA9648Fh S1=7FAE6994h S2=C0EFAAD5h S3=42712C57h
</TD></TR></TABLE>
And, the T1 and T2 translation tables are different, too.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbagameboyplayer"></A>&nbsp;
  GBA Gameboy Player
</FONT></TD></TR></TABLE><BR>
The Gameboy Player is an "adapter" for the Gamecube console. It's basicly is a
GBA in a black box without LCD screen and without buttons, connected to an
expansion port at the bottom of the Gamecube. The Gamecube is then capturing
the GBA video output (and passing it to the television set), and in the other
direction, passing the Gamecube joypad input to the GBA inputs.<BR>
<BR>
<B>Unlocking and Detecting Gameboy Player Functions</B><BR>
Both unlocking and detection requires to display the 240x160 pixel Gameboy
Player logo (44 colors) for a number of frames... maybe at least 3-4 frames?
not sure if it checks the color of the logo... so maybe it can be hidden by
using dark gray on black background?<BR>
While displaying this logo, the joypad data will switch between values 03FFh (2
frames duration) and 030Fh (1 frame duration). The latter value (left, right,
up, down all pressed) indicates that it's a Gameboy Player.<BR>
<BR>
<B>Palette</B><BR>
Knowing Nintendo, they've probably not reproduced the blurred GBA colors (?),
so the games won't look as desired on the TV screen. Unless the game does
detect the Gameboy Player, and adjust the colors accordingly by software.<BR>
<BR>
<B>Rumble</B><BR>
The only known existing special function is the joypad rumble function,
controlled by sending data through the serial port (the normal GBA port, even
though it also has the connectors).<BR>
<BR>
The Game Boy Player added a rumble feature to certain Game Boy Advance games
when played with a GameCube controller. Those games included:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 Drill Dozer (supports BOTH handheld-rumble and GBP-rumble?)
 Mario &amp; Luigi: Superstar Saga
 Pokemon Pinball: Ruby &amp; Sapphire
 Shikakui Atama wo Marukusuru Advance: Kokugo Sansu Rika Shakai
 Shikakui Atama wo Marukusuru Advance: Kanji Keisan
 Summon Night Craft Sword Monogatari: Hajimari no Ishi
 Super Mario Advance 4: Super Mario Bros. 3
</TD></TR></TABLE>
<BR>
Fredrik Olsson (aka Flubba) has implemented rumble in 3 applications now
RumblePong (FluBBA) (homebrew)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Remudvance (FluBBA) (homebrew)
  Goomba (FluBBA) (8bit Gameboy Color Emulator for 32bit GBA) (homebrew)
  and, supposedly in "Tetanus on Drugs" (Tepples) (homebrew)
</TD></TR></TABLE>
<BR>
The GBP can also use some of the extra controllers for the GC like the Bongas<BR>
from Donkey Konga.<BR>
<BR>
The logo requires at least 256 colors, it doesn't matter if you use a tiled<BR>
screen mode or a bitmapped one, the logo can be ripped from either<BR>
"Pokemon Pinball" or "Super Mario Advance 4".<BR>
<BR>
<B>Rumble</B><BR>
After detecting/unlocking the Gameboy Player, init RCNT and SIOCNT to 32bit
normal mode, external clock, SO=high, with IRQ enabled, and set the transfer
start bit. You should then receive the following sequence (about once per
frame), and your serial IRQ handler should send responses accordingly:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Receive  Response
  0000494E 494EB6B1
  xxxx494E 494EB6B1
  B6B1494E 544EB6B1
  B6B1544E 544EABB1
  ABB1544E 4E45ABB1
  ABB14E45 4E45B1BA
  B1BA4E45 4F44B1BA
  B1BA4F44 4F44B0BB
  B0BB4F44 8000B0BB
  B0BB8002 10000010
  10000010 20000013
  20000013 40000004
  30000003 40000004
  30000003 40000004
  30000003 40000004
  30000003 400000yy
  30000003 40000004
</TD></TR></TABLE>
The first part of the transfer just contains the string "NINTENDO" split into
16bit fragments, and bitwise inversions thereof (eg. 494Eh="NI", and B6B1h=NOT
494Eh). In the second part, &lt;yy&gt; should be 04h=RumbleOff, or
26h=RumbleOn.<BR>
<BR>
<B>Note</B><BR>
If it's having a similar range of functions as the 8bit Super Gameboy, then the
Gameboy Player might be also able to access analogue joypad input, and to
access other features of the Gamecube hardware, up to possibly executing code
on the Gamecube CPU...?<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="gbaunpredictablethings"></A>&nbsp;
  GBA Unpredictable Things
</FONT></TD></TR></TABLE><BR>
<B>Forward</B><BR>
Most of the below is caused by 'traces' from previous operations which have
used the databus. No promises that the results are stable on all current or
future GBA models, and/or under all temperature and interference circumstances.<BR>
Also, below specifies 32bit data accesses only. When reading units less than
32bit, data is rotated depending on the alignment of the originally specified
address, and 8bit or 16bit are then isolated from the 32bit value as usually.<BR>
<BR>
<B>Reading from BIOS Memory (00000000-00003FFF)</B><BR>
The BIOS memory is protected against reading, the GBA allows to read opcodes or
data only if the program counter is located inside of the BIOS area. If the
program counter is not in the BIOS area, reading will return the most recent
successfully fetched BIOS opcode (eg. the opcode at [00DCh+8] after startup and
SoftReset, the opcode at [0134h+8] during IRQ execution, and opcode at
[013Ch+8] after IRQ execution, and opcode at [0188h+8] after SWI execution).<BR>
<BR>
<B>Reading from Unused Memory (00004000-01FFFFFF,10000000-FFFFFFFF)</B><BR>
Accessing unused memory at 00004000h-01FFFFFFh, and 10000000h-FFFFFFFFh (and
02000000h-03FFFFFFh when RAM is disabled via Port 4000800h) returns the
recently pre-fetched opcode. For ARM code this is simply:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  WORD = [$+8]
</TD></TR></TABLE>
For THUMB code the result consists of two 16bit fragments and depends on the
address area and alignment where the opcode was stored.<BR>
For THUMB code in Main RAM, Palette Memory, VRAM, and Cartridge ROM this is:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  LSW = [$+4], MSW = [$+4]
</TD></TR></TABLE>
For THUMB code in BIOS or OAM (and in 32K-WRAM on Original-NDS (in GBA mode)):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  LSW = [$+4], MSW = [$+6]   ;for opcodes at 4-byte aligned locations
  LSW = [$+2], MSW = [$+4]   ;for opcodes at non-4-byte aligned locations
</TD></TR></TABLE>
For THUMB code in 32K-WRAM on GBA, GBA SP, GBA Micro, NDS-Lite (but not NDS):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  LSW = [$+4], MSW = OldHI   ;for opcodes at 4-byte aligned locations
  LSW = OldLO, MSW = [$+4]   ;for opcodes at non-4-byte aligned locations
</TD></TR></TABLE>
Whereas OldLO/OldHI are usually:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  OldLO=[$+2], OldHI=[$+2]
</TD></TR></TABLE>
Unless the previous opcode's prefetch was overwritten; that can happen if the
previous opcode was itself an LDR opcode, ie. if it was itself reading data:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  OldLO=LSW(data), OldHI=MSW(data)
  Theoretically, this might also change if a DMA transfer occurs.
</TD></TR></TABLE>
Note: Additionally, as usually, the 32bit data value will be rotated if the
data address wasn't 4-byte aligned, and the upper bits of the 32bit value will
be masked in case of LDRB/LDRH reads.<BR>
Note: The opcode prefetch is caused by the prefetch pipeline in the CPU itself,
not by the external gamepak prefetch, ie. it works for code in ROM and RAM as
well.<BR>
<BR>
<B>Reading from Unused or Write-Only I/O Ports</B><BR>
Works like above Unused Memory when the entire 32bit memory fragment is Unused
(eg. 0E0h) and/or Write-Only (eg. DMA0SAD). And otherwise, returns zero if the
lower 16bit fragment is readable (eg. 04Ch=MOSAIC, 04Eh=NOTUSED/ZERO).<BR>
<BR>
<B>Reading from GamePak ROM when no Cartridge is inserted</B><BR>
Because Gamepak uses the same signal-lines for both 16bit data and for lower
16bit halfword address, the entire gamepak ROM area is effectively filled by
incrementing 16bit values (Address/2 AND FFFFh).<BR>
<BR>
<B>Memory Mirrors</B><BR>
Most internal memory is mirrored across the whole 24bit/16MB address space in
which it is located: Slow On-board RAM at 2XXXXXX, Fast On-Chip RAM at
3XXXXXXh, Palette RAM at 5XXXXXXh, VRAM at 6XXXXXXh, and OAM at 7XXXXXXh. Even
though VRAM is sized 96K (64K+32K), it is repeated in steps of 128K
(64K+32K+32K, the two 32K blocks itself being mirrors of each other).<BR>
BIOS ROM, Normal ROM Cartridges, and I/O area are NOT mirrored, the only
exception is the undocumented I/O port at 4000800h (repeated each 64K).<BR>
The 64K SRAM area is mirrored across the whole 32MB area at E000000h-FFFFFFFh,
also, inside of the 64K SRAM field, 32K SRAM chips are repeated twice.<BR>
<BR>
<B>Writing 8bit Data to Video Memory</B><BR>
Video Memory (BG, OBJ, OAM, Palette) can be written to in 16bit and 32bit units
only. Attempts to write 8bit data (by STRB opcode) won't work:<BR>
Writes to OBJ (6010000h-6017FFFh) (or 6014000h-6017FFFh in Bitmap mode) and to
OAM (7000000h-70003FFh) are ignored, the memory content remains unchanged.<BR>
Writes to BG (6000000h-600FFFFh) (or 6000000h-6013FFFh in Bitmap mode) and to
Palette (5000000h-50003FFh) are writing the new 8bit value to BOTH upper and
lower 8bits of the addressed halfword, ie. "[addr AND NOT 1]=data*101h".<BR>
<BR>
<B>Using Invalid Tile Numbers</B><BR>
In Text mode, large tile numbers (combined with a non-zero character base
setting in BGnCNT register) may exceed the available 64K of BG VRAM.<BR>
On GBA and GBA SP, such invalid tiles are displayed as if the character data is
filled by the 16bit BG Map entry value (ie. as vertically striped tiles). Above
applies only if there is only one BG layer enabled, with two or more layers,
things are getting much more complicated: tile-data is then somehow derived
from the other layers, depending on their priority order and scrolling offsets.<BR>
On NDS (in GBA mode), such invalid tiles are displayed as if the character data
is zero-filled (ie. as invisible/transparent tiles).<BR>
<BR>
<B>Accessing SRAM Area by 16bit/32bit</B><BR>
Reading retrieves 8bit value from specified address, multiplied by 0101h (LDRH)
or by 01010101h (LDR). Writing changes the 8bit value at the specified address
only, being set to LSB of (source_data ROR (address*8)).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="ndsreference"></A>&nbsp;
  NDS Reference
</FONT></TD></TR></TABLE><BR>
<B>Overview</B><BR>
<A HREF="#dstechnicaldata">DS Technical Data</A><BR>
<A HREF="#dsiomaps">DS I/O Maps</A><BR>
<A HREF="#dsmemorymaps">DS Memory Maps</A><BR>
<BR>
<B>Hardware Programming</B><BR>
<A HREF="#dsmemorycontrol">DS Memory Control</A><BR>
<A HREF="#dsvideo">DS Video</A><BR>
<A HREF="#ds3dvideo">DS 3D Video</A><BR>
<A HREF="#dssound">DS Sound</A><BR>
<A HREF="#dssystemandbuiltinperipherals">DS System and Built-in Peripherals</A><BR>
<A HREF="#dscartridgesencryptionfirmware">DS Cartridges, Encryption, Firmware</A><BR>
<A HREF="#dsxboo">DS Xboo</A><BR>
<A HREF="#dswirelesscommunications">DS Wireless Communications</A><BR>
<BR>
<B>Other</B><BR>
<A HREF="#biosfunctions">BIOS Functions</A><BR>
<A HREF="#armcpureference">ARM CPU Reference</A><BR>
<A HREF="#externalconnectors">External Connectors</A><BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dstechnicaldata"></A>&nbsp;
  DS Technical Data
</FONT></TD></TR></TABLE><BR>
<B>Processors</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1x ARM946E-S 32bit RISC CPU, 66MHz (NDS9 video) (not used in GBA mode)
  1x ARM7TDMI  32bit RISC CPU, 33MHz (NDS7 sound) (16MHz in GBA mode)
</TD></TR></TABLE>
<B>Internal Memory</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4096KB Main RAM (8192KB in debug version)
  96KB   WRAM (64K mapped to NDS7, plus 32K mappable to NDS7 or NDS9)
  60KB   TCM/Cache (TCM: 16K Data, 32K Code) (Cache: 4K Data, 8K Code)
  656KB  VRAM (allocateable as BG/OBJ/2D/3D/Palette/Texture/WRAM memory)
  4KB    OAM/PAL (2K OBJ Attribute Memory, 2K Standard Palette RAM)
  248KB  Internal 3D Memory (104K Polygon RAM, 144K Vertex RAM)
  ?KB    Matrix Stack, 48 scanline cache
  8KB    Wifi RAM
  256KB  Firmware FLASH (512KB in iQue variant, with chinese charset)
  36KB   BIOS ROM (4K NDS9, 16K NDS7, 16K GBA)
</TD></TR></TABLE>
<B>Video</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  2x LCD screens (each 256x192 pixel, 3 inch, 18bit color depth, backlight)
  2x 2D video engines (extended variants of the GBA's video controller)
  1x 3D video engine (can be assigned to upper or lower screen)
  1x video capture (for effects, or for forwarding 3D to the 2nd 2D engine)
</TD></TR></TABLE>
<B>Sound</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  16 sound channels (16x PCM8/PCM16/IMA-ADPCM, 6x PSG-Wave, 2x PSG-Noise)
  2 sound capture units (for echo effects, etc.)
  Output: Two built-in stereo speakers, and headphones socket
  Input:  One built-in microphone, and microphone socket
</TD></TR></TABLE>
<B>Controls</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Gamepad      4 Direction Keys, 8 Buttons
  Touchscreen  (on lower LCD screen)
</TD></TR></TABLE>
<B>Communication Ports</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Wifi IEEE802.11b
</TD></TR></TABLE>
<B>Specials</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Built-in Real Time Clock
  Power Managment Device
  Hardware divide and square root functions
  CP15 System Control Coprocessor (cache, tcm, pu, bist, etc.)
</TD></TR></TABLE>
<B>External Memory</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  NDS Slot (for NDS games) (encrypted 8bit data bus, and serial 1bit bus)
  GBA Slot (for NDS expansions, or for GBA games) (but not for DMG/CGB games)
</TD></TR></TABLE>
<B>Manufactured Cartridges</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ROM: 16MB, 32MB, or 64MB
  EEPROM/FLASH/FRAM: 0.5KB, 8KB, 64KB, 256KB, or 512KB
</TD></TR></TABLE>
<B>Can be booted from</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  NDS Cartridge (NDS mode)
  Firmware FLASH (NDS mode) (eg. by patching firmware via ds-xboo cable)
  Wifi (NDS mode)
  GBA Cartridge (GBA mode) (without DMG/CGB support) (without SIO support)
</TD></TR></TABLE>
<B>Power Supply</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Built-in rechargeable Lithium ion battery, 3.7V 1000mAh (DS-Lite)
  External Supply: 5.2V DC
</TD></TR></TABLE>
<BR>
<B>NDS-Lite</B><BR>
Slightly smaller than the original NDS, coming in a more decently elegant case.
The LCDs are much more colorful (and thus not backwards compatible with any
older NDS or GBA games), and the LCDs support wider viewing angles. Slightly
different power managment device (with selectable backlight brightness, new
external power source flag, lost audio amplifier mute flag). Slightly different
Wifi controller (different chip ID, different dirt effects when accessing
invalid wifi ports and unused wifi memory regions, different behaviour on
GAPDISP registers, RF/BB chips replaced by a single chip). Slightly different
touch screen controller (with new unused input, and slightly different
powerdown bits).<BR>
<BR>
<B>Notice</B><BR>
NDS9 means the ARM9 processor and its memory and I/O ports in NDS mode<BR>
NDS7 means the ARM7 processor and its memory and I/O ports in NDS mode<BR>
GBA means the ARM7 processor and its memory and I/O ports in GBA mode<BR>
<BR>
<B>The two Processors</B><BR>
Most game code is usually executed on the ARM9 processor (in fact, Nintendo
reportedly doesn't allow developers use the ARM7 processor, except by
predefined API functions, anyways, even with the most likely inefficient API
code, most of the ARM7's 33MHz horsepower is left unused).<BR>
The ARM9's 66MHz "horsepower" is a different tale - it seems Nintendo thought
that a 33MHz processor would be too "slow" for 3D games, and so they (tried to)
badge an additional CPU to the original GBA hardware.<BR>
However, the real 66MHz can be used only with cache and tcm, all other memory
and I/O accesses are delayed to the 33MHz bus clock, that'd be still quite
fast, but, there seems to be a hardware glitch that adds 3 waitcycles to all
nonsequential accesses at the NDS9 side, which effectively drops its bus clock
to about 8MHz, making it ways slower than the 33MHz NDS7 processor, it's even
slower than the original 16MHz GBA processor.<BR>
Altogether, with the bugged 66MHz, and the unused 33MHz, Nintendo could have
reached almost the same power when staying with the GBA's 16MHz processor :-)<BR>
Although, when properly using cache/tcm, then the 66MHz processor &lt;can&gt;
be very fast, still, the NDS should have worked as well with a single
processor, though using only an ARM9 might cause a lot of compatibility
problems with GBA games, so there's at least one reason for keeping the ARM7
included.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsiomaps"></A>&nbsp;
  DS I/O Maps
</FONT></TD></TR></TABLE><BR>
ARM9 I/O Map<BR>
<B>ARM9 Display Engine A</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4000000h  4    2D Engine A - DISPCNT - LCD Control (Read/Write)
  4000004h  2    2D Engine A+B - DISPSTAT - General LCD Status (Read/Write)
  4000006h  2    2D Engine A+B - VCOUNT - Vertical Counter (Read only)
  4000008h  50h  2D Engine A (same registers as GBA, some changed bits)
  4000060h  2    DISP3DCNT - 3D Display Control Register (R/W)
  4000064h  4    DISPCAPCNT - Display Capture Control Register (R/W)
  4000068h  4    DISP_MMEM_FIFO - Main Memory Display FIFO (R?/W)
  400006Ch  2    2D Engine A - MASTER_BRIGHT - Master Brightness Up/Down
</TD></TR></TABLE>
<A HREF="#gbaiomap">GBA I/O Map</A><BR>
<B>ARM9 DMA, Timers, and Keypad</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  40000B0h  30h  DMA Channel 0..3
  40000E0h  10h  DMA FILL Registers for Channel 0..3
  4000100h  10h  Timers 0..3
  4000130h  2    KEYINPUT
  4000132h  2    KEYCNT
</TD></TR></TABLE>
<B>ARM9 IPC/ROM</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4000180h  2  IPCSYNC - IPC Synchronize Register (R/W)
  4000184h  2  IPCFIFOCNT - IPC Fifo Control Register (R/W)
  4000188h  4  IPCFIFOSEND - IPC Send Fifo (W)
  40001A0h  2  AUXSPICNT - Gamecard ROM and SPI Control
  40001A2h  2  AUXSPIDATA - Gamecard SPI Bus Data/Strobe
  40001A4h  4  Gamecard bus timing/control
  40001A8h  8  Gamecard bus 8-byte command out
  40001B0h  4  Gamecard Encryption Seed 0 Lower 32bit
  40001B4h  4  Gamecard Encryption Seed 1 Lower 32bit
  40001B8h  2  Gamecard Encryption Seed 0 Upper 7bit (bit7-15 unused)
  40001BAh  2  Gamecard Encryption Seed 1 Upper 7bit (bit7-15 unused)
</TD></TR></TABLE>
<B>ARM9 Memory and IRQ Control</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4000204h  2  EXMEMCNT - External Memory Control (R/W)
  4000208h  2  IME - Interrupt Master Enable (R/W)
  4000210h  4  IE  - Interrupt Enable (R/W)
  4000214h  4  IF  - Interrupt Request Flags (R/W)
  4000240h  1  VRAMCNT_A - VRAM-A (128K) Bank Control (W)
  4000241h  1  VRAMCNT_B - VRAM-B (128K) Bank Control (W)
  4000242h  1  VRAMCNT_C - VRAM-C (128K) Bank Control (W)
  4000243h  1  VRAMCNT_D - VRAM-D (128K) Bank Control (W)
  4000244h  1  VRAMCNT_E - VRAM-E (64K) Bank Control (W)
  4000245h  1  VRAMCNT_F - VRAM-F (16K) Bank Control (W)
  4000246h  1  VRAMCNT_G - VRAM-G (16K) Bank Control (W)
  4000247h  1  WRAMCNT   - WRAM Bank Control (W)
  4000248h  1  VRAMCNT_H - VRAM-H (32K) Bank Control (W)
  4000249h  1  VRAMCNT_I - VRAM-I (16K) Bank Control (W)
</TD></TR></TABLE>
<B>ARM9 Maths</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4000280h  2  DIVCNT - Division Control (R/W)
  4000290h  8  DIV_NUMER - Division Numerator (R/W)
  4000298h  8  DIV_DENOM - Division Denominator (R/W)
  40002A0h  8  DIV_RESULT - Division Quotient (=Numer/Denom) (R)
  40002A8h  8  DIVREM_RESULT - Division Remainder (=Numer MOD Denom) (R)
  40002B0h  2  SQRTCNT - Square Root Control (R/W)
  40002B4h  4  SQRT_RESULT - Square Root Result (R)
  40002B8h  8  SQRT_PARAM - Square Root Parameter Input (R/W)
  4000300h  4  POSTFLG - Undoc
  4000304h  2  POWCNT1 - Graphics Power Control Register (R/W)
</TD></TR></TABLE>
<B>ARM9 3D Display Engine</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4000320h..6A3h
</TD></TR></TABLE>
<A HREF="#ds3diomap">DS 3D I/O Map</A><BR>
<B>ARM9 Display Engine B</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4001000h  4    2D Engine B - DISPCNT - LCD Control (Read/Write)
  4001008h  50h  2D Engine B (same registers as GBA, some changed bits)
  400106Ch  2    2D Engine B - MASTER_BRIGHT - 16bit - Brightness Up/Down
</TD></TR></TABLE>
<B>ARM9 DSi Extra Registers</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  40021Axh  ..  DSi Registers
  4004xxxh  ..  DSi Registers
</TD></TR></TABLE>
<B>ARM9 IPC/ROM</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4100000h  4    IPCFIFORECV - IPC Receive Fifo (R)
  4100010h  4    Gamecard bus 4-byte data in, for manual or dma read
</TD></TR></TABLE>
<B>ARM9 DS Debug Registers (Emulator/Devkits)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4FFF0xxh  ..   Ensata Emulator Debug Registers
  4FFFAxxh  ..   No$gba Emulator Debug Registers
</TD></TR></TABLE>
<B>ARM9 Hardcoded RAM Addresses for Exception Handling</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  27FFD9Ch   ..  NDS9 Debug Stacktop / Debug Vector (0=None)
  DTCM+3FF8h 4   NDS9 IRQ Check Bits (hardcoded RAM address)
  DTCM+3FFCh 4   NDS9 IRQ Handler (hardcoded RAM address)
</TD></TR></TABLE>
<B>Main Memory Control</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  27FFFFEh  2    Main Memory Control
</TD></TR></TABLE>
<B>Further Memory Control Registers</B><BR>
<A HREF="#armcp15systemcontrolcoprocessor">ARM CP15 System Control Coprocessor</A><BR>
<BR>
<B>ARM7 I/O Map</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4000004h  2   DISPSTAT
  4000006h  2   VCOUNT
  40000B0h  30h DMA Channels 0..3
  4000100h  10h Timers 0..3
  4000120h  4   Debug SIODATA32
  4000128h  4   Debug SIOCNT
  4000130h  2   keyinput
  4000132h  2   keycnt
  4000134h  2   Debug RCNT
  4000136h  2   EXTKEYIN
  4000138h  1   RTC Realtime Clock Bus
  4000180h  2   IPCSYNC - IPC Synchronize Register (R/W)
  4000184h  2   IPCFIFOCNT - IPC Fifo Control Register (R/W)
  4000188h  4   IPCFIFOSEND - IPC Send Fifo (W)
  40001A0h  2   AUXSPICNT - Gamecard ROM and SPI Control
  40001A2h  2   AUXSPIDATA - Gamecard SPI Bus Data/Strobe
  40001A4h  4   Gamecard bus timing/control
  40001A8h  8   Gamecard bus 8-byte command out
  40001B0h  4   Gamecard Encryption Seed 0 Lower 32bit
  40001B4h  4   Gamecard Encryption Seed 1 Lower 32bit
  40001B8h  2   Gamecard Encryption Seed 0 Upper 7bit (bit7-15 unused)
  40001BAh  2   Gamecard Encryption Seed 1 Upper 7bit (bit7-15 unused)
  40001C0h  2   SPI bus Control (Firmware, Touchscreen, Powerman)
  40001C2h  2   SPI bus Data
</TD></TR></TABLE>
<B>ARM7 Memory and IRQ Control</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4000204h  2   EXMEMSTAT - External Memory Status
  4000206h  2   WIFIWAITCNT
  4000208h  4   IME - Interrupt Master Enable (R/W)
  4000210h  4   IE  - Interrupt Enable (R/W)
  4000214h  4   IF  - Interrupt Request Flags (R/W)
  4000218h  -   IE2  ;\DSi only (additional ARM7 interrupt sources)
  400021Ch  -   IF2  ;/
  4000240h  1   VRAMSTAT - VRAM-C,D Bank Status (R)
  4000241h  1   WRAMSTAT - WRAM Bank Status (R)
  4000300h  1   POSTFLG
  4000301h  1   HALTCNT (different bits than on GBA) (plus NOP delay)
  4000304h  2   POWCNT2  Sound/Wifi Power Control Register (R/W)
  4000308h  4   BIOSPROT - Bios-data-read-protection address
</TD></TR></TABLE>
<B>ARM7 Sound Registers</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4000400h 100h Sound Channel 0..15 (10h bytes each)
  40004x0h  4   SOUNDxCNT - Sound Channel X Control Register (R/W)
  40004x4h  4   SOUNDxSAD - Sound Channel X Data Source Register (W)
  40004x8h  2   SOUNDxTMR - Sound Channel X Timer Register (W)
  40004xAh  2   SOUNDxPNT - Sound Channel X Loopstart Register (W)
  40004xCh  4   SOUNDxLEN - Sound Channel X Length Register (W)
  4000500h  2   SOUNDCNT - Sound Control Register (R/W)
  4000504h  2   SOUNDBIAS - Sound Bias Register (R/W)
  4000508h  1   SNDCAP0CNT - Sound Capture 0 Control Register (R/W)
  4000509h  1   SNDCAP1CNT - Sound Capture 1 Control Register (R/W)
  4000510h  4   SNDCAP0DAD - Sound Capture 0 Destination Address (R/W)
  4000514h  2   SNDCAP0LEN - Sound Capture 0 Length (W)
  4000518h  4   SNDCAP1DAD - Sound Capture 1 Destination Address (R/W)
  400051Ch  2   SNDCAP1LEN - Sound Capture 1 Length (W)
</TD></TR></TABLE>
<B>ARM7 DSi Extra Registers</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  40021Axh  ..  DSi Registers
  4004xxxh  ..  DSi Registers
  4004700h  2   DSi SNDEXCNT Register  ;\mapped even in DS mode
  4004C0xh  ..  DSi GPIO Registers     ;/
</TD></TR></TABLE>
<B>ARM7 IPC/ROM</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4100000h  4   IPCFIFORECV - IPC Receive Fifo (R)
  4100010h  4   Gamecard bus 4-byte data in, for manual or dma read
</TD></TR></TABLE>
<B>ARM7 WLAN Registers</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4800000h  ..  Wifi WS0 Region (32K) (Wifi Ports, and 8K Wifi RAM)
  4808000h  ..  Wifi WS1 Region (32K) (mirror of above, other waitstates)
</TD></TR></TABLE>
<B>ARM7 Hardcoded RAM Addresses for Exception Handling</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  380FFC0h  4   DSi7 IRQ IF2 Check Bits (hardcoded RAM address) (DSi only)
  380FFDCh  ..  NDS7 Debug Stacktop / Debug Vector (0=None)
  380FFF8h  4   NDS7 IRQ IF Check Bits (hardcoded RAM address)
  380FFFCh  4   NDS7 IRQ Handler (hardcoded RAM address)
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsmemorymaps"></A>&nbsp;
  DS Memory Maps
</FONT></TD></TR></TABLE><BR>
<B>NDS9 Memory Map</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00000000h  Instruction TCM (32KB) (not moveable) (mirror-able to 1000000h)
  0xxxx000h  Data TCM        (16KB) (moveable)
  02000000h  Main Memory     (4MB)
  03000000h  Shared WRAM     (0KB, 16KB, or 32KB can be allocated to ARM9)
  04000000h  ARM9-I/O Ports
  05000000h  Standard Palettes (2KB) (Engine A BG/OBJ, Engine B BG/OBJ)
  06000000h  VRAM - Engine A, BG VRAM  (max 512KB)
  06200000h  VRAM - Engine B, BG VRAM  (max 128KB)
  06400000h  VRAM - Engine A, OBJ VRAM (max 256KB)
  06600000h  VRAM - Engine B, OBJ VRAM (max 128KB)
  06800000h  VRAM - "LCDC"-allocated (max 656KB)
  07000000h  OAM (2KB) (Engine A, Engine B)
  08000000h  GBA Slot ROM (max 32MB)
  0A000000h  GBA Slot RAM (max 64KB)
  FFFF0000h  ARM9-BIOS (32KB) (only 3K used)
</TD></TR></TABLE>
The ARM9 Exception Vectors are located at FFFF0000h. The IRQ handler redirects
to [DTCM+3FFCh].<BR>
<BR>
<B>NDS7 Memory Map</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00000000h  ARM7-BIOS (16KB)
  02000000h  Main Memory (4MB)
  03000000h  Shared WRAM (0KB, 16KB, or 32KB can be allocated to ARM7)
  03800000h  ARM7-WRAM (64KB)
  04000000h  ARM7-I/O Ports
  04800000h  Wireless Communications Wait State 0 (8KB RAM at 4804000h)
  04808000h  Wireless Communications Wait State 1 (I/O Ports at 4808000h)
  06000000h  VRAM allocated as Work RAM to ARM7 (max 256K)
  08000000h  GBA Slot ROM (max 32MB)
  0A000000h  GBA Slot RAM (max 64KB)
</TD></TR></TABLE>
The ARM7 Exception Vectors are located at 00000000h. The IRQ handler redirects
to [3FFFFFCh aka 380FFFCh].<BR>
<BR>
<B>Further Memory (not mapped to ARM9/ARM7 bus)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  3D Engine Polygon RAM (52KBx2)
  3D Engine Vertex RAM (72KBx2)
  Firmware (256KB) (built-in serial flash memory)
  GBA-BIOS (16KB) (not used in NDS mode)
  NDS Slot ROM (serial 8bit-bus, max 4GB with default protocol)
  NDS Slot FLASH/EEPROM/FRAM (serial 1bit-bus)
</TD></TR></TABLE>
<BR>
<B>Shared-RAM</B><BR>
Even though Shared WRAM begins at 3000000h, programs are commonly using mirrors
at 37F8000h (both ARM9 and ARM7). At the ARM7-side, this allows to use 32K
Shared WRAM and 64K ARM7-WRAM as a continous 96K RAM block.<BR>
<BR>
<B>Undefined I/O Ports</B><BR>
On the NDS (at the ARM9-side at least) undefined I/O ports are always zero.<BR>
<BR>
<B>Undefined Memory Regions</B><BR>
16MB blocks that do not contain any defined memory regions (or that contain
only mapped TCM regions) are typically completely undefined.<BR>
16MB blocks that do contain valid memory regions are typically containing
mirrors of that memory in the unused upper part of the 16MB area (only
exceptions are TCM and BIOS which are not mirrored).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsmemorycontrol"></A>&nbsp;
  DS Memory Control
</FONT></TD></TR></TABLE><BR>
<B>Memory Control</B><BR>
<A HREF="#dsmemorycontrolcacheandtcm">DS Memory Control - Cache and TCM</A><BR>
<A HREF="#dsmemorycontrolcartridgesandmainram">DS Memory Control - Cartridges and Main RAM</A><BR>
<A HREF="#dsmemorycontrolwram">DS Memory Control - WRAM</A><BR>
<A HREF="#dsmemorycontrolvram">DS Memory Control - VRAM</A><BR>
<A HREF="#dsmemorycontrolbios">DS Memory Control - BIOS</A><BR>
<BR>
<B>Memory Access Time</B><BR>
<A HREF="#dsmemorytimings">DS Memory Timings</A><BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsmemorycontrolcacheandtcm"></A>&nbsp;
  DS Memory Control - Cache and TCM
</FONT></TD></TR></TABLE><BR>
TCM and Cache are controlled by the System Control Coprocessor,<BR>
<A HREF="#armcp15systemcontrolcoprocessor">ARM CP15 System Control Coprocessor</A><BR>
<BR>
The specifications for the NDS9 are:<BR>
<BR>
<B>Tightly Coupled Memory (TCM)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ITCM 32K, base=00000000h (fixed, not move-able)
  DTCM 16K, base=moveable  (default base=27C0000h)
</TD></TR></TABLE>
Note: Although ITCM is NOT moveable, the NDS Firmware configures the ITCM size
to 32MB, and so, produces ITCM mirrors at 0..1FFFFFFh. Furthermore, the PU can
be used to lock/unlock memory in that region. That trick allows to move ITCM
anywhere within the lower 32MB of memory.<BR>
<BR>
<B>Cache</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Data Cache 4KB, Instruction Cache 8KB
  4-way set associative method
  Cache line 8 words (32 bytes)
  Read-allocate method (ie. writes are not allocating cache lines)
  Round-robin and Pseudo-random replacement algorithms selectable
  Cache Lockdown, Instruction Prefetch, Data Preload
  Data write-through and write-back modes selectable
</TD></TR></TABLE>
<BR>
<B>Protection Unit (PU)</B><BR>
Recommended/default settings are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Region  Name            Address   Size   Cache WBuf Code Data
  -       Background      00000000h 4GB    -     -    -    -
  0       I/O and VRAM    04000000h 64MB   -     -    R/W  R/W
  1       Main Memory     02000000h 4MB    On    On   R/W  R/W
  2       ARM7-dedicated  027C0000h 256KB  -     -    -    -
  3       GBA Slot        08000000h 128MB  -     -    -    R/W
  4       DTCM            027C0000h 16KB   -     -    -    R/W
  5       ITCM            01000000h 32KB   -     -    R/W  R/W
  6       BIOS            FFFF0000h 32KB   On    -    R    R
  7       Shared Work     027FF000h 4KB    -     -    -    R/W
</TD></TR></TABLE>
Notes: In Nintendo's hardware-debugger, Main Memory is expanded to 8MB (for
that reason, some addresses are at 27NN000h instead 23NN000h) (some of the
extra memory is reserved for the debugger, some can be used for game
development). Region 2 and 7 are not understood? GBA Slot should be max
32MB+64KB, rounded up to 64MB, no idea why it is 128MB? DTCM and ITCM do not
use Cache and Write-Buffer because TCM is fast. Above settings do not allow to
access Shared Memory at 37F8000h? Do not use cache/wbuf for I/O, doing so might
suppress writes, and/or might read outdated values.<BR>
The main purpose of the Protection Unit is debugging, a major problem with GBA
programs have been faulty accesses to memory address 00000000h and up (due to
[base+offset] addressing with uninitialized (zero) base values). This problem
has been fixed in the NDS, for the ARM9 processor at least, still there are
various leaks: For example, the 64MB I/O and VRAM area contains only ca. 660KB
valid addresses, and the ARM7 probably doesn't have a Protection Unit at all.
Alltogether, the protection is better than in GBA, but it's still pretty crude
compared with software debugging tools.<BR>
Region address/size are unified (same for code and data), however, cachabilty
and access rights are non-unified (and may be separately defined for code and
data).<BR>
<BR>
Note: The NDS7 doesn't have any TCM, Cache, or CP15.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsmemorycontrolcartridgesandmainram"></A>&nbsp;
  DS Memory Control - Cartridges and Main RAM
</FONT></TD></TR></TABLE><BR>
<B>4000204h - NDS9 - EXMEMCNT - 16bit - External Memory Control (R/W)</B><BR>
<B>4000204h - NDS7 - EXMEMSTAT - 16bit - External Memory Status (R/W..R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-1   32-pin GBA Slot SRAM Access Time    (0-3 = 10, 8, 6, 18 cycles)
  2-3   32-pin GBA Slot ROM 1st Access Time (0-3 = 10, 8, 6, 18 cycles)
  4     32-pin GBA Slot ROM 2nd Access Time (0-1 = 6, 4 cycles)
  5-6   32-pin GBA Slot PHI-pin out   (0-3 = Low, 4.19MHz, 8.38MHz, 16.76MHz)
  7     32-pin GBA Slot Access Rights     (0=ARM9, 1=ARM7)
  8-10  Not used (always zero)
  11    17-pin NDS Slot Access Rights     (0=ARM9, 1=ARM7)
  12    Not used (always zero)
  13    Not used (always set ?)
  14    Main Memory Interface Mode Switch (0=Async/GBA/Reserved, 1=Synchronous)
  15    Main Memory Access Priority       (0=ARM9 Priority, 1=ARM7 Priority)
</TD></TR></TABLE>
Bit0-6 can be changed by both NDS9 and NDS7, changing these bits affects the
local EXMEM register only, not that of the other CPU.<BR>
Bit7-15 can be changed by NDS9 only, changing these bits affects both EXMEM
registers, ie. both NDS9 and NDS7 can read the current NDS9 setting.<BR>
Bit14=0 is intended for GBA mode, however, writes to this bit appear to be
ignored?<BR>
<A HREF="#dsmainmemorycontrol">DS Main Memory Control</A><BR>
<BR>
<B>GBA Slot (8000000h-AFFFFFFh)</B><BR>
The GBA Slot can be mapped to ARM9 or ARM7 via EXMEMCNT.7.<BR>
For the selected CPU, memory at 8000000h-9FFFFFFh contains the "GBA ROM"
region, and memory at A000000h-AFFFFFFh contains the "GBA SRAM" region
(repeated every 64Kbytes). If there is no cartridge in GBA Slot, then the
ROM/SRAM regions will contain open-bus values: SRAM region is FFh-filled
(High-Z). And ROM region is filled by increasing 16bit values (Addr/2),
possibly ORed with garbage depending on the selected ROM Access Time:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  6 clks   --&gt; returns "Addr/2"
  8 clks   --&gt; returns "Addr/2"
  10 clks  --&gt; returns "Addr/2 OR FE08h" (or similar garbage)
  18 clks  --&gt; returns "FFFFh" (High-Z)
</TD></TR></TABLE>
For the deselected CPU, all memory at 8000000h-AFFFFFFh becomes 00h-filled,
this is required for bugged games like Digimon Story: Super Xros Wars (which is
accidently reading deselected GBA SRAM at [main_ram_base+main_ram_addr*4],
whereas it does presumably want to read Main RAM at [main_ram_base+index*4]).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsmemorycontrolwram"></A>&nbsp;
  DS Memory Control - WRAM
</FONT></TD></TR></TABLE><BR>
<B>4000247h - NDS9 - WRAMCNT - 8bit - WRAM Bank Control (R/W)</B><BR>
<B>4000241h - NDS7 - WRAMSTAT - 8bit - WRAM Bank Status (R)</B><BR>
Should not be changed when using Nintendo's API.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-1   ARM9/ARM7 (0-3 = 32K/0K, 2nd 16K/1st 16K, 1st 16K/2nd 16K, 0K/32K)
  2-7   Not used
</TD></TR></TABLE>
The ARM9 WRAM area is 3000000h-3FFFFFFh (16MB range).<BR>
The ARM7 WRAM area is 3000000h-37FFFFFh (8MB range).<BR>
The allocated 16K or 32K are mirrored everywhere in the above areas.<BR>
De-allocation (0K) is a special case: At the ARM9-side, the WRAM area is then
empty (containing undefined data). At the ARM7-side, the WRAM area is then
containing mirrors of the 64KB ARM7-WRAM (the memory at 3800000h and up).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsmemorycontrolvram"></A>&nbsp;
  DS Memory Control - VRAM
</FONT></TD></TR></TABLE><BR>
<B>4000240h - NDS7 - VRAMSTAT - 8bit - VRAM Bank Status (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     VRAM C enabled and allocated to NDS7  (0=No, 1=Yes)
  1     VRAM D enabled and allocated to NDS7  (0=No, 1=Yes)
  2-7   Not used (always zero)
</TD></TR></TABLE>
The register indicates if VRAM C/D are allocated to NDS7 (as Work RAM), ie. if
VRAMCNT_C/D are enabled (Bit7=1), with MST=2 (Bit0-2). However, it does not
reflect the OFS value.<BR>
<BR>
<B>4000240h - NDS9 - VRAMCNT_A - 8bit - VRAM-A (128K) Bank Control (W)</B><BR>
<B>4000241h - NDS9 - VRAMCNT_B - 8bit - VRAM-B (128K) Bank Control (W)</B><BR>
<B>4000242h - NDS9 - VRAMCNT_C - 8bit - VRAM-C (128K) Bank Control (W)</B><BR>
<B>4000243h - NDS9 - VRAMCNT_D - 8bit - VRAM-D (128K) Bank Control (W)</B><BR>
<B>4000244h - NDS9 - VRAMCNT_E - 8bit - VRAM-E (64K) Bank Control (W)</B><BR>
<B>4000245h - NDS9 - VRAMCNT_F - 8bit - VRAM-F (16K) Bank Control (W)</B><BR>
<B>4000246h - NDS9 - VRAMCNT_G - 8bit - VRAM-G (16K) Bank Control (W)</B><BR>
<B>4000248h - NDS9 - VRAMCNT_H - 8bit - VRAM-H (32K) Bank Control (W)</B><BR>
<B>4000249h - NDS9 - VRAMCNT_I - 8bit - VRAM-I (16K) Bank Control (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-2   VRAM MST              ;Bit2 not used by VRAM-A,B,H,I
  3-4   VRAM Offset (0-3)     ;Offset not used by VRAM-E,H,I
  5-6   Not used
  7     VRAM Enable (0=Disable, 1=Enable)
</TD></TR></TABLE>
There is a total of 656KB of VRAM in Blocks A-I.<BR>
Table below shows the possible configurations.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
<B>  VRAM    SIZE  MST  OFS   ARM9, Plain ARM9-CPU Access (so-called LCDC mode)</B>
  A       128K  0    -     6800000h-681FFFFh
  B       128K  0    -     6820000h-683FFFFh
  C       128K  0    -     6840000h-685FFFFh
  D       128K  0    -     6860000h-687FFFFh
  E       64K   0    -     6880000h-688FFFFh
  F       16K   0    -     6890000h-6893FFFh
  G       16K   0    -     6894000h-6897FFFh
  H       32K   0    -     6898000h-689FFFFh
  I       16K   0    -     68A0000h-68A3FFFh
<B>  VRAM    SIZE  MST  OFS   ARM9, 2D Graphics Engine A, BG-VRAM (max 512K)</B>
  A,B,C,D 128K  1    0..3  6000000h+(20000h*OFS)
  E       64K   1    -     6000000h
  F,G     16K   1    0..3  6000000h+(4000h*OFS.0)+(10000h*OFS.1)
<B>  VRAM    SIZE  MST  OFS   ARM9, 2D Graphics Engine A, OBJ-VRAM (max 256K)</B>
  A,B     128K  2    0..1  6400000h+(20000h*OFS.0)  ;(OFS.1 must be zero)
  E       64K   2    -     6400000h
  F,G     16K   2    0..3  6400000h+(4000h*OFS.0)+(10000h*OFS.1)
<B>  VRAM    SIZE  MST  OFS   2D Graphics Engine A, BG Extended Palette</B>
  E       64K   4    -     Slot 0-3  ;only lower 32K used
  F,G     16K   4    0..1  Slot 0-1 (OFS=0), Slot 2-3 (OFS=1)
<B>  VRAM    SIZE  MST  OFS   2D Graphics Engine A, OBJ Extended Palette</B>
  F,G     16K   5    -     Slot 0  ;16K each (only lower 8K used)
<B>  VRAM    SIZE  MST  OFS   Texture/Rear-plane Image</B>
  A,B,C,D 128K  3    0..3  Slot OFS(0-3)   ;(Slot2-3: Texture, or Rear-plane)
<B>  VRAM    SIZE  MST  OFS   Texture Palette</B>
  E       64K   3    -     Slots 0-3                 ;OFS=don't care
  F,G     16K   3    0..3  Slot (OFS.0*1)+(OFS.1*4)  ;ie. Slot 0, 1, 4, or 5
<B>  VRAM    SIZE  MST  OFS   ARM9, 2D Graphics Engine B, BG-VRAM (max 128K)</B>
  C       128K  4    -     6200000h
  H       32K   1    -     6200000h
  I       16K   1    -     6208000h
<B>  VRAM    SIZE  MST  OFS   ARM9, 2D Graphics Engine B, OBJ-VRAM (max 128K)</B>
  D       128K  4    -     6600000h
  I       16K   2    -     6600000h
<B>  VRAM    SIZE  MST  OFS   2D Graphics Engine B, BG Extended Palette</B>
  H       32K   2    -     Slot 0-3
<B>  VRAM    SIZE  MST  OFS   2D Graphics Engine B, OBJ Extended Palette</B>
  I       16K   3    -     Slot 0  ;(only lower 8K used)
<B>  VRAM    SIZE  MST  OFS   &lt;ARM7&gt;, Plain &lt;ARM7&gt;-CPU Access</B>
  C,D     128K  2    0..1  6000000h+(20000h*OFS.0)  ;OFS.1 must be zero
</TD></TR></TABLE>
<BR>
<B>Notes</B><BR>
In Plain-CPU modes, VRAM can be accessed only by the CPU (and by the Capture
Unit, and by VRAM Display mode). In "Plain &lt;ARM7&gt;-CPU Access" mode, the
VRAM blocks are allocated as Work RAM to the NDS7 CPU.<BR>
In BG/OBJ VRAM modes, VRAM can be accessed by the CPU at specified addresses,
and by the display controller.<BR>
In Extended Palette and Texture Image/Palette modes, VRAM is not mapped to CPU
address space, and can be accessed only by the display controller (so, to
initialize or change the memory, it should be temporarily switched to Plain-CPU
mode).<BR>
All VRAM (and Palette, and OAM) can be written to only in 16bit and 32bit units
(STRH, STR opcodes), 8bit writes are ignored (by STRB opcode). The only
exception is "Plain &lt;ARM7&gt;-CPU Access" mode: The ARM7 CPU can use STRB to
write to VRAM (the reason for this special feature is that, in GBA mode, two
128K VRAM blocks are used to emulate the GBA's 256K Work RAM).<BR>
<BR>
<B>Other Video RAM</B><BR>
Aside from the map-able VRAM blocks, there are also some video-related memory
regions at fixed addresses:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  5000000h Engine A Standard BG Palette (512 bytes)
  5000200h Engine A Standard OBJ Palette (512 bytes)
  5000400h Engine B Standard BG Palette (512 bytes)
  5000600h Engine B Standard OBJ Palette (512 bytes)
  7000000h Engine A OAM (1024 bytes)
  7000400h Engine B OAM (1024 bytes)
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsmemorycontrolbios"></A>&nbsp;
  DS Memory Control - BIOS
</FONT></TD></TR></TABLE><BR>
<B>4000308h - NDS7 - BIOSPROT - Bios-data-read-protection address</B><BR>
Used to double-protect the first some KBytes of the NDS7 BIOS. The BIOS is
split into two protection regions, one always active, one controlled by the
BIOSPROT register. The overall idea is that only the BIOS can read from itself,
any other attempts to read from that regions return FFh-bytes.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Opcodes at...      Can read from      Expl.
  0..[BIOSPROT]-1    0..3FFFh           Double-protected (when BIOSPROT is set)
  [BIOSPROT]..3FFFh  [BIOSPROT]..3FFFh  Normal-protected (always active)
</TD></TR></TABLE>
The initial BIOSPROT setting on power-up is zero (disabled). Before starting
the cartridge, the BIOS boot code sets the register to 1204h (actually 1205h,
but the mis-aligned low-bit is ignored). Once when initialized, further writes
to the register are ignored.<BR>
<BR>
The double-protected region contains the exception vectors, some bytes of code,
and the cartridge KEY1 encryption seed (about 4KBytes). As far as I know, it is
impossible to unlock the memory once when it is locked, however, with some
trickery, it is possible execute code before it gets locked. Also, the two
THUMB opcodes at 05ECh can be used to read all memory at 0..3FFFh,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  05ECh  ldrb r3,[r3,12h]      ;requires incoming r3=src-12h
  05EEh  pop  r2,r4,r6,r7,r15  ;requires dummy values &amp; THUMB retadr on stack
</TD></TR></TABLE>
Additionally most BIOS functions (eg. CpuSet), include a software-based
protection which rejects source addresses in the BIOS area (the only exception
is GetCRC16, though it still cannot bypass the BIOSPROT setting).<BR>
<BR>
<B>Note</B><BR>
The NDS9 BIOS doesn't include any software or hardware based read protection.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsmemorytimings"></A>&nbsp;
  DS Memory Timings
</FONT></TD></TR></TABLE><BR>
<B>System Clock</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bus clock  = 33MHz (33.513982 MHz) (1FF61FEh Hertz)
  NDS7 clock = 33MHz (same as bus clock)
  NDS9 clock = 66MHz (internally twice bus clock; for cache/tcm)
</TD></TR></TABLE>
Most timings in this document are specified for 33MHz clock (not for the 66MHz
clock). Respectively, NDS9 timings are counted in "half" cycles.<BR>
<BR>
<B>Memory Access Times</B><BR>
Tables below show the different access times for code/data fetches on arm7/arm9
cpus, measured for sequential/nonsequential 32bit/16bit accesses.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  NDS7/CODE             NDS9/CODE
  N32 S32 N16 S16 Bus   N32 S32 N16 S16 Bus
  9   2   8   1   16    9   9   4.5 4.5 16  Main RAM (read) (cache off)
  1   1   1   1   32    4   4   2   2   32  WRAM,BIOS,I/O,OAM
  2   2   1   1   16    5   5   2.5 2.5 16  VRAM,Palette RAM
  16  12  10  6   16    19  19  9.5 9.5 16  GBA ROM (example 10,6 access)
  -   -   -   -   -     0.5 0.5 0.5 0.5 32  TCM, Cache_Hit
  -   -   -   -   -     (--Load 8 words--)  Cache_Miss
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  NDS7/DATA             NDS9/DATA
  N32 S32 N16 S16 Bus   N32 S32 N16 S16 Bus
  10  2   9   1   16    10  2   9   1   16  Main RAM (read) (cache off)
  1   1   1   1   32    4   1   4   1   32  WRAM,BIOS,I/O,OAM
  1?  2   1   1   16    5   2   4   1   16  VRAM,Palette RAM
  15  12  9   6   16    19  12  13  6   16  GBA ROM (example 10,6 access)
  9   10  9   10  8     13  10  13  10  8   GBA RAM (example 10 access)
  -   -   -   -   -     0.5 0.5 0.5 -   32  TCM, Cache_Hit
  -   -   -   -   -     (--Load 8 words--)  Cache_Miss
  -   -   -   -   -     11  11  11  -   32  Cache_Miss (BIOS)
  -   -   -   -   -     23  23  23  -   16  Cache_Miss (Main RAM)
</TD></TR></TABLE>
All timings are counted in 33MHz units (so "half" cycles can occur on NDS9).<BR>
Note: 8bit data accesses have same timings than 16bit data.<BR>
<BR>
*** DS Memory Timing Notes ***<BR>
<BR>
The NDS timings are altogether pretty messed up, with different timings for
CODE and DATA fetches, and different timings for NDS7 and NDS9...<BR>
<BR>
<B>NDS7/CODE</B><BR>
Timings for this region can be considered as "should be" timings.<BR>
<BR>
<B>NDS7/DATA</B><BR>
Quite the same as NDS7/CODE. Except that, nonsequential Main RAM accesses are 1
cycle slower, and more strange, nonsequential GBA Slot accesses are 1 cycle
faster.<BR>
<BR>
<B>NDS9/CODE</B><BR>
This is the most messiest timing. An infamous PENALTY of 3 cycles is added to
all nonsequential accesses (except cache, tcm, and main ram). And, all opcode
fetches are forcefully made nonsequential 32bit (the NDS9 simply doesn't
support fast sequential opcode fetches). That applies also for THUMB code (two
16bit opcodes are fetched by a single nonsequential 32bit access) (so the time
per 16bit opcode is one half of the 32bit fetch) (unless a branch causes only
one of the two 16bit opcodes to be executed, then that opcode will have the
full 32bit access time).<BR>
<BR>
<B>NDS9/DATA</B><BR>
Allows both sequential and nonsequential access, and both 16bit and 32bit
access, so it's faster than NDS9/CODE. Nethertheless, it's still having the 3
cycle PENALTY on nonsequential accesses. And, similar as NDS7/DATA, it's also
adding 1 cycle to nonsequential Main RAM accesses.<BR>
<BR>
*** More Timing Notes / Lots of unsorted Info ***<BR>
<BR>
<B>Actual CPU Performance</B><BR>
The 33MHz NDS7 is running more or less nicely at 33MHz. However, the so-called
"66MHz" NDS9 is having &lt;much&gt; higher waitstates, and it's effective bus
speed is barely about 8..16MHz, the only exception is code/data in cache/tcm,
which is eventually reaching real 66MHz (that, assuming cache HITS, otherwise,
in case of cache MISSES, the cached memory timing might even drop to 1.4MHz or
so?).<BR>
*********************<BR>
ARM9 opcode fetches are always N32 + 3 waits.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  S16 and N16 do not exist (because thumb-double-fetching) (see there).
  S32 becomes N32 (ie. the ARM9 does NOT support fast sequential timing).
</TD></TR></TABLE>
That N32 is having same timing as normal N32 access on NDS7, plus 3 waits.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Eg. an ARM9 N32 or S32 to 16bit bus will take: N16 + S16 + 3 waits.
  Eg. an ARM9 N32 or S32 to 32bit bus will take: N32 + 3 waits.
</TD></TR></TABLE>
Main Memory is ALWAYS having the nonsequential 3 wait PENALTY (even on ARM7).<BR>
*********************<BR>
ARM9 Data fetches however are allowed to use sequential timing, as well as raw
16bit accesses (which aren't forcefully expanded to slow 32bit accesses).<BR>
Nethertheless, the 3 wait PENALTY is added to any NONSEQUENTIAL accesses.<BR>
Only exceptions are cache and tcm which do not have that penalty.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 Eg. LDRH on 16bit-data-bus is N16+3waits.
 Eg. LDR  on 16bit-data-bus is N16+S16+3waits.
 Eg. LDM  on 16bit-data-bus is N16+(n*2-1)*S16+3waits.
</TD></TR></TABLE>
Eventually, data fetches can take place parallel with opcode fetches.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 That is NOT true for LDM (works only for LDR/LDRB/LDRH).
 That is NOT true for DATA in SAME memory region than CODE.
 That is NOT true for DATA in ITCM (no matter if CODE is in ITCM).
</TD></TR></TABLE>
*********************<BR>
<BR>
<B>NDS9 Busses</B><BR>
Unlike ARM7, the ARM9 has separate code and data busses, allowing it to perform
code and data fetches simultaneously (provided that both are in different
memory regions).<BR>
Normally, opcode execution times are calculated as "(codetime+datatime)", with
the two busses, it can (ideally) be "MAX(codetime,datatime)", so the data
access time may virtually take "NULL" clock cycles.<BR>
In practice, DTCM and Data Cache access can take NULL cycles (however, data
access to ITCM can't).<BR>
When executing code in cache/itcm, data access to non-cache/tcm won't be any
faster than with only one bus (as it's best, it could subtract 0.5 cycles from
datatime, but, the access must be "aligned" to the bus-clock, so the
"datatime-0.5" will be rounded back to the original "datatime").<BR>
When executing code in uncached main ram, and accessing data (elsewhere than in
main memory, cache/tcm), then execution time is typically
"codetime+datatime-2".<BR>
<BR>
<B>NDS9 Internal Cycles</B><BR>
Additionally to codetime+datatime, some opcodes include one or more internal
cycles. Compared with ARM7, the behaviour of that internal cycles is slightly
different on ARM9. First of, on the NDS9, the internal cycles are of course
"half" cycles (ie. counted in 66MHz units, not in 33MHz units) (although they
may get rounded to "full" cycles upon next memory access outside tcm/cache).
And, the ARM9 is in some cases "skipping" the internal cycles, that often
depending on whether or not the next opcode is using the result of the current
opcode.<BR>
Another big difference is that the ARM9 has lost the fast-multiply feature for
small numbers; in some cases that may result in faster execution, but may also
result in slower execution (one workaround would be to manually replace MUL
opcodes by the new ARM9 halfword multiply opcodes); the slowest case are MUL
opcodes that do update flags (eg. MULS, MLAS, SMULLS, etc. in ARM mode, and all
ALL multiply opcodes in THUMB mode).<BR>
<BR>
<B>NDS9 Thumb Code</B><BR>
In thumb mode, the NDS9 is fetching two 16bit opcodes by a single 32bit read.
In case of 32bit bus, this reduces the amount of memory traffic and may result
in faster execution time, of course that works only if the two opcodes are
within a word-aligned region (eg. loops at word-aligned addresses will be
faster than non-aligned loops). However, the double-opcode-fetching is also
done on 16bit bus memory, including for unnecessary fetches, such like opcodes
after branch commands, so the feature may cause heavy slowdowns.<BR>
<BR>
<B>Main Memory</B><BR>
Reportedly, the main memory access times would be 5 cycles (nonsequential
read), 4 cycles (nonsequential write), and 1 cycle (sequential read or write).
Plus whatever termination cycles. Plus 3 cycles on nonsequential access to the
last 2-bytes of a 32-byte block.<BR>
That's of course all wrong. Reads are much slower than 5 cycles. Not yet tested
if writes are faster. And, I haven't been able to reproduce the 3 cycles on
last 2-bytes effect, actually, it looks more as if that 3 cycles are accidently
added to ALL nonsequential accesses, at ALL main memory addresses, and even to
most OTHER memory regions... which might be the source of the PENALTY which
occurs on VRAM/WRAM/OAM/Palette and I/O accesses.<BR>
<BR>
<B>DMA</B><BR>
In some cases DMA main memory read cycles are reportedly performed
simultaneously with DMA write cycles to other memory.<BR>
<BR>
<B>NDS9</B><BR>
On the NDS9, all external memory access (and I/O) is delayed to bus clock (or
actually MUCH slower due to the massive waitstates), so the full 66MHz can be
used only internally in the NDS9 CPU core, ie. with cache and TCM.<BR>
<BR>
<B>Bus Clock</B><BR>
The exact bus clock is specified as 33.513982 MHz (1FF61FEh Hertz). However, on
my own NDS, measured in relation to the RTC seconds IRQ, it appears more like
1FF6231h, that inaccuary of 1 cycle per 657138 cycles (about one second per
week) on either oscillator, isn't too significant though.<BR>
<BR>
<B>GBA Slot</B><BR>
The access time for GBA slot can be configured via EXMEMCNT register.<BR>
<BR>
<B>VRAM Waitstates</B><BR>
Additionally, on NDS9, a one cycle wait can be added to VRAM accesses (when the
video controller simultaneously accesses it) (that can be disabled by Forced
Blank, see DISPCNT.Bit7). Moreover, additional VRAM waitstates occur when using
the video capture function.<BR>
Note: VRAM being mapped to NDS7 is always free of additional waits.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsvideo"></A>&nbsp;
  DS Video
</FONT></TD></TR></TABLE><BR>
The NDS has two 2D Video Engines, each basically the same as in GBA, see<BR>
<A HREF="#gbalcdvideocontroller">GBA LCD Video Controller</A><BR>
<BR>
<B>NDS Specific 2D Video Features</B><BR>
<A HREF="#dsvideostuff">DS Video Stuff</A><BR>
<A HREF="#dsvideobgmodescontrol">DS Video BG Modes / Control</A><BR>
<A HREF="#dsvideoobjs">DS Video OBJs</A><BR>
<A HREF="#dsvideoextendedpalettes">DS Video Extended Palettes</A><BR>
<A HREF="#dsvideocaptureandmainmemorydisplaymode">DS Video Capture and Main Memory Display Mode</A><BR>
<A HREF="#dsvideodisplaysystemblockdiagram">DS Video Display System Block Diagram</A><BR>
<BR>
For Display Power Control (and Display Swap), and VRAM Allocation, see<BR>
<A HREF="#dspowermanagement">DS Power Management</A><BR>
<A HREF="#dsmemorycontrolvram">DS Memory Control - VRAM</A><BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsvideostuff"></A>&nbsp;
  DS Video Stuff
</FONT></TD></TR></TABLE><BR>
<B>DS Display Dimensions / Timings</B><BR>
Dot clock = 5.585664 MHz (=33.513982 MHz / 6)<BR>
H-Timing: 256 dots visible, 99 dots blanking, 355 dots total (15.7343KHz)<BR>
V-Timing: 192 lines visible, 71 lines blanking, 263 lines total (59.8261 Hz)<BR>
The V-Blank cycle for the 3D Engine consists of the 23 lines, 191..213.<BR>
Screen size 62.5mm x 47.0mm (each) (256x192 pixels)<BR>
Vertical space between screens 22mm (equivalent to 90 pixels)<BR>
<BR>
<B>400006Ch - NDS9 - MASTER_BRIGHT - 16bit - Master Brightness Up/Down</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-4   Factor used for 6bit R,G,B Intensities (0-16, values &gt;16 same as 16)
          Brightness up:   New = Old + (63-Old) * Factor/16
          Brightness down: New = Old - Old      * Factor/16
  5-13  Not used
  14-15 Mode (0=Disable, 1=Up, 2=Down, 3=Reserved)
  16-31 Not used
</TD></TR></TABLE>
<BR>
<B>DISPSTAT/VCOUNT</B><BR>
The LY and LYC values are in range 0..262, so LY/LYC values have been expanded
to 9bit values: LY = VCOUNT Bit 0..8, and LYC=DISPSTAT Bit8..15,7.<BR>
VCOUNT register is write-able, allowing to synchronize linked DS consoles.<BR>
For proper synchronization:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  write new LY values only in range of 202..212
  write only while old LY values are in range of 202..212
</TD></TR></TABLE>
DISPSTAT/VCOUNT supported by NDS9 (Engine A Ports, without separate Engine B
Ports), and by NDS7 (allowing to synchronize NDS7 with display timings).<BR>
Similar as on GBA, the VBlank flag isn't set in the last line (ie. only in
lines 192..261, but not in line 262).<BR>
Although the drawing time is only 1536 cycles (256*6), the NDS9 H-Blank flag is
"0" for a total of 1606 cycles (and, for whatever reason, a bit longer, 1613
cycles in total, on NDS7).<BR>
<BR>
<B>VRAM Waitstates</B><BR>
The display controller performs VRAM-reads once every 6 clock cycles, a 1 cycle
waitstate is generated if the CPU simultaneously accesses VRAM. With capture
enabled, additionally VRAM-writes take place once every 6 cycles, so the total
VRAM-read/write access rate is then once every 3 cycles.<BR>
<BR>
<B>DS Window Glitches</B><BR>
The DS counts scanlines in range 0..262 (0..106h), of which only the lower 8bit
are compared with the WIN0V/WIN1V register settings. Respectively, Y1
coordinates 00h..06h will be triggered in scanlines 100h-106h by mistake. That
means, the window gets activated within VBlank period, and will be active in
scanline 0 and up (that is no problem with Y1=0, but Y1=1..6 will appear as if
if Y1 would be 0). Workaround would be to disable the Window during VBlank, or
to change Y1 during VBlank (to a value that does not occur during VBlank
period, ie. 7..191).<BR>
Also, there's a problem to fit the 256 pixel horizontal screen resolution into
8bit values: X1=00h is treated as 0 (left-most), X2=00h is treated as 100h
(right-most). However, the window is not displayed if X1=X2=00h; the window
width can be max 255 pixels.<BR>
<BR>
<B>2D Engines</B><BR>
Includes two 2D Engines, called A and B. Both engines are accessed by the ARM9
processor, each using different memory and register addresses:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Region______Engine A______________Engine B___________
  I/O Ports   4000000h              4001000h
  Palette     5000000h (1K)         5000400h (1K)
  BG VRAM     6000000h (max 512K)   6200000h (max 128K)
  OBJ VRAM    6400000h (max 256K)   6600000h (max 128K)
  OAM         7000000h (1K)         7000400h (1K)
</TD></TR></TABLE>
Engine A additionally supports 3D and large-screen 256-color Bitmaps, plus
main-memory-display and vram-display modes, plus capture unit.<BR>
<BR>
<B>Viewing Angles</B><BR>
The LCD screens are best viewed at viewing angles of 90 degrees. Colors may
appear distorted, and may even become invisible at other viewing angles.<BR>
When the console is handheld, both screens can be turned into preferred
direction. When the console is settled on a table, only the upper screen can be
turned, but the lower screen is stuck into horizontal position - which results
in rather bad visibility (unless the user moves his/her head directly above of
it).<BR>
<BR>
<B>4000070h - NDS9 - TVOUTCNT - Unknown (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-3  "COMMAND"  (?)
  Bit4-7  "COMMAND2" (?)
  Bit8-11 "COMMAND3" (?)
</TD></TR></TABLE>
This register has been mentioned in an early I/O map from Nintendo, as far as I
know, the register isn't used by any games/firmware/bios, not sure if it does
really exist on release-version, or if it's been prototype stuff...?<BR>
<BR>
<B>DS-Lite Screens</B><BR>
The screens in the DS-Lite seem to allow a wider range of vertical angles.<BR>
The bad news is that the colors of the DS-Lite are (no surprise) not backwards
compatible with older NDS and GBA displays. The good news is that Nintendo has
finally reached near-CRT-quality (without blurred colors), so one could hope
that they won't show up with more displays with other colors in future.<BR>
Don't know if there's an official/recommended way to detect DS-Lite displays
(?) possible methods would be whatever values in Firmware header, or by
functionality of Power Managment device, or (not too LCD-related) by Wifi Chip
ID.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsvideobgmodescontrol"></A>&nbsp;
  DS Video BG Modes / Control
</FONT></TD></TR></TABLE><BR>
<B>4000000h - NDS9 - DISPCNT</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit  Engine Expl.
  0-2   A+B   BG Mode
  3     A     BG0 2D/3D Selection (instead CGB Mode) (0=2D, 1=3D)
  4     A+B   Tile OBJ Mapping        (0=2D; max 32KB, 1=1D; max 32KB..256KB)
  5     A+B   Bitmap OBJ 2D-Dimension (0=128x512 dots, 1=256x256 dots)
  6     A+B   Bitmap OBJ Mapping      (0=2D; max 128KB, 1=1D; max 128KB..256KB)
  7-15  A+B   Same as GBA
  16-17 A+B   Display Mode (Engine A: 0..3, Engine B: 0..1, GBA: Green Swap)
  18-19 A     VRAM block (0..3=VRAM A..D) (For Capture &amp; above Display Mode=2)
  20-21 A+B   Tile OBJ 1D-Boundary   (see Bit4)
  22    A     Bitmap OBJ 1D-Boundary (see Bit5-6)
  23    A+B   OBJ Processing during H-Blank (was located in Bit5 on GBA)
  24-26 A     Character Base (in 64K steps) (merged with 16K step in BGxCNT)
  27-29 A     Screen Base (in 64K steps) (merged with 2K step in BGxCNT)
  30    A+B   BG Extended Palettes   (0=Disable, 1=Enable)
  31    A+B   OBJ Extended Palettes  (0=Disable, 1=Enable)
</TD></TR></TABLE>
<BR>
<B>BG Mode</B><BR>
Engine A BG Mode (DISPCNT LSBs) (0-6, 7=Reserved)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Mode  BG0      BG1      BG2      BG3
  0     Text/3D  Text     Text     Text
  1     Text/3D  Text     Text     Affine
  2     Text/3D  Text     Affine   Affine
  3     Text/3D  Text     Text     Extended
  4     Text/3D  Text     Affine   Extended
  5     Text/3D  Text     Extended Extended
  6     3D       -        Large    -
</TD></TR></TABLE>
Of which, the "Extended" modes are sub-selected by BGxCNT bits:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  BGxCNT.Bit7 BGxCNT.Bit2 Extended Affine Mode Selection
  0           CharBaseLsb rot/scal with 16bit bgmap entries (Text+Affine mixup)
  1           0           rot/scal 256 color bitmap
  1           1           rot/scal direct color bitmap
</TD></TR></TABLE>
Engine B: Same as above, except that: Mode 6 is reserved (no Large screen
bitmap), and BG0 is always Text (no 3D support).<BR>
Affine = formerly Rot/Scal mode (with 8bit BG Map entries)<BR>
Large Screen Bitmap = rot/scal 256 color bitmap (using all 512K of 2D VRAM)<BR>
<BR>
<B>Display Mode (DISPCNT.16-17):</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0  Display off (screen becomes white)
  1  Graphics Display (normal BG and OBJ layers)
  2  Engine A only: VRAM Display (Bitmap from block selected in DISPCNT.18-19)
  3  Engine A only: Main Memory Display (Bitmap DMA transfer from Main RAM)
</TD></TR></TABLE>
Mode 2-3 display a raw direct color bitmap (15bit RGB values, the upper bit in
each halfword is unused), without any further BG,OBJ,3D layers, these modes are
completely bypassing the 2D/3D engines as well as any 2D effects, however the
Master Brightness effect can be applied to these modes. Mode 2 is particulary
useful to display captured 2D/3D images (in that case it can indirectly use the
2D/3D engine).<BR>
<BR>
<B>BGxCNT</B><BR>
character base extended from bit2-3 to bit2-5 (bit4-5 formerly unused)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  engine A screen base: BGxCNT.bits*2K + DISPCNT.bits*64K
  engine B screen base: BGxCNT.bits*2K + 0
  engine A char base: BGxCNT.bits*16K + DISPCNT.bits*64K
  engine B char base: BGxCNT.bits*16K + 0
</TD></TR></TABLE>
char base is used only in tile/map modes (not bitmap modes)<BR>
screen base is used in tile/map modes,<BR>
screen base used in bitmap modes as BGxCNT.bits*16K, without DISPCNT.bits*64K<BR>
screen base however NOT used at all for Large screen bitmap mode<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  bgcnt size  text     rotscal    bitmap   large bmp
  0           256x256  128x128    128x128  512x1024
  1           512x256  256x256    256x256  1024x512
  2           256x512  512x512    512x256  -
  3           512x512  1024x1024  512x512  -
</TD></TR></TABLE>
bitmaps that require more than 128K VRAM are supported on engine A only.<BR>
<BR>
For BGxCNT.Bit7 and BGxCNT.Bit2 in Extended Affine modes, see above BG Mode
description (extended affine doesn't include 16-color modes, so color depth bit
can be used for mode selection. Also, bitmap modes do not use charbase, so
charbase.0 can be used for mode selection as well).<BR>
<BR>
for BG0, BG1 only: bit13 selects extended palette slot<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
                   (BG0: 0=Slot0, 1=Slot2, BG1: 0=Slot1, 1=Slot3)
</TD></TR></TABLE>
<BR>
Direct Color Bitmap BG, and Direct Color Bitmap OBJ<BR>
BG/OBJ Supports 32K colors (15bit RGB value) - so far same as GBAs BG.<BR>
However, the upper bit (Bit15) is used as Alpha flag. That is,
Alpha=0=Transparent, Alpha=1=Normal (ie. on the NDS, Direct Color values
0..7FFFh are NOT displayed).<BR>
<BR>
Unlike GBA bitmap modes, NDS bitmap modes are supporting the Area Overflow bit
(BG2CNT and BG3CNT, Bit 13).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsvideoobjs"></A>&nbsp;
  DS Video OBJs
</FONT></TD></TR></TABLE><BR>
<B>DS OBJ Priority</B><BR>
The GBA has been assigning OBJ priority in respect to the 7bit OAM entry
number, regardless of the OBJs 2bit BG-priority attribute (which allowed to
specify invalid priority orders). That problem has been fixed in DS mode by
combining the above two values into a 9bit priority value.<BR>
<BR>
<B>OBJ Tile Mapping (DISPCNT.4,20-21):</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit4  Bit20-21  Dimension Boundary Total ;Notes
  0     x         2D        32       32K   ;Same as GBA 2D Mapping
  1     0         1D        32       32K   ;Same as GBA 1D Mapping
  1     1         1D        64       64K
  1     2         1D        128      128K
  1     3         1D        256      256K  ;Engine B: 128K max
</TD></TR></TABLE>
TileVramAddress = TileNumber * BoundaryValue<BR>
Even if the boundary gets changed, OBJs are kept composed of 8x8 tiles.<BR>
<BR>
<B>Bitmap OBJ Mapping (DISPCNT.6,5,22):</B><BR>
Bitmap OBJs are 15bit Direct Color data, plus 1bit Alpha flag (in bit15).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit6 Bit5 Bit22 Dimension    Boundary   Total ;Notes
  0    0    x     2D/128 dots  8x8 dots   128K  ;Source Bitmap width 128 dots
  0    1    x     2D/256 dots  8x8 dots   128K  ;Source Bitmap width 256 dots
  1    0    0     1D           128 bytes  128K  ;Source Width = Target Width
  1    0    1     1D           256 bytes  256K  ;Engine A only
  1    1    x     Reserved
</TD></TR></TABLE>
In 1D mapping mode, the Tile Number is simply multiplied by the boundary value.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1D_BitmapVramAddress = TileNumber(0..3FFh) * BoundaryValue(128..256)
  2D_BitmapVramAddress = (TileNo AND MaskX)*10h + (TileNo AND NOT MaskX)*80h
</TD></TR></TABLE>
In 2D mode, the Tile Number is split into X and Y indices, the X index is
located in the LSBs (ie. MaskX=0Fh, or MaskX=1Fh, depending on DISPCNT.5).<BR>
<BR>
<B>OBJ Attribute 0 and 2</B><BR>
Setting the OBJ Mode bits (Attr 0, Bit10-11) to a value of 3 has been
prohibited in GBA, however, in NDS it selects the the new Bitmap OBJ mode; in
that mode, the Color depth bit (Attr 0, Bit13) should be set to zero; also in
that mode, the color bits (Attr 2, Bit 12-15) are used as Alpha-OAM value
(instead of as palette setting).<BR>
<BR>
<B>OBJ Vertical Wrap</B><BR>
On the GBA, a large OBJ (with 64pix height, scaled into double-size region of
128pix height) located near the bottom of the screen has been wrapped to the
top of the screen (and was NOT displayed at the bottom of the screen).<BR>
This problem has been "corrected" in the NDS (except in GBA mode), that is, on
the NDS, the OBJ appears BOTH at the top and bottom of the screen. That isn't
necessarily better - the advantage is that one can manually enable/disable the
OBJ in the desired screen-half on IRQ level; that'd be required only if the
wrapped portion is non-transparent.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsvideoextendedpalettes"></A>&nbsp;
  DS Video Extended Palettes
</FONT></TD></TR></TABLE><BR>
<B>Extended Palettes</B><BR>
When allocating extended palettes, the allocated memory is not mapped to the
CPU bus, so the CPU can access extended palette only when temporarily
de-allocating it.<BR>
<BR>
Color 0 of all standard/extended palettes is transparent, color 0 of BG
standard palette 0 is used as backdrop. extended palette memory must be
allocated to VRAM.<BR>
<BR>
BG Extended Palette enabled in DISPCNT Bit 30, when enabled,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 standard palette --&gt; 16-color tiles (with 16bit bgmap entries) (text)
                      256-color tiles (with 8bit bgmap entries) (rot/scal)
                      256-color bitmaps
                      backdrop-color (color 0)
 extended palette --&gt; 256-color tiles (with 16bit bgmap entries)(text,rot/scal)
</TD></TR></TABLE>
Allocated VRAM is split into 4 slots of 8K each (32K used in total), normally
BG0..3 are using Slot 0..3, however BG0 and BG1 can be optionally changed to
BG0=Slot2, and BG1=Slot3 via BG0CNT and BG1CNT.<BR>
<BR>
OBJ Extended Palette enabled in DISPCNT Bit 31, when enabled,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 16 colors x 16 palettes --&gt; standard palette memory (=256 colors)
 256 colors x 16 palettes --&gt; extended palette memory (=4096 colors)
</TD></TR></TABLE>
Extended OBJ palette memory must be allocated to VRAM F, G, or I (which are
16K) of which only the first 8K are used for extended palettes (=1000h 16bit
entries).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsvideocaptureandmainmemorydisplaymode"></A>&nbsp;
  DS Video Capture and Main Memory Display Mode
</FONT></TD></TR></TABLE><BR>
<B>4000064h - NDS9 - DISPCAPCNT - 32bit - Display Capture Control Register (R/W)</B><BR>
Capture is supported for Display Engine A only.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-4   EVA               (0..16 = Blending Factor for Source A)
  5-7   Not used
  8-12  EVB               (0..16 = Blending Factor for Source B)
  13-15 Not used
  16-17 VRAM Write Block  (0..3 = VRAM A..D) (VRAM must be allocated to LCDC)
  18-19 VRAM Write Offset (0=00000h, 0=08000h, 0=10000h, 0=18000h)
  20-21 Capture Size      (0=128x128, 1=256x64, 2=256x128, 3=256x192 dots)
  22-23 Not used
  24    Source A          (0=Graphics Screen BG+3D+OBJ, 1=3D Screen)
  25    Source B          (0=VRAM, 1=Main Memory Display FIFO)
  26-27 VRAM Read Offset  (0=00000h, 0=08000h, 0=10000h, 0=18000h)
  28    Not used
  29-30 Capture Source    (0=Source A, 1=Source B, 2/3=Sources A+B blended)
  31    Capture Enable    (0=Disable/Ready, 1=Enable/Busy)
</TD></TR></TABLE>
Notes:<BR>
VRAM Read Block (VRAM A..D) is selected in DISPCNT Bits 18-19.<BR>
VRAM Read Block can be (or must be ?) allocated to LCDC (MST=0).<BR>
VRAM Read Offset is ignored (zero) in VRAM Display Mode (DISPCNT.16-17).<BR>
VRAM Read/Write Offsets wrap to 00000h when exceeding 1FFFFh (max 128K).<BR>
Capture Sizes less than 256x192 capture the upper-left portion of the screen.<BR>
Blending factors EVA and EVB are used only if "Source A+B blended" selected.<BR>
After setting the Capture Enable bit, capture starts at next line 0, and the
capture enable/busy bit is then automatically cleared (in line 192, regardless
of the capture size).<BR>
<BR>
Capture data is 15bit color depth (even when capturing 18bit 3D-images).<BR>
Capture A:  Dest_Intensity = SrcA_Intensitity ; Dest_Alpha=SrcA_Alpha.<BR>
Capture B:  Dest_Intensity = SrcB_Intensitity ; Dest_Alpha=SrcB_Alpha.<BR>
Capture A+B (blending):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 Dest_Intensity = (  (SrcA_Intensitity * SrcA_Alpha * EVA)
                   + (SrcB_Intensitity * SrcB_Alpha * EVB) ) / 16
 Dest_Alpha = (SrcA_Alpha AND (EVA&gt;0)) OR (SrcB_Alpha AND EVB&gt;0))
</TD></TR></TABLE>
<BR>
Capture provides a couple of interesting effects.<BR>
For example, 3D Engine output can be captured via source A (to LCDC-allocated
VRAM), in the next frame, either Graphics Engine A or B can display the
captured 3D image in VRAM image as BG2, BG3, or OBJ (from BG/OBJ-allocated
VRAM); this method requires to switch between LCDC- and BG/OBJ-allocation.<BR>
Another example would be to capture Engine A output, the captured image can be
displayed (via VRAM Display mode) in the following frames, simultaneously the
new Engine A output can be captured, blended with the old captured image; in
that mode moved objects will leave traces on the screen; this method works with
a single LCDC-allocated VRAM block.<BR>
<A HREF="#dsvideodisplaysystemblockdiagram">DS Video Display System Block Diagram</A><BR>
<BR>
<B>4000068h - NDS9 - DISP_MMEM_FIFO - 32bit - Main Memory Display FIFO (R?/W)</B><BR>
Intended to send 256x192 pixel 32K color bitmaps by DMA directly<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 - to Screen A             (set DISPCNT to Main Memory Display mode), or
 - to Display Capture unit (set DISPCAPCNT to Main Memory Source).
</TD></TR></TABLE>
The FIFO can receive 4 words (8 pixels) at a time, each pixel is a 15bit RGB
value (the upper bit, bit15, is unused).<BR>
Set DMA to Main Memory mode, 32bit transfer width, word count set to 4,
destination address to DISP_MMEM_FIFO, source address must be in Main Memory.<BR>
Transfer starts at next frame.<BR>
Main Memory Display/Capture is supported for Display Engine A only.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsvideodisplaysystemblockdiagram"></A>&nbsp;
  DS Video Display System Block Diagram
</FONT></TD></TR></TABLE><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
             _____________               __________
  VRAM A --&gt;| 2D Graphics |--------OBJ-&gt;|          |
  VRAM B --&gt;| Engine A    |--------BG3-&gt;| Layering |
  VRAM C --&gt;|             |--------BG2-&gt;| and      |
  VRAM D --&gt;|             |--------BG1-&gt;| Special  |
  VRAM E --&gt;|             |   ___       | Effects  |
  VRAM F --&gt;|             |-&gt;|SEL|      |          |          ______
  VRAM G --&gt;| - - - - - - |  |BG0|-BG0-&gt;|          |----+---&gt;|      |
            | 3D Graphics |-&gt;|___|      |__________|    |    |Select|
            | Engine      |                             |    |Video |
            |_____________|--------3D----------------+  |    |Input |
             _______      _______              ___   |  |    |      |
            |       |    |       |&lt;-----------|SEL|&lt;-+  |    |and   |--&gt;
            |       |    |       |    _____   |A  |     |    |      |
  VRAM A &lt;--|Select |    |Select |   |     |&lt;-|___|&lt;----+    |Master|
  VRAM B &lt;--|Capture|&lt;---|Capture|&lt;--|Blend|   ___           |Bright|
  VRAM C &lt;--|Dest.  |    |Source |   |_____|&lt;-|SEL|&lt;----+    |A     |
  VRAM D &lt;--|       |    |       |            |B  |     |    |      |
            |_______|    |_______|&lt;-----------|___|&lt;-+  |    |      |
             _______                                 |  |    |      |
  VRAM A --&gt;|Select |                                |  |    |      |
  VRAM B --&gt;|Display|--------------------------------+------&gt;|      |
  VRAM C --&gt;|VRAM   |                                   |    |      |
  VRAM D --&gt;|_______|   _____________                   |    |      |
                       |Main Memory  |                  |    |      |
  Main   ------DMA----&gt;|Display FIFO |------------------+---&gt;|______|
  Memory               |_____________|
             _____________               __________           ______
  VRAM C --&gt;| 2D Graphics |--------OBJ-&gt;| Layering |         |      |
  VRAM D --&gt;| Engine B    |--------BG3-&gt;| and      |         |Master|
  VRAM H --&gt;|             |--------BG2-&gt;| Special  |--------&gt;|Bright|--&gt;
  VRAM I --&gt;|             |--------BG1-&gt;| Effects  |         |B     |
            |_____________|--------BG0-&gt;|__________|         |______|
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="ds3dvideo"></A>&nbsp;
  DS 3D Video
</FONT></TD></TR></TABLE><BR>
<A HREF="#ds3doverview">DS 3D Overview</A><BR>
<A HREF="#ds3diomap">DS 3D I/O Map</A><BR>
<A HREF="#ds3ddisplaycontrol">DS 3D Display Control</A><BR>
<A HREF="#ds3dgeometrycommands">DS 3D Geometry Commands</A><BR>
<A HREF="#ds3dmatrixloadmultiply">DS 3D Matrix Load/Multiply</A><BR>
<A HREF="#ds3dmatrixtypes">DS 3D Matrix Types</A><BR>
<A HREF="#ds3dmatrixstack">DS 3D Matrix Stack</A><BR>
<A HREF="#ds3dmatrixexamplesprojection">DS 3D Matrix Examples (Projection)</A><BR>
<A HREF="#ds3dmatrixexamplesrotatescaletranslate">DS 3D Matrix Examples (Rotate/Scale/Translate)</A><BR>
<A HREF="#ds3dmatrixexamplesmathsbasics">DS 3D Matrix Examples (Maths Basics)</A><BR>
<A HREF="#ds3dpolygonattributes">DS 3D Polygon Attributes</A><BR>
<A HREF="#ds3dpolygondefinitionsbyvertices">DS 3D Polygon Definitions by Vertices</A><BR>
<A HREF="#ds3dpolygonlightparameters">DS 3D Polygon Light Parameters</A><BR>
<A HREF="#ds3dshadowpolygons">DS 3D Shadow Polygons</A><BR>
<A HREF="#ds3dtextureattributes">DS 3D Texture Attributes</A><BR>
<A HREF="#ds3dtextureformats">DS 3D Texture Formats</A><BR>
<A HREF="#ds3dtexturecoordinates">DS 3D Texture Coordinates</A><BR>
<A HREF="#ds3dtextureblending">DS 3D Texture Blending</A><BR>
<A HREF="#ds3dtoonedgefogalphablendingantialiasing">DS 3D Toon, Edge, Fog, Alpha-Blending, Anti-Aliasing</A><BR>
<A HREF="#ds3dstatus">DS 3D Status</A><BR>
<A HREF="#ds3dtests">DS 3D Tests</A><BR>
<A HREF="#ds3drearplane">DS 3D Rear-Plane</A><BR>
<A HREF="#ds3dfinal2doutput">DS 3D Final 2D Output</A><BR>
<BR>
3D is more or less (about 92%) understood and described.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="ds3doverview"></A>&nbsp;
  DS 3D Overview
</FONT></TD></TR></TABLE><BR>
The NDS 3D hardware consists of a Geometry Engine, and a Rendering Engine.<BR>
<BR>
<B>Geometry Engine (Precalculate coordinates &amp; assign polygon attributes)</B><BR>
Geometry commands can be sent via Ports 4000440h and up (or alternately,
written directly to Port 4000400h).<BR>
The commands include matrix and vector multiplications, the purpose is to
rotate/scale/translate coordinates (vertices), the resulting coordinates are
stored in Vertex RAM.<BR>
Moreover, it allows to assign attributes to the polygons and vertices, that
includes vertex colors (or automatically calculated light colors), texture
attributes, number of vertices per polygon (three or four), and a number of
flags, these attributes are stored in Polygon RAM. Polygon RAM also contains
pointers to the corresponding vertices in Vertex RAM.<BR>
<BR>
<B>Swap Buffers (Pass data from the Geometry Engine to the Rendering Engine)</B><BR>
The hardware includes two sets of Vertex/Polygon RAM, one used by the Geometry
Engine, one by the Rendering Engine. The SwapBuffers command simply exchanges
these buffers (so the new Geometry Data is passed to the Rendering Engine) (and
the old buffer is emptied, so the Geometry engine can write new data to it).
Additionally, the two parameter bits from the &lt;previous&gt; SwapBuffers
command are copied to the Geometry Engine.<BR>
Data that is NOT swapped: SwapBuffers obviously can't swap Texture memory (so
software must take care that Texture memory is kept mapped throughout
rendering). Moreover, the rendering control registers (ports 4000060h, and
4000330h..40003BFh) are not swapped (so that values must be kept intact during
rendering, too).<BR>
<BR>
<B>Rendering Engine (Display Output)</B><BR>
The Rendering Engine draws the various Polygons, and outputs them as BG0 layer
to the 2D Video controller (which may then output them to the screen, or to the
video capture unit). The Rendering part is done automatically by hardware, so
the software has little influence on it.<BR>
Rendering is done scanline-by-scanline, so there's only a limited number of
clock cycles per scanline, which is limiting the maximum number of polygons per
scanline. However, due to the 48-line cache (see below), some scanlines are
allowed to exceed that maximum.<BR>
Rendering starts 48 lines in advance (while still in the Vblank period) (and
does then continue throughout the whole display period), the rendered data is
written to a small cache that can hold up to 48 scanlines.<BR>
<BR>
<B>Scanline Cache vs Framebuffer</B><BR>
Note: There's only the 48-line cache (not a full 192-line framebuffer to store
the whole rendered image). That is perfectly reasonable since animated data is
normally drawn only once (so there would be no need to store it). That,
assuming that the Geometry Engine presents new data every frame (otherwise, if
the Geometry software is too slow, or if the image isn't animated, then the
hardware is automatically rendering the same image again, and again).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="ds3diomap"></A>&nbsp;
  DS 3D I/O Map
</FONT></TD></TR></TABLE><BR>
<B>3D I/O Map</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Address  Siz Name            Expl.
<B>  Rendering Engine (per Frame settings)</B>
  4000060h 2   DISP3DCNT       3D Display Control Register (R/W)
  4000320h 1   RDLINES_COUNT   Rendered Line Count Register (R)
  4000330h 10h EDGE_COLOR      Edge Colors 0..7 (W)
  4000340h 1   ALPHA_TEST_REF  Alpha-Test Comparision Value (W)
  4000350h 4   CLEAR_COLOR     Clear Color Attribute Register (W)
  4000354h 2   CLEAR_DEPTH     Clear Depth Register (W)
  4000356h 2   CLRIMAGE_OFFSET Rear-plane Bitmap Scroll Offsets (W)
  4000358h 4   FOG_COLOR       Fog Color (W)
  400035Ch 2   FOG_OFFSET      Fog Depth Offset (W)
  4000360h 20h FOG_TABLE       Fog Density Table, 32 entries (W)
  4000380h 40h TOON_TABLE      Toon Table, 32 colors (W)
<B>  Geometry Engine (per Polygon/Vertex settings)</B>
  4000400h 40h GXFIFO          Geometry Command FIFO (W)
  4000440h ... ...             Geometry Command Ports (see below)
  4000600h 4   GXSTAT          Geometry Engine Status Register (R and R/W)
  4000604h 4   RAM_COUNT       Polygon List &amp; Vertex RAM Count Register (R)
  4000610h 2   DISP_1DOT_DEPTH 1-Dot Polygon Display Boundary Depth (W)
  4000620h 10h POS_RESULT      Position Test Results (R)
  4000630h 6   VEC_RESULT      Vector Test Results (R)
  4000640h 40h CLIPMTX_RESULT  Read Current Clip Coordinates Matrix (R)
  4000680h 24h VECMTX_RESULT   Read Current Directional Vector Matrix (R)
</TD></TR></TABLE>
<BR>
<B>Geometry Commands (can be invoked by Port Address, or by Command ID)</B><BR>
Table shows Port Address, Command ID, Number of Parameters, and Clock Cycles.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Address  Cmd Pa.Cy.
  N/A      00h -  -   NOP - No Operation (for padding packed GXFIFO commands)
  4000440h 10h 1  1   MTX_MODE - Set Matrix Mode (W)
  4000444h 11h -  17  MTX_PUSH - Push Current Matrix on Stack (W)
  4000448h 12h 1  36  MTX_POP - Pop Current Matrix from Stack (W)
  400044Ch 13h 1  17  MTX_STORE - Store Current Matrix on Stack (W)
  4000450h 14h 1  36  MTX_RESTORE - Restore Current Matrix from Stack (W)
  4000454h 15h -  19  MTX_IDENTITY - Load Unit Matrix to Current Matrix (W)
  4000458h 16h 16 34  MTX_LOAD_4x4 - Load 4x4 Matrix to Current Matrix (W)
  400045Ch 17h 12 30  MTX_LOAD_4x3 - Load 4x3 Matrix to Current Matrix (W)
  4000460h 18h 16 35* MTX_MULT_4x4 - Multiply Current Matrix by 4x4 Matrix (W)
  4000464h 19h 12 31* MTX_MULT_4x3 - Multiply Current Matrix by 4x3 Matrix (W)
  4000468h 1Ah 9  28* MTX_MULT_3x3 - Multiply Current Matrix by 3x3 Matrix (W)
  400046Ch 1Bh 3  22  MTX_SCALE - Multiply Current Matrix by Scale Matrix (W)
  4000470h 1Ch 3  22* MTX_TRANS - Mult. Curr. Matrix by Translation Matrix (W)
  4000480h 20h 1  1   COLOR - Directly Set Vertex Color (W)
  4000484h 21h 1  9*  NORMAL - Set Normal Vector (W)
  4000488h 22h 1  1   TEXCOORD - Set Texture Coordinates (W)
  400048Ch 23h 2  9   VTX_16 - Set Vertex XYZ Coordinates (W)
  4000490h 24h 1  8   VTX_10 - Set Vertex XYZ Coordinates (W)
  4000494h 25h 1  8   VTX_XY - Set Vertex XY Coordinates (W)
  4000498h 26h 1  8   VTX_XZ - Set Vertex XZ Coordinates (W)
  400049Ch 27h 1  8   VTX_YZ - Set Vertex YZ Coordinates (W)
  40004A0h 28h 1  8   VTX_DIFF - Set Relative Vertex Coordinates (W)
  40004A4h 29h 1  1   POLYGON_ATTR - Set Polygon Attributes (W)
  40004A8h 2Ah 1  1   TEXIMAGE_PARAM - Set Texture Parameters (W)
  40004ACh 2Bh 1  1   PLTT_BASE - Set Texture Palette Base Address (W)
  40004C0h 30h 1  4   DIF_AMB - MaterialColor0 - Diffuse/Ambient Reflect. (W)
  40004C4h 31h 1  4   SPE_EMI - MaterialColor1 - Specular Ref. &amp; Emission (W)
  40004C8h 32h 1  6   LIGHT_VECTOR - Set Light's Directional Vector (W)
  40004CCh 33h 1  1   LIGHT_COLOR - Set Light Color (W)
  40004D0h 34h 32 32  SHININESS - Specular Reflection Shininess Table (W)
  4000500h 40h 1  1   BEGIN_VTXS - Start of Vertex List (W)
  4000504h 41h -  1   END_VTXS - End of Vertex List (W)
  4000540h 50h 1  392 SWAP_BUFFERS - Swap Rendering Engine Buffer (W)
  4000580h 60h 1  1   VIEWPORT - Set Viewport (W)
  40005C0h 70h 3  103 BOX_TEST - Test if Cuboid Sits inside View Volume (W)
  40005C4h 71h 2  9   POS_TEST - Set Position Coordinates for Test (W)
  40005C8h 72h 1  5   VEC_TEST - Set Directional Vector for Test (W)
</TD></TR></TABLE>
All cycle timings are counted in 33.51MHz units. NORMAL commands takes 9..12
cycles, depending on the number of enabled lights in PolyAttr (Huh, 9..12 (four
timings) cycles for 0..4 (five settings) lights?) Total execution time of
SwapBuffers is Duration until VBlank, plus 392 cycles.<BR>
In MTX_MODE=2 (Simultanous Set), MTX_MULT/TRANS take additional 30 cycles.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="ds3ddisplaycontrol"></A>&nbsp;
  DS 3D Display Control
</FONT></TD></TR></TABLE><BR>
<B>4000060h - DISP3DCNT - 3D Display Control Register (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Texture Mapping      (0=Disable, 1=Enable)
  1     PolygonAttr Shading  (0=Toon Shading, 1=Highlight Shading)
  2     Alpha-Test           (0=Disable, 1=Enable) (see ALPHA_TEST_REF)
  3     Alpha-Blending       (0=Disable, 1=Enable) (see various Alpha values)
  4     Anti-Aliasing        (0=Disable, 1=Enable)
  5     Edge-Marking         (0=Disable, 1=Enable) (see EDGE_COLOR)
  6     Fog Color/Alpha Mode (0=Alpha and Color, 1=Only Alpha) (see FOG_COLOR)
  7     Fog Master Enable    (0=Disable, 1=Enable)
  8-11  Fog Depth Shift      (FOG_STEP=400h shr FOG_SHIFT) (see FOG_OFFSET)
  12    Color Buffer RDLINES Underflow (0=None, 1=Underflow/Acknowledge)
  13    Polygon/Vertex RAM Overflow    (0=None, 1=Overflow/Acknowledge)
  14    Rear-Plane Mode                (0=Blank, 1=Bitmap)
  15-31 Not used
</TD></TR></TABLE>
<BR>
<B>4000540h - Cmd 50h - SWAP_BUFFERS - Swap Rendering Engine Buffer (W)</B><BR>
SwapBuffers exchanges the two sets of Polygon/Vertex RAM buffers, that is, the
newly defined polygons/vertices are passed to the rendering engine (and will be
displayed in following frame(s)). The other buffer is emptied, and passed to
the Geometry Engine (to be filled with new polygons/vertices by Geometry
Commands).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Translucent polygon Y-sorting (0=Auto-sort, 1=Manual-sort)
  1     Depth Buffering  (0=With Z-value, 1=With W-value)
        (mode 1 does not function properly with orthogonal projections)
  2-31  Not used
</TD></TR></TABLE>
SwapBuffers isn't executed until next VBlank (Scanline 192) (the Geometry
Engine is halted for that duration). SwapBuffers should not be issued within
Begin/End. The two parameter bits of the SwapBuffers command are used for the
following gxcommands (ie. not for the old gxcommands prior to SwapBuffers).<BR>
SwapBuffers does lock-up the 3D hardware if an incomplete polygon list has been
defined (eg. a triangle with only 2 vertices). On lock-up, only 2D video is
kept working, any wait-loops for GXSTAT.27 will hang the program. Once lock-up
has occured, there seems to be no way to recover by software, not by sending
the missing veric(es), and not even by pulsing POWCNT1.Bit2-3.<BR>
<BR>
<B>4000580h - Cmd 60h - VIEWPORT - Set Viewport (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-7   Screen/BG0 Coordinate X1 (0..255) (For Fullscreen: 0=Left-most)
  8-15  Screen/BG0 Coordinate Y1 (0..191) (For Fullscreen: 0=Bottom-most)
  16-23 Screen/BG0 Coordinate X2 (0..255) (For Fullscreen: 255=Right-most)
  24-31 Screen/BG0 Coordinate Y2 (0..191) (For Fullscreen: 191=Top-most)
</TD></TR></TABLE>
Coordinate 0,0 is the lower-left (unlike for 2D where it'd be upper-left).<BR>
The 3D view-volume (size as defined by the Projection Matrix) is automatically
scaled to match into the Viewport area. Although polygon vertices are clipped
to the view-volume, some vertices may still exceed to X2,Y1 (lower-right)
boundary by one pixel, due to some sort of rounding errors. The Viewport
settings don't affect the size or position of the 3D Rear-Plane. Viewport
should not be issued within Begin/End.<BR>
<BR>
<B>4000610h - DISP_1DOT_DEPTH - 1-Dot Polygon Display Boundary Depth (W)</B><BR>
1-Dot Polygons are very small, or very distant polygons, which would be
rendered as a single pixel on screen. Polygons with a depth value greater (more
distant) than DISP_1DOT_DEPTH can be automatically hidden; in order to reduce
memory consumption, or to reduce dirt on the screen.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-14  W-Coordinate (Unsigned, 12bit integer, 3bit fractional part)
  15-31 Not used                 (0000h=Closest, 7FFFh=Most Distant)
</TD></TR></TABLE>
The DISP_1DOT_DEPTH comparision can be enabled/disabled per polygon (via
POLYGON_ATTR.Bit13), so "important" polygons can be displayed regardless of
their size and distance.<BR>
Note: The comparision is always using the W-coordinate of the vertex (not the
Z-coordinate) (ie. no matter if using Z-buffering, or W-buffering). The polygon
is rendered if at least one of its vertices is having a w-coordinate less or
equal than DISP_1DOT_DEPTH. NB. despite of checking the w-coords of ALL
vertices, the polygon is rendered using the color/depth/texture of its FIRST
vertex.<BR>
Note: The hardware does round-up the width and height of all polygons to at
least 1, so polygons of 0x0, 1x0, 0x1, and 1x1 dots will be all rounded-up to a
size of 1x1. Of which, the so-called "1dot" depth check is applied only to the
0x0 dot variant (so "0dot" depth check would be a better name for it).<BR>
Caution: Although DISP_1DOT_DEPTH is a Geometry Engine parameter, it is NOT
routed through GXFIFO, ie. changes will take place immediately, and will affect
all following polygons, including such that are still in GXFIFO. Workaround:
ensure that GXFIFO is empty before changing this parameter.<BR>
<BR>
<B>4000340h - ALPHA_TEST_REF - Alpha-Test Comparision Value (W)</B><BR>
Alpha Test can be enabled in DISP3DCNT.Bit2. When enabled, pixels are rendered
only if their Alpha value is GREATER than ALPHA_TEST_REF. Otherwise, when
disabled, pixels are rendered only if their Alpha value is GREATER than zero.
Alpha Test is performed on the final polygon pixels (ie. after texture
blending).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-4   Alpha-Test Comparision Value (0..31) (Draw pixels if Alpha&gt;AlphaRef)
  5-31  Not used
</TD></TR></TABLE>
Value 00h is effectively the same as when Alpha Test is disabled. Value 1Fh
hides all polygons, including opaque ones.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="ds3dgeometrycommands"></A>&nbsp;
  DS 3D Geometry Commands
</FONT></TD></TR></TABLE><BR>
<B>4000400h - GXFIFO - Geometry Command FIFO (W) (mirrored up to 400043Fh?)</B><BR>
Used to send packed commands, unpacked commands,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-7   First  Packed Command (or Unpacked Command)
  8-15  Second Packed Command (or 00h=None)
  16-23 Third  Packed Command (or 00h=None)
  24-31 Fourth Packed Command (or 00h=None)
</TD></TR></TABLE>
and parameters,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-31  Parameter data for the previously sent (packed) command(s)
</TD></TR></TABLE>
to the Geometry engine.<BR>
<BR>
<B>FIFO / PIPE Number of Entries</B><BR>
The FIFO has 256 entries, additionally, there is a PIPE with four entries
(giving a total of 260 entries). If the FIFO is empty, and if the PIPE isn't
full, then data is moved directly into the PIPE, otherwise it is moved into the
FIFO. If the PIPE runs half empty (less than 3 entries) then 2 entries are
moved from the FIFO to the PIPE. The state of the FIFO can be obtained in
GXSTAT.Bit16-26, observe that there may be still data in the PIPE, even if the
FIFO is empty. Check the busy flag in GXSTAT.Bit27 to see if the PIPE or FIFO
contains data (or if a command is still executing).<BR>
Each PIPE/FIFO entry consists of 40bits of data (8bit command code, plus 32bit
parameter value). Commands without parameters occupy 1 entry, and Commands with
N parameters occupy N entries.<BR>
<BR>
<B>Sending Commands by Ports 4000440h..40005FFh</B><BR>
Geometry commands can be indirectly sent to the FIFO via ports 4000440h and up.<BR>
For a command with N paramters: issue N writes to the port.<BR>
For a command without parameters: issue one dummy-write to the port.<BR>
That mechanism puts the 8bit command + 32bit parameter into the FIFO/PIPE.<BR>
If the FIFO is full, then a wait is generated until data is removed from the
FIFO, ie. the STR opcode gets freezed, during the wait, the bus cannot be used
even by DMA, interrupts, or by the NDS7 CPU.<BR>
<BR>
<B>GXFIFO Access via DMA</B><BR>
Larger pre-calculated data blocks can be sent directly to the FIFO. This is
usually done via DMA (use DMA in Geometry Command Mode, 32bit units,
Dest=4000400h/fixed, Length=NumWords, Repeat=0). The timings are handled
automatically, ie. the system (should) doesn't freeze when the FIFO is full
(see below Overkill note though). DMA starts when the FIFO becomes less than
half full, the DMA does then write 112 words to the GXFIFO register (or less,
if the remaining DMA transfer length gets zero).<BR>
<BR>
<B>GXFIFO Access via STR,STRD,STM</B><BR>
If desired, STR,STRD,STM opcodes can be used to write to the FIFO.<BR>
Opcodes that write more than one 32bit value (ie. STRD and STM) can be used to
send ONE UNPACKED command, plus any parameters which belong to that command.
After that, there must be a 1 cycle delay before sending the next command (ie.
one cannot sent more than one command at once with a single opcode, each
command must be invoked by a new opcode). STRD and STM can be used because the
GXFIFO register is mirrored to 4000400h..43Fh (16 words).<BR>
As with Ports 4000440h and up, the CPU gets stopped if (and as long as) the
FIFO is full.<BR>
<BR>
<B>GXFIFO / Unpacked Commands</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  - command1 (upper 24bit zero)
  - parameter(s) for command1 (if any)
  - command2 (upper 24bit zero)
  - parameter(s) for command2 (if any)
  - command3 (upper 24bit zero)
  - parameter(s) for command3 (if any)
</TD></TR></TABLE>
<BR>
<B>GXFIFO / Packed Commands</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  - command1,2,3,4 packed into one 32bit value (all bits used)
  - parameter(s) for command1 (if any)
  - parameter(s) for command2 (if any)
  - parameter(s) for command3 (if any)
  - parameter(s) for command4 (top-most packed command MUST have parameters)
  - command5,6 packed into one 32bit value (upper 16bit zero)
  - parameter(s) for command5 (if any)
  - parameter(s) for command6 (top-most packed command MUST have parameters)
  - command7,8,9 packed into one 32bit value (upper 8bit zero)
  - parameter(s) for command7 (if any)
  - parameter(s) for command8 (if any)
  - parameter(s) for command9 (top-most packed command MUST have parameters)
</TD></TR></TABLE>
Packed commands are first decompressed and then stored in command the FIFO.<BR>
<BR>
<B>GXFIFO DMA Overkill on Packed Commands Without Parameters</B><BR>
Normally, the 112 word limit ensures that the FIFO (256 entries) doesn't get
full, however, this limit is much too high for sending a lot of "Packed
Commands Without Parameters" (ie. PUSH, IDENTITY, or END) - eg. sending 112 x
Packed(00151515h) to GXFIFO would write 336 x Cmd(15h) to the FIFO, which is
causing the FIFO to get full, and which is causing the DMA (and CPU) to be
paused (for several seconds, in WORST case) until enough FIFO commands have
been processed to allow the DMA to finish the 112 word transfer.<BR>
Not sure if there's much chance to get Overkills in practice. Normally most
commands DO have parameters, and so, usually even LESS than 112 FIFO entries
are occupied (since 8bit commands with 32bit parameters are merged into single
40bit FIFO entries).<BR>
<BR>
<B>Invalid GX commands</B><BR>
Invalid commands (anything else than 10h..1Ch, 20h..2Bh, 30h..33h, 40h..41h,
50h, 60h, or 70h..72h) seem to be simply ignored by the hardware (at least,
testing has confirmed that they do not fetch any parameters from the gxfifo).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="ds3dmatrixloadmultiply"></A>&nbsp;
  DS 3D Matrix Load/Multiply
</FONT></TD></TR></TABLE><BR>
<B>4000440h - Cmd 10h - MTX_MODE - Set Matrix Mode (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-1   Matrix Mode (0..3)
         0  Projection Matrix
         1  Position Matrix (aka Modelview Matrix)
         2  Position &amp; Vector Simultaneous Set mode (used for Light+VEC_TEST)
         3  Texture Matrix (see DS 3D Texture Coordinates chapter)
  2-31  Not used
</TD></TR></TABLE>
Selects the current Matrix, all following MTX commands (load, multiply, push,
pop, etc.) are applied to that matrix. In Mode 2, all MTX commands are applied
to both the Position and Vector matrices (except for MTX_SCALE which doesn't
change the Vector Matrix, even in Mode 2).<BR>
<BR>
<B>4000454h - Cmd 15h - MTX_IDENTITY - Load Unit Matrix to Current Matrix (W)</B><BR>
Sets C=I. Parameters: None<BR>
The Identity Matrix (I), aka Unit Matrix, consists of all zeroes, with a
diagonal row of ones. A matrix multiplied by the Unit Matrix is left unchanged.<BR>
<BR>
<B>4000458h - Cmd 16h - MTX_LOAD_4x4 - Load 4x4 Matrix to Current Matrix (W)</B><BR>
Sets C=M. Parameters: 16, m[0..15]<BR>
<BR>
<B>400045Ch - Cmd 17h - MTX_LOAD_4x3 - Load 4x3 Matrix to Current Matrix (W)</B><BR>
Sets C=M. Parameters: 12, m[0..11]<BR>
<BR>
<B>4000460h - Cmd 18h - MTX_MULT_4x4 - Multiply Current Matrix by 4x4 Matrix (W)</B><BR>
Sets C=M*C. Parameters: 16, m[0..15]<BR>
<BR>
<B>4000464h - Cmd 19h - MTX_MULT_4x3 - Multiply Current Matrix by 4x3 Matrix (W)</B><BR>
Sets C=M*C. Parameters: 12, m[0..11]<BR>
<BR>
<B>4000468h - Cmd 1Ah - MTX_MULT_3x3 - Multiply Current Matrix by 3x3 Matrix (W)</B><BR>
Sets C=M*C. Parameters: 9, m[0..8]<BR>
<BR>
<B>400046Ch - Cmd 1Bh - MTX_SCALE - Multiply Current Matrix by Scale Matrix (W)</B><BR>
Sets C=M*C. Parameters: 3, m[0..2] (MTX_SCALE doesn't change Vector Matrix)<BR>
<BR>
<B>4000470h - Cmd 1Ch - MTX_TRANS - Mult. Curr. Matrix by Translation Matrix (W)</B><BR>
Sets C=M*C. Parameters: 3, m[0..2] (x,y,z position)<BR>
<BR>
<B>4000640h..67Fh - CLIPMTX_RESULT - Read Current Clip Coordinates Matrix (R)</B><BR>
This 64-byte region (16 words) contains the m[0..15] values of the Current Clip
Coordinates Matrix, arranged in 4x4 Matrix format. Make sure that the Geometry
Engine is stopped (GXSTAT.27) before reading from these registers.<BR>
The Clip Matrix is internally used to convert vertices to screen coordinates,
and is internally re-calculated anytime when changing the Position or
Projection matrices:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ClipMatrix = PositionMatrix * ProjectionMatrix
</TD></TR></TABLE>
To read only the Position Matrix, or only the Projection Matrix: Use Load
Identity on the OTHER matrix, so the ClipMatrix becomes equal to the DESIRED
matrix (multiplied by the Identity Matrix, which has no effect on the result).<BR>
<BR>
<B>4000680h..6A3h - VECMTX_RESULT - Read Current Directional Vector Matrix (R)</B><BR>
This 36-byte region (9 words) contains the m[0..8] values of the Current
Directional Vector Matrix, arranged in 3x3 Matrix format (the fourth row/column
may contain any values).<BR>
Make sure that the Geometry Engine is stopped (GXSTAT.27) before reading from
these registers.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="ds3dmatrixtypes"></A>&nbsp;
  DS 3D Matrix Types
</FONT></TD></TR></TABLE><BR>
Essentially, all matrices in the NDS are 4x4 Matrices, consisting of 16 values,
m[0..15]. Each element is a signed fixed-point 32bit number, with a fractional
part in the lower 12bits.<BR>
The other Matrix Types are used to reduce the number of parameters being
transferred, for example, 3x3 Matrix requires only nine parameters, the other
seven elements are automatically set to 0 or 1.0 (whereas "1.0" means "1 SHL
12" in 12bit fixed-point notation).<BR>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
<B>   _      4x4 Matrix       _        _    Identity Matrix    _</B>
  | m[0]  m[1]  m[2]  m[3]  |      |  1.0   0     0     0    |
  | m[4]  m[5]  m[6]  m[7]  |      |  0     1.0   0     0    |
  | m[8]  m[9]  m[10] m[11] |      |  0     0     1.0   0    |
  |_m[12] m[13] m[14] m[15]_|      |_ 0     0     0     1.0 _|
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
<B>   _      4x3 Matrix       _        _  Translation Matrix   _</B>
  | m[0]  m[1]  m[2]   0    |      |  1.0   0     0     0    |
  | m[3]  m[4]  m[5]   0    |      |  0     1.0   0     0    |
  | m[6]  m[7]  m[8]   0    |      |  0     0     1.0   0    |
  |_m[9]  m[10] m[11]  1.0 _|      |_m[0]  m[1]  m[2]   1.0 _|
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
<B>   _      3x3 Matrix       _        _     Scale Matrix      _</B>
  | m[0]  m[1]  m[2]   0    |      | m[0]   0     0     0    |
  | m[3]  m[4]  m[5]   0    |      |  0    m[1]   0     0    |
  | m[6]  m[7]  m[8]   0    |      |  0     0    m[2]   0    |
  |_ 0     0     0     1.0 _|      |_ 0     0     0     1.0 _|
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="ds3dmatrixstack"></A>&nbsp;
  DS 3D Matrix Stack
</FONT></TD></TR></TABLE><BR>
<B>Matrix Stack</B><BR>
The NDS has three Matrix Stacks, and two Matrix Stack Pointers (the Coordinate
Matrix stack pointer is also shared for Directional Matrix Stack).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Matrix Stack        Valid Stack Area    Stack Pointer
  Projection Stack    0..0  (1 entry)     0..1  (1bit) (GXSTAT: 1bit)
  Coordinate Stack    0..30 (31 entries)  0..63 (6bit) (GXSTAT: 5bit only)
  Directional Stack   0..30 (31 entries)  (uses Coordinate Stack Pointer)
  Texture Stack       One..None?          0..1  (1bit) (GXSTAT: N/A)
</TD></TR></TABLE>
The initial value of the Stack Pointers is zero, the current value of the
pointers can be read from GXSTAT (read-only), that register does also indicate
stack overflows (errors flag gets set on read/write to invalid entries, ie.
entries 1 or 1Fh..3Fh). For all stacks, the upper half (ie. 1 or 20h..3Fh) are
mirrors of the lower half (ie. 0 or 0..1Fh).<BR>
<BR>
<B>4000444h - Cmd 11h - MTX_PUSH - Push Current Matrix on Stack (W)</B><BR>
Parameters: None. Sets [S]=C, and then S=S+1.<BR>
<BR>
<B>4000448h - Cmd 12h - MTX_POP - Pop Current Matrix from Stack (W)</B><BR>
Sets S=S-N, and then C=[S].<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Parameter Bit0-5:  Stack Offset (signed value, -30..+31) (usually +1)
  Parameter Bit6-31: Not used
</TD></TR></TABLE>
Offset N=(+1) pops the most recently pushed value, larger offsets of N&gt;1
will "deallocate" N values (and load the Nth value into C). Zero or negative
values can be used to pop previously "deallocated" values.<BR>
The stack has only one level (at address 0) in projection mode, in that mode,
the parameter value is ignored, the offset is always +1 in that mode.<BR>
<BR>
<B>400044Ch - Cmd 13h - MTX_STORE - Store Current Matrix on Stack (W)</B><BR>
Sets [N]=C. The stack pointer S is not used, and is left unchanged.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Parameter Bit0-4:  Stack Address (0..30) (31 causes overflow in GXSTAT.15)
  Parameter Bit5-31: Not used
</TD></TR></TABLE>
The stack has only one level (at address 0) in projection mode, in that mode,
the parameter value is ignored.<BR>
<BR>
<B>4000450h - Cmd 14h - MTX_RESTORE - Restore Current Matrix from Stack (W)</B><BR>
Sets C=[N]. The stack pointer S is not used, and is left unchanged.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Parameter Bit0-4:  Stack Address (0..30) (31 causes overflow in GXSTAT.15)
  Parameter Bit5-31: Not used
</TD></TR></TABLE>
The stack has only one level (at address 0) in projection mode, in that mode,
the parameter value is ignored.<BR>
<BR>
In Projection mode, the parameter for POP, STORE, and RESTORE is unused - not
sure if the parameter (ie. a dummy value) is - or is not - to be written to the
command FIFO?<BR>
There appear to be actually 32 entries in Coordinate &amp; Directional Stacks,
entry 31 appears to exist, and appears to be read/write-able (although the
stack overflow flag gets set when accessing it).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="ds3dmatrixexamplesprojection"></A>&nbsp;
  DS 3D Matrix Examples (Projection)
</FONT></TD></TR></TABLE><BR>
The most important matrix is the Projection Matrix (to be initialized with
MTX_MODE=0 via MTX_LOAD_4x4 command). It does specify the dimensions of the
view volume.<BR>
<BR>
With Perspective Projections more distant objects will appear smaller, with
Orthogonal Projects the size of the objects is always same regardless of their
distance.<BR>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
<B>  Perspective Projection     Orthogonal Projection</B>
                   __                  __________
       top __..--''  |            top |          |
          |   view   |                |   view   |
  Eye ----|---------&gt;|        Eye ----|---------&gt;|
          |__volume  |                |  volume  |
     bottom  ''--..__|          bottom|__________|
        near        far             near        far
</TD></TR></TABLE>
<BR>
Correctly initializing the projection matrix (as shown in the examples below)
can be quite difficult (mind that fixed point multiply/divide requires to
adjust the fixed-point width before/after calculation). For beginners, it may
be recommended to start with a simple Identity Matrix (MTX_IDENTITY command)
used as Projection Matrix (ie. Ortho with t,b,l,r set to +/-1).<BR>
<BR>
<B>Orthogonal Projections (Ortho)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  | (2.0)/(r-l)       0             0            0     |
  |      0       (2.0)/(t-b)        0            0     |
  |      0            0        (2.0)/(n-f)       0     |
  | (l+r)/(l-r)  (b+t)/(b-t)   (n+f)/(n-f)      1.0    |
</TD></TR></TABLE>
n,f specify the distance from eye to near and far clip planes. t,b,l,r are the
coordinates of near clip plane (top,bottom,left,right). For a symmetrical view
(ie. the straight-ahead view line centered in the middle of viewport) t,b,l,r
should be usually t=+ysiz/2, b=-ysiz/2, r=+xsiz/2, l=-xsiz/2; the (xsiz/ysiz)
ratio should be usually equal to the viewport's (width/heigh) ratio. Examples
for a asymmetrical view would be b=0 (frog's view), or t=0 (bird's view).<BR>
<BR>
<B>Left-Right Asymmetrical Perspective Projections (Frustum)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  | (2*n)/(r-l)       0             0            0     |
  |      0       (2*n)/(t-b)        0            0     |
  | (r+l)/(r-l)  (t+b)/(t-b)   (n+f)/(n-f)     -1.0    |
  |      0            0       (2*n*f)/(n-f)      0     |
</TD></TR></TABLE>
n,f,t,b,l,r have same meanings as above (Ortho), the difference is that more
distant objects will appear smaller with Perspective Projection (unlike
Orthogonal Projection where the size isn't affected by the distance).<BR>
<BR>
<B>Left-Right Symmetrical Perspective Projections (Perspective)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  | cos/(asp*sin)     0             0            0     |
  |      0         cos/sin          0            0     |
  |      0            0        (n+f)/(n-f)     -1.0    |
  |      0            0       (2*n*f)/(n-f)      0     |
</TD></TR></TABLE>
Quite the same as above (Frustum), but with symmetrical t,b values (which are
in this case obtained from a vertical view range specified in degrees), and l,r
are matched to the aspect ratio of the viewport (asp=height/width).<BR>
<BR>
<B>Moving the Camera</B><BR>
After initializing the Projection Matrix, you may multiply it with Rotate
and/or Translation Matrices to change camera's position and view direction.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="ds3dmatrixexamplesrotatescaletranslate"></A>&nbsp;
  DS 3D Matrix Examples (Rotate/Scale/Translate)
</FONT></TD></TR></TABLE><BR>
<B>Identity Matrix</B><BR>
The MTX_IDENTITY command can be used to initialize the Position Matrix before
doing any Translation/Scaling/Rotation, for example:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Load(Identity)                           ;no rotation/scaling used
  Load(Identity), Mul(Rotate), Mul(Scale)  ;rotation/scaling (not so efficient)
  Load(Rotate), Mul(Scale)                 ;rotation/scaling (more efficient)
</TD></TR></TABLE>
<BR>
<B>Rotation Matrices</B><BR>
Rotation can be performed with MTX_MULT_3x3 command, simple examples are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Around X-Axis          Around Y-Axis          Around Z-Axis
  | 1.0  0     0   |     | cos   0    sin |     | cos   sin   0   |
  | 0    cos   sin |     | 0     1.0  0   |     | -sin  cos   0   |
  | 0    -sin  cos |     | -sin  0    cos |     | 0     0     1.0 |
</TD></TR></TABLE>
<BR>
<B>Scale Matrix</B><BR>
The MTX_SCALE command allows to adjust the size of the polygon. The x,y,z
parameters should be normally all having the same value, x=y=z (unless if you
want to change only the height of the object, for example). Identical results
can be obtained with MTX_MULT commands, however, when using lighting
(MTX_MODE=2), then scaling should be done ONLY with MTX_SCALE (which keeps the
length of the light's directional vector intact).<BR>
<BR>
<B>Translation Matrix</B><BR>
The MTX_TRANS command allows to move polygons to the desired position. The
polygon VTX commands are spanning only a small range of coordinates (near
zero-coordinate), so translation is required to move the polygons to other
locations in the world coordinates. Aside from that, translation is useful for
moved objects (at variable coordinates), and for re-using an object at various
locations (eg. you can create a forest by translating a tree to different
coordinates).<BR>
<BR>
<B>Matrix Multiply Order</B><BR>
The Matrix must be set up BEFORE sending the Vertices (which are then
automatically multiplied by the matrix). When using multiple matrices
multiplied with each other: Mind that, for matrix maths A*B is NOT the same as
B*A. For example, if you combine Rotate and Translate Matrices, the object will
be either rotated around it's own zero-coordinate, or around world-space
zero-coordinate, depending on the multiply order.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="ds3dmatrixexamplesmathsbasics"></A>&nbsp;
  DS 3D Matrix Examples (Maths Basics)
</FONT></TD></TR></TABLE><BR>
Below is a crash-course on matrix maths. Most of it is carried out
automatically by the hardware. So this chapter is relevant only if you are
interested in details about what happens inside of the 3D engine.<BR>
<BR>
<B>Matrix-by-Matrix Multiplication</B><BR>
Matrix multiplication, C = A * B, is possible only if the number of columns in
A is equal to the number of rows in B, so it works fine with the 4x4 matrices
which are used in the NDS. For the multiplication, assume matrix C to consist
of elements cyx, and respecitively, matrix A and B to consist of elements ayx
and byx. So that C = A * B looks like:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  | c11 c12 c13 c14 |     | a11 a12 a13 a14 |     | b11 b12 b13 b14 |
  | c21 c22 c23 c24 |  =  | a21 a22 a23 a24 |  *  | b21 b22 b23 b24 |
  | c31 c32 c33 c34 |     | a31 a32 a33 a34 |     | b31 b32 b33 b34 |
  | c41 c42 c43 c44 |     | a41 a42 a43 a44 |     | b41 b42 b43 b44 |
</TD></TR></TABLE>
Each element in C is calculated by multiplying the elements from one row in A
by the elements from the corresponding column in B, and then taking the sum of
the products, ie.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  cyx = ay1*b1x + ay2*b2x + ay3*b3x + ay4*b4x
</TD></TR></TABLE>
In total, that requires 64 multiplications (four multiplications for each of
the 16 cyx elements), and 48 additions (three per cyx element), the hardware
carries out that operation at a relative decent speed of 30..35 clock cycles,
possibly by performing several multiplications simultaneously with separate
multiply units.<BR>
Observe that for matrix multiplication, A*B is NOT the same as B*A.<BR>
<BR>
<B>Matrix-by-Vector &amp; Vector-by-Matrix Multiplication</B><BR>
Vectors are Matrices with only one row, or only one column. Multiplication
works as for normal matrices; the number of rows/columns must match up,
repectively, row-vectors can be multiplied by matrices; and matrices can be
multiplied by column-vectors (but not vice-versa). Eg. C = A * B:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
                                                  | b11 b12 b13 b14 |
  | c11 c12 c13 c14 |  =  | a11 a12 a13 a14 |  *  | b21 b22 b23 b24 |
                                                  | b31 b32 b33 b34 |
                                                  | b41 b42 b43 b44 |
</TD></TR></TABLE>
The formula for calculating the separate elements is same as above,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  cyx = ay1*b1x + ay2*b2x + ay3*b3x + ay4*b4x
</TD></TR></TABLE>
Of which, C and A have only one y-index, so one may replace "cyx and ayx" by
"c1x and a1x", or completely leave out the y-index, ie. "cx and ax".<BR>
<BR>
<B>Matrix-by-Number Multiplication</B><BR>
Simply multiply all elements of the Matrix by the number, C = A * n:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  cyx = ayx*n
</TD></TR></TABLE>
Of course, works also with vectors (matrices with only one row/column).<BR>
<BR>
<B>Matrix-to-Matrix Addition/Subtraction</B><BR>
Both matrices must have the same number of rows &amp; columns, add/subtract all
elements with corresponding elements in other matrix, C = A +/- B:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  cyx = ayx +/- byx
</TD></TR></TABLE>
Of course, works also with vectors (two matrices with only one row/column).<BR>
<BR>
<B>Vectors</B><BR>
A vector, for example (x,y,z), consists of offsets along x-,y-, and z-axis. The
line from origin to origin-plus-offset is having two characteristics: A
direction, and a length.<BR>
The length (aka magnitude) can be calculated as L=sqrt(x^2+y^2+z^2).<BR>
<BR>
<B>Vector-by-Vector Multiplication</B><BR>
This can be processed as LineVector*RowVector, so the result is a number (aka
scalar) (aka a matrix with only 1x1 elements). Multiplying two (normalized)
vectors results in: "cos(angle)=vec1*vec2", ie. the cosine of the angle between
the two vectors (eg. used for light vectors). Multiplying a vector with itself,
and taking the square root of the result obtains its length, ie.
"length=sqrt(vec^2)".<BR>
That stuff should be done with 3-dimensional vectors (not 4-dimensionals).<BR>
<BR>
<B>Normalized Vectors</B><BR>
Normalized Vectors (aka Unit Vectors) are vectors with length=1.0. To normalize
a vector, divide its coordinates by its length, ie. x=x/L, y=y/L, z=z/L, the
direction remains the same, but the length is now 1.0.<BR>
On the NDS, normalized vectors should have a length of something less than 1.0
(eg. something like 0.99) because several NDS registers are limited to 1bit
sign, 0bit interger, Nbit fraction part (so vectors that are parallel to the
x,y,z axes, or that become parallel to them after rotation, cannot have a
length of 1.0).<BR>
<BR>
<B>Fixed-Point Numbers</B><BR>
The NDS uses fixed-point numbers (rather than floating point numbers). Addition
and Subtraction works as with normal integers, provided that the fractional
part is the same for both numbers. If it is not the same: Shift-left the value
with the smaller fractional part.<BR>
For multiplication, the fractional part of result is the sum of the fractional
parts (eg. 12bit fraction * 12bit fraction = 24bit fraction; shift-right the
result by 12 to convert it 12bit fraction). The NDS matrix multiply unit is
maintaining the full 24bit fraction when processing the<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  cyx = ay1*b1x + ay2*b2x + ay3*b3x + ay4*b4x
</TD></TR></TABLE>
formula, ie. the three additions are using full 24bit fractions (with
carry-outs to upper bits), the final result of the additions is then
shifted-right by 12.<BR>
For division, it's vice versa, the fractions of the operands are substracted,
24bit fraction / 12bit fraction = 12bit fraction. When dividing two 12bit
numbers, shift-left the first number by 12 before division to get a result with
12bit fractional part.<BR>
<BR>
<B>Four-Dimensional Matrices</B><BR>
The NDS uses four-dimensional matrices and vectors, ie. matrices with 4x4
elements, and vectors with 4 elements. The first three elements are associated
with the X,Y,Z-axes of the three-dimensional space. The fourth element is
somewhat a "W-axis".<BR>
With 4-dimensional matrices, the Translate matrix can be used to move an object
to another position. Ie. once when you've setup a matrix (which may consists of
pre-multiplied scaling, rotation, translation matrices), then that matrix can
be used on vertices to perform the rotation, scaling, translation all-at-once;
by a single Vector*Matrix operation.<BR>
With 3-dimensional matrices, translation would require a separate addition,
additionally to the multiply operation.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="ds3dpolygonattributes"></A>&nbsp;
  DS 3D Polygon Attributes
</FONT></TD></TR></TABLE><BR>
<B>40004A4h - Cmd 29h - POLYGON_ATTR - Set Polygon Attributes (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-3   Light 0..3 Enable Flags (each bit: 0=Disable, 1=Enable)
  4-5   Polygon Mode  (0=Modulation,1=Decal,2=Toon/Highlight Shading,3=Shadow)
  6     Polygon Back Surface   (0=Hide, 1=Render)  ;Line-segments are always
  7     Polygon Front Surface  (0=Hide, 1=Render)  ;rendered (no front/back)
  8-10  Not used
  11    Depth-value for Translucent Pixels    (0=Keep Old, 1=Set New Depth)
  12    Far-plane intersecting polygons       (0=Hide, 1=Render/clipped)
  13    1-Dot polygons behind DISP_1DOT_DEPTH (0=Hide, 1=Render)
  14    Depth Test, Draw Pixels with Depth    (0=Less, 1=Equal) (usually 0)
  15    Fog Enable                            (0=Disable, 1=Enable)
  16-20 Alpha      (0=Wire-Frame, 1..30=Translucent, 31=Solid)
  21-23 Not used
  24-29 Polygon ID (00h..3Fh, used for translucent, shadow, and edge-marking)
  30-31 Not used
</TD></TR></TABLE>
Writes to POLYGON_ATTR have no effect until next BEGIN_VTXS command.<BR>
Changes to the Light bits have no effect until lighting is re-calculated by
Normal command. The interior of Wire-frame polygons is transparent (Alpha=0),
and only the lines at the polygon edges are rendered, using a fixed Alpha value
of 31.<BR>
<BR>
<B>4000480h - Cmd 20h - COLOR - Directly Set Vertex Color (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Parameter 1, Bit 0-4    Red
  Parameter 1, Bit 5-9    Green
  Parameter 1, Bit 10-14  Blue
  Parameter 1, Bit 15-31  Not used
</TD></TR></TABLE>
The 5bit RGB values are internally expanded to 6bit RGB as follows:
X=X*2+(X+31)/32, ie. zero remains zero, all other values are X=X*2+1.<BR>
Aside from by using the Color command, the color can be also changed by
MaterialColor0 command (if MaterialColor0.Bit15 is set, it acts identical as
the Color Command), and by the Normal command (which calculates the color based
on light/material parameters).<BR>
<BR>
<B>Depth Test</B><BR>
The Depth Test compares the depth of the pixels of the polygon with the depth
of previously rendered polygons (or of the rear plane if there have been none
rendered yet). The new pixels are drawn if the new depth is Less (closer to the
camera), or if it is Equal, as selected by POLYGON_ATTR.Bit14.<BR>
Normally, Depth Equal would work only exact matches (ie. if the overlapping
polygons have exactly the same coordinates; and thus have the same rounding
errors), however, the NDS hardware is allowing "Equal" to have a tolerance of
+/-200h (within the 24bit depth range of 0..FFFFFFh), that may bypass rounding
errors, but it may also cause nearby polygons to be accidently treated to have
equal depth.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="ds3dpolygondefinitionsbyvertices"></A>&nbsp;
  DS 3D Polygon Definitions by Vertices
</FONT></TD></TR></TABLE><BR>
The DS supports polygons with 3 or 4 edges, triangles and quadliterals.<BR>
The position of the edges is defined by vertices, each consisting of (x,y,z)
values.<BR>
<BR>
For Line Segments, use Triangles with twice the same vertex, Line Segments are
rendered always because they do not have any front and back sides.<BR>
The Prohibited Quad shapes may produce unintended results, namely, that are
Quads with crossed sides, and quads with angles greater than 180 degrees.<BR>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Separate Tri.     Triangle Strips   Line Segment
  v0                 v2___v4____v6
  |\      v3         /|\  |\    /\     v0    v1
  | \     /\      v0( | \ | \  /  \     ------
  |__\   /__\        \|__\|__\/____\         v2
  v1 v2 v4  v5       v1   v3  v5   v7
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Separate Quads          Quadliteral Strips         Prohibited Quads
    v0__v3                 v0__v2____v4     v10__    v0__v3     v4
     /  \   v4____v7        /  \     |\ _____ / /v11   \/       |\
    /    \   |    \        /    \    | |v6 v8| /       /\     v5| \
   /______\  |_____\      /______\___|_|_____|/       /__\     /___\
   v1    v2  v5    v6     v1    v3  v5 v7   v9       v2   v1   v6   v7
</TD></TR></TABLE>
<BR>
The vertices are normally arranged anti-clockwise, except that: in
triangle-strips each second polygon uses clockwise arranged vertices, and
quad-strips are sorts of "up-down" arranged (whereas "up" and "down" may be
anywhere due to rotation). Other arrangements may result in quads with crossed
lines, or may swap the front and back sides of the polygon (above examples are
showing the front sides).<BR>
<BR>
<B>4000500h - Cmd 40h - BEGIN_VTXS - Start of Vertex List (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Parameter 1, Bit 0-1    Primitive Type (0..3, see below)
  Parameter 1, Bit 2-31   Not used
</TD></TR></TABLE>
Indicates the Start of a Vertex List, and its Primitive Type:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0  Separate Triangle(s)    ;3*N vertices per N triangles
  1  Separate Quadliteral(s) ;4*N vertices per N quads
  2  Triangle Strips         ;3+(N-1) vertices per N triangles
  3  Quadliteral Strips      ;4+(N-1)*2 vertices per N quads
</TD></TR></TABLE>
The BEGIN_VTX command should be followed by VTX_-commands to define the
Vertices of the list, and should be then terminated by END_VTX command.<BR>
BEGIN_VTX additionally applies changes to POLYGON_ATTR.<BR>
<BR>
<B>4000504h - Cmd 41h - END_VTXS - End of Vertex List (W)</B><BR>
Parameters: None. This is a Dummy command for OpenGL compatibility. It should
be used to terminate a BEGIN_VTX, VTX_&lt;values&gt; sequence. END_VTXS is
possibly required for Nintendo's software emulator? On real NDS consoles (and
in no$gba) it does have no effect, it can be left out, or can be issued
multiple times inside of a vertex list, without disturbing the display.<BR>
<BR>
<B>400048Ch - Cmd 23h - VTX_16 - Set Vertex XYZ Coordinates (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Parameter 1, Bit 0-15   X-Coordinate (signed, with 12bit fractional part)
  Parameter 1, Bit 16-31  Y-Coordinate (signed, with 12bit fractional part)
  Parameter 2, Bit 0-15   Z-Coordinate (signed, with 12bit fractional part)
  Parameter 2, Bit 16-31  Not used
</TD></TR></TABLE>
<BR>
<B>4000490h - Cmd 24h - VTX_10 - Set Vertex XYZ Coordinates (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Parameter 1, Bit 0-9    X-Coordinate (signed, with 6bit fractional part)
  Parameter 1, Bit 10-19  Y-Coordinate (signed, with 6bit fractional part)
  Parameter 1, Bit 20-29  Z-Coordinate (signed, with 6bit fractional part)
  Parameter 1, Bit 30-31  Not used
</TD></TR></TABLE>
Same as VTX_16, with only one parameter, with smaller fractional part.<BR>
<BR>
<B>4000494h - Cmd 25h - VTX_XY - Set Vertex XY Coordinates (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Parameter 1, Bit 0-15   X-Coordinate (signed, with 12bit fractional part)
  Parameter 1, Bit 16-31  Y-Coordinate (signed, with 12bit fractional part)
</TD></TR></TABLE>
The Z-Coordinate is kept unchanged, and re-uses the value from previous VTX.<BR>
<BR>
<B>4000498h - Cmd 26h - VTX_XZ - Set Vertex XZ Coordinates (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Parameter 1, Bit 0-15   X-Coordinate (signed, with 12bit fractional part)
  Parameter 1, Bit 16-31  Z-Coordinate (signed, with 12bit fractional part)
</TD></TR></TABLE>
The Y-Coordinate is kept unchanged, and re-uses the value from previous VTX.<BR>
<BR>
<B>400049Ch - Cmd 27h - VTX_YZ - Set Vertex YZ Coordinates (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Parameter 1, Bit 0-15   Y-Coordinate (signed, with 12bit fractional part)
  Parameter 1, Bit 16-31  Z-Coordinate (signed, with 12bit fractional part)
</TD></TR></TABLE>
The X-Coordinate is kept unchanged, and re-uses the value from previous VTX.<BR>
<BR>
<B>40004A0h - Cmd 28h - VTX_DIFF - Set Relative Vertex Coordinates (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Parameter 1, Bit 0-9    X-Difference (signed, with 9/12bit fractional part)
  Parameter 1, Bit 10-19  Y-Difference (signed, with 9/12bit fractional part)
  Parameter 1, Bit 20-29  Z-Difference (signed, with 9/12bit fractional part)
  Parameter 1, Bit 30-31  Not used
</TD></TR></TABLE>
Sets XYZ-Coordinate relative to the XYZ-Coordinates from previous VTX. In
detail: The 9bit fractional values are divided by 8 (sign expanded to 12bit
fractions, in range +/-0.125), and that 12bit fraction is then added to the old
vtx coordinates. The result of the addition should not overflow 16bit vertex
coordinate range (1bit sign, 3bit integer, 12bit fraction).<BR>
<BR>
<B>Notes on VTX commands</B><BR>
On each VTX command, the viewport coordinates of the vertex are calculated and
stored in Vertex RAM,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ( xx, yy, zz, ww ) = ( x, y, z, 1.0 ) * ClipMatrix
</TD></TR></TABLE>
The actual screen position (in pixels) is then,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  screen_x = (xx+ww)*viewport_width / (2*ww) + viewport_x1
  screen_y = (yy+ww)*viewport_height / (2*ww) + viewport_y1
</TD></TR></TABLE>
Each VTX command that completes the definition of a polygon (ie. each 3rd for
Separate Trangles) does additionally store data in Polygon List RAM.<BR>
VTX commands may be issued only between Begin and End commands.<BR>
<BR>
<B>Clipping</B><BR>
Polygons are clipped to the 6 sides of the view volume (ie. to the left, right,
top, bottom, near, and far edges). If one or more vertic(es) exceed one of
these sides, then these vertic(es) are replaced by two newly created vertices
(which are located on the intersections of the polygon edges and the view
volume edge).<BR>
Depending on the number of clipped vertic(es), this may increase or decrease
the number of entries in Vertex RAM (ie. minus N clipped vertices, plus 2 new
vertices). Also, clipped polygons which are part of polygon strips are
converted to separate polygons (which does increase number of entries in Vertex
RAM). Polygons that are fully outside of the View Volume aren't stored in
Vertex RAM, nor in Polygon RAM (the only exception are polygons that are
located exactly one pixel below of, or right of lower/right edges, which appear
to be accidently stored in memory).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="ds3dpolygonlightparameters"></A>&nbsp;
  DS 3D Polygon Light Parameters
</FONT></TD></TR></TABLE><BR>
The lighting operation is performed by executing the Normal command (which sets
the VertexColor based on the Light/Material parameters) (to the rest of the
hardware it doesn't matter if the VertexColor was set by Color command or by
Normal command). Light is calculated only for the Front side of the polygon
(assuming that the Normal is matched to that side), so the Back side will be
(incorrectly) using the same color.<BR>
<BR>
<B>40004C8h - Cmd 32h - LIGHT_VECTOR - Set Light's Directional Vector (W)</B><BR>
Sets direction of the specified light (ie. the light selected in Bit30-31).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-9   Directional Vector's X component (1bit sign + 9bit fractional part)
  10-19 Directional Vector's Y component (1bit sign + 9bit fractional part)
  20-29 Directional Vector's Z component (1bit sign + 9bit fractional part)
  30-31 Light Number                     (0..3)
</TD></TR></TABLE>
Upon executing this command, the incoming vector is multiplied by the current
Directional Matrix, the result is then applied as LightVector. This allows to
rotate the light direction. However, normally, to keep the light unrotated, be
sure to use LoadIdentity (in MtxMode=2) before setting the LightVector.<BR>
<BR>
<B>40004CCh - Cmd 33h - LIGHT_COLOR - Set Light Color (W)</B><BR>
Sets the color of the specified light (ie. the light selected in Bit30-31).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-4   Red          (0..1Fh)      ;\light color this will be combined with
  5-9   Green        (0..1Fh)      ; diffuse, specular, and ambient colors
  10-14 Blue         (0..1Fh)      ;/upon execution of the normal command
  15-29 Not used
  30-31 Light Number (0..3)
</TD></TR></TABLE>
<BR>
<B>40004C0h - Cmd 30h - DIF_AMB - MaterialColor0 - Diffuse/Ambient Reflect. (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-4   Diffuse Reflection Red     ;\light(s) that directly hits the polygon,
  5-9   Diffuse Reflection Green   ; ie. max when NormalVector has opposite
  10-14 Diffuse Reflection Blue    ;/direction of LightVector
  15    Set Vertex Color (0=No, 1=Set Diffuse Reflection Color as Vertex Color)
  16-20 Ambient Reflection Red     ;\light(s) that indirectly hits the polygon,
  21-25 Ambient Reflection Green   ; ie. assuming that light is reflected by
  26-30 Ambient Reflection Blue    ;/walls/floor, regardless of LightVector
  31    Not used
</TD></TR></TABLE>
With Bit15 set, the lower 15bits are applied as VertexColor (exactly as when
when executing the Color command), the purpose is to use it as default color
(eg. when outcommenting the Normal command), normally, when using lighting, the
color setting gets overwritten (as soon as executing the Normal command).<BR>
<BR>
<B>40004C4h - Cmd 31h - SPE_EMI - MaterialColor1 - Specular Ref. &amp; Emission (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-4   Specular Reflection Red    ;\light(s) reflected towards the camera,
  5-9   Specular Reflection Green  ; ie. max when NormalVector is in middle of
  10-14 Specular Reflection Blue   ;/LightVector and ViewDirection
  15    Specular Reflection Shininess Table (0=Disable, 1=Enable)
  16-20 Emission Red               ;\light emitted by the polygon itself,
  21-25 Emission Green             ; ie. regardless of light colors/vectors,
  26-30 Emission Blue              ;/and no matter if any lights are enabled
  31    Not used
</TD></TR></TABLE>
Caution: Specular Reflection WON'T WORK when the ProjectionMatrix is rotated.<BR>
<BR>
<B>40004D0h - Cmd 34h - SHININESS - Specular Reflection Shininess Table (W)</B><BR>
Write 32 parameter words (each 32bit word containing four 8bit entries),
entries 0..3 in the first word, through entries 124..127 in the last word:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-7   Shininess 0 (unsigned fixed-point, 0bit integer, 8bit fractional part)
  8-15  Shininess 1 ("")
  16-23 Shininess 2 ("")
  24-31 Shininess 3 ("")
</TD></TR></TABLE>
If the table is disabled (by MaterialColor1.Bit15), then reflection will act as
if the table would be filled with linear increasing numbers.<BR>
<BR>
<B>4000484h - Cmd 21h - NORMAL - Set Normal Vector (W)</B><BR>
In short, this command does calculate the VertexColor, based on the various
light-parameters.<BR>
In detail, upon executing this command, the incoming vector is multiplied by
the current Directional Matrix, the result is then applied as NormalVector
(giving it the same rotation as used for the following polygon vertices).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-9   X-Component of Normal Vector (1bit sign + 9bit fractional part)
  10-19 Y-Component of Normal Vector (1bit sign + 9bit fractional part)
  20-29 Z-Component of Normal Vector (1bit sign + 9bit fractional part)
  30-31 Not used
</TD></TR></TABLE>
Defines the Polygon's Normal. And, does then update the Vertex Color; by
recursing the View Direction, the NormalVector, the LightVector(s), and
Light/Material Colors. The execution time of the Normal command varies
depending on the number of enabled light(s).<BR>
<BR>
<B>Additional Light Registers</B><BR>
Additionally to above registers, light(s) must be enabled in PolygonAttr (mind
that changes to PolygonAttr aren't applied until next Begin command). And, the
Directional Matrix must be set up correctly (in MtxMode=2) for the LightVector
and NormalVector commands.<BR>
<BR>
<B>Normal Vector</B><BR>
The Normal vector must point "away from the polygon surface" (eg. for the
floor, the Normal should point upwards). That direction is implied by the
polygon vertices, however, the hardware cannot automatically calculate it, so
it must be set manually with the Normal command (prior to the VTX-commands).<BR>
When using lighting, the Normal command must be re-executed after switching
Lighting on/off, or after changing light/material parameters. And, of course,
also before defining polygons with different orientation. Polygons with same
orientation (eg. horizontal polygon surfaces) and same material color can use
the same Normal. Changing the Normal per polygon gives differently colored
polygons with flat surfaces, changing the Normal per vertex gives the illusion
of curved surfaces.<BR>
<BR>
<B>Light Vector</B><BR>
Each light consists of parallel beams; similar to sunlight, which appears to us
(due to the great distance) to consist of parallel beams, all emmitted into the
same direction; towards Earth.<BR>
In reality, light is emitted into ALL directions, originated from the light
source (eg. a candle), the hardware doesn't support that type of non-parallel
light. However, the light vectors can be changed per polygon, so a polygon that
is located north of the light source may use different light direction than a
polygon that is east of the light source.<BR>
And, of course, Light 0..3 may (and should) have different directions.<BR>
<BR>
<B>Normalized Vectors</B><BR>
The Normal Vector and the Light Vectors should be normalized (ie. their length
should be 1.0) (in practice: something like 0.99, since the registers have only
fractional parts) (a length of 1.0 can cause overflows).<BR>
<BR>
<B>Lighting Limitations</B><BR>
The functionality of the light feature is limited to reflecting light to the
camera (light is not reflected to other polygons, nor does it cast shadows on
other polygons). However, independently of the lighting feature, the DS
hardware does allow to create shadows, see:<BR>
<A HREF="#ds3dshadowpolygons">DS 3D Shadow Polygons</A><BR>
<BR>
<B>Internal Operation on Normal Command</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  IF TexCoordTransformMode=2 THEN TexCoord=NormalVector*Matrix (see TexCoord)
  NormalVector=NormalVector*DirectionalMatrix
  VertexColor = EmissionColor
  FOR i=0 to 3
   IF PolygonAttrLight[i]=enabled THEN
    DiffuseLevel = max(0,-(LightVector[i]*NormalVector))
    ShininessLevel = max(0,(-HalfVector[i])*(NormalVector))^2
    IF TableEnabled THEN ShininessLevel = ShininessTable[ShininessLevel]
    ;note: below processed separately for the R,G,B color components...
    VertexColor = VertexColor + SpecularColor*LightColor[i]*ShininessLevel
    VertexColor = VertexColor + DiffuseColor*LightColor[i]*DiffuseLevel
    VertexColor = VertexColor + AmbientColor*LightColor[i]
   ENDIF
  NEXT i
</TD></TR></TABLE>
<BR>
<B>Internal Operation on Light_Vector Command (for Light i)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  LightVector[i] = (LightVector*DirectionalMatrix)
  HalfVector[i] = (LightVector[i]+LineOfSightVector)/2
</TD></TR></TABLE>
<BR>
<B>LineOfSightVector (how it SHOULD work)</B><BR>
Ideally, the LineOfSightVector should point from the camera to the vertic(es),
however, the vertic(es) are still unknown at time of normal command, so it is
just pointing from the camera to the screen, ie.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  LineOfSightVector = (0,0,-1.0)
</TD></TR></TABLE>
Moreover, the LineOfSightVector should be multiplied by the Projection Matrix
(so the vector would get rotated accordingly when the camera gets rotated),
and, after multiplication by a scaled matrix, it'd be required to normalize the
resulting vector.<BR>
<BR>
<B>LineOfSightVector (how it DOES actually work)</B><BR>
However, the NDS cannot normalize vectors by hardware, and therefore, it does
completely leave out the LineOfSightVector*ProjectionMatrix multiplication. So,
the LineOfSightVector is always (0,0,-1.0), no matter of any camera rotation.
That means,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Specular Reflection WON'T WORK when the ProjectionMatrix is rotated (!)
</TD></TR></TABLE>
So, if you want to rotate the "camera" (in MTX_MODE=0), then you must instead
rotate the "world" in the opposite direction (in MTX_MODE=2).<BR>
That problem applies only to Specular Reflection, ie. only if Lighting is used,
and only if the Specular Material Color is nonzero.<BR>
<BR>
<B>Maths Notes</B><BR>
Note on Vector*Vector multiplication: Processed as LineVector*RowVector, so the
result is a number (aka scalar) (aka a matrix with only 1x1 elements),
multiplying two (normalized) vectors results in: "cos(angle)=vec1*vec2", ie.
the consine of the angle between the two vectors.<BR>
The various Normal/Light/Half/Sight vectors are only 3-dimensional (x,y,z), ie.
only the upper-left 3x3 matrix elements are used on multiplications with the
4x4 DirectionalMatrix.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="ds3dshadowpolygons"></A>&nbsp;
  DS 3D Shadow Polygons
</FONT></TD></TR></TABLE><BR>
The DS hardware's Light-function allows to reflect light to the camera, it does
not reflect light to other polygons, and it does not cast any shadows. For
shadows at fixed locations it'd be best to pre-calculate their shape and
position, and to change the vertex color of the shaded polygons.<BR>
Additionally, the Shadow Polygon feature can be used to create animated
shadows, ie. moved objects and variable light sources.<BR>
<BR>
<B>Shadow Polygons and Shadow Volume</B><BR>
The software must define a Shadow Volume (ie. the region which doesn't contain
light), the hardware does then automatically draw the shadow on all pixels
whose x/y/z-coordinates are inside of that region.<BR>
The Shadow Volume must be defined by several Shadow Polygons which are
enclosing the shaded region. The 'top' of the shadow volume should be usually
translated to the position of the object that casts the shadow, if the light
direction changes then the shadow volume should be also rotated to match the
light direction. The 'length' of the shadow volume should be (at least) long
enough to reach from the object to the walls/floor where the shadow is to be
drawn. The shadow volume must be passed TWICE to the hardware:<BR>
<BR>
<B>Step 1 - Shadow Volume for Mask</B><BR>
Set Polygon_Attr Mode=Shadow, PolygonID=00h, Back=Render, Front=Hide,
Alpha=01h..1Eh, and pass the shadow volume (ie. the shadow polygons) to the
geometry engine.<BR>
The Back=Render / Front=Hide setting causes the 'rear-side' of the shadow
volume to be rendered, of course only as far as it is in front of other
polygons. The Mode=Shadow / ID=00h setting causes the polygon NOT to be drawn
to the Color Buffer - instead, flags are set in the Stencil Buffer (to be used
in Step 2).<BR>
<BR>
<B>Step 2 - Shadow Volume for Rendering</B><BR>
Simply repeat step 1, but with Polygon_Attr Mode=Shadow, PolygonID=01h..3Fh,
Back=Render(what/why?), Front=Render, Alpha=01h..1Eh.<BR>
The Front=Render setting causes the 'front-side' of the shadow volume to be
rendered, again, only as far as it is in front of other polygons. The
Mode=Shadow / ID&gt;00h setting causes the polygon to be drawn to the Color
Buffer as usually, but only if the Stencil Buffer bits are zero (ie. the
portion from Step 1 is excluded) (additionally, Step 2 resets the stencil bits
after checking them). Moreover, the shadow is rendered only if its Polygon ID
differs from the ID in the Attribute Buffer.<BR>
<BR>
<B>Shadow Alpha and Shadow Color</B><BR>
The Alpha=Translucent setting in Step 1 and 2 ensures that the Shadow is drawn
AFTER the normal (opaque) polygons have been rendered. In Step 2 it does
additionally specify the 'intensity' of the shadow. For normal shadows, the
Vertex Color should be usually black, however, the shadow volume may be also
used as 'spotlight volume' when using other colors.<BR>
<BR>
<B>Rendering Order</B><BR>
The Mask Volume must be rendered prior to the Rendering Volume, ie. Step 1 and
2 must be performed in that order, and, to keep that order intact, Auto-sorting
must have been disabled in the previous Swap_Buffers command.<BR>
The shadow volume must be rendered after the 'target' polygons have been
rendered, for opaque targets this is done automatically (due to the translucent
alpha setting; translucent polygons are always rendered last, even with
auto-sort disabled).<BR>
<BR>
<B>Translucent Targets</B><BR>
Casting shadows on Translucent Polygons. First draw the translucent target
(with update depth buffer enabled, required for the shadow z-coordinates), then
draw the Shadow Mask/Rendering volumes.<BR>
Due to the updated depth buffer the shadow will be cast only on the translucent
target (not on any other polygons underneath of the translucent polygon). If
you want the shadow to appear on both: Draw draw the Shadow Mask/Rendering
volume TWICE (once before, and once after drawing the translucent target).<BR>
<BR>
<B>Polygon ID and Fog Enable</B><BR>
The "Render only if Polygon ID differs" feature (see Step 2) allows to prevent
the shadow to be cast on the object that casts the shadow (ie. the object and
shadow should have the same IDs). The feature also allows to select whether
overlapping shadows (with same/different IDs) are shaded once or twice.<BR>
The old Fog Enable flag in the Attribute Buffer is ANDed with the Fog Enable
flag of the Shadow Polygons, this allows to exclude Fog in shaded regions.<BR>
<BR>
<B>Shadow Volume Open/Closed Shapes</B><BR>
Normally, the shadow volume should have a closed shape, ie. should have
rear-sides (step 1), and corresponding front-sides (step 2) for all possible
viewing angles. That is required for the shadow to be drawn correctly, and also
for the Stencil Buffer to be reset to zero (in step 2, so that the stencil bits
won't disturb other shadow volumes).<BR>
Due to that, drawing errors may occur if the shadow volume's front or rear side
gets clipped by near/far clip plane.<BR>
One exception is that the volume doesn't need a bottom-side (with a suitable
volume length, the bottom may be left open, since it vanishes in the
floor/walls anyways).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="ds3dtextureattributes"></A>&nbsp;
  DS 3D Texture Attributes
</FONT></TD></TR></TABLE><BR>
<B>4000488h - Cmd 22h - TEXCOORD - Set Texture Coordinates (W)</B><BR>
Specifies the texture source coordinates within the texture bitmap which are to
be associated with the next vertex.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Parameter 1, Bit 0-15   S-Coordinate (X-Coordinate in Texture Source)
  Parameter 1, Bit 16-31  T-Coordinate (Y-Coordinate in Texture Source)
  Both values are 1bit sign + 11bit integer + 4bit fractional part.
  A value of 1.0 (=1 SHL 4) equals to one Texel.
</TD></TR></TABLE>
With Position 0.0 , 0.0 drawing starts from upperleft of the Texture.<BR>
With positive offsets, drawing origin starts more "within" the texture.<BR>
With negative offsets, drawing starts "before" the texture.<BR>
"When texture mapping, the Geometry Engine works faster if you issue commands
in the order TexCoord -&gt; Normal -&gt; Vertex."<BR>
<BR>
<B>40004A8h - Cmd 2Ah - TEXIMAGE_PARAM - Set Texture Parameters (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15  Texture VRAM Offset div 8 (0..FFFFh -&gt; 512K RAM in Slot 0,1,2,3)
        (VRAM must be allocated as Texture data, see Memory Control chapter)
  16    Repeat in S Direction (0=Clamp Texture, 1=Repeat Texture)
  17    Repeat in T Direction (0=Clamp Texture, 1=Repeat Texture)
  18    Flip in S Direction   (0=No, 1=Flip each 2nd Texture) (requires Repeat)
  19    Flip in T Direction   (0=No, 1=Flip each 2nd Texture) (requires Repeat)
  20-22 Texture S-Size        (for N=0..7: Size=(8 SHL N); ie. 8..1024 texels)
  23-25 Texture T-Size        (for N=0..7: Size=(8 SHL N); ie. 8..1024 texels)
  26-28 Texture Format        (0..7, see below)
  29    Color 0 of 4/16/256-Color Palettes (0=Displayed, 1=Made Transparent)
  30-31 Texture Coordinates Transformation Mode (0..3, see below)
</TD></TR></TABLE>
Texture Formats:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0  No Texture
  1  A3I5 Translucent Texture
  2  4-Color Palette Texture
  3  16-Color Palette Texture
  4  256-Color Palette Texture
  5  4x4-Texel Compressed Texture
  6  A5I3 Translucent Texture
  7  Direct Texture
</TD></TR></TABLE>
Texture Coordinates Transformation Modes:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0  Do not Transform texture coordinates
  1  TexCoord source
  2  Normal source
  3  Vertex source
</TD></TR></TABLE>
The S-Direction equals to the horizontal direction of the source bitmap.<BR>
The T-Direction, T-repeat, and T-flip are the same in vertical direction.<BR>
For a "/" shaped texture, the S-clamp, S-repeat, and S-flip look like so:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Clamp _____  Repeat       Repeat+Flip
  _____/       ///////////  /\/\/\/\/\/
</TD></TR></TABLE>
With "Clamp", the texture coordinates are clipped to MinMax(0,Size-1), so the
texels at the edges of the texture bitmap are repeated (to avoid that effect,
fill the bitmap edges by texels with alpha=0, so they become invisible).<BR>
<BR>
<B>40004ACh - Cmd 2Bh - PLTT_BASE - Set Texture Palette Base Address (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-12   Palette Base Address (div8 or div10h, see below)
         (Not used for Texture Format 7: Direct Color Texture)
         (0..FFF8h/8 for Texture Format 2: ie. 4-color-palette Texture)
         (0..17FF0h/10h for all other Texture formats)
  13-31  Not used
</TD></TR></TABLE>
The palette data occupies 16bit per color, Bit0-4: Red, Bit5-9: Green,
Bit10-14: Blue, Bit15: Not used.<BR>
(VRAM must be allocated as Texture Palette, there can be up to 6 Slots
allocated, ie. the addressable 18000h bytes, see Memory Control chapter)<BR>
<BR>
<B>TexImageParam and TexPlttBase</B><BR>
Can be issued per polygon (except within polygon strips).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="ds3dtextureformats"></A>&nbsp;
  DS 3D Texture Formats
</FONT></TD></TR></TABLE><BR>
<B>Format 2: 4-Color Palette Texture</B><BR>
Each Texel occupies 2bit, the first Texel is located in LSBs of 1st byte.<BR>
In this format, the Palette Base is specified in 8-byte steps; all other
formats use 16-byte steps (see PLTT_BASE register).<BR>
<BR>
<B>Format 3: 16-Color Palette Texture</B><BR>
Each Texel occupies 4bit, the 1st Texel is located in LSBs of 1st byte.<BR>
<BR>
<B>Format 4: 256-Color Palette Texture</B><BR>
Each Texel occupies 8bit, the 1st Texel is located in 1st byte.<BR>
<BR>
<B>Format 7: Direct Color Texture</B><BR>
Each Texel occupies 16bit, the 1st Texel is located in 1st halfword.<BR>
Bit0-4: Red, Bit5-9: Green, Bit10-14: Blue, Bit15: Alpha<BR>
<BR>
<B>Format 1: A3I5 Translucent Texture (3bit Alpha, 5bit Color Index)</B><BR>
Each Texel occupies 8bit, the 1st Texel is located in 1st byte.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-4: Color Index (0..31) of a 32-color Palette
  Bit5-7: Alpha       (0..7; 0=Transparent, 7=Solid)
</TD></TR></TABLE>
The 3bit Alpha value (0..7) is internally expanded into a 5bit Alpha value
(0..31) as follows: Alpha=(Alpha*4)+(Alpha/2).<BR>
<BR>
<B>Format 6: A5I3 Translucent Texture (5bit Alpha, 3bit Color Index)</B><BR>
Each Texel occupies 8bit, the 1st Texel is located in 1st byte.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-2: Color Index (0..7) of a 8-color Palette
  Bit3-7: Alpha       (0..31; 0=Transparent, 31=Solid)
</TD></TR></TABLE>
<BR>
<B>Format 5: 4x4-Texel Compressed Texture</B><BR>
Consists of 4x4 Texel blocks in Slot 0 or 2, 32bit per block, 2bit per Texel,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-7   Upper 4-Texel row (LSB=first/left-most Texel)
  Bit8-15  Next  4-Texel row ("")
  Bit16-23 Next  4-Texel row ("")
  Bit24-31 Lower 4-Texel row ("")
</TD></TR></TABLE>
Additional Palette Index Data for each 4x4 Texel Block is located in Slot 1,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-13  Palette Offset in 4-byte steps; Addr=(PLTT_BASE*10h)+(Offset*4)
  Bit14-15 Transparent/Interpolation Mode (0..3, see below)
</TD></TR></TABLE>
whereas, the Slot 1 offset is related to above Slot 0 or 2 offset,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  slot1_addr = slot0_addr / 2           ;lower 64K of Slot1 assoc to Slot0
  slot1_addr = slot2_addr / 2 + 10000h  ;upper 64K of Slot1 assoc to Slot2
</TD></TR></TABLE>
The 2bit Texel values (0..3) are intepreted depending on the Mode (0..3),<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Texel  Mode 0       Mode 1             Mode 2         Mode 3
  0      Color 0      Color0             Color 0        Color 0
  1      Color 1      Color1             Color 1        Color 1
  2      Color 2      (Color0+Color1)/2  Color 2        (Color0*5+Color1*3)/8
  3      Transparent  Transparent        Color 3        (Color0*3+Color1*5)/8
</TD></TR></TABLE>
Mode 1 and 3 are using only 2 Palette Colors (which requires only half as much
Palette memory), the 3rd (and 4th) Texel Colors are automatically set to above
values (eg. to gray-shades if color 0 and 1 are black and white).<BR>
Note: The maximum size for 4x4-Texel Compressed Textures is 1024x512 or
512x1024 (which are both occupying the whole 128K in slot 0 or 2, plus 64K in
slot1), a larger size of 1024x1024 cannot be used because of the gap between
slot 0 and 2.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="ds3dtexturecoordinates"></A>&nbsp;
  DS 3D Texture Coordinates
</FONT></TD></TR></TABLE><BR>
For textured polygons, a texture coordinate must be associated with each vertex
of the polygon. The coordinates (S,T) are defined by TEXCOORD command
(typically issued prior to each VTX command), and can be optionally
automatically transformed, by the Transformation Mode selected in
TEXIMAGE_PARAM register.<BR>
<BR>
<B>Texture Matrix</B><BR>
Although the texture matrix is 4x4, with values m[0..15], only the left two
columns of this matrix are actually used. In Mode 2 and 3, the bottom row of
the matrix is replaced by S and T values from most recent TEXCOORD command.<BR>
<BR>
<B>Texture Coordinates Transformation Mode 0 - No Transform</B><BR>
The values are set upon executing the TEXCOORD command,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ( S' T' )  =  ( S  T )
</TD></TR></TABLE>
Simple coordinate association, without using the Texture Matrix at all.<BR>
<BR>
<B>Texture Coordinates Transformation Mode 1 - TexCoord source</B><BR>
The values are calculated upon executing the TEXCOORD command,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
                                     | m[0]  m[1]  |
  ( S' T' )  =  ( S  T 1/16 1/16 ) * | m[4]  m[5]  |
                                     | m[8]  m[9]  |
                                     | m[12] m[13] |
</TD></TR></TABLE>
Can be used to produce a simple texture scrolling, rotation, or scaling, by
setting a translate, rotate, or scale matrix for the texture matrix.<BR>
<BR>
<B>Texture Coordinates Transformation Mode 2 - Normal source</B><BR>
The values are calculated upon executing the NORMAL command,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
                                     | m[0]  m[1]  |
  ( S' T' )  =  ( Nx  Ny  Nz 1.0 ) * | m[4]  m[5]  |
                                     | m[8]  m[9]  |
                                     | S     T     |
</TD></TR></TABLE>
Can be used to produce spherical reflection mapping by setting the texture
matrix to the current directional vector matrix, multiplied by a scaling matrix
that expands the directional vector space from -1.0..+1.0 to one half of the
texture size. For that purpose, translate the origin of the texture coordinate
to the center of the spherical texture by using TexCoord command (spherical
texture means a bitmap that contains some circle-shaped image).<BR>
<BR>
<B>Texture Coordinates Transformation Mode 3 - Vertex source</B><BR>
The values are calculated upon executing any VTX commands,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
                                     | m[0]  m[1]  |
  ( S' T' )  =  ( Vx  Vy  Vz 1.0 ) * | m[4]  m[5]  |
                                     | m[8]  m[9]  |
                                     | S     T     |
</TD></TR></TABLE>
Can be used to produce texture scrolls dependent on the View coordinates by
copying the current position coordinate matrix into the texture matrix. For
example, the PositionMatrix can be obtained via CLIPMTX_RESULT (see there for
details), and that values can be then manually copied to the TextureMatrix.<BR>
<BR>
<B>Sign+Integer+Fractional Parts used in above Formulas</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Matrix    m[..]     1+19+12 (32bit)
  Vertex    Vx,Vy,Vz  1+3+12  (16bit)
  Normal    Nx,Ny,Nz  1+0+9   (10bit)
  Constant  1.0       0+1+0   (1bit)
  Constant  1/16      0+0+4   (4bit)
  TexCoord  S,T       1+11+4  (16bit)
  Result    S',T'     1+11+4  (16bit) &lt;-------- clipped to that size !
</TD></TR></TABLE>
Observe that the S',T' values are clipped to 16bit size. Ie. after the
Vector*Matrix calaction, the result is shifted right (to make it having a 4bit
fraction), and the value is then masked to 16bit size.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="ds3dtextureblending"></A>&nbsp;
  DS 3D Texture Blending
</FONT></TD></TR></TABLE><BR>
Polygon pixels consist of a Vertex Color, and of Texture Colors.<BR>
These colors can be blended as described below. Or, to use only either one:<BR>
To use only the Vertex Color: Select No Texture in TEXIMAGE_PARAM.<BR>
To use only the Texture Color: Select Modulation Mode and Alpha=31 in
POLYGON_ATTR, and set COLOR to 7FFFh (white), or to gray values (to decrease
brightness of the texture color).<BR>
<BR>
<B>Vertex Color (Rv,Gv,Bv,Av)</B><BR>
The Vertex Color (Rv,Gv,Bv) can be changed per Vertex (either by Color, Normal,
or Material0 command), pixels between vertices are shaded to medium values of
the surrounding vertices. The Vertex Alpha (Av), can be changed only per
polygon (by PolygonAttr command).<BR>
<BR>
<B>Texture Colors (Rt,Gt,Bt,At)</B><BR>
The Texture Colors (Rt,Gt,Bt), and Alpha value (At), are defined by the Texture
Bitmap. For formats without Alpha value, assume At=31 (solid), and for formats
with 1bit Alpha assume At=A*31.<BR>
<BR>
<B>Shading Table Colors (Rs,Gs,Bs)</B><BR>
In Toon/Highlight Shading Mode, the red component of the Vertex Color (Rv) is
mis-used as an index in the Shading Table, ie. Rv is used to read Shading
Colors (Rs,Gs,Bs) from the table; the green and blue components of the Vertex
Color (Gv,Bv) are unused in this mode. The Vertex Alpha (Av) is kept used.<BR>
Shading is used in Polygon Mode 2, whether it is Toon or Highlight Shading is
selected in DISP3DCNT; this is a per-frame selection, so only either one can be
used.<BR>
<BR>
<B>Texture Blending - Modulation Mode (Polygon Attr Mode 0)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  R = ((Rt+1)*(Rv+1)-1)/64
  G = ((Gt+1)*(Gv+1)-1)/64
  B = ((Bt+1)*(Bv+1)-1)/64
  A = ((At+1)*(Av+1)-1)/64
</TD></TR></TABLE>
The multiplication result is decreased intensity (unless both factors are 63).<BR>
<BR>
<B>Texture Blending - Decal Mode (Polygon Attr Mode 1)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  R = (Rt*At + Rv*(63-At))/64  ;except, when At=0: R=Rv, when At=31: R=Rt
  G = (Gt*At + Gv*(63-At))/64  ;except, when At=0: G=Gv, when At=31: G=Gt
  B = (Bt*At + Bv*(63-At))/64  ;except, when At=0: B=Bv, when At=31: B=Bt
  A = Av
</TD></TR></TABLE>
The At value is used (only) as ratio for Texture color vs Vertex Color.<BR>
<BR>
<B>Texture Blending - Toon Shading (Polygon Mode 2, DISP3DCNT=Toon)</B><BR>
The vertex color Red component (Rv) is used as an index in the toon table.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  R = ((Rt+1)*(Rs+1)-1)/64   ;Rs=ToonTableRed[Rv]
  G = ((Gt+1)*(Gs+1)-1)/64   ;Gs=ToonTableGreen[Rv]
  B = ((Bt+1)*(Bs+1)-1)/64   ;Bs=ToonTableBlue[Rv]
  A = ((At+1)*(Av+1)-1)/64
</TD></TR></TABLE>
This is same as Modulation Mode, but using Rs,Gs,Bs instead Rv,Gv,Bv.<BR>
<BR>
<B>Texture Blending - Highlight Shading (Polygon Mode 2, DISP3DCNT=Highlight)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  R = ((Rt+1)*(Rs+1)-1)/64+Rs ;truncated to MAX=63
  G = ((Gt+1)*(Gs+1)-1)/64+Gs ;truncated to MAX=63
  B = ((Bt+1)*(Bs+1)-1)/64+Bs ;truncated to MAX=63
  A = ((At+1)*(Av+1)-1)/64
</TD></TR></TABLE>
Same as Toon Shading, with additional addition offset, the addition may
increase the intensity, however, it may also change the hue of the color.<BR>
<BR>
Above formulas are for 6bit RGBA values, ie. 5bit values internally expanded to
6bit as such: IF X&gt;0 THEN X=X*2+1.<BR>
<BR>
<B>Uni-Colored Textures</B><BR>
Although textures are normally containing "pictures", in some cases it makes
sense to use "blank" textures that are filled with a single color:<BR>
Wire-frame polygons are always having Av=31, however, they can be made
transparent by using Translucent Textures (ie. A5I3 or A3I5 formats) with
At&lt;31.<BR>
In Toon/Highlight shading modes, the Vertex Color is mis-used as table index,
however, Toon/Highlight shading can be used on uni-colored textures, which is
more or less the same as using Toon/Highlight shading on uni-colored
Vertex-colors.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="ds3dtoonedgefogalphablendingantialiasing"></A>&nbsp;
  DS 3D Toon, Edge, Fog, Alpha-Blending, Anti-Aliasing
</FONT></TD></TR></TABLE><BR>
<B>4000380h..3BFh - TOON_TABLE - Toon Table (W)</B><BR>
This 64-byte region contains the 32 toon colors (16bit per color), used for
both Toon and Highlight Shading. In both modes, the Red (R) component of the
RGBA vertex color is mis-used as index to obtain the new RGB value from the
toon table, vertex Alpha (A) is kept used as is.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-4: Red, Bit5-9: Green, Bit10-14: Blue, Bit15: Not Used
</TD></TR></TABLE>
Shading can be enabled (per polygon) in Polygon_Attr, whether it is Toon or
Highlight Shading is set (per frame) in DISP3DCNT. For more info on shading,
see:<BR>
<A HREF="#ds3dtextureblending">DS 3D Texture Blending</A><BR>
<BR>
<B>4000330h..33Fh - EDGE_COLOR - Edge Colors 0..7 (W)</B><BR>
This 16-byte region contains the 8 edge colors (16bit per color), Edge Color 0
is used for Polygon ID 00h..07h, Color 1 for ID 08h..0Fh, and so on.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-4: Red, Bit5-9: Green, Bit10-14: Blue, Bit15: Not Used
</TD></TR></TABLE>
Edge Marking allows to mark the edges of an object (whose polygons all have the
same ID) in a wire-frame style. Edge Marking can be enabled (per frame) in
DISP3DCNT. When enabled, the polygon edges are drawn at the edge color, but
only if the old ID value in the Attribute Buffer is different than the Polygon
ID of the new polygon, so no edges are drawn between connected or overlapping
polygons with same ID values.<BR>
Edge Marking is applied ONLY to opaque polygons (including wire-frames).<BR>
Edge Marking increases the size of opaque polygons (see notes below).<BR>
Edge Marking doesn't work very well with Anti-Aliasing (see Anti-Aliasing).<BR>
Technically, when rendering a polygon, it's edges (ie. the wire-frame region)
are flagged as possible-edges (but it's still rendered normally, without using
the edge-color). Once when all opaque polygons (*) have been rendered, the edge
color is applied to these flagged pixels, under following conditions: At least
one of the four surrounding pixels (up, down, left, right) must have different
polygon_id than the edge, and, the edge depth must be LESS than the depth of
that surrounding pixel (ie. no edges are rendered if the depth is GREATER or
EQUAL, even if the polygon_id differs). At the screen borders, edges seem to be
rendered in respect to the rear-plane's polygon_id entry (see Port 4000350h).<BR>
(*) Actually, edge-marking is reportedly performed not until all opaque AND
translucent polygons have been rendered. That brings up some effects/problems
when edges are covered by translucent polys: The edge-color is probably drawn
as is (ie. it'll overwrite the translucent color, rather than being blended
with the translucent color). And, any translucent polygons that do update the
depth buffer will cause total edge-marking malfunction (since edge-marking
involves the comparision of the current/surrounding pixel's depth values).<BR>
<BR>
<B>4000358h - FOG_COLOR - Fog Color (W)</B><BR>
Fog can be used to let more distant polygons to disappear in foggy grayness (or
in darkness, or other color). This is particulary useful to "hide" the far clip
plane. Fog can be enabled in DISP3DCNT.Bit7, moreover, when enabled, it can be
activated or deactivated per polygon (POLYGON_ATTR.Bit15), and per Rear-plane
(see there).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-4    Fog Color, Red     ;\
  5-9    Fog Color, Green   ; used only when DISP3DCNT.Bit6 is zero
  10-14  Fog Color, Blue    ;/
  15     Not used
  16-20  Fog Alpha          ;-used no matter of DISP3DCNT.Bit6
  21-31  Not used
</TD></TR></TABLE>
Whether or not fog is applied to a pixel depends on the Fog flag in the
framebuffer, the initial value of that flag can be defined in the rear-plane.
When rendering opaque pixels, the framebuffer's fog flag gets replaced by
PolygonAttr.Bit15. When rendering translucent pixels, the old flag in the
framebuffer gets ANDed with PolygonAttr.Bit15.<BR>
<BR>
<B>400035Ch - FOG_OFFSET - Fog Depth Offset (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-14   Fog Offset (Unsigned) (0..7FFFh)
  15-31  Not used
</TD></TR></TABLE>
FogDepthBoundary[0..31] (for FogDensity[0..31]) are defined as:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  FogDepthBoundary[n] = FOG_OFFSET + FOG_STEP*(n+1)   ;with n = 0..31
</TD></TR></TABLE>
Whereas FOG_STEP is derived from the FOG_SHIFT value in DISP3DCNT.Bit8-11
(FOG_STEP=400h shr FOG_SHIFT) (normally FOG_SHIFT should be 0..10 (bigger shift
amounts of 11..15 would cause FOG_STEP to become zero, so only Density[0] and
Density[31] would be used).<BR>
The meaning of the depth values depends on whether z-values or w-values are
stored in the framebuffer (see SwapBuffers.Bit1).<BR>
For translucent polygons, the depth value (and therefore: the amount of fog)
depends on the depth update bit (see PolygonAttr.Bit11).<BR>
<BR>
<B>4000360h..37Fh - FOG_TABLE - Fog Density Table (W)</B><BR>
This 32-byte region contains FogDensity[0..31] (used at FogDepthBoundary[n]),<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-6    Fog Density (00h..7Fh = None..Full) (usually increasing values)
  7      Not used
</TD></TR></TABLE>
FogDensity[0] is used for all pixels closer than FogDepthBoundary[0],
FogDensity[31] is used for all pixels more distant than FogDepthBoundary[0].<BR>
Density is linear interpolated for pixels that are between two Density depth
boundaries. The formula for Fog Blending is:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  FrameBuffer[R] = (FogColor[R]*Density + FrameBuffer[R]*(128-Density)) / 128
  FrameBuffer[G] = (FogColor[G]*Density + FrameBuffer[G]*(128-Density)) / 128
  FrameBuffer[B] = (FogColor[B]*Density + FrameBuffer[B]*(128-Density)) / 128
  FrameBuffer[A] = (FogColor[A]*Density + FrameBuffer[A]*(128-Density)) / 128
</TD></TR></TABLE>
If DISP3DCNT.Bit6 is set (=Alpha Only), then only FrameBuffer[A] is updated,
and FrameBuffer[RGB] are kepth unchanged. Density=127 is handled as if
Density=128.<BR>
Fog Glitch: The fog_alpha value appears to be ignored (treated as
fog_alpha=1Fh) in the region up to the first density boundary. However,
normally that value will be multiplied by zero (assumung that density[0] is
usually zero), so you won't ever notice that hardware glitch.<BR>
<BR>
<B>Alpha-Blending (Polygon vs FrameBuffer)</B><BR>
Alpha-Blending occurs for pixels of translucent polygons,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  FrameBuf[R] = (Poly[R]*(Poly[A]+1) + FrameBuf[R]*(31-(Poly[A])) / 32
  FrameBuf[G] = (Poly[G]*(Poly[A]+1) + FrameBuf[G]*(31-(Poly[A])) / 32
  FrameBuf[B] = (Poly[B]*(Poly[A]+1) + FrameBuf[B]*(31-(Poly[A])) / 32
  FrameBuf[A] = max(Poly[A],FrameBuf[A])
</TD></TR></TABLE>
There are three situations in which Alpha-Blending is bypassed (the old
Framebuf[R,G,B,A] value is then simply overwritten by Poly[R,G,B,A]):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1) Alpha-Blending is disabled                       (DISP3DCNT.Bit3=0)
  2) The polygon pixel is opaque                      (Poly[A]=31)
  3) The old framebuffer value is totally transparent (FrameBuf[A]=0)
</TD></TR></TABLE>
The third case can happen if the rear-plane was initialized with Alpha=0, which
causes the polygon not to be blended with the rear-plane (which may give better
results when subsequently blending the 3D layer with the 2D engine).<BR>
Note: Totally transparent pixels (with Poly[A]=0) are not rendered (ie. neither
FrameBuf[R,G,B,A] nor FrameBuf[Depth,Fog,PolyID,etc.] are updated.<BR>
<BR>
<B>Anti-Aliasing</B><BR>
Anti-Aliasing can be enabled in DISP3DCNT, when enabled, the edges of opaque
polygons will be anti-aliased (ie. the pixels at the edges may become
translucent).<BR>
Anti-Aliasing is not applied on translucent polygons. And, Anti-Aliasing is not
applied on the interiors of the poylgons (eg. an 8x8 chessboard texture will be
anti-aliased only at the board edges, not at the edges of the 64 fields).<BR>
Anti-Aliasing is (accidently) applied to opaque 1dot polygongs, line-segments
and wire-frames (which results in dirty lines with missing pixels, 1dot polys
become totally invisible), workaround is to use translucent dots, lines and
wires (eg. with alpha=30).<BR>
Anti-Aliasing is (correctly) not applied to edges of Edge-Marked polygons, in
that special case even opaque line-segments and wire-frames are working even if
anti-aliasing is enabled (provided that they are edge-marked, ie. if their
polygon ID differs from the framebuffer's ID).<BR>
Anti-Aliasing is (accidently) making the edges of Edge-Marked polygons
translucent (with alpha=16 or so?), that reduces the contrast of the edge
colors. Moreover, if two of these translucent do overlap, then they blended
twice (even if they have the same polygon_id, and even if the depth_update bit
in polygon_attr is set; both should normally prevent double-blending), that
scatters the brightness of such edges.<BR>
<BR>
<B>Polygon Size</B><BR>
In some cases, the NDS hardware doesn't render the lower/right edges of certain
polygons. That feature reduces rendering load, and, when rendering connected
polygons (eg. strips), then it'd be unnecessary to render that edges (since
they'd overlap with the upper/left edges of the other polygon). On the
contrary, if there's no connected polygon displayed, then the polygon may
appear smaller than expected. Small polygons with excluded edges are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Opaque polygons (except wire-frames) without Edge-Marking and Anti-Aliasing,
  and, all polygons with vertical right-edges (except line-segments).
  Plus, Translucent Polys when Alpha-Blending is disabled in DISP3DCNT.Bit3.
</TD></TR></TABLE>
All other polygons are rendered at full size with all edges included (except
vertical right edges). Note: To disable the small-polygon feature, you can
enable edge-marking (which does increase the polygon size, even if no edges are
drawn, ie. even if all polys do have the same ID).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="ds3dstatus"></A>&nbsp;
  DS 3D Status
</FONT></TD></TR></TABLE><BR>
<B>4000600h - GXSTAT - Geometry Engine Status Register (R and R/W)</B><BR>
Bit 30-31 are R/W. Writing "1" to Bit15 does reset the Error Flag (Bit15), and
additionally resets the Projection Stack Pointer (Bit13), and probably (?) also
the Texture Stack Pointer. All other GXSTAT bits are read-only.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     BoxTest,PositionTest,VectorTest Busy (0=Ready, 1=Busy)
  1     BoxTest Result  (0=All Outside View, 1=Parts or Fully Inside View)
  2-7   Not used
  8-12  Position &amp; Vector Matrix Stack Level (0..31) (lower 5bit of 6bit value)
  13    Projection Matrix Stack Level        (0..1)
  14    Matrix Stack Busy (0=No, 1=Yes; Currently executing a Push/Pop command)
  15    Matrix Stack Overflow/Underflow Error (0=No, 1=Error/Acknowledge/Reset)
  16-24 Number of 40bit-entries in Command FIFO  (0..256)
 (24)   Command FIFO Full (MSB of above)  (0=No, 1=Yes; Full)
  25    Command FIFO Less Than Half Full  (0=No, 1=Yes; Less than Half-full)
  26    Command FIFO Empty                (0=No, 1=Yes; Empty)
  27    Geometry Engine Busy (0=No, 1=Yes; Busy; Commands are executing)
  28-29 Not used
  30-31 Command FIFO IRQ (0=Never, 1=Less than half full, 2=Empty, 3=Reserved)
</TD></TR></TABLE>
When GXFIFO IRQ is enabled (setting 1 or 2), the IRQ flag (IF.Bit21) is set
while and as long as the IRQ condition is true (and attempts to acknowledge the
IRQ by writing to IF.Bit21 have no effect). So that, the IRQ handler must
either fill the FIFO, or disable the IRQ (setting 0), BEFORE trying to
acknowledge the IRQ.<BR>
<BR>
<B>4000604h - RAM_COUNT - Polygon List &amp; Vertex RAM Count Register (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-11   Number of Polygons currently stored in Polygon List RAM (0..2048)
  12-15  Not used
  16-28  Number of Vertices currently stored in Vertex RAM       (0..6144)
  13-15  Not used
</TD></TR></TABLE>
If a SwapBuffers command has been sent, then the counters are reset 10 cycles
(at 33.51MHz clock) after next VBlank.<BR>
<BR>
<B>4000320h - RDLINES_COUNT - Rendered Line Count Register (R)</B><BR>
Rendering starts in scanline 214, the rendered lines are stored in a buffer
that can hold up to 48 scanlines. The actual screen output begins after
scanline 262, the lines are then read from the buffer and sent to the display.
Simultaneously, the rendering engine keeps writing new lines to the buffer
(ideally at the same speed than display output, so the buffer would always
contain 48 pre-calculated lines).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-5    Minimum Number (minus 2) of buffered lines in previous frame (0..46)
  6-31   Not used
</TD></TR></TABLE>
If rendering becomes slower than the display output, then the number of
buffered lines decreases. Smaller values in RDLINES indicate that additional
load to the rendering engine may cause buffer underflows in further frames, if
so, the program should reduce the number of polygons to avoid display glitches.<BR>
Even if RDLINES becomes zero, it doesn't indicate whether actual buffer
underflows have occured or not (underflows are indicated in DISP3DCNT Bit12).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="ds3dtests"></A>&nbsp;
  DS 3D Tests
</FONT></TD></TR></TABLE><BR>
<B>40005C0h - Cmd 70h - BOX_TEST - Test if Cuboid Sits inside View Volume (W)</B><BR>
The BoxTest result indicates if one or more of the 6 faces of the box are fully
or parts of inside of the view volume. Can be used to reduce unnecessary
overload, ie. if the result is false, then the program can skip drawing of
objects which are inside of the box.<BR>
BoxTest verifies only if the faces of the box are inside view volume, and so,
it will return false if the whole view volume is located inside of the box
(still objects inside of the box may be inside of view).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Parameter 1, Bit 0-15   X-Coordinate
  Parameter 1, Bit 16-31  Y-Coordinate
  Parameter 2, Bit 0-15   Z-Coordinate
  Parameter 2, Bit 16-31  Width  (presumably: X-Offset?)
  Parameter 3, Bit 0-15   Height (presumably: Y-Offset?)
  Parameter 3, Bit 16-31  Depth  (presumably: Z-Offset?)
  All values are 1bit sign, 3bit integer, 12bit fractional part
</TD></TR></TABLE>
The result of the "coordinate+offset" additions should not overflow 16bit
vertex coordinate range (1bit sign, 3bit integer, 12bit fraction).<BR>
Before using BoxTest, be sure that far-plane-intersecting &amp; 1-dot polygons
are enabled, if they aren't: Send the PolygonAttr command (with bit12,13 set to
enable them), followed by dummy Begin and End commands (required to apply the
new PolygonAttr settings). BoxTest should not be issued within Begin/End.<BR>
After sending the BoxTest command, wait until GXSTAT.Bit0 indicates Ready, then
read the result from GXSTAT.Bit1.<BR>
<BR>
<B>40005C4h - Cmd 71h - POS_TEST - Set Position Coordinates for Test (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Parameter 1, Bit 0-15   X-Coordinate
  Parameter 1, Bit 16-31  Y-Coordinate
  Parameter 2, Bit 0-15   Z-Coordinate
  Parameter 2, Bit 16-31  Not used
  All values are 1bit sign, 3bit integer, 12bit fractional part.
</TD></TR></TABLE>
Multiplies the specified line-vector (x,y,z,1) by the clip coordinate matrix.<BR>
After sending the command, wait until GXSTAT.Bit0 indicates Ready, then read
the result from POS_RESULT registers. POS_TEST can be issued anywhere (except
within polygon strips, huh?).<BR>
Caution: POS_TEST overwrites the internal VTX registers, so the next vertex
should be &lt;fully&gt; defined by VTX_10 or VTX_16, otherwise, when using
VTX_XY, VTX_XZ, VTX_YZ, or VTX_DIFF, then the new vertex will be relative to
the POS_TEST coordinates (rather than to the previous vertex).<BR>
<BR>
<B>4000620h..62Fh - POS_RESULT - Position Test Results (R)</B><BR>
This 16-byte region (4 words) contains the resulting clip coordinates (x,y,z,w)
from the POS_TEST command. Each value is 1bit sign, 19bit integer, 12bit
fractional part.<BR>
<BR>
<B>40005C8h - Cmd 72h - VEC_TEST - Set Directional Vector for Test (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Parameter 1, Bit 0-9    X-Component
  Parameter 1, Bit 10-19  Y-Component
  Parameter 1, Bit 20-29  Z-Component
  Parameter 1, Bit 30-31  Not used
  All values are 1bit sign, 9bit fractional part.
</TD></TR></TABLE>
Multiplies the specified line-vector (x,y,z,0) by the directional vector
matrix. Similar as for the NORMAL command, it does require Matrix Mode 2 (ie.
Position &amp; Vector Simultaneous Set mode).<BR>
After sending the command, wait until GXSTAT.Bit0 indicates Ready, then read
the result ("the directional vector in the View coordinate space") from
VEC_RESULT registers.<BR>
<BR>
<B>4000630h..635h - VEC_RESULT - Vector Test Results (R)</B><BR>
This 6-byte region (3 halfwords) contains the resulting vector (x,y,z) from the
VEC_TEST command. Each value is 4bit sign, 0bit integer, 12bit fractional part.
The 4bit sign is either 0000b (positive) or 1111b (negative).<BR>
There is no integer part, so values &gt;=1.0 or &lt;-1.0 will cause overflows.<BR>
(Eg. +1.0 aka 1000h will be returned as -1.0 aka F000h due to overflow and
sign-expansion).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="ds3drearplane"></A>&nbsp;
  DS 3D Rear-Plane
</FONT></TD></TR></TABLE><BR>
Other docs seem to refer to this as Clear-plane, rather than Rear-plane,
anyways, the plane can be an image, so it isn't always "cleared".<BR>
The view order is as such:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  --&gt; 2D Layers --&gt; 3D Polygons --&gt; 3D Rear-plane --&gt; 2D Layers --&gt; 2D Backdrop
</TD></TR></TABLE>
The rear-plane can be disabled (by making it transparent; alpha=0), so that the
2D layers become visible as background.<BR>
2D layers can be moved in front of, or behind the 3D layer-group (which is
represented as BG0 to the 2D Engine), 2D layers behind BG0 can be used instead
of, or additionally to the rear-plane.<BR>
<BR>
The rear-plane can be initialized via below two registers (so all pixels in the
plane have the same colors and attributes), this method is used when
DISP3DCNT.14 is zero:<BR>
<BR>
<B>4000350h - CLEAR_COLOR - Clear Color Attribute Register (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-4    Clear Color, Red
  5-9    Clear Color, Green
  10-14  Clear Color, Blue
  15     Fog (enables Fog to the rear-plane) (doesn't affect Fog of polygons)
  16-20  Alpha
  21-23  Not used
  24-29  Clear Polygon ID (affects edge-marking, at the screen-edges?)
  30-31  Not used
</TD></TR></TABLE>
<BR>
<B>4000354h - CLEAR_DEPTH - Clear Depth Register (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-14   Clear Depth (0..7FFFh) (usually 7FFFh = most distant)
  15     Not used
  16-31  See Port 4000356h, CLRIMAGE_OFFSET
</TD></TR></TABLE>
The 15bit Depth is expanded to 24bit as "X=(X*200h)+((X+1)/8000h)*1FFh".<BR>
<BR>
<B>Rear Color/Depth Bitmaps</B><BR>
Alternately, the rear-plane can be initialized by bitmap data (allowing to
assign different colors &amp; attributes to each pixel), this method is used
when DISP3DCNT.14 is set:<BR>
Consists of two bitmaps (one with color data, one with depth data), each
containing 256x256 16bit entries, and so, each occupying a whole 128K slot,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Rear Color Bitmap (located in Texture Slot 2)
    0-4    Clear Color, Red
    5-9    Clear Color, Green
    10-14  Clear Color, Blue
    15     Alpha (0=Transparent, 1=Solid) (equivalent to 5bit-alpha 0 and 31)
  Rear Depth Bitmap (located in Texture Slot 3)
    0-14   Clear Depth, expanded to 24bit as X=(X*200h)+((X+1)/8000h)*1FFh
    15     Clear Fog (Initial fog enable value)
</TD></TR></TABLE>
This method requires VRAM to be allocated to Texture Slot 2 and 3 (see Memory
Control chapter). Of course, in that case the VRAM is used as Rear-plane, and
cannot be used for Textures.<BR>
The bitmap method is restricted to 1bit alpha values (the register-method
allows to use a 5bit alpha value).<BR>
The Clear Polygon ID is kept defined in the CLEAR_COLOR register, even in
bitmap mode.<BR>
<BR>
<B>4000356h - CLRIMAGE_OFFSET - Rear-plane Bitmap Scroll Offsets (W)</B><BR>
The visible portion of the bitmap is 256x192 pixels (regardless of the viewport
setting, which is used only for polygon clipping). Internally, the bitmap is
256x256 pixels, so the bottom-most 64 rows are usually offscreen, unless
scrolling is used to move them into view.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-7   X-Offset (0..255; 0=upper row of bitmap)
  Bit8-14  Y-Offset (0..255; 0=left column of bitmap)
</TD></TR></TABLE>
The bitmap wraps to the upper/left edges when exceeding the lower/right edges.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="ds3dfinal2doutput"></A>&nbsp;
  DS 3D Final 2D Output
</FONT></TD></TR></TABLE><BR>
The final 3D image (consisting of polygons and rear-plane) is passed to 2D
Engine A as BG0 layer (provided that DISPCNT is configured to use 3D as BG0).<BR>
<BR>
<B>Scrolling</B><BR>
The BG0HOFS register (4000010h) can be used the scroll the 3D layer
horizontally, the scroll region is 512 pixels, consisting of 256 pixels for the
3D image, followed by 256 transparent pixels, and then wrapped to the 3D image
again. Vertical scrolling (and rotation/scaling) cannot be used on the 3D
layer.<BR>
<BR>
<B>BG Priority Order</B><BR>
The lower 2bit of the BG0CNT register (4000008h) control the priority relative
to other BGs and OBJs, so the 3D layer can be in front of or behind 2D layers.
All other bits in BG0CNT have no effect on 3D, namely, mosaic cannot be used on
the 3D layer.<BR>
<BR>
<B>Special Effects</B><BR>
Special Effects Registers (4000050h..54h) can be used as such:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Brightness up/down with BG0 as 1st Target via EVY   (as for 2D)
  Blending with BG0 as 2nd Target via EVA/EVB         (as for 2D)
  Blending with BG0 as 1st Target via 3D Alpha-values (unlike as for 2D)
</TD></TR></TABLE>
The latter method probably (?) uses per-pixel 3D alpha values as such: EVA=A/2,
and EVB=16-A/2, without using the EVA/EVB settings in 4000052h.<BR>
<BR>
<B>Window Feature</B><BR>
Window Feature (4000040h..4Bh) can be used as for 2D.<BR>
"If the 3D screen has highest priority, then alpha-blending is always enabled,
regardless of the Window Control register's color effect enable flag [ie.
regardless of Bit5 of WIN0IN, WIN1IN, WINOBJ, WINOUT registers]"... not sure if
that is true, and if it superseedes the effect selection in Port 4000050h...?<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dssound"></A>&nbsp;
  DS Sound
</FONT></TD></TR></TABLE><BR>
The DS contains 16 hardware sound channels.<BR>
The console contains two speakers, arranged left and right of the upper screen,
and so, provides stereo sound even without using the headphone socket.<BR>
<BR>
<A HREF="#dssoundchannels015">DS Sound Channels 0..15</A><BR>
<A HREF="#dssoundcontrolregisters">DS Sound Control Registers</A><BR>
<A HREF="#dssoundcapture">DS Sound Capture</A><BR>
<A HREF="#dssoundblockdiagrams">DS Sound Block Diagrams</A><BR>
<A HREF="#dssoundnotes">DS Sound Notes</A><BR>
<BR>
Power control<BR>
When restoring power supply to the sound circuit, do not output any sound
during the first 15 milliseconds.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dssoundchannels015"></A>&nbsp;
  DS Sound Channels 0..15
</FONT></TD></TR></TABLE><BR>
Each of the 16 sound channels occopies 16 bytes in the I/O region, starting
with channel 0 at 4000400h..400040Fh, up to channel 15 at 40004F0h..40004FFh.<BR>
<BR>
<B>40004x0h - NDS7 - SOUNDxCNT - Sound Channel X Control Register (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-6    Volume Mul   (0..127=silent..loud)
  Bit7      Not used     (always zero)
  Bit8-9    Volume Div   (0=Normal, 1=Div2, 2=Div4, 3=Div16)
  Bit10-14  Not used     (always zero)
  Bit15     Hold         (0=Normal, 1=Hold last sample after one-shot sound)
  Bit16-22  Panning      (0..127=left..right) (64=half volume on both speakers)
  Bit23     Not used     (always zero)
  Bit24-26  Wave Duty    (0..7) ;HIGH=(N+1)*12.5%, LOW=(7-N)*12.5% (PSG only)
  Bit27-28  Repeat Mode  (0=Manual, 1=Loop Infinite, 2=One-Shot, 3=Prohibited)
  Bit29-30  Format       (0=PCM8, 1=PCM16, 2=IMA-ADPCM, 3=PSG/Noise)
  Bit31     Start/Status (0=Stop, 1=Start/Busy)
</TD></TR></TABLE>
All channels support ADPCM/PCM formats, PSG rectangular wave can be used only
on channels 8..13, and white noise only on channels 14..15.<BR>
<BR>
<B>40004x4h - NDS7 - SOUNDxSAD - Sound Channel X Data Source Register (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-26  Source Address (must be word aligned, bit0-1 are always zero)
  Bit27-31 Not used
</TD></TR></TABLE>
<BR>
<B>40004x8h - NDS7 - SOUNDxTMR - Sound Channel X Timer Register (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-15  Timer Value, Sample frequency, timerval=-(33513982/2)/freq
</TD></TR></TABLE>
The PSG Duty Cycles are composed of eight "samples", and so, the frequency for
Rectangular Wave is 1/8th of the selected sample frequency.<BR>
For PSG Noise, the noise frequency is equal to the sample frequency.<BR>
<BR>
<B>40004xAh - NDS7 - SOUNDxPNT - Sound Channel X Loopstart Register (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-15  Loop Start, Sample loop start position
           (counted in words, ie. N*4 bytes)
</TD></TR></TABLE>
<BR>
<B>40004xCh - NDS7 - SOUNDxLEN - Sound Channel X Length Register (W)</B><BR>
The number of samples for N words is 4*N PCM8 samples, 2*N PCM16 samples, or
8*(N-1) ADPCM samples (the first word containing the ADPCM header). The Sound
Length is not used in PSG mode.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-21  Sound length (counted in words, ie. N*4 bytes)
  Bit22-31 Not used
</TD></TR></TABLE>
Minimum length (the sum of PNT+LEN) is 4 words (16 bytes), smaller values (0..3
words) are causing hang-ups (busy bit remains set infinite, but no sound output
occurs).<BR>
<BR>
In One-shot mode, the sound length is the sum of (PNT+LEN).<BR>
In Looped mode, the length is (1*PNT+Infinite*LEN), ie. the first part (PNT) is
played once, the second part (LEN) is repeated infinitely.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dssoundcontrolregisters"></A>&nbsp;
  DS Sound Control Registers
</FONT></TD></TR></TABLE><BR>
<B>4000500h - NDS7 - SOUNDCNT - Sound Control Register (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-6   Master Volume       (0..127=silent..loud)
  Bit7     Not used            (always zero)
  Bit8-9   Left Output from    (0=Left Mixer, 1=Ch1, 2=Ch3, 3=Ch1+Ch3)
  Bit10-11 Right Output from   (0=Right Mixer, 1=Ch1, 2=Ch3, 3=Ch1+Ch3)
  Bit12    Output Ch1 to Mixer (0=Yes, 1=No) (both Left/Right)
  Bit13    Output Ch3 to Mixer (0=Yes, 1=No) (both Left/Right)
  Bit14    Not used            (always zero)
  Bit15    Master Enable       (0=Disable, 1=Enable)
  Bit16-31 Not used            (always zero)
</TD></TR></TABLE>
<BR>
<B>4000504h - NDS7 - SOUNDBIAS - Sound Bias Register (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-9   Sound Bias    (0..3FFh, usually 200h)
  Bit10-31 Not used      (always zero)
</TD></TR></TABLE>
After applying the master volume, the signed left/right audio signals are in
range -200h..+1FFh (with medium level zero), the Bias value is then added to
convert the signed numbers into unsigned values (with medium level 200h).<BR>
BIAS output is always enabled, even when Master Enable (SOUNDCNT.15) is off.<BR>
<BR>
The sampling frequency of the mixer is 1.04876 MHz with an amplitude resolution
of 24 bits, but the sampling frequency after mixing with PWM modulation is
32.768 kHz with an amplitude resolution of 10 bits.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dssoundcapture"></A>&nbsp;
  DS Sound Capture
</FONT></TD></TR></TABLE><BR>
The DS contains 2 built-in sound capture devices that can capture output
waveform data to memory.<BR>
Sound capture 0 can capture output from left-mixer or output from channel 0.<BR>
Sound capture 1 can capture output from right-mixer or output from channel 2.<BR>
<BR>
<B>4000508h - NDS7 - SNDCAP0CNT - Sound Capture 0 Control Register (R/W)</B><BR>
<B>4000509h - NDS7 - SNDCAP1CNT - Sound Capture 1 Control Register (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0     Control of Associated Sound Channels (ANDed with Bit7)
            SNDCAP0CNT: Output Sound Channel 1 (0=As such, 1=Add to Channel 0)
            SNDCAP1CNT: Output Sound Channel 3 (0=As such, 1=Add to Channel 2)
            Caution: Addition mode works only if BOTH Bit0 and Bit7 are set.
  Bit1     Capture Source Selection
            SNDCAP0CNT: Capture 0 Source (0=Left Mixer, 1=Channel 0/Bugged)
            SNDCAP1CNT: Capture 1 Source (0=Right Mixer, 1=Channel 2/Bugged)
  Bit2     Capture Repeat        (0=Loop, 1=One-shot)
  Bit3     Capture Format        (0=PCM16, 1=PCM8)
  Bit4-6   Not used              (always zero)
  Bit7     Capture Start/Status  (0=Stop, 1=Start/Busy)
</TD></TR></TABLE>
<BR>
<B>4000510h - NDS7 - SNDCAP0DAD - Sound Capture 0 Destination Address (R/W)</B><BR>
<B>4000518h - NDS7 - SNDCAP1DAD - Sound Capture 1 Destination Address (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-26  Destination address (word aligned, bit0-1 are always zero)
  Bit27-31 Not used (always zero)
</TD></TR></TABLE>
Capture start address (also used as re-start address for looped capture).<BR>
<BR>
<B>4000514h - NDS7 - SNDCAP0LEN - Sound Capture 0 Length (W)</B><BR>
<B>400051Ch - NDS7 - SNDCAP1LEN - Sound Capture 1 Length (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-15  Buffer length (1..FFFFh words) (ie. N*4 bytes)
  Bit16-31 Not used
</TD></TR></TABLE>
Minimum length is 1 word (attempts to use 0 words are interpreted as 1 word).<BR>
<BR>
<B>SOUND1TMR - NDS7 - Sound Channel 1 Timer shared as Capture 0 Timer</B><BR>
<B>SOUND3TMR - NDS7 - Sound Channel 3 Timer shared as Capture 1 Timer</B><BR>
There are no separate capture frequency registers, instead, the sample
frequency of Channel 1/3 is shared for Capture 0/1. These channels are intended
to output the captured data, so it makes sense that both capture and sound
output use the same frequency.<BR>
<BR>
For Capture 0, a=0, b=1, x=0.<BR>
For Capture 1, a=2, b=3, x=1.<BR>
<BR>
<B>Capture Bugs</B><BR>
The NDS contains two hardware bugs which do occur when capturing data from
ch(a) (SNDCAPxCNT.Bit1=1), if so, either bug occurs depending on whether
ch(a)+ch(b) addition is enabled or disabled (SNDCAPxCNT.Bit0).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1) Both Negative Bug - SNDCAPxCNT Bit1=1, Bit0=0 (addition disabled)
   Capture data is accidently set to -8000h if ch(a) and ch(b) are both &lt;0.
   Otherwise the correct capture result is returned, ie. plain ch(a) data,
   not being affected by ch(b) (since addition is disabled).
   Workaround: Ensure that ch(a) and/or ch(b) are &gt;=0 (or disabled).
 2) Overflow Bug - SNDCAPxCNT Bit1=1, Bit0=1 (addition enabled)
   In this mode, Capture data isn't clipped to MinMax(-8000h,+7FFFh),
   instead, it is ANDed with FFFFh, so the sign bit is lost if the
   addition result ch(a)+ch(b) is less/greater than -8000h/+7FFFh.
   Workaround: Reduce ch(a)/ch(b) volume or data to avoid overflows.
</TD></TR></TABLE>
These bugs occur only for capture (speaker output remains intact), and they
occur only when capturing ch(a) (capturing mixer-output works flawless).<BR>
<BR>
<B>ch(a)+ch(b) Channel Addition</B><BR>
The ch(a)+ch(b) addition unit has 2 outputs, with slightly different results:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 1) Addition Result for Capture(x) when using capture source=ch(a):
  Addition is performed always, no matter of SOUNDCNT.Bit12/13.
  And, no matter of ch(a) enable, result is plain ch(b) if ch(a) is disabled.
  Result is 16bit (plus fraction) with overflow error (see Capture Bugs).
 2) Addition Result for Mixer (towards speakers, and capture source=mixer):
  Ch(b) is muted if ch(a) is disabled.
  Ch(b) is muted if ch(b) SOUNDCNT.Bit12/13 is set to "Ch(b) not to mixer".
  Result is 17bit (plus fraction) without overflow error.
</TD></TR></TABLE>
Addition mode can be used only if the &lt;corresponding&gt; capture unit is
enabled, ie. if SNDCAPxCNT (Bit0 AND Bit7)=1. If so, addition affects both
mixers (and so, may also affect the &lt;other&gt; capture unit if it reads from
mixer).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dssoundblockdiagrams"></A>&nbsp;
  DS Sound Block Diagrams
</FONT></TD></TR></TABLE><BR>
<B>Left Mixer with Capture 0</B><BR>
<B>(Right Mixer with Capture 1, respectively)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
                       _____
  Ch0.L -------------&gt;|     |  +------------------------------&gt; to Capture 0
               ___    |     |  |                  ___
  Ch1.L ---+-&gt;|Sel|--&gt;|     |  |       Ch0..Ch15 |   |
           |  |___|   |Left |--+----------------&gt;|   |
  Ch2.L ---|---------&gt;|Mixer|                    |Sel|   ______    ____
           |   ___    |     |                Ch1 |   |  |Master|  |Add |
  Ch3.L -+-|-&gt;|Sel|--&gt;|     | +-----------------&gt;|   |-&gt;|Volume|-&gt;|Bias|-&gt; L
         | |  |___|   |     | |                  |   |  |______|  |____|
  Ch4.L -|-|---------&gt;|     | |              Ch3 |   |
  ...   -|-|---------&gt;|     | | +---------------&gt;|   |
  Ch15.L-|-|---------&gt;|_____| | |   ___          |   |
         | +------------------+-|-&gt;|Add| Ch1+Ch3 |   |
         +----------------------+-&gt;|___|--------&gt;|___|
</TD></TR></TABLE>
<BR>
<B>Channel 0 and 1, Capture 0 with input from Left Mixer</B><BR>
<B>(Channel 2 and 3, Capture 1 with input from Right Mixer, respectively)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ____     _________     ___     ___      ___
 |FIFO|--&gt;|Channel 0|--&gt;|Vol|--&gt;|Add|-+-&gt;|Pan|--&gt; Ch0.L
 |____|   |_________|   |___|   |___| |  |___|--&gt; Ch0.R
  ____     _________     ___      ^   |
 |FIFO|&lt;--|Capture 0|&lt;--|Sel|&lt;----|---+
 |____|   |_ _____ _|   |___|&lt;----|-------------- Left Mixer
  ____     _:Timer:_     ___     _|_      ___
 |FIFO|--&gt;|Channel 1|--&gt;|Vol|--&gt;|Sel|---&gt;|Pan|--&gt; Ch1.L
 |____|   |_________|   |___|   |___|    |___|--&gt; Ch1.R
</TD></TR></TABLE>
<BR>
<B>Channel 4 (Channel 5..15, respectively)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ____     _________     ___              ___
 |FIFO|--&gt;|Channel 4|--&gt;|Vol|-----------&gt;|Pan|--&gt; Ch4.L
 |____|   |_________|   |___|            |___|--&gt; Ch4.R
</TD></TR></TABLE>
<BR>
The FIFO isn't used in PSG/Noise modes (supported on channel 8..15).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dssoundnotes"></A>&nbsp;
  DS Sound Notes
</FONT></TD></TR></TABLE><BR>
<B>Sound delayed Start/Restart (timing glitch)</B><BR>
A sound will be started/restarted when changing its start bit from 0 to 1,
however, the sound won't start immediately: PSG/Noise starts after 1 sample,
PCM starts after 3 samples, and ADPCM starts after 11 samples (3 dummy samples
as for PCM, plus 8 dummy samples for the ADPCM header).<BR>
<BR>
<B>Sound Stop (timing note)</B><BR>
In one-shot mode, the Busy bit gets cleared automatically at the BEGIN of the
last sample period, nethertheless (despite of the cleared Busy bit) the last
sample is kept output until the END of the last sample period (or, if the Hold
flag is set, then the last sample is kept output infinitely, that is, until
Hold gets cleared, or until the sound gets restarted).<BR>
<BR>
<B>Hold Flag (appears useless/bugged)</B><BR>
The Hold flag allows to keep the last sample being output infinitely after the
end of one-shot sounds. This feature is probably intended to allow to play two
continous one-shot sound blocks (without producing any scratch noise upon small
delays between both blocks, which would occur if the output level would drop to
zero).<BR>
However, the feature doesn't work as intended. As described above, PCM8/PCM16
sound starts are delayed by 3 samples. With Hold flag set, old output level is
acually kept intact during the 1st sample, but the output level drops to zero
during 2nd-3rd sample, before starting the new sound in 4th sample.<BR>
<BR>
<B>7bit Volume and Panning Values</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  data.vol   = data*N/128
  pan.left   = data*(128-N)/128
  pan.right  = data*N/128
  master.vol = data*N/128/64
</TD></TR></TABLE>
Register settings of 0..126,127 are interpreted as N=0..126,128.<BR>
<BR>
<B>Max Output Levels</B><BR>
When configured to max volume (and left-most or right-most panning), each
channel can span the full 10bit output range (-200h..1FFh) on one speaker, as
well as the full 16bit input range (-8000h..7FFFh) on one capture unit.<BR>
(It needs 2 channels to span the whole range on BOTH speakers/capture units.)<BR>
Together, all sixteen channels could thus reach levels up to -1E00h..21F0h
(with default BIAS=200h) on one speaker, and -80000h..+7FFF0h on one capture
unit. However, to avoid overflows, speaker outputs are clipped to
MinMax(0,3FFh), and capture inputs to MinMax(-8000h..+7FFFh).<BR>
<BR>
<B>Channel/Mixer Bit-Widths</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Step                           Bits  Min        Max
  0 Incoming PCM16 Data          16.0  -8000h     +7FFFh
  1 Volume Divider (div 1..16)   16.4  -8000h     +7FFFh
  2 Volume Factor (mul N/128)    16.11 -8000h     +7FFFh
  3 Panning (mul N/128)          16.18 -8000h     +7FFFh
  4 Rounding Down (strip 10bit)  16.8  -8000h     +7FFFh
  5 Mixer (add channel 0..15)    20.8  -80000h    +7FFF0h
  6 Master Volume (mul N/128/64) 14.21 -2000h     +1FF0h
  7 Strip fraction               14.0  -2000h     +1FF0h
  8 Add Bias (0..3FFh, def=200h) 15.0  -2000h+0   +1FF0h+3FFh
  9 Clip (min/max 0h..3FFh)      10.0  0          +3FFh
</TD></TR></TABLE>
Table shows integer.fractional bits, and min/max values (without fraction).<BR>
<BR>
<B>Capture Clipping/Rounding</B><BR>
Incoming ch(a) is NOT clipped, ch(a)+ch(b) may overflow (see Capture Bugs).<BR>
Incoming mixer data (20.8bits) is clipped to 16.8bits (MinMax -8000h..7FFFh).<BR>
For PCM8 capture format, the 16.8 bits are divided by 100h (=8.16 bits).<BR>
If the MSB of the fractional part is set, then data is rounded towards zero.<BR>
(Positive values are rounded down, negative values are rounded up.)<BR>
The fractional part is then discarded, and plain integer data is captured.<BR>
<BR>
<B>PSG Sound</B><BR>
The output volume equals to PCM16 values +7FFFh (HIGH) and -7FFFh (LOW).<BR>
PSG sound is always Infinite (the SOUNDxLEN Register, and the SOUNDxCNT Repeat
Mode bits have no effect). The PSG hardware doesn't support sound length,
sweep, or volume envelopes, however, these effects can be produced by software
with little overload (or, more typically, with enormous overload, depending on
the programming language used).<BR>
<BR>
<B>PSG Wave Duty (channel 8..13 in PSG mode)</B><BR>
Each duty cycle consists of eight HIGH or LOW samples, so the sound frequency
is 1/8th of the selected sample rate. The duty cycle always starts at the begin
of the LOW period when the sound gets (re-)started.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0  12.5% "_______-_______-_______-"
  1  25.0% "______--______--______--"
  2  37.5% "_____---_____---_____---"
  3  50.0% "____----____----____----"
  4  62.5% "___-----___-----___-----"
  5  75.0% "__------__------__------"
  6  87.5% "_-------_-------_-------"
  7   0.0% "________________________"
</TD></TR></TABLE>
The Wave Duty bits exist and are read/write-able on all channels (although they
are actually used only in PSG mode on channels 8-13).<BR>
<BR>
<B>PSG Noise (channel 14..15 in PSG mode)</B><BR>
Noise randomly switches between HIGH and LOW samples, the output levels are
calculated, at the selected sample rate, as such:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  X=X SHR 1, IF carry THEN Out=LOW, X=X XOR 6000h ELSE Out=HIGH
</TD></TR></TABLE>
The initial value when (re-)starting the sound is X=7FFFh. The formula is more
or less same as "15bit polynomial counter" used on 8bit Gameboy and GBA.<BR>
<BR>
<B>PCM8 and PCM16</B><BR>
Signed samples in range -80h..+7Fh (PCM8), or -8000h..+7FFFh (PCM16).<BR>
The output volume of PCM8=NNh is equal to PCM16=NN00h.<BR>
<BR>
<B>IMA-ADPCM Format</B><BR>
IMA-ADPCM is a Adaptive Differential Pulse Code Modulation (ADPCM) variant,
designed by International Multimedia Association (IMA), the format is used,
among others, in IMA-ADPCM compressed Windows .WAV files.<BR>
The NDS data consist of a 32bit header, followed by 4bit values (so each byte
contains two values, the first value in the lower 4bits, the second in upper 4
bits). The 32bit header contains initial values:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-15   Initial PCM16 Value (Pcm16bit = -7FFFh..+7FFF) (not -8000h)
  Bit16-22  Initial Table Index Value (Index = 0..88)
  Bit23-31  Not used (zero)
</TD></TR></TABLE>
In theory, the 4bit values are decoded into PCM16 values, as such:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Diff = ((Data4bit AND 7)*2+1)*AdpcmTable[Index]/8      ;see rounding-error
  IF (Data4bit AND 8)=0 THEN Pcm16bit = Max(Pcm16bit+Diff,+7FFFh)
  IF (Data4bit AND 8)=8 THEN Pcm16bit = Min(Pcm16bit-Diff,-7FFFh)
  Index = MinMax (Index+IndexTable[Data4bit AND 7],0,88)
</TD></TR></TABLE>
In practice, the first line works like so (with rounding-error):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Diff = AdpcmTable[Index]/8
  IF (data4bit AND 1) THEN Diff = Diff + AdpcmTable[Index]/4
  IF (data4bit AND 2) THEN Diff = Diff + AdpcmTable[Index]/2
  IF (data4bit AND 4) THEN Diff = Diff + AdpcmTable[Index]/1
</TD></TR></TABLE>
And, a note on the second/third lines (with clipping-error):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Max(+7FFFh) leaves -8000h unclipped (can happen if initial PCM16 was -8000h)
  Min(-7FFFh) clips -8000h to -7FFFh (possibly unlike windows .WAV files?)
</TD></TR></TABLE>
Whereas, IndexTable[0..7] = -1,-1,-1,-1,2,4,6,8. And AdpcmTable [0..88] =<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0007h,0008h,0009h,000Ah,000Bh,000Ch,000Dh,000Eh,0010h,0011h,0013h,0015h
  0017h,0019h,001Ch,001Fh,0022h,0025h,0029h,002Dh,0032h,0037h,003Ch,0042h
  0049h,0050h,0058h,0061h,006Bh,0076h,0082h,008Fh,009Dh,00ADh,00BEh,00D1h
  00E6h,00FDh,0117h,0133h,0151h,0173h,0198h,01C1h,01EEh,0220h,0256h,0292h
  02D4h,031Ch,036Ch,03C3h,0424h,048Eh,0502h,0583h,0610h,06ABh,0756h,0812h
  08E0h,09C3h,0ABDh,0BD0h,0CFFh,0E4Ch,0FBAh,114Ch,1307h,14EEh,1706h,1954h
  1BDCh,1EA5h,21B6h,2515h,28CAh,2CDFh,315Bh,364Bh,3BB9h,41B2h,4844h,4F7Eh
  5771h,602Fh,69CEh,7462h,7FFFh
</TD></TR></TABLE>
The closest way to reproduce the AdpcmTable with 32bit integer maths appears:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  X=000776d2h, FOR I=0 TO 88, Table[I]=X SHR 16, X=X+(X/10), NEXT I
  Table[3]=000Ah, Table[4]=000Bh, Table[88]=7FFFh, Table[89..127]=0000h
</TD></TR></TABLE>
When using ADPCM and loops, set the loopstart position to the data part, rather
than the header. At the loop end, the SAD value is reloaded to the loop start
location, additionally index and pcm16 values are reloaded to the values that
have originally appeared at that location. Do not change the ADPCM loop start
position during playback.<BR>
<BR>
<B>Microphone Input</B><BR>
For Microphone (and Touchscreen) inputs, see<BR>
<A HREF="#dstouchscreencontrollertsc">DS Touch Screen Controller (TSC)</A><BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dssystemandbuiltinperipherals"></A>&nbsp;
  DS System and Built-in Peripherals
</FONT></TD></TR></TABLE><BR>
<A HREF="#dsdmatransfers">DS DMA Transfers</A><BR>
<A HREF="#dstimers">DS Timers</A><BR>
<A HREF="#dsinterrupts">DS Interrupts</A><BR>
<A HREF="#dsmaths">DS Maths</A><BR>
<A HREF="#dsinterprocesscommunicationipc">DS Inter Process Communication (IPC)</A><BR>
<A HREF="#dskeypad">DS Keypad</A><BR>
<A HREF="#dsabsentlinkport">DS Absent Link Port</A><BR>
<A HREF="#dsrealtimeclockrtc">DS Real-Time Clock (RTC)</A><BR>
<A HREF="#dsserialperipheralinterfacebusspi">DS Serial Peripheral Interface Bus (SPI)</A><BR>
<A HREF="#dstouchscreencontrollertsc">DS Touch Screen Controller (TSC)</A><BR>
<A HREF="#dspowermanagement">DS Power Management</A><BR>
<A HREF="#dsbackwardscompatiblegbamode">DS Backwards-compatible GBA-Mode</A><BR>
<A HREF="#dsdebugregistersemulatordevkits">DS Debug Registers (Emulator/Devkits)</A><BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsdmatransfers"></A>&nbsp;
  DS DMA Transfers
</FONT></TD></TR></TABLE><BR>
The DS includes four DMA channels for each CPU (ie. eight channels in total),
which are working more or less the same as on GBA:<BR>
<A HREF="#gbadmatransfers">GBA DMA Transfers</A><BR>
All NDS9 and NDS7 DMA Registers are R/W. The gamepak bit (Bit 27) has been
removed (on the NDS9 the bit is used to expand the mode setting to 3bits).<BR>
<BR>
<B>NDS9 DMA</B><BR>
Word count of all channels is expanded to 21bits (max 1..1FFFFFh units, or
0=200000h units), and SAD/DAD registers for all channels support ranges of
0..0FFFFFFEh. The transfer modes (DMACNT Bit27-29) are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0  Start Immediately
  1  Start at V-Blank
  2  Start at H-Blank (paused during V-Blank)
  3  Synchronize to start of display
  4  Main memory display
  5  DS Cartridge Slot
  6  GBA Cartridge Slot
  7  Geometry Command FIFO
</TD></TR></TABLE>
<BR>
<B>NDS7 DMA</B><BR>
Word Count, SAD, and DAD are R/W, aside from that they do have the same
restrictions as on GBA (max 4000h or 10000h units, some addresses limited to
0..07FFFFFEh). DMACNT Bit27 is unused on NDS7. The transfer modes (DMACNT
Bit28-29) are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0  Start Immediately
  1  Start at V-Blank
  2  DS Cartridge Slot
  3  DMA0/DMA2: Wireless interrupt, DMA1/DMA3: GBA Cartridge Slot
</TD></TR></TABLE>
<BR>
<B>40000E0h - NDS9 only - DMA0FILL - DMA 0 Filldata (R/W)</B><BR>
<B>40000E4h - NDS9 only - DMA1FILL - DMA 1 Filldata (R/W)</B><BR>
<B>40000E8h - NDS9 only - DMA2FILL - DMA 2 Filldata (R/W)</B><BR>
<B>40000ECh - NDS9 only - DMA3FILL - DMA 3 Filldata (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-31 Filldata
</TD></TR></TABLE>
The DMA Filldata registers contain 16 bytes of general purpose WRAM, intended
to be used as fixed source addresses for DMA memfill operations.<BR>
This is useful because DMA cannot read from TCM, and reading from Main RAM
would require to recurse cache &amp; write buffer.<BR>
<BR>
<B>NDS7 Sound DMA</B><BR>
The NDS additionally includes 16 Sound DMA channels, plus 2 Sound Capture DMA
channels (see Sound chapter). The priority of these channels is unknown.<BR>
<BR>
<B>NDS9 Cache, Writebuffer, DTCM, and ITCM</B><BR>
Cache and tightly coupled memory are connected directly to the NDS9 CPU,
without using the system bus. So that, DMA cannot access DTCM/ITCM, and access
to cached memory regions must be handled with care: Drain the writebuffer
before DMA-reads, and invalidate the cache after DMA-writes. See,<BR>
<A HREF="#armcp15systemcontrolcoprocessor">ARM CP15 System Control Coprocessor</A><BR>
The CPU can be kept running during DMA, provided that it is accessing only TCM
(or cached memory), otherwise the CPU is halted until DMA finishes.<BR>
Respectively, interrupts executed during DMA will usually halt the CPU (unless
the IRQ handler uses only TCM and cache; the IRQ vector at FFFF00xxh must be
cached, or relocated to ITCM at 000000xxh, and the IRQ handler may not access
IE, IF, or other I/O ports).<BR>
<BR>
<B>NDS Sequential Main Memory DMA</B><BR>
Main RAM has different access time for sequential and non-sequential access.
Normally DMA uses sequential access (except for the first word), however, if
the source and destination addresses are both in Main RAM, then all accesses
become non-sequential. In that case it would be faster to use two DMA
transfers, one from Main RAM to a scratch buffer in WRAM, and one from WRAM to
Main RAM.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dstimers"></A>&nbsp;
  DS Timers
</FONT></TD></TR></TABLE><BR>
Same as GBA, except F = 33.513982 MHz (for both NDS9 and NDS7).<BR>
<A HREF="#gbatimers">GBA Timers</A><BR>
Both NDS9 and NDS7 have four Timers each, eight Timers in total.<BR>
The NDS sound controller is having its own frequency generators (unlike GBA,
which needed to use Timers to drive channel A/B sounds).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsinterrupts"></A>&nbsp;
  DS Interrupts
</FONT></TD></TR></TABLE><BR>
<B>4000208h - NDS9/NDS7 - IME - Interrupt Master Enable (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Disable all interrupts  (0=Disable All, 1=See IE register)
  1-31  Not used
</TD></TR></TABLE>
<BR>
<B>4000210h - NDS9/NDS7 - IE - 32bit - Interrupt Enable (R/W)</B><BR>
<B>4000214h - NDS9/NDS7 - IF - 32bit - Interrupt Request Flags (R/W)</B><BR>
Bits in the IE register are 0=Disable, 1=Enable.<BR>
Reading IF returns 0=No request, 1=Interrupt Request.<BR>
Writing IF acts as 0=No change, 1=Acknowledge (clears that bit).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     LCD V-Blank
  1     LCD H-Blank
  2     LCD V-Counter Match
  3     Timer 0 Overflow
  4     Timer 1 Overflow
  5     Timer 2 Overflow
  6     Timer 3 Overflow
  7     NDS7 only: SIO/RCNT/RTC (Real Time Clock)
  8     DMA 0
  9     DMA 1
  10    DMA 2
  11    DMA 3
  12    Keypad
  13    GBA-Slot (external IRQ source) / DSi: None such
  14    Not used                       / DSi9: NDS-Slot Card change?
  15    Not used                       / DSi: dito for 2nd NDS-Slot?
  16    IPC Sync
  17    IPC Send FIFO Empty
  18    IPC Recv FIFO Not Empty
  19    NDS-Slot Game Card Data Transfer Completion
  20    NDS-Slot Game Card IREQ_MC
  21    NDS9 only: Geometry Command FIFO
  22    NDS7 only: Screens unfolding
  23    NDS7 only: SPI bus
  24    NDS7 only: Wifi    / DSi9: XpertTeak DSP
  25    Not used           / DSi9: Camera
  26    Not used           / DSi9: Undoc, IF.26 set on FFh-filling 40021Axh
  27    Not used           / DSi:  Maybe IREQ_MC for 2nd gamecard?
  28    Not used           / DSi: NewDMA0
  29    Not used           / DSi: NewDMA1
  30    Not used           / DSi: NewDMA2
  31    Not used           / DSi: NewDMA3
  ?     DSi7: any further new IRQs on ARM7 side...?
</TD></TR></TABLE>
Raw TCM-only IRQs can be processed even during DMA ?<BR>
Trying to set all IE bits gives FFFFFFFFh (DSi7) or FFFFFF7Fh (DSi9).<BR>
<BR>
<B>4000218h - DSi7 - IE2 - DSi7 Extra Interrupt Enable Bits</B><BR>
<B>400021Ch - DSi7 - IF2 - DSi7 Extra Interrupt Flags</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     DSi7: GPIO18[0]   ;\
  1     DSi7: GPIO18[1]   ; maybe 1.8V signals?
  2     DSi7: GPIO18[2]   ;/
  3     DSi7: Unused (0)
  4     DSi7: GPIO33[0] unknown (related to "GPIO330" testpoint on mainboard?)
  5     DSi7: GPIO33[1] Headphone connect (HP#SP) (static state)
  6     DSi7: GPIO33[2] Powerbutton interrupt (short pulse upon key-down)
  7     DSi7: GPIO33[3]
  8     DSi7: SD card 1
  9     DSi7: SDIO card 1 async
  10    DSi7: SD card 2
  11    DSi7: SDIO card 2 async
  12    DSi7: AES interrupt
  13    DSi7: I2C interrupt
  14    DSi7: Microphone Extended interrupt
  15-31 DSi7: Unused (0)
</TD></TR></TABLE>
Trying to set all IE2 bits gives 00007FF7h (DSi7) or 00000000h (DSi9).<BR>
<BR>
<B>DTCM+3FFCh - NDS9 - IRQ Handler (hardcoded DTCM address)</B><BR>
<B>380FFFCh - NDS7 - IRQ Handler (hardcoded RAM address)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit 0-31  Pointer to IRQ Handler
</TD></TR></TABLE>
NDS7 Handler must use ARM code, NDS9 Handler can be ARM/THUMB (Bit0=Thumb).<BR>
<BR>
<B>DTCM+3FF8h - NDS9 - IRQ Check Bits (hardcoded DTCM address)</B><BR>
<B>380FFF8h - NDS7 - IRQ Check Bits (hardcoded RAM address)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit 0-31  IRQ Flags (same format as IE/IF registers)
</TD></TR></TABLE>
When processing &amp; acknowleding interrupts via IF register, the user
interrupt handler should also set the corresponding bits of the IRQ Check value
(required for BIOS IntrWait and VBlankIntrWait SWI functions).<BR>
<BR>
<B>380FFC0h - DSi7 only - Extra IRQ Check Bits for IE2/IF2 (hardcoded RAM addr)</B><BR>
Same as the above 380FFF8h value, but for new IE2/IF2 registers, intended for
use with IntrWait and VBlankIntrWait functions. However, that functions are
BUGGED on DSi and won't actually work in practice (they do support only the new
380FFC0h bits, but do accidently ignore the old 380FFF8h bits).<BR>
<BR>
--- Below for other (non-IRQ) exceptions ---<BR>
<BR>
<B>27FFD9Ch - RAM - NDS9 Debug Stacktop / Debug Vector (0=None)</B><BR>
<B>380FFDCh - RAM - NDS7 Debug Stacktop / Debug Vector (0=None)</B><BR>
These addresses contain a 32bit pointer to the Debug Handler, and, memory below
of the addresses is used as Debug Stack. The debug handler is called on
undefined instruction exceptions, on data/prefetch aborts (caused by the
protection unit), on FIQ (possibly caused by hardware debuggers). It is also
called by accidental software-jumps to the reset vector, and by unused SWI
numbers within range 0..1Fh.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsmaths"></A>&nbsp;
  DS Maths
</FONT></TD></TR></TABLE><BR>
<B>4000280h - NDS9 - DIVCNT - Division Control (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-1   Division Mode    (0-2=See below) (3=Reserved; same as Mode 1)
  2-13  Not used
  14    Division by zero (0=Okay, 1=Division by zero error; 64bit Denom=0)
  15    Busy             (0=Ready, 1=Busy) (Execution time see below)
  16-31 Not used
</TD></TR></TABLE>
Division Modes and Busy Execution Times<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Mode  Numer / Denom = Result, Remainder ; Cycles
  0     32bit / 32bit = 32bit , 32bit     ; 18 clks
  1     64bit / 32bit = 64bit , 32bit     ; 34 clks
  2     64bit / 64bit = 64bit , 64bit     ; 34 clks
</TD></TR></TABLE>
Division is started when writing to any of the DIVCNT/NUMER/DENOM registers.<BR>
<BR>
<B>4000290h - NDS9 - DIV_NUMER - 64bit Division Numerator (R/W)</B><BR>
<B>4000298h - NDS9 - DIV_DENOM - 64bit Division Denominator (R/W)</B><BR>
Signed 64bit values (or signed 32bit values in 32bit modes, the upper 32bits
are then unused, with one exception: the DIV0 flag in DIVCNT is set only if the
full 64bit DIV_DENOM value is zero, even in 32bit mode).<BR>
<BR>
<B>40002A0h - NDS9 - DIV_RESULT - 64bit Division Quotient (=Numer/Denom) (R)</B><BR>
<B>40002A8h - NDS9 - DIVREM_RESULT - 64bit Remainder (=Numer MOD Denom) (R)</B><BR>
Signed 64bit values (in 32bit modes, the values are sign-expanded to 64bit).<BR>
<BR>
<B>Division Overflows</B><BR>
Overflows occur on "DIV0" and "-MAX/-1" (eg. -80000000h/-1 in 32bit mode):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  DIV0     --&gt;  REMAIN=NUMER, RESULT=+/-1 (with sign opposite of NUMER)
  -MAX/-1  --&gt;  RESULT=-MAX               (instead +MAX)
</TD></TR></TABLE>
On overflows in 32bit/32bit=32bit mode: the upper 32bit of the sign-expanded
32bit result are inverted. This feature produces a correct 64bit (+MAX) result
in case of the incorrect 32bit (-MAX) result. The feature also applies on DIV0
errors (which makes the sign-expanded 64bit result even more messed-up than the
normal 32bit result).<BR>
The DIV0 flag in DIVCNT.14 indicates DENOM=0 errors (it does not indicate
"-MAX/-1" errors). The DENOM=0 check relies on the full 64bit value (so, in
32bit mode, the flag works only if the unused upper 32bit of DENOM are zero).<BR>
<BR>
<B>40002B0h - NDS9 - SQRTCNT - Square Root Control (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Mode (0=32bit input, 1=64bit input)
  1-14  Not used
  15    Busy (0=Ready, 1=Busy) (Execution time is 13 clks, in either Mode)
  16-31 Not used
</TD></TR></TABLE>
Calculation is started when writing to any of the SQRTCNT/PARAM registers.<BR>
<BR>
<B>40002B4h - NDS9 - SQRT_RESULT - 32bit - Square Root Result (R)</B><BR>
<B>40002B8h - NDS9 - SQRT_PARAM - 64bit - Square Root Parameter Input (R/W)</B><BR>
Unsigned 64bit parameter, and unsigned 32bit result.<BR>
<BR>
<B>IRQ Notes</B><BR>
Push all DIV/SQRT values (parameters and control registers) when using DIV/SQRT
registers on interrupt level, and, after restoring them, be sure to wait until
the busy flag goes off, before leaving the IRQ handler.<BR>
<BR>
<B>BIOS Notes</B><BR>
The NDS9 and NDS7 BIOSes additionally contain software based division and
square root functions, which are NOT using above hardware registers (even the
NDS9 functions are raw software).<BR>
<BR>
<B>Timing Notes</B><BR>
The Div/Sqrt timings are counted in 33.51MHz units. Although the calculations
are quite fast, mind that reading/writing the result/parameter registers takes
up additional clock cycles (especially due to the PENALTY cycle glitch for
non-sequential accesses; parts of that problem can be eventually bypassed by
using sequential STMIA/LDMIA opcodes) (nethertheless, in some cases, software
may be actually faster than the hardware registers; eg. for small 8bit numbers;
that of course NOT by using the BIOS software functions which are endless
inefficient).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsinterprocesscommunicationipc"></A>&nbsp;
  DS Inter Process Communication (IPC)
</FONT></TD></TR></TABLE><BR>
Allows to exchange status information between ARM7 and ARM9 CPUs.<BR>
The register can be accessed simultaneously by both CPUs (without violating
access permissions, and without generating waitstates at either side).<BR>
<BR>
<B>4000180h - NDS9/NDS7 - IPCSYNC - IPC Synchronize Register (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Dir  Expl.
  0-3   R    Data input from IPCSYNC Bit8-11 of remote CPU (00h..0Fh)
  4-7   -    Not used
  8-11  R/W  Data output to IPCSYNC Bit0-3 of remote CPU   (00h..0Fh)
  12    -    Not used
  13    W    Send IRQ to remote CPU      (0=None, 1=Send IRQ)
  14    R/W  Enable IRQ from remote CPU  (0=Disable, 1=Enable)
  15-31 -    Not used
</TD></TR></TABLE>
<BR>
<B>4000184h - NDS9/NDS7 - IPCFIFOCNT - IPC Fifo Control Register (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Dir  Expl.
  0     R    Send Fifo Empty Status      (0=Not Empty, 1=Empty)
  1     R    Send Fifo Full Status       (0=Not Full, 1=Full)
  2     R/W  Send Fifo Empty IRQ         (0=Disable, 1=Enable)
  3     W    Send Fifo Clear             (0=Nothing, 1=Flush Send Fifo)
  4-7   -    Not used
  8     R    Receive Fifo Empty          (0=Not Empty, 1=Empty)
  9     R    Receive Fifo Full           (0=Not Full, 1=Full)
  10    R/W  Receive Fifo Not Empty IRQ  (0=Disable, 1=Enable)
  11-13 -    Not used
  14    R/W  Error, Read Empty/Send Full (0=No Error, 1=Error/Acknowledge)
  15    R/W  Enable Send/Receive Fifo    (0=Disable, 1=Enable)
  16-31 -    Not used
</TD></TR></TABLE>
<BR>
<B>4000188h - NDS9/NDS7 - IPCFIFOSEND - IPC Send Fifo (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-31  Send Fifo Data (max 16 words; 64bytes)
</TD></TR></TABLE>
<BR>
<B>4100000h - NDS9/NDS7 - IPCFIFORECV - IPC Receive Fifo (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-31  Receive Fifo Data (max 16 words; 64bytes)
</TD></TR></TABLE>
<BR>
<B>IPCFIFO Notes</B><BR>
When IPCFIFOCNT.15 is disabled: Writes to IPCFIFOSEND are ignored (no data is
stored in the FIFO, the error bit doesn't get set though), and reads from
IPCFIFORECV return the oldest FIFO word (as usually) (but without removing the
word from the FIFO).<BR>
When the Receive FIFO is empty: Reading from IPCFIFORECV returns the most
recently received word (if any), or ZERO (if there was no data, or if the FIFO
was cleared via IPCFIFOCNT.3), and, in either case the error bit gets set.<BR>
The Fifo-IRQs are edge triggered, IF.17 gets set when the condition
"(IPCFIFOCNT.2 AND IPCFIFOCNT.0)" changes from 0-to-1, and IF.18 gets set when
"(IPCFIFOCNT.10 AND NOT IPCFIFOCNT.8)" changes from 0-to-1. The IRQ flags can
be acknowledged even while that conditions are true.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dskeypad"></A>&nbsp;
  DS Keypad
</FONT></TD></TR></TABLE><BR>
For the GBA-buttons: Same as GBA, both ARM7 and ARM9 have keyboard input
registers, and each its own keypad IRQ control register.<BR>
<A HREF="#gbakeypadinput">GBA Keypad Input</A><BR>
<BR>
For Touchscreen (and Microphone) inputs, see<BR>
<A HREF="#dstouchscreencontrollertsc">DS Touch Screen Controller (TSC)</A><BR>
<BR>
<B>4000136h - NDS7 - EXTKEYIN - Key X/Y Input (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0      Button X     (0=Pressed, 1=Released)
  1      Button Y     (0=Pressed, 1=Released)
  3      DEBUG button (0=Pressed, 1=Released/None such)
  6      Pen down     (0=Pressed, 1=Released/Disabled) (always 0 in DSi mode)
  7      Hinge/folded (0=Open, 1=Closed)
  2,4,5  Unknown / set
  8..15  Unknown / zero
</TD></TR></TABLE>
The Hinge stuff is a magnetic sensor somewhere underneath of the Start/Select
buttons (NDS) or between A/B/X/Y buttons (DSi), it will be triggered by the
magnet field from the right speaker when the console is closed. The hinge
generates an interrupt request (there seems to be no way to disable this,
unlike as for all other IRQ sources), however, the interrupt execution can be
disabled in IE register (as for other IRQ sources).<BR>
The Pen Down is the /PENIRQ signal from the Touch Screen Controller (TSC), if
it is enabled in the TSC control register, then it will notify the program when
the screen pressed, the program should then read data from the TSC (if there's
no /PENIRQ then doing unneccassary TSC reads would just waste CPU power).
However, the user may release the screen before the program performs the TSC
read, so treat the screen as not pressed if you get invalid TSC values (even if
/PENIRQ was LOW).<BR>
Not sure if the TSC /PENIRQ is actually triggering an IRQ in the NDS?<BR>
The Debug Button should be connected to R03 and GND (on original NDS, R03 is
the large soldering point between the SL1 jumper and the VR1 potentiometer)
(there is no R03 signal visible on the NDS-Lite board).<BR>
Interrupts are reportedly not supported for X,Y buttons.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsabsentlinkport"></A>&nbsp;
  DS Absent Link Port
</FONT></TD></TR></TABLE><BR>
The DS doesn't have a Serial Link Port Socket, however, internally, the NDS7
contains the complete set of Serial I/O Ports, as contained in the GBA:<BR>
<A HREF="#gbacommunicationports">GBA Communication Ports</A><BR>
<BR>
In GBA mode, the ports are working as on real GBA (as when no cable is
connected). In NDS mode, the ports are even containing some additional bits:<BR>
<BR>
<B>NDS7 SIO Bits (according to an early I/O map from Nintendo)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  NDS7 4000128h SIOCNT   Bit15 "CKUP"  New Bit in NORMAL/MULTI/UART mode (R/W)
  NDS7 4000128h SIOCNT   Bit14 "N/A"   Removed IRQ Bit in UART mode (?)
  NDS7 400012Ah SIOCNT_H Bit14 "TFEMP" New Bit (R/W)
  NDS7 400012Ah SIOCNT_H Bit15 "RFFUL" New Bit (always zero?)
  NDS7 400012Ch SIOSEL   Bit0  "SEL"   New Bit (always zero?)
  NDS7 4000140h JOYCNT   Bit7  "MOD"   New Bit (R/W)
</TD></TR></TABLE>
The "CKUP" bit duplicates the internal clock transfer rate (selected in
SIOCNT.1) (tested in normal mode) (probably works also in multi/uart mode?).<BR>
<BR>
<B>NDS7 DS-Lite 4001080h (W) (?)</B><BR>
DS-Lite Firmware writes FFFFh to this address (prior to accessing SIOCNT), so
it's probably SIO or debugging related (might be as well a bug or so). Reading
from the port always returns 0000h on both DS and DS-Lite.<BR>
<BR>
<B>NDS9 SIO Bits (according to an early I/O map from Nintendo)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  NDS9 4000120h SIODATA32 Bit0-31 Data            (always zero?)
  NDS9 4000128h SIOCNT    Bit2    "TRECV" New Bit (always zero?)
  NDS9 4000128h SIOCNT    Bit3    "TSEND" New Bit (always zero?)
  NDS9 400012Ch SIOSEL    Bit0    "SEL"   New Bit (always zero?)
</TD></TR></TABLE>
Not sure if these ports really exist in the release-version, or if it's been
prototype stuff?<BR>
<BR>
<B>RCNT</B><BR>
RCNT (4000134h) should be set to 80xxh (general purpose mode) before accessing
EXTKEYIN (4000136h) or RTC (4000138h). No idea why (except when using
RTC/SI-interrupt).<BR>
<BR>
<B>DS Serial Port</B><BR>
The SI line is labeled "INT" on the NDS mainboard, it is connected to Pin 1 of
the RTC chip (ie. the /INT interrupt pin).<BR>
I have no idea where to find SO, SC, and SD. I've written a test proggy that
pulsed all four RCNT bits - but all I could find was the SI signal. However,
the BIOS contains some code that uses SIO normal mode transfers (for the debug
version), so at least SI, SO, SC should exist...?<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsrealtimeclockrtc"></A>&nbsp;
  DS Real-Time Clock (RTC)
</FONT></TD></TR></TABLE><BR>
Seiko Instruments Inc. S-35180 (compatible with S-35190A)<BR>
Miniature 8pin RTC with 3-wire serial bus<BR>
<BR>
<B>4000138h - NDS7 - Real Time Clock Register</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit  Expl.
  0    Data I/O   (0=Low, 1=High)
  1    Clock Out  (0=Low, 1=High)
  2    Select Out (0=Low, 1=High/Select)
  4    Data  Direction  (0=Read, 1=Write)
  5    Clock Direction  (should be 1=Write)
  6    Select Direction (should be 1=Write)
  3,8-11   Unused I/O Lines
  7,12-15  Direction for Bit3,8-11 (usually 0)
  16-31    Not used
</TD></TR></TABLE>
<BR>
<B>Serial Transfer Flowchart</B><BR>
Chipselect and Command/Parameter Sequence:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Init CS=LOW and /SCK=HIGH, and wait at least 1us
  Switch CS=HIGH, and wait at least 1us
  Send the Command byte (see bit-transfer below)
  Send/receive Parameter byte(s) associated with the command (see below)
  Switch CS to LOW
</TD></TR></TABLE>
Bit transfer (repeat 8 times per cmd/param byte) (bits transferred LSB first):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Output /SCK=LOW and SIO=databit (when writing), then wait at least 5us
  Output /SCK=HIGH, wait at least 5us, then read SIO=databit (when reading)
  In either direction, data is output on (or immediately after) falling edge.
</TD></TR></TABLE>
Ideally, &lt;both&gt; commands and parameters should be transmitted LSB-first
(unlike the original Seiko document, which recommends LSB-first for data, and
MSB-first for commands).<BR>
<BR>
<B>Command Register</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Command Register
    Fwd  Rev
    0-3  7-4 Fixed Code (must be 06h = 0110b) (same for Fwd and Rev)
    4-6  3-1 Command
             Fwd Rev Parameter bytes (read/write access)
             0   0   1 byte, status register 1
             4   1   1 byte, status register 2
             2   2   7 bytes, date &amp; time (year,month,day,day_of_week,hh,mm,ss)
             6   3   3 bytes, time (hh,mm,ss)
             1*  4*  1 byte, int1, frequency duty setting
             1*  4*  3 bytes, int1, alarm time 1 (day_of_week, hour, minute)
             5   5   3 bytes, int2, alarm time 2 (day_of_week, hour, minute)
             3   6   1 byte, clock adjustment register
             7   7   1 byte, free register
    7    0   Parameter Read/Write Access (0=Write, 1=Read)
</TD></TR></TABLE>
* INT1: Type and number of parameters depend on INT1 setting in stat reg2.<BR>
The "Fwd" bit numbers and command values for LSB-first command transfers (ie.
both commands and parameters use the same bit-order).<BR>
The "Rev" numbers/values are for MSB-first command transfers (ie. commands
using opposite bit-order than parameters, as being suggested by Seiko).<BR>
<BR>
<B>Control and Status Registers</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Status Register 1
    0   W   Reset                (0=Normal, 1=Reset)
    1   R/W 12/24 hour mode      (0=12 hour, 1=24 hour)
    2-3 R/W General purpose bits
    4   R   Interrupt 1 Flag (1=Yes)                      ;auto-cleared on read
    5   R   Interrupt 2 Flag (1=Yes)                      ;auto-cleared on read
    6   R   Power Low Flag (0=Normal, 1=Power is/was low) ;auto-cleared on read
    7   R   Power Off Flag (0=Normal, 1=Power was off)    ;auto-cleared on read
    Power off indicates that the battery was removed or fully discharged,
    all registers are reset to 00h (or 01h), and must be re-initialized.
  Status Register 2
    0-3 R/W INT1 Mode/Enable
            0000b Disable
            0x01b Selected Frequency steady interrupt
            0x10b Per-minute edge interrupt
            0011b Per-minute steady interrupt 1 (duty 30.0 seconds)
            0100b Alarm 1 interrupt
            0111b Per-minute steady interrupt 2 (duty 0.0079 seconds)
            1xxxb 32kHz output
    4-5 R/W General purpose bits
    6   R/W INT2 Enable
            0b    Disable
            1b    Alarm 2 interrupt
    7   R/W Test Mode (0=Normal, 1=Test, don't use) (cleared on Reset)
  Clock Adjustment Register (to compensate oscillator inaccuracy)
    0-7 R/W Adjustment (00h=Normal, no adjustment)
  Free Register
    0-7 R/W General purpose bits
</TD></TR></TABLE>
<BR>
<B>Date Registers</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Year Register
    0-7 R/W Year     (BCD 00h..99h = 2000..2099)
  Month Register
    0-4 R/W Month    (BCD 01h..12h = January..December)
    5-7 -   Not used (always zero)
  Day Register
    0-5 R/W Day      (BCD 01h..28h,29h,30h,31h, range depending on month/year)
    6-7 -   Not used (always zero)
  Day of Week Register (septenary counter)
    0-2 R/W Day of Week (00h..06h, custom assignment, usually 0=Monday?)
    3-7 -   Not used (always zero)
</TD></TR></TABLE>
<BR>
<B>Time Registers</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Hour Register
    0-5 R/W Hour     (BCD 00h..23h in 24h mode, or 00h..11h in 12h mode)
    6   *   AM/PM    (0=AM before noon, 1=PM after noon)
            * 24h mode: AM/PM flag is read only (PM=1 if hour = 12h..23h)
            * 12h mode: AM/PM flag is read/write-able
            * 12h mode: Observe that 12 o'clock is defined as 00h (not 12h)
    7   -   Not used (always zero)
  Minute Register
    0-6 R/W Minute   (BCD 00h..59h)
    7   -   Not used (always zero)
  Second Register
    0-6 R/W Minute   (BCD 00h..59h)
    7   -   Not used (always zero)
</TD></TR></TABLE>
<BR>
<B>Alarm 1 and Alarm 2 Registers</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Alarm1 and Alarm2 Day of Week Registers (INT1 and INT2 each)
    0-2 R/W Day of Week (00h..06h)
    3-6 -   Not used (always zero)
    7   R/W Compare Enable (0=Alarm every day, 1=Alarm only at specified day)
  Alarm1 and Alarm2 Hour Registers (INT1 and INT2 each)
    0-5 R/W Hour     (BCD 00h..23h in 24h mode, or 00h..11h in 12h mode)
    6   R/W AM/PM    (0=AM, 1=PM) (must be correct even in 24h mode?)
    7   R/W Compare Enable (0=Alarm every hour, 1=Alarm only at specified hour)
  Alarm1 and Alarm2 Minute Registers (INT1 and INT2 each)
    0-6 R/W Minute   (BCD 00h..59h)
    7   R/W Compare Enable (0=Alarm every min, 1=Alarm only at specified min)
  Selected Frequency Steady Interrupt Register (INT1 only) (when Stat2/Bit2=0)
    0   R/W Enable 1Hz Frequency  (0=Disable, 1=Enable)
    1   R/W Enable 2Hz Frequency  (0=Disable, 1=Enable)
    2   R/W Enable 4Hz Frequency  (0=Disable, 1=Enable)
    3   R/W Enable 8Hz Frequency  (0=Disable, 1=Enable)
    4   R/W Enable 16Hz Frequency (0=Disable, 1=Enable)
            The signals are ANDed when two or more frequencies are enabled,
            ie. the /INT signal gets LOW when either of the signals is LOW.
    5-7 R/W General purpose bits
</TD></TR></TABLE>
Note: There is only one register shared as "Selected Frequency Steady
Interrupt" (accessed as single byte parameter when Stat2/Bit2=0) and as "Alarm1
Minute" (accessed as 3rd byte of 3-byte parameter when Stat2/Bit2=1), changing
either value will also change the other value.<BR>
<BR>
<B>Interrupt</B><BR>
There's only one /INT signal, shared for both INT1 and INT2.<BR>
In the NDS, it is connected to the SI-input of the SIO unit (and so, also
shared with SIO interrupts). To enable the interrupt, RCNT should be set to
8144h (Bit14-15=General Purpose mode, Bit8=SI Interrupt Enable, Bit6,2=SI
Output/High).<BR>
The Output/High settings seems to be used as pullup (giving faster reactions on
low-to-high transitions) (nethertheless, in most cases it seems to be also
working okay as Input, ie. with RCNT=8100h).<BR>
The RCNT interrupt is generated on high-to-low transitions on the SI line (but
only if the IRQ is enabled in RCNT.8, and only if RCNT is set to general
purpose mode) (note: changing RCNT.8 from off-to-on does NOT generate IRQs,
even when SI is LOW).<BR>
<BR>
<B>Pin-Outs</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1 /INT      8 VDD
  2 XOUT      7 SIO
  3 XIN       6 /SCK
  4 GND       5 CS
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsserialperipheralinterfacebusspi"></A>&nbsp;
  DS Serial Peripheral Interface Bus (SPI)
</FONT></TD></TR></TABLE><BR>
<B>Serial Peripheral Interface Bus</B><BR>
SPI Bus is a 4-wire (Data In, Data Out, Clock, and Chipselect) serial bus.<BR>
The NDS supports the following SPI devices (each with its own chipselect).<BR>
<A HREF="#dsfirmwareserialflashmemory">DS Firmware Serial Flash Memory</A><BR>
<A HREF="#dstouchscreencontrollertsc">DS Touch Screen Controller (TSC)</A><BR>
<A HREF="#dspowermanagement">DS Power Management</A><BR>
<BR>
<B>40001C0h - NDS7 - SPICNT - SPI Bus Control/Status Register</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-1   Baudrate (0=4MHz/Firmware, 1=2MHz/Touchscr, 2=1MHz/Powerman., 3=512KHz)
  2-6   Not used            (Zero)
  7     Busy Flag           (0=Ready, 1=Busy) (presumably Read-only)
  8-9   Device Select       (0=Powerman., 1=Firmware, 2=Touchscr, 3=Reserved)
  10    Transfer Size       (0=8bit/Normal, 1=16bit/Bugged)
  11    Chipselect Hold     (0=Deselect after transfer, 1=Keep selected)
  12-13 Not used            (Zero)
  14    Interrupt Request   (0=Disable, 1=Enable)
  15    SPI Bus Enable      (0=Disable, 1=Enable)
</TD></TR></TABLE>
The "Hold" flag should be cleared BEFORE transferring the LAST data unit, the
chipselect will be then automatically cleared after the transfer, the program
should issue a WaitByLoop(3) manually AFTER the LAST transfer.<BR>
<BR>
<B>40001C2h - NDS7 - SPIDATA - SPI Bus Data/Strobe Register (R/W)</B><BR>
The SPI transfer is started on writing to this register, so one must
&lt;write&gt; a dummy value (should be zero) even when intending to
&lt;read&gt; from SPI bus.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-7   Data
  8-15  Not used (always zero, even in bugged-16bit mode)
</TD></TR></TABLE>
During transfer, the Busy flag in SPICNT is set, and the written SPIDATA value
is transferred to the device (via output line), simultaneously data is received
(via input line). Upon transfer completion, the Busy flag goes off (with
optional IRQ), and the received value can be then read from SPIDATA, if
desired.<BR>
<BR>
<B>Notes/Glitches</B><BR>
SPICNT Bits 12,13 appear to be unused (always zero), although the BIOS
(attempts to) set Bit13=1, and Bit12=Bit11 when accessing the firmware.<BR>
The SPIDATA register is restricted to 8bit, so that only each 2nd byte will
appear in SPIDATA when attempting to use the bugged-16bit mode.<BR>
<BR>
<B>Cartridge Backup Auxiliar SPI Bus</B><BR>
The NDS Cartridge Slot uses a separate SPI bus (with other I/O Ports), see<BR>
<A HREF="#dscartridgebackup">DS Cartridge Backup</A><BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dstouchscreencontrollertsc"></A>&nbsp;
  DS Touch Screen Controller (TSC)
</FONT></TD></TR></TABLE><BR>
<B>Texas Instruments TSC2046 (NDS)</B><BR>
<B>Asahi Kasei Microsystems AK4148AVT (NDS-Lite)</B><BR>
The Touch Screen Controller (for lower LCD screen) is accessed via SPI bus,<BR>
<A HREF="#dsserialperipheralinterfacebusspi">DS Serial Peripheral Interface Bus (SPI)</A><BR>
<BR>
<B>Control Byte (transferred MSB first)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-1  Power Down Mode Select
  2    Reference Select (0=Differential, 1=Single-Ended)
  3    Conversion Mode  (0=12bit, max CLK=2MHz, 1=8bit, max CLK=3MHz)
  4-6  Channel Select   (0-7, see below)
  7    Start Bit (Must be set to access Control Byte)
</TD></TR></TABLE>
<BR>
<B>Channel</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0 Temperature 0 (requires calibration, step 2.1mV per 1'C accuracy)
  1 Touchscreen Y-Position  (somewhat 0B0h..F20h, or FFFh=released)
  2 Battery Voltage         (not used, connected to GND in NDS, always 000h)
  3 Touchscreen Z1-Position (diagonal position for pressure measurement)
  4 Touchscreen Z2-Position (diagonal position for pressure measurement)
  5 Touchscreen X-Position  (somewhat 100h..ED0h, or 000h=released)
  6 AUX Input               (connected to Microphone in the NDS)
  7 Temperature 1 (difference to Temp 0, without calibration, 2'C accuracy)
</TD></TR></TABLE>
All channels can be accessed in Single-Ended mode.<BR>
In differential mode, only channel 1,3,4,5 (X,Z1,Z2,Y) can be accessed.<BR>
On AK4148AVT, channel 6 (AUX) is split into two separate channels, IN1 and IN2,
separated by Bit2 (Reference Select). IN1 is selected when Bit2=1, IN2 is
selected when Bit2=0 (despite of the Bit2 settings, both IN1 and IN2 are using
single ended more). On the NDS-Lite, IN1 connects to the mircrophone (as on
original NDS), and the new IN2 input is simply wired to VDD3.3 (which is equal
the the external VREF voltage, so IN2 is always FFFh).<BR>
<BR>
<B>Power Down Mode</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Mode /PENIRQ   VREF  ADC   Recommended use
  0    Enabled   Auto  Auto  Differential Mode (Touchscreen, Penirq)
  1    Disabled  Off   On    Single-Ended Mode (Temperature, Microphone)
  2    Enabled   On    Off   Don't use
  3    Disabled  On    On    Don't use
</TD></TR></TABLE>
Allows to enable/disable the /PENIRQ output, the internal reference voltage
(VREF), and the Analogue-Digital Converter.<BR>
For AK4148AVT, Power Down modes are slightly different (among others, /PENIRQ
is enabled in Mode 0..2).<BR>
<BR>
<B>Reference Voltage (VREF)</B><BR>
VREF is used as reference voltage in single ended mode, at 12bit resolution one
ADC step equals to VREF/4096. The TSC generates an internal VREF of 2.5V
(+/-0.05V), however, the NDS uses as external VREF of 3.33V (sinks to 3.31V at
low battery charge), the external VREF is always enabled, no matter if internal
VREF is on or off. Power Down Mode 1 disables the internal VREF, which may
reduce power consumption in single ended mode. After conversion, Power Down
Mode 0 should be restored to re-enable the Penirq signal.<BR>
<BR>
<B>Sending the first Command after Chip-Select</B><BR>
Switch chipselect low, then output the command byte (MSB first).<BR>
<BR>
<B>Reply Data</B><BR>
The following reply data is received (via Input line) after the Command byte
has been transferred: One dummy bit (zero), followed by the 8bit or 12bit
conversion result (MSB first), followed by endless padding (zero).<BR>
Note: The returned ADC value may become unreliable if there are longer delays
between sending the command, and receiving the reply byte(s).<BR>
<BR>
<B>Sending further Commands during/after receiving Reply Data</B><BR>
In general, the Output line should be LOW during the reply period, however,
once when Data bit6 has been received (or anytime later), a new Command can be
invoked (started by sending the HIGH-startbit, ie. Command bit7),
simultanously, the remaining reply-data bits (bit5..0) can be received.<BR>
In other words, the new command can be output after receiving 3 bits in 8bit
mode (the dummy bit, and data bits 7..6), or after receiving 7 bits in 12bit
mode (the dummy bit, and data bits 11..6).<BR>
In practice, the NDS SPI register always transfers 8 bits at once, so that one
would usually receive 8 bits (rather than above 3 or 7 bits), before outputting
a new command.<BR>
<BR>
<B>Touchscreen Position</B><BR>
Read the X and Y positions in 12bit differential mode, then convert the
touchscreen values (adc) to screen/pixel positions (scr), as such:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  scr.x = (adc.x-adc.x1) * (scr.x2-scr.x1) / (adc.x2-adc.x1) + (scr.x1-1)
  scr.y = (adc.y-adc.y1) * (scr.y2-scr.y1) / (adc.y2-adc.y1) + (scr.y1-1)
</TD></TR></TABLE>
The X1,Y1 and X2,Y2 calibration points are found in Firmware User Settings,<BR>
<A HREF="#dsfirmwareusersettings">DS Firmware User Settings</A><BR>
scr.x1,y1,x2,y2 are originated at 1,1 (converted to 0,0 by above formula).<BR>
<BR>
<B>Touchscreen Pressure (not supported on DSi)</B><BR>
To calculate the pressure resistance, in respect to X/Y/Z positions and X/Y
plate resistances, either of below formulas can be used,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Rtouch = (Rx_plate*Xpos*(Z2pos/Z1pos-1))/4096
  Rtouch = (Rx_plate*Xpos*(4096/Z1pos-1)-Ry_plate*(1-Ypos))/4096
</TD></TR></TABLE>
The second formula requires less CPU load (as it doesn't require to measure
Z2), the downside is that one must know both X and Y plate resistance (or at
least their ratio). The first formula doesn't require that ratio, and so
Rx_plate can be set to any value, setting it to 4096 results in<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  touchval = Xpos*(Z2pos/Z1pos-1)
</TD></TR></TABLE>
Of course, in that case, touchval is just a number, not a resistance in Ohms.<BR>
<BR>
<B>Touchscreen Notes</B><BR>
It may be impossible to press locations close to the screen borders.<BR>
When pressing two or more locations the TSC values will be somewhere in the
middle of these locations.<BR>
The TSC values may be garbage if the screen becomes newly pressed or released,
to avoid invalid inputs: read TSC values at least two times, and ignore BOTH
positions if ONE position was invalid.<BR>
<BR>
<B>Microphone / AUX Channel</B><BR>
Observe that the microphone amplifier is switched off after power up, see:<BR>
<A HREF="#dspowermanagement">DS Power Management</A><BR>
<BR>
<B>Temperature Calculation (not supported on DSi)</B><BR>
TP0 decreases by circa 2.1mV per degree Kelvin. The voltage difference between
TP1 minus TP0 increases by circa 0.39mV (1/2573 V) per degree Kelvin. At
VREF=3.33V, one 12bit ADC step equals to circa 0.8mV (VREF/4096).<BR>
Temperature can be calculated at best resolution when using the current TP0
value, and two calibration values (an ADC value, and the corresponding
temperature in degrees kelvin):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  K = (CAL.TP0-ADC.TP0) * 0.4 + CAL.KELVIN
</TD></TR></TABLE>
Alternately, temperature can be calculated at rather bad resolution, but
without calibration, by using the difference between TP1 and TP0:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  K = (ADC.TP1-ADC.TP0) * 8568 / 4096
</TD></TR></TABLE>
To convert Kelvin to other formats,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Celsius:     C = (K-273.15)
  Fahrenheit:  F = (K-273.15)*9/5+32
  Reaumur:     R = (K-273.15)*4/5
  Rankine:     X = (K)*9/5
</TD></TR></TABLE>
The Temperature Range for the TSC 2046 chip is -40'C..+85'C (for AK4181AVT only
-20'C..+70'C). According to Nintendo, the DS should not be exposed to "extreme"
heat or cold, the optimal battery charging temperature is specified as
+10'C..+40'C.<BR>
The original firmware does not support temperature calibration, calibration is
supported by nocash firmware (if present). See Extended Settings,<BR>
<A HREF="#dsfirmwareextendedsettings">DS Firmware Extended Settings</A><BR>
<BR>
<B>Pin-Outs</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
         ________
  VCC  1|o       |16 DCLK
  X+   2|        |15 /CS
  Y+   3|  TSC   |14 DIN
  X-   4|  2046  |13 BUSY
  Y-   5|        |12 DOUT
  GND  6|        |11 /PENIRQ
  VBAT 7|        |10 IOVDD
  AUX  8|________|9  VREF
</TD></TR></TABLE>
<BR>
For AK4181AVT, same pins as above, except that IOVDD replaced by the new IN2
input, the pin is wired to VDD3.3 (so IN2 is always equal to VREF, which is
wired to VDD3.3, too) (and AUX is renamed to IN1, and is kept used for MIC
input).<BR>
<BR>
<B>DSi Touchscreen Controller (in NDS mode)</B><BR>
DSi in NDS mode does support only X, Y, and MIC (all other channels do return
FFFh in 12bit mode, and FFh in 8bit mode, ie. no pressure, no temperature, and
no GNDed battery sensor). On DSi, MIC does return data in both single-ended and
differential mode (unlike as on real NDS).<BR>
<BR>
<B>DSi Touchscreen Controller (in DSi mode)</B><BR>
The DSi touchscreen controller supports a NDS backwards compatibility mode.
But, in DSi mode, it is working entirely different (it's still accessed via SPI
bus, but with some new MODE/INDEX values).<BR>
<A HREF="#dsitouchscreensoundcontroller">DSi Touchscreen/Sound Controller</A><BR>
The NDS Touchscreen controller did additionally allow to read Temperature and
Touchscreen Pressure - unknown if the DSi is also supporting such stuff (via
whatever DSi-specific registers).<BR>
The touchscreen hardware can be switched to NDS compatibility mode (for older
games), but unknown how to do that.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dspowermanagement"></A>&nbsp;
  DS Power Management
</FONT></TD></TR></TABLE><BR>
The DS contains several Power Managment functions, some accessed via I/O ports,
some accessed via SPI bus (described later on below).<BR>
<BR>
<B>4000304h - NDS9 - POWCNT1 - Graphics Power Control Register (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Enable Flag for both LCDs (0=Disable) (Prohibited, see notes)
  1     2D Graphics Engine A      (0=Disable) (Ports 008h-05Fh, Pal 5000000h)
  2     3D Rendering Engine       (0=Disable) (Ports 320h-3FFh)
  3     3D Geometry Engine        (0=Disable) (Ports 400h-6FFh)
  4-8   Not used
  9     2D Graphics Engine B      (0=Disable) (Ports 1008h-105Fh, Pal 5000400h)
  10-14 Not used
  15    Display Swap (0=Send Display A to Lower Screen, 1=To Upper Screen)
  16-31 Not used
</TD></TR></TABLE>
Use SwapBuffers command once after enabling Rendering/Geometry Engine.<BR>
Improper use of Bit0 may damage the hardware?<BR>
When disabled, corresponding Ports become Read-only, corresponding (palette-)
memory becomes read-only-zero-filled.<BR>
<BR>
<B>4000304h - NDS7 - POWCNT2 - Sound/Wifi Power Control Register (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0     Sound Speakers (0=Disable, 1=Enable) (Initial setting = 1)
  1     Wifi           (0=Disable, 1=Enable) (Initial setting = 0)
  2-31  Not used
</TD></TR></TABLE>
Note: Bit0 disables the internal Speaker only, headphones are not disabled.<BR>
Bit1 disables Port 4000206h, and Ports 4800000h-480FFFFh.<BR>
<BR>
<B>4000206h - NDS7 - WIFIWAITCNT - Wifi Waitstate Control</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-2   Wifi WS0 Control (0-7) (Ports 4800000h-4807FFFh)
  3-5   Wifi WS1 Control (0-7) (Ports 4808000h-480FFFFh)
  4-15  Not used (zero)
</TD></TR></TABLE>
This register is initialized by firmware on power-up, don't change.<BR>
Note: WIFIWAITCNT can be accessed only when enabled in POWCNT2.<BR>
<BR>
<B>4000301h - NDS7 - HALTCNT - Low Power Mode Control (R/W)</B><BR>
In Halt mode, the CPU is paused as long as (IE AND IF)=0.<BR>
In Sleep mode, most of the hardware including sound and video are paused, this
very-low-power mode could be used much like a screensaver.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-5   Not used (zero)
  6-7   Power Down Mode  (0=No function, 1=Enter GBA Mode, 2=Halt, 3=Sleep)
</TD></TR></TABLE>
The HALTCNT register should not be accessed directly. Instead, the BIOS Halt,
Sleep, CustomHalt, IntrWait, or VBlankIntrWait SWI functions should be used.<BR>
<A HREF="#bioshaltfunctions">BIOS Halt Functions</A><BR>
<A HREF="#armcp15systemcontrolcoprocessor">ARM CP15 System Control Coprocessor</A><BR>
The NDS9 does not have a HALTCNT register, instead, the Halt function uses the
co-processor opcode "mcr p15,0,r0,c7,c0,4" - this opcode locks up if interrupts
are disabled via IME=0 (unlike NDS7 HALTCNT method which doesn't check IME).<BR>
<BR>
<B>4000300h - NDS7/NDS9 - POSTFLG - BYTE - Post Boot Flag (R/W)</B><BR>
The NDS7 and NDS9 post boot flags are usually set upon BIOS/Firmware boot
completion, once when set the reset vector is redirected to the debug handler
of Nintendo's hardware debugger. That allows the NDS7 debugger to capture
accidental jumps to address 0, that appears to be a common problem with
HLL-programmers, asm-coders know that (and why) they should not jump to 0.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0     Post Boot Flag (0=Boot in progress, 1=Boot completed)
  1     NDS7: Not used (always zero), NDS9: Bit1 is read-writeable
  2-7   Not used (always zero)
</TD></TR></TABLE>
There are some write-restrictions: The NDS7 register can be written to only
from code executed in BIOS. Bit0 of both NDS7 and NDS9 registers cannot be
cleared (except by Reset) once when it is set.<BR>
<BR>
<B>Power Management Device - Mitsumi 3152A (NDS) / Mitsumi 3205B (NDS-LITE)</B><BR>
The Power Management Device is accessed via SPI bus,<BR>
<A HREF="#dsserialperipheralinterfacebusspi">DS Serial Peripheral Interface Bus (SPI)</A><BR>
To access the device, write the Index Register, then read or write the data
register, and release the chipselect line when finished.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
<B>  Index Register</B>
  Bit0-6 Register Select          (0..3) (0..4 for DS-Lite) (0..7Fh for DSi)
  Bit7   Register Direction       (0=Write, 1=Read)
<B>  Register 0 - Powermanagement Control (R/W)</B>
  Bit0   Sound Amplifier Enable   (0=Disable, 1=Enable)
         (Old-DS:  Disabled: Sound is very silent, but still audible)
         (DS-Lite: Disabled: Sound is NOT audible)
         (DSi in NDS Mode: R/W, but effect is unknown yet)
         (DSi in DSi Mode: Not used, Bit0 is always 1)
  Bit1   Sound Amplifier Mute     (0=Normal, 1=Mute) (Old-DS Only, not DS-Lite)
         (Old-DS:  Muted: Sound is NOT audible, that works only if Bit0=1)
         (DS-Lite: Not used, Bit1 is always zero)
         (DSi in NDS Mode: R/W, but effect is unknown yet)
         (DSi in DSi Mode: R/W, but effect is unknown yet)
  Bit2   Lower Backlight          (0=Disable, 1=Enable)
  Bit3   Upper Backlight          (0=Disable, 1=Enable)
  Bit4   Power LED Blink Enable   (0=Always ON, 1=Blinking OFF/ON)
  Bit5   Power LED Blink Speed    (0=Slow, 1=Fast) (only if Blink enabled)
         (DSi: Power LED Blinking isn't supported, neither in NDS nor DSi mode)
  Bit6   DS System Power          (0=Normal, 1=Shut Down)
  Bit7   Not used                 (always 0)
<B>  Register 1 - Battery Status (R)</B>
  Bit0   Battery Power LED Status (0=Power Good/Green, 1=Power Low/Red)
         (DSi: Usually 0, not tested if it changes upon Power=Low)
  Bit1-7 Not used
<B>  Register 2 - Microphone Amplifier Control (R/W)</B>
  Bit0   Amplifier                (0=Disable, 1=Enable)
  Bit1-7 Not used                 (always 0)
  (DSi in NDS Mode: looks same as NDS, ie. only bit0 is R/W)
  (DSi in DSi Mode: Not used, always FFh)
<B>  Register 3 - Microphone Amplifier Gain Control (R/W)</B>
  Bit0-1 Gain                     (0..3=Gain 20, 40, 80, 160)
  Bit2-7 Not used                 (always 0)
  (DSi in NDS Mode: looks same as NDS, ie. only bit0-1 are R/W)
  (DSi in DSi Mode: Not used, always FFh)
<B>  Register 4 - DS-Lite and DSi Only - Backlight Levels/Power Source (R/W)</B>
  Bit0-1 Backlight Brightness (0..3=Low,Med,High,Max)   (R/W)
         (when bit2+3 are both set, then reading bit0-1 always returns 3)
  Bit2   Force Max Brightness when Bit3=1 (0=No, 1=Yes) (R/W)
  Bit3   External Power Present           (0=No, 1=Yes) (Read-Only)
  Bit4-7 Unknown (Always 4) (Read-Only)
  (DSi in NDS Mode: looks same as in DSi mode)
  (DSi in DSi Mode: Bit0-1 are R/W, but ignored, bit2-3 are always 0)
<B>  Register 10h - DSi Only - Backlight Mirrors &amp; Reset (R/W)</B>
  Bit0   Reset (0=No, 1=Reboot) (same/similar as BPTWL reset feature?)
  Bit1   Unknown (R/W) (note: whatever it is, it isn't warmboot flag)
  Bit2-3 Mirror of Register 0, bit2-3 (backlight enable bits) (R/W)
  Bit4-7 Not used (always 0)
  (DSi in NDS Mode: seems to behave same as in DSi mode, except that, reset
  defaults to warmboot, since BPTWL always has warmboot enabled in NDS mode)
</TD></TR></TABLE>
On Old-DS, registers 4..7Fh are mirrors of 0..3. On DS-Lite, registers 5,6,7
are mirrors of 4, register 8..7Fh are mirrors of 0-7.<BR>
On DSi (in DS mode), index 0,1,2,3,4,10h are used (reads as
0Fh,00h,00h,01h,41h,0Fh - regardless of backlight level, and power source),
index 5..0Fh and 11h..7Fh return 00h (ie. unlike DS and DS-Lite, there are no
mirrors; aside from the 3 bits in register 10h).<BR>
<BR>
<B>Backlight Dimming / Backlight caused Shut-Down(s)</B><BR>
The above bits are essentially used to switch Backlights on or off. However,
there a number of strange effects. Backlight dimming is possible by pulse width
modulation, ie. by using a timer interrupt to issue pulse widths of N% ON, and
100-N% OFF. Too long pulses are certainly resulting in flickering. Too short
pulses are ignored, the backlights will remain OFF, even if the ON and OFF
pulses are having the same length. Much too short pulses cause the power supply
to shut-down; after changing the backlight state, further changes must not
occur within the next (circa) 2500 clock cycles. The mainboard can be operated
without screens &amp; backlights connected, however, if so, the power supply
will shut-down as soon as backlights are enabled.<BR>
Pulse width modulated dimming does also work on the DS-Lite, allowing to use
smoother fade in/out effects as when using the five "hardware" levels
(Off,Low,Med,High,Max).<BR>
<BR>
<B>Memory Power Down Functions</B><BR>
<A HREF="#dsmainmemorycontrol">DS Main Memory Control</A><BR>
<A HREF="#dsfirmwareserialflashmemory">DS Firmware Serial Flash Memory</A><BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsmainmemorycontrol"></A>&nbsp;
  DS Main Memory Control
</FONT></TD></TR></TABLE><BR>
<B>Main Memory</B><BR>
The DS Main Memory is 2Mx16bit (4MByte), 1.8V Pseudo SRAM (PSRAM); all Dynamic
RAM refresh is handled internally, the chip doesn't require any external
refresh signals, and alltogether behaves like Static RAM. Non-sequential access
time is 70ns, sequential (burst) access time is 12ns.<BR>
<BR>
<B>Main Memory Control</B><BR>
The memory chips contain built-in Control functions, which can be accessed via
Port 27FFFFEh and/or by EXMEMCNT Bit 14. Nintendo is using at least two
different types of memory chips in DS consoles, Fujitsu 82DBS02163C-70L, and ST
M69AB048BL70ZA8, both appear to have different control mechanisms, other chips
(with 8MB size) are used in the semi-professional DS hardware debuggers, and
further chips may be used in future, so using the memory control functions may
lead into compatibitly problems.<BR>
<BR>
<B>Power Consumption / Power Control</B><BR>
Power Consumption during operation (read/write access) is somewhat 30mA, in
standby mode (no read/write access) consumption is reduced to 100uA.<BR>
Furthermore, a number of power-down modes are supported: In "Deep" Power Down
mode the refresh is fully disabled, consumption is 10uA (and all data will be
lost), in "Partial" Power Down modes only fragment of memory is refreshed, for
smallest fragments, consumption goes to down to circa 50uA. The chip cannot be
accessed while it is in Deep or Partial Power Down mode.<BR>
<BR>
<B>Fujitsu 82DBS02163C-70L</B><BR>
The Configuration Register (CR) can be written to by the following sequence:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  LDRH R0,[27FFFFEh]      ;read one value
  STRH R0,[27FFFFEh]      ;write should be same value as above
  STRH R0,[27FFFFEh]      ;write should be same value as above
  STRH R0,[27FFFFEh]      ;write any value
  STRH R0,[27FFFFEh]      ;write any value
  LDRH R0,[2400000h+CR*2] ;read, address-bits are defining new CR value
</TD></TR></TABLE>
Do not access any other Main Memory addresses during above sequence (ie.
disable interrupts, and do not execute the sequence by code located in Main
Memory). The CR value is write-only. The CR bits are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit    Expl.
  0-6    Reserved         (Must be 7Fh)
  7      Write Control
           0=WE Single Clock Pulse Control without Write Suspend Function
           1=WE Level Control with Write Suspend Function)
          Burst Read/Single Write is not supported at WE Single Clock Mode.
  8      Reserved         (Must be 1)
  9      Valid Clock Edge (0=Falling Edge, 1=Rising Edge)
  10     Single Write     (0=Burst Read/Burst Write, 1=Burst Read/Single Write)
  11     Burst Sequence   (0=Reserved, 1=Sequential)
  12-14  Read Latency     (1=3 clocks, 2=4 clocks, 3=5 clocks, other=Reserved)
  15     Mode
           0=Synchronous:  Burst Read, Burst Write
           1=Asynchronous: Page Read, Normal Write
          In Mode 1 (Async), only the Partial Size bits are used,
          all other bits, CR bits 0..18, must be "1".
  16-18  Burst Length     (2=8 Words, 3=16Words, 7=Continous, other=Reserved)
  19-20  Partial Size     (0=1MB, 1=512KB, 2=Reserved, 3=Deep/0 bytes)
</TD></TR></TABLE>
The Power Down mode is entered by setting CE2=LOW, this can be probably done by
setting EXMEMCNT Bit14 to zero.<BR>
<BR>
<B>ST Microelectronics M69AB048BL70ZA8</B><BR>
The chip name decodes as PSRAM (M96), Asynchronous (A), 1.8V Burst (B), 2Mx16
(048), Two Chip Enables (B), Low Leakage (L), 70ns (70), Package (ZA),
-30..+85'C (8).<BR>
There are three data sheets for different PSRAM chips available at www.st.com
(unfortunately none for M69AB048BL70ZA8), each using different memory control
mechanisms.<BR>
<BR>
<B>NDS9 BIOS</B><BR>
The NDS9 BIOS contains the following Main Memory initialization code, that
method doesn't match up with any ST (nor Fujitsu) data sheets that I've seen.
At its best, it looks like a strange (and presumably non-functional) mix-up of
different ST control methods.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  STRH 2000h,[4000204h]
  LDRH R0,[27FFFFEh]
  STRH R0,[27FFFFEh]
  STRH R0,[27FFFFEh]
  STRH FFDFh,[27FFFFEh]
  STRH E732h,[27FFFFEh]
  LDRH R0,[27E57FEh]
  STRH 6000h,[4000204h]
</TD></TR></TABLE>
In the above BIOS code, EXMEMCNT.14 appears to be used to unlock the control
register. However, the NDS Firmware appears to use EXMEMCNT.14 to switch Main
Memory into Power Down mode before entering GBA mode.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsbackwardscompatiblegbamode"></A>&nbsp;
  DS Backwards-compatible GBA-Mode
</FONT></TD></TR></TABLE><BR>
When booting a 32pin GBA cartridge, the NDS is automatically switched into GBA
mode, in that mode all NDS related features are disabled, and the console
behaves (almost) like a GBA.<BR>
<BR>
<B>GBA Features that are NOT supported on NDS in GBA Mode.</B><BR>
Unlike real GBA, the NDS does not support 8bit DMG/CGB cartridges.<BR>
The undocumented Internal Memory Control register (Port 800h) isn't supported,
so the NDS doesn't allow to use 'overclocked' RAM.<BR>
The NDS doesn't have a link-port, so GBA games can be played only in single
player mode, link-port accessories cannot be used, and the NDS cannot run GBA
code via multiboot.<BR>
<BR>
<B>GBA Features that are slightly different on NDS in GBA Mode.</B><BR>
The CPU, Timers, and Sound Frequencies are probably clocked at 16.76MHz;
33.51Mhz/2; a bit slower than the original GBA's 16.78MHz clock?<BR>
In the BIOS, a single byte in a formerly 00h-filled area has been changed from
00h to 01h, resulting in SWI 0Dh returning a different BIOS checksum.<BR>
The GBA picture can be shown on upper or lower screen (selectable in
boot-menu), the backlight for the selected screen is always on, resulting in
different colors &amp; much better visibility than original GBA. Unlike GBA-SP,
the NDS doesn't have a backlight-button.<BR>
<BR>
<B>Screen Border in GBA mode</B><BR>
The GBA screen is centered in the middle of the NDS screen. The surrounding
pixels are defined by 32K-color bitmap data in VRAM Block A and B. Each frame,
the GBA picture is captured into one block, and is displayed in the next frame
(while capturing new data to the other block).<BR>
To get a flicker-free border, both blocks should be initialized to contain the
same image before entering GBA mode (usually both are zero-filled, resulting in
a plain black border).<BR>
Note: When using two different borders, the flickering will be irregular - so
there appears to be a frame inserted or skipped once every some seconds in GBA
mode?!<BR>
<BR>
<B>Switching from NDS Mode to GBA Mode</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  --- NDS9: ---
  ZEROFILL VRAM A,B     ;init black screen border (or other color/image)
  POWCNT=8003h          ;enable 2D engine A on upper screen (0003h=lower)
  EXMEMCNT=...          ;set Async Main Memory mode (clear bit14)
  IME=0                 ;disable interrupts
  SWI 06h               ;halt with interrupts disabled (lockdown)
  --- NDS7: ---
  POWERMAN.REG0=09h     ;enable sound amplifier &amp; upper backlight (05h=lower)
  IME=0                 ;disable interrupts
  wait for VCOUNT=200   ;wait until VBlank
  SWI 1Fh with R2=40h   ;enter GBA mode, by CustomHalt(40h)
</TD></TR></TABLE>
After that, the GBA BIOS will be booted, the GBA Intro will be displayed, and
the GBA cartridge (if any) will be started.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsdebugregistersemulatordevkits"></A>&nbsp;
  DS Debug Registers (Emulator/Devkits)
</FONT></TD></TR></TABLE><BR>
<B>No$gba Emulator Pseudo I/O Ports (no$gba) (NDS9)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4FFFA00h..A0Fh R Emulation ID (16 bytes, eg. "no$gba v2.7", padded with 20h)
  4FFFA10h       W String Out (raw)
  4FFFA14h       W String Out (with %param's)
  4FFFA18h       W String Out (with %param's, plus linefeed)
  4FFFA1Ch       W Char Out (nocash)
  4FFFA20h..A27h R Clock Cycles (64bit)
  4FFFA28h..A3Fh - N/A
</TD></TR></TABLE>
<BR>
<B>Ensata Emulator Pseudo I/O Ports (NDS9)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4000640h (32bit) ;aka CLIPMTX_RESULT (mis-used to invoke detection)
  4000006h (16bit) ;aka VCOUNT (mis-used to get detection result)
  4FFF010h (32bit) ;use to initialize/unlock/reset something
  4FFF000h (8bit)  ;debug message character output (used when Ensata detected)
</TD></TR></TABLE>
The Ensata detection works by mis-using CLIPMTX_RESULT and VCOUNT registers:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  [4000640h]=2468ACE0h      ;CLIPMTX_RESULT (on real hardware it's read-only)
  if ([4000006h] AND 1FFh)=10Eh ;VCOUNT (on real hardware it's 000h..106h)
    [4FFF010h]=13579BDFh        ;\initialize/reset something
    [4FFF010h]=FDB97531h        ;/
    Ensata=true
  else
    Ensata=false
  endif
</TD></TR></TABLE>
Once when a commercial game has detected Ensata, it stops communicating with
the ARM7, and instead it does seem to want to communicate with the Ensata
executable (which has little to do with real NDS hardware). Ie. aside from
"unlocking" port 4FFF000h, it does also "lock" access to the ARM7 hardware
(like sound, touchscreen, RTC, etc).<BR>
<BR>
<B>ISD (Intelligent Systems Debugger or so) I/O Ports</B><BR>
The ISD ports seem to be real (non-emulated) debugging ports, mapped to the GBA
Slot region at 8000000h-9FFFFFFh, and used to output text messages, and
possible also other debugging stuff.<BR>
There are appear to be two variants: nitroemu and cgbemu (the latter appears to
be dating back to old 8bit CGB hardware; which was apparently still used for
the NDS two hardware generations later).<BR>
<BR>
<B>NDS Devkit</B><BR>
In Nintendo's devkit, debug messages are handled in file "os_printf.c", this
file detects the available hardware/software based debug I/O ports, and
redirects the [OS_PutString] vector to the corresponding string_out function
(eg. to OS_PutStringAris for writing a 00h-terminated string to port 4FFF000h).
With some minimal efforts, this could be redirected to the corresponding no$gba
debug I/O ports.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dscartridgesencryptionfirmware"></A>&nbsp;
  DS Cartridges, Encryption, Firmware
</FONT></TD></TR></TABLE><BR>
<B>Cartridges</B><BR>
<A HREF="#dscartridgeheader">DS Cartridge Header</A><BR>
<A HREF="#dscartridgesecurearea">DS Cartridge Secure Area</A><BR>
<A HREF="#dscartridgeicontitle">DS Cartridge Icon/Title</A><BR>
<A HREF="#dscartridgeprotocol">DS Cartridge Protocol</A><BR>
<A HREF="#dscartridgebackup">DS Cartridge Backup</A><BR>
<A HREF="#dscartridgeioports">DS Cartridge I/O Ports</A><BR>
<A HREF="#dscartridgenitroromandnitroarcfilesystems">DS Cartridge NitroROM and NitroARC File Systems</A><BR>
<A HREF="#dscartridgepassmepassthrough">DS Cartridge PassMe/PassThrough</A><BR>
<A HREF="#dscartridgegbaslot">DS Cartridge GBA Slot</A><BR>
<BR>
<B>Add-Ons</B><BR>
<A HREF="#dscartrumblepak">DS Cart Rumble Pak</A><BR>
<A HREF="#dscartsliderwithrumble">DS Cart Slider with Rumble</A><BR>
<A HREF="#dscartexpansionram">DS Cart Expansion RAM</A><BR>
<A HREF="#dscartunknownextras">DS Cart Unknown Extras</A><BR>
<BR>
<B>Special Cartridges</B><BR>
<A HREF="#dscartcheatactionreplayds">DS Cart Cheat Action Replay DS</A><BR>
<A HREF="#dscartcheatcodebreakerds">DS Cart Cheat Codebreaker DS</A><BR>
<BR>
<B>Encryption</B><BR>
<A HREF="#dsencryptionbygamecodeidcodekey1">DS Encryption by Gamecode/Idcode (KEY1)</A><BR>
<A HREF="#dsencryptionbyrandomseedkey2">DS Encryption by Random Seed (KEY2)</A><BR>
<BR>
<B>Firmware</B><BR>
<A HREF="#dsfirmwareserialflashmemory">DS Firmware Serial Flash Memory</A><BR>
<A HREF="#dsfirmwareheader">DS Firmware Header</A><BR>
<A HREF="#dsfirmwarewificalibrationdata">DS Firmware Wifi Calibration Data</A><BR>
<A HREF="#dsfirmwarewifiinternetaccesspoints">DS Firmware Wifi Internet Access Points</A><BR>
<A HREF="#dsfirmwareusersettings">DS Firmware User Settings</A><BR>
<A HREF="#dsfirmwareextendedsettings">DS Firmware Extended Settings</A><BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dscartridgeheader"></A>&nbsp;
  DS Cartridge Header
</FONT></TD></TR></TABLE><BR>
<B>Header Overview (loaded from ROM Addr 0 to Main RAM 27FFE00h on Power-up)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Address Bytes Expl.
  000h    12    Game Title  (Uppercase ASCII, padded with 00h)
  00Ch    4     Gamecode    (Uppercase ASCII, NTR-&lt;code&gt;)        (0=homebrew)
  010h    2     Makercode   (Uppercase ASCII, eg. "01"=Nintendo) (0=homebrew)
  012h    1     Unitcode    (00h=NDS, 02h=NDS+DSi, 03h=DSi) (bit1=DSi)
  013h    1     Encryption Seed Select (00..07h, usually 00h)
  014h    1     Devicecapacity         (Chipsize = 128KB SHL nn) (eg. 7 = 16MB)
  015h    9     Reserved    (zero filled) (except, [1Ch..1Dh] used on DSi)
  01Eh    1     ROM Version (usually 00h)
  01Fh    1     Autostart (Bit2: Skip "Press Button" after Health and Safety)
                (Also skips bootmenu, even in Manual mode &amp; even Start pressed)
  020h    4     ARM9 rom_offset    (4000h and up, align 1000h)
  024h    4     ARM9 entry_address (2000000h..23BFE00h)
  028h    4     ARM9 ram_address   (2000000h..23BFE00h)
  02Ch    4     ARM9 size          (max 3BFE00h) (3839.5KB)
  030h    4     ARM7 rom_offset    (8000h and up)
  034h    4     ARM7 entry_address (2000000h..23BFE00h, or 37F8000h..3807E00h)
  038h    4     ARM7 ram_address   (2000000h..23BFE00h, or 37F8000h..3807E00h)
  03Ch    4     ARM7 size          (max 3BFE00h, or FE00h) (3839.5KB, 63.5KB)
  040h    4     File Name Table (FNT) offset
  044h    4     File Name Table (FNT) size
  048h    4     File Allocation Table (FAT) offset
  04Ch    4     File Allocation Table (FAT) size
  050h    4     File ARM9 overlay_offset
  054h    4     File ARM9 overlay_size
  058h    4     File ARM7 overlay_offset
  05Ch    4     File ARM7 overlay_size
  060h    4     Port 40001A4h setting for normal commands (usually 00586000h)
  064h    4     Port 40001A4h setting for KEY1 commands   (usually 001808F8h)
  068h    4     Icon/Title offset (0=None) (8000h and up)
  06Ch    2     Secure Area Checksum, CRC-16 of [[020h]..00007FFFh]
  06Eh    2     Secure Area Delay (in 131kHz units) (051Eh=10ms or 0D7Eh=26ms)
  070h    4     ARM9 Auto Load List RAM Address (?)
  074h    4     ARM7 Auto Load List RAM Address (?)
  078h    8     Secure Area Disable (by encrypted "NmMdOnly") (usually zero)
  080h    4     Total Used ROM size (remaining/unused bytes usually FFh-padded)
  084h    4     ROM Header Size (4000h)
  088h    38h   Reserved (zero filled) (except, [88h..93h] used on DSi)
  0C0h    9Ch   Nintendo Logo (compressed bitmap, same as in GBA Headers)
  15Ch    2     Nintendo Logo Checksum, CRC-16 of [0C0h-15Bh], fixed CF56h
  15Eh    2     Header Checksum, CRC-16 of [000h-15Dh]
  160h    4     Debug rom_offset   (0=none) (8000h and up)       ;only if debug
  164h    4     Debug size         (0=none) (max 3BFE00h)        ;version with
  168h    4     Debug ram_address  (0=none) (2400000h..27BFE00h) ;SIO and 8MB
  16Ch    4     Reserved (zero filled) (transferred, and stored, but not used)
  170h    90h   Reserved (zero filled) (transferred, but not stored in RAM)
</TD></TR></TABLE>
DSi Cartridges are using an extended cartridge header,<BR>
<A HREF="#dsicartridgeheader">DSi Cartridge Header</A><BR>
Newer NDS cartridges are reportedly containing RSA signatures - the format of
that signatures is still unknown (probably it's same or similar as in DSi
headers), those RSA signatures are required for running NDS carts on DSi
consoles (at least with newer DSi firmwares) (the DSi firmware contains a
whitelist with known checksums for all existing older NDS games, and requires
RSA signatures in newer NDS games - this is making it impossible to run
unlicensed/homebrew NDS programs on DSi, unless using trickery such like
savegame exploits).<BR>
<BR>
For more info about CRC-16, see description of GetCRC16 BIOS function,<BR>
<A HREF="#biosmiscfunctions">BIOS Misc Functions</A><BR>
For the Logo checksum, the BIOS verifies only [15Ch]=CF56h, it does NOT verify
the actual data at [0C0h-15Bh] (nor it's checksum), however, the data is
verified by the firmware.<BR>
<BR>
<B>Secure Area Delay</B><BR>
The Secure Area Delay at header[06Eh] is counted in 130.912kHz units (which can
be clocked via one of the hardware timers with prescaler=F/256 and
reload=(10000h-((X AND 3FFFh)+2)); for some weird reason, in case of Header
checksum it's ANDed with 1FFFh instead of 3FFFh). Commonly used values are
X=051Eh (10ms), and X=0D7Eh (26ms).<BR>
The delay is used for all Blowfish encrypted commands, the actual usage/purpose
differs depending on bit31 of the ROM Chip ID:<BR>
When ChipID.Bit31=0 (commands are sent ONCE): The delay is issued BEFORE
sending the command:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Delay,Cmd
</TD></TR></TABLE>
Older/newer games are using delays of 10ms/26ms (although all known existing
cartridges with Bit31=0 would actually work WITHOUT delays).<BR>
When ChipID.Bit31=1 (commands are repeated MULTIPLE times): The delay is issued
AFTER sending the command for the FIRST time:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Cmd,Delay,Cmd                               ;for 2x repeat
  Cmd,Delay,Cmd,Cmd,Cmd,CmdCmd,Cmd,Cmd,Cmd    ;for 9x repeat
</TD></TR></TABLE>
Known games are using delays of 26ms (although all known existing cartridges
(=Cooking Coach) with Bit31=1 would actually work with shorter delays of ca.
6.5ms).<BR>
<BR>
<B>NDS Gamecodes</B><BR>
This is the same code as the NTR-UTTD (NDS) or TWL-UTTD (DSi) code which is
printed on the package and sticker on (commercial) cartridges (excluding the
leading "NTR-" or "TWL-" part).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  U  Unique Code          (usually "A", "B", "C", or special meaning)
  TT Short Title          (eg. "PM" for Pac Man)
  D  Destination/Language (usually "J" or "E" or "P" or specific language)
</TD></TR></TABLE>
The first character (U) is usually "A" or "B", in detail:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  A NDS common games
  B NDS common games
  C NDS common games
  D DSi-exclusive games
  H DSiWare (system utilities and browser) (eg. HNGP=browser)
  I NDS and DSi-enhanced games with built-in Infrared port
  K DSiWare (dsiware games and flipnote) (eg. KGUV=flipnote)
  N NDS nintendo channel demo's japan (NTR-NTRJ-JPN)
  T NDS many games
  U NDS utilities, educational games, or uncommon extra hardware?
  V DSi-enhanced games
  Y NDS many games
</TD></TR></TABLE>
The second/third characters (TT) are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Usually an abbreviation of the game title (eg. "PM" for "Pac Man") (unless
  that gamecode was already used for another game, then TT is just random)
</TD></TR></TABLE>
The fourth character (D) indicates Destination/Language:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  A Asian    E English/USA  I Italian   M Swedish  Q Danish   U Australian
  B N/A      F French       J Japanese  N Nor      R Russian  V EUR+AUS
  C Chinese  G N/A          K Korean    O Int      S Spanish  W..Z Europe #3..5
  D German   H Dutch        L USA #2    P Europe   T USA+AUS
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dscartridgesecurearea"></A>&nbsp;
  DS Cartridge Secure Area
</FONT></TD></TR></TABLE><BR>
The Secure Area is located in ROM at 4000h..7FFFh, it can contain normal
program code and data, however, it can be used only for ARM9 boot code, it
cannot be used for ARM7 boot code, icon/title, filesystem, or other data.<BR>
<BR>
<B>Secure Area Size</B><BR>
The Secure Area exists if the ARM9 boot code ROM source address (src) is
located within 4000h..7FFFh, if so, it will be loaded (by BIOS via KEY1
encrypted commands) in 4K portions, starting at src, aligned by 1000h, up to
address 7FFFh. The secure area size if thus 8000h-src, regardless of the ARM9
boot code size entry in header.<BR>
Note: The BIOS silently skips any NDS9 bootcode at src&lt;4000h.<BR>
Cartridges with src&gt;=8000h do not have a secure area.<BR>
<BR>
<B>Secure Area ID</B><BR>
The first 8 bytes of the secure area are containing the Secure Area ID, the ID
is required (verified by BIOS boot code), the ID value changes during boot
process:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Value                Expl.
  "encryObj"           raw ID before encryption (raw ROM-image)
  (encrypted)          encrypted ID after encryption (encrypted ROM-image)
  "encryObj"           raw ID after decryption (verified by BIOS boot code)
  E7FFDEFFh,E7FFDEFFh  destroyed ID (overwritten by BIOS after verify)
</TD></TR></TABLE>
If the decrypted ID does match, then the BIOS overwrites the first 8 bytes by
E7FFDEFFh-values (ie. only the ID is destroyed). If the ID doesn't match, then
the first 800h bytes (2K) are overwritten by E7FFDEFFh-values.<BR>
<BR>
<B>Secure Area First 2K Encryption/Content</B><BR>
The first 2K of the Secure Area (if it exists) are KEY1 encrypted. In official
games, this 2K region contains data like so (in decrypted form):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h..007h  Secure Area ID (see above)
  008h..00Dh  Fixed (FFh,DEh,FFh,E7h,FFh,DEh)
  00Eh..00Fh  CRC16 across following 7E0h bytes, ie. [010h..7FFh]
  010h..7FDh  Unknown/random values, mixed with some THUMB SWI calls
  7FEh..7FFh  Fixed (00h,00h)
</TD></TR></TABLE>
Of which, only the ID in the first 8 bytes is verified. Neither BIOS nor
(current) firmare versions are verifying the data at 008h..7FFh, so the 7F8h
bytes may be also used for normal program code/data.<BR>
<BR>
<B>Avoiding Secure Area Encryption</B><BR>
WLAN files are reportedly same format as cartridges, but without Secure Area,
so games with Secure Area cannot be booted via WLAN. No$gba can encrypt and
decrypt Secure Areas only if the NDS BIOS-images are present. And, Nintendo's
devkit doesn't seem to support Secure Area encryption of unreleased games.<BR>
So, unencrypted cartridges are more flexible in use. Ways to avoid encryption
(which still work on real hardware) are:<BR>
1) Set NDS9 ROM offset to 4000h, and leave the first 800h bytes of the Secure
Area 00h-filled, which can be (and will be) safely destroyed during loading;
due to the missing "encryObj" ID; that method is used by Nintendo's devkit.<BR>
2) Set NDS9 ROM offset to 8000h or higher (cartridge has no Secure Area at
all).<BR>
3) Set NDS9 ROM offset, RAM address, and size to zero, set NDS7 ROM offset to
200h, and point both NDS9 and NDS7 entrypoints to the loaded NDS7 region. That
method avoids waste of unused memory at 200h..3FFFh, and it should be
compatible with the NDS console, however, it is not comaptible with commercial
cartridges - which do silently redirect address below 4000h to
"addr=8000h+(addr AND 1FFh)". Still, it should work with inofficial flashcards,
which do not do that redirection. No$gba emulates the redirection for regular
official cartridges, but it disables redirection for homebrew carts if NDS7 rom
offset&lt;8000h, and NDS7 size&gt;0.<BR>
[One possible problem: Newer "anti-passme" firmware versions reportedly check
that the entrypoint isn't set to 80000C0h, that firmwares might also reject
NDS9 entrypoints within the NDS7 bootcode region?]<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dscartridgeicontitle"></A>&nbsp;
  DS Cartridge Icon/Title
</FONT></TD></TR></TABLE><BR>
The ROM offset of the Icon/Title is defined in CartHdr[68h]. The size was
originally implied by the size of the Icon/Title structure (ie. five 200h-byte
sectors, A00h bytes for Version 1 or 2), however, later DSi carts are having a
size entry at CartHdr[208h] (usually 23C0h).<BR>
If it is present (ie. if CartHdr[68h]=nonzero), then Icon/Title are displayed
in the bootmenu.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Addr   Siz  Expl.
  0000h  2    Version (0001h=Original, 0002h=With Chinese, 0103h=DSi)
  0002h  2    CRC16 across entries 0020h..083Fh
  0004h  2    CRC16 across entries 0020h..093Fh (Version 2 and up)
  0006h  2    CRC16 across entries 0020h..0A3Fh (Version 103h and up?)
  0008h  2    CRC16 across entries 1240h..23BFh (Version 103h and up)
  000Ah  16h  Reserved (zero-filled)
  0020h  200h Icon Bitmap  (32x32 pix) (4x4 tiles, each 4x8 bytes, 4bit depth)
  0220h  20h  Icon Palette (16 colors, 16bit, range 0000h-7FFFh)
              (Color 0 is transparent, so the 1st palette entry is ignored)
  0240h  100h Title 0 Japanese  (128 characters, 16bit Unicode)
  0340h  100h Title 1 English   ("")
  0440h  100h Title 2 French    ("")
  0540h  100h Title 3 German    ("")
  0640h  100h Title 4 Italian   ("")
  0740h  100h Title 5 Spanish   ("")
  0840h  100h Title 6 Chinese   ("")                 (Version 2 and up)
  0940h  100h Title 7 Whatever? ("")                 (Version 103h and up?)
  0A40h  800h Zerofilled (maybe reserved for Title 8..15)
</TD></TR></TABLE>
Below is usually just containing same bitmap/palette as for above icon. Purpose
might be alternate icon for DSi mode, and/or animated icons with 8 animation
frames...?<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1240h  200h Icon Bitmap 2  (same format as above)  (Version 103h and up)
  1440h  E00h Zerofilled (maybe reserved for 7 more icons bitmaps)
  2240h  20h  Icon Palette 2 (same format as above)  (Version 103h and up)
  2260h  E0h  Zerofilled (maybe reserved for 7 more icons palettes)
  2340h  80h  Unknown (01,00,00,01, followed by 7Ch zerofilled bytes)
  0840h  1C0h Unused/padding (FFh-filled) in Version 1
  0940h  C0h  Unused/padding (FFh-filled) in Version 2
  23C0h  40h  Unused/padding (FFh-filled) in Version 103h
</TD></TR></TABLE>
Usually, for non-multilanguage games, the same (english) title is stored in all
title entries. The title may consist of ASCII characters 0020h-007Fh, character
000Ah (linefeed), and should be terminated/padded by 0000h. The whole text
should not exceed the dimensions of the DS cart field in the bootmenu. The
title is usually split into a primary title, optional sub-title, and
manufacturer, each separated by 000Ah character(s). For example: "America",
000Ah, "The Axis of War", 000Ah, "Cynicware", 0000h.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dscartridgeprotocol"></A>&nbsp;
  DS Cartridge Protocol
</FONT></TD></TR></TABLE><BR>
Communication with Cartridge ROM relies on sending 8 byte commands to the
cartridge, after the sending the command, a data stream can be received from
the cartridge (the length of the data stream isn't fixed, below descriptions
show the default length in brackets, but one may receive more, or less bytes,
if desired).<BR>
<BR>
<B>Cartridge Memory Map</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0000000h-0000FFFh Header (unencrypted)
  0001000h-0003FFFh Not read-able (zero filled in ROM-images)
  0004000h-0007FFFh Secure Area, 16KBytes (first 2Kbytes with extra encryption)
  0008000h-...      Main Data Area
</TD></TR></TABLE>
DSi cartridges are split into a NDS area (as above), and a new DSi area:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  XX00000h XX02FFFh DSi Not read-able (XX00000h=first megabyte after NDS area)
  XX03000h-XX06FFFh DSi ARM9i Secure Area (usually with modcrypt encryption)
  XX07000h-...      DSi Main Data Area
</TD></TR></TABLE>
Cartridge memory must be copied to RAM (the CPU cannot execute code in ROM).<BR>
<BR>
<B>Command Summary, Cmd/Reply-Encryption Type, Default Length</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Command/Params    Expl.                             Cmd  Reply Len
  -- Unencrypted Load --
  9F00000000000000h Dummy (read HIGH-Z bytes)         RAW  RAW   2000h
  0000000000000000h Get Cartridge Header              RAW  RAW   200h DSi:1000h
  9000000000000000h 1st Get ROM Chip ID               RAW  RAW   4
  00aaaaaaaa000000h Unencrypted Data (debug ver only) RAW  RAW   200h
  3Ciiijjjxkkkkkxxh Activate KEY1 Encryption Mode     RAW  RAW   0
  -- Secure Area Load --
  4llllmmmnnnkkkkkh Activate KEY2 Encryption Mode     KEY1 FIX   910h+0
  1lllliiijjjkkkkkh 2nd Get ROM Chip ID               KEY1 KEY2  910h+4
  xxxxxxxxxxxxxxxxh Invalid - Get KEY2 Stream XOR 00h KEY1 KEY2  910h+...
  2bbbbiiijjjkkkkkh Get Secure Area Block (4Kbytes)   KEY1 KEY2  910h+10A8h
  6lllliiijjjkkkkkh Optional KEY2 Disable             KEY1 KEY2  910h+?
  Alllliiijjjkkkkkh Enter Main Data Mode              KEY1 KEY2  910h+0
  -- Main Data Load --
  B7aaaaaaaa000000h Encrypted Data Read               KEY2 KEY2  200h
  B800000000000000h 3rd Get ROM Chip ID               KEY2 KEY2  4
  xxxxxxxxxxxxxxxxh Invalid - Get KEY2 Stream XOR 00h KEY2 KEY2  ...
</TD></TR></TABLE>
The parameter digits contained in above commands are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  aaaaaaaa     32bit ROM address (command B7 can access only 8000h and up)
  bbbb         Secure Area Block number (0004h..0007h for addr 4000h..7000h)
  x,xx         Random, not used in further commands (DSi: always zero)
  iii,jjj,llll Random, must be SAME value in further commands
  kkkkk        Random, must be INCREMENTED after FURTHER commands
  mmm,nnn      Random, used as KEY2-encryption seed
</TD></TR></TABLE>
<BR>
++++ Unencrypted Commands (First Part of Boot Procedure) ++++<BR>
<BR>
<B>Cartridge Reset</B><BR>
The /RES Pin switches the cartridge into unencrypted mode. After reset, the
first two commands (9Fh and 00h) are transferred at 4MB/s CLK rate.<BR>
<BR>
<B>9F00000000000000h (2000h) - Dummy</B><BR>
Dummy command send after reset, returns endless stream of HIGH-Z bytes (ie.
usually receiving FFh, immediately after sending the command, the first 1-2
received bytes may be equal to the last command byte).<BR>
<BR>
<B>0000000000000000h (200h) (DSi:1000h) - Get Header</B><BR>
Returns RAW unencrypted cartridge header, repeated every 1000h bytes. The
interesting area are the 1st 200h bytes, the rest is typically zero filled
(except on DSi carts, which do use the whole 1000h bytes).<BR>
The Gamecode header entry is used later on to initialize the encryption. Also,
the ROM Control entries define the length of the KEY1 dummy periods (typically
910h clocks), and the CLK transfer rate for further commands (typically faster
than the initial 4MB/s after power up).<BR>
<BR>
<B>9000000000000000h (4) - 1st Get ROM Chip ID</B><BR>
Returns RAW unencrypted Chip ID (eg. C2h,0Fh,00h,00h), repeated every 4 bytes.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1st byte - Manufacturer (eg. C2h=Macronix) (roughly based on JEDEC IDs)
  2nd byte - Chip size (00h..7Fh: (N+1)Mbytes, F0h..FFh: (100h-N)*256Mbytes?)
  3rd byte - Flags (see below)
  4th byte - Flags (see below)
</TD></TR></TABLE>
The Flag Bits in 3th byte can be<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0   Maybe Infrared flag? (in case ROM does contain on-chip infrared stuff)
  1   Unknown (set in some 3DS carts)
  2-7 Zero
</TD></TR></TABLE>
The Flag Bits in 4th byte can be<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-2 Zero
  3   Seems to be NAND flag (0=ROM, 1=NAND) (observed in only ONE cartridge)
  4   3DS Flag (0=NDS/DSi, 1=3DS)
  5   Zero   ... set in ... DSi-exclusive games?
  6   DSi flag (0=NDS/3DS, 1=DSi)
  7   Cart Protocol Variant (0=older/smaller carts, 1=newer/bigger carts)
</TD></TR></TABLE>
Existing/known ROM IDs are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  C2h,07h,00h,00h NDS Macronix 8MB ROM  (eg. DS Vision)
  C2h,0Fh,00h,00h NDS Macronix 16MB ROM (eg. Metroid Demo)
  C2h,1Fh,00h,00h NDS Macronix 32MB ROM (eg. Over the Hedge)
  C2h,1Fh,00h,40h DSi Macronix 32MB ROM (eg. Art Academy, TWL-VAAV)
  80h,3Fh,01h,E0h ?            64MB ROM+Infrared (eg. Walk with Me, NTR-IMWP)
  AEh,3Fh,00h,E0h DSi Noname   64MB ROM (eg. de Blob 2, TWL-VD2V)
  C2h,3Fh,00h,00h NDS Macronix 64MB ROM (eg. Ultimate Spiderman)
  C2h,3Fh,00h,40h DSi Macronix 64MB ROM (eg. Crime Lab, NTR-VAOP)
  80h,7Fh,00h,80h NDS SanDisk  128MB ROM (DS Zelda, NTR-AZEP-0)
  80h,7Fh,01h,E0h ?            128MB ROM+Infrared? (P-letter Soul Silver, IPGE)
  C2h,7Fh,00h,80h NDS Macronix 128MB ROM (eg. Spirit Tracks, NTR-BKIP)
  C2h,7Fh,00h,C0h DSi Macronix 128MB ROM (eg. Cooking Coach/TWL-VCKE)
  ECh,7Fh,00h,88h NDS Samsung  128MB NAND (eg. Warioware D.I.Y.)
  ECh,7Fh,01h,88h NDS Samsung? 128MB NAND+What? (eg. Jam with the Band, UXBP)
  ECh,7Fh,00h,E8h DSi Samsung? 128MB NAND (eg. Face Training, USKV)
  80h,FFh,80h,E0h NDS          256MB ROM (Kingdom Hearts - Re-Coded, NTR-BK9P)
  C2h,FFh,01h,C0h DSi Macronix 256MB ROM+Infrared? (eg. P-Letter White)
  C2h,FFh,00h,80h NDS Macronix 256MB ROM (eg. Band Hero, NTR-BGHP)
  C2h,FEh,01h,C0h DSi Macronix 512MB ROM+Infrared? (eg. P-Letter White 2)
  C2h,FEh,00h,90h 3DS Macronix probably 512MB? ROM (eg. Sims 3)
  45h,FAh,00h,90h 3DS SunDisk? maybe... 1.5GB? ROM (eg. Starfox)
  C2h,F8h,00h,90h 3DS Macronix maybe... 2GB?   ROM (eg. Kid Icarus)
  C2h,7Fh,00h,90h 3DS Macronix 128MB ROM CTR-P-AENJ MMinna no Ennichi
  C2h,FFh,00h,90h 3DS Macronix 256MB ROM CTR-P-AFSJ Pro Yakyuu Famista 2011
  C2h,FEh,00h,90h 3DS Macronix 512MB ROM CTR-P-AFAJ Real 3D Bass FishingFishOn
  C2h,FAh,00h,90h 3DS Macronix 1GB ROM CTR-P-ASUJ Hana to Ikimono Rittai Zukan
  C2h,FAh,02h,90h 3DS Macronix 1GB ROM CTR-P-AGGW Luigis Mansion 2 ASiA CHT
  C2h,F8h,00h,90h 3DS Macronix 2GB ROM CTR-P-ACFJ Castlevania - Lords of Shadow
  C2h,F8h,02h,90h 3DS Macronix 2GB ROM CTR-P-AH4J Monster Hunter 4
  AEh,FAh,00h,90h 3DS          1GB ROM CTR-P-AGKJ Gyakuten Saiban 5
  AEh,FAh,00h,98h 3DS          1GB NAND CTR-P-EGDJ Tobidase Doubutsu no Mori
  45h,FAh,00h,90h 3DS          1GB ROM CTR-P-AFLJ Fantasy Life
  45h,F8h,00h,90h 3DS          2GB ROM CTR-P-AVHJ Senran Kagura Burst - Guren
  C2h,F0h,00h,90h 3DS Macronix 4GB ROM CTR-P-ABRJ Biohazard Revelations
  FFh,FFh,FFh,FFh None (no cartridge inserted)
</TD></TR></TABLE>
The Samsung NAND chip appears to use a slightly different protocol (seems as if
it allows to read ROM header and ID only once, or as if it gets confused when
reading more than 4 ID bytes, or so) (and of course, the protocol is somehow
extended, allowing to write data to the NAND memory). The official JEDEC ID for
Samsung would be "CEh", but for some reason, Samsung's NDS chip does spit out
"ECh" as Maker ID.<BR>
ID "45h" ("SunDisk" according to a JEDEC ID list) might refer to "SanDisk"?<BR>
<BR>
<B>3Ciiijjjxkkkkkxxh (0) - Activate KEY1 Encryption Mode</B><BR>
The 3Ch command returns endless stream of HIGH-Z bytes, all following commands,
and their return values, are encrypted. The random parameters iii,jjj,kkkkk
must be re-used in further commands; the 20bit kkkkk value is to be incremented
by one after each &lt;further&gt; command (it is &lt;not&gt; incremented after
the 3Ch command).<BR>
<BR>
<B>3Diiijjjxkkkkkxxh (0) - Activate KEY1 Encryption Mode and Unlock DSi Mode</B><BR>
Same as command 3Ch (but with different initial 1048h-byte encryption values),
and works only on DSi carts. Command 3Dh is unlocking two features on DSi
carts:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1) Command 2bbbbiiijjjkkkkkh loads ARM9i secure area (instead of ARM9 area)
  2) Command B7aaaaaaaa000000h allows to read the 'whole' cartridge space
</TD></TR></TABLE>
Without command 3Dh, DSi carts will allow to read only the first some megabytes
(for example, the first 11 Mbyte of the System Flaw cartridge), and the
remaining memory returns mirrors of "addr=8000h+(addr AND 1FFh)").<BR>
Note: After reset, the cartridge protocol allows to send only either one of the
3Ch/3Dh commands (DSi consoles can control the cartridge reset pin, so they can
first send 3Ch and read the normal secure area, then issue a reset and 3Dh and
read the DSi secure area) (on a NDS one could do the same by ejecting/inserting
the cartridge instead of toggling the reset pin).<BR>
<BR>
++++ KEY1 Encrypted Commands (2nd Part of Boot procedure) ++++<BR>
<BR>
<B>4llllmmmnnnkkkkkh (910h) - Activate KEY2 Encryption Mode</B><BR>
KEY1 encrypted command, parameter mmmnnn is used to initialize the KEY2
encryption stream. Returns 910h dummy bytes (which are still subject to old
KEY2 settings; at pre-initialization time, this is fixed: HIGH-Z, C5h, 3Ah,
81h, etc.). The new KEY2 seeds are then applied, and the first KEY2 byte is
then precomputed. The 910h dummy stream is followed by that precomputed byte
value endless repeated (this is the same value as that "underneath" of the
first HIGH-Z dummy-byte of the next command).<BR>
Secure1000h: Returns repeated FFh bytes (instead of the leading C5h, 3Ah, 81h,
etc. stuff).<BR>
Secure1000h: Returns repeated FFh bytes (instead of the repeated precomputed
value).<BR>
<BR>
<B>1lllliiijjjkkkkkh (914h) - 2nd Get ROM Chip ID / Get KEY2 Stream</B><BR>
KEY1 encrypted command. Returns 910h dummy bytes, followed by KEY2 encrypted
Chip ID repeated every 4 bytes, which must be identical as for the 1st Get ID
command. The BIOS randomly executes this command once or twice. Changing the
first command byte to any other value returns an endless KEY2 encrypted stream
of 00h bytes, that is the easiest way to retrieve encryption values and to
bypass the copyprotection.<BR>
<BR>
<B>2bbbbiiijjjkkkkkh (19B8h) - Get Secure Area Block</B><BR>
KEY1 encrypted command. Used to read a secure area block (bbbb in range
0004h..0007h for addr 4000h..7000h) (or, after sending command 3Dh on a DSi:
bbbb in range 0004h..0007h for addr XX03000h..XX06000h).<BR>
Each block is 4K, so it requires four Get Secure Area commands to receive the
whole Secure Area (ROM locations 4000h-7FFFh), the BIOS is reading these blocks
in random order.<BR>
Normally (if the upper bit of the Chip ID is set): Returns 910h dummy bytes,
followed by 200h KEY2 encrypted Secure Area bytes, followed by 18h KEY2
encrypted 00h bytes, then the next 200h KEY2 encrypted Secure Area bytes, again
followed by 18h KEY2 encrypted 00h bytes, and so on. That stream is repeated
every 10C0h bytes (8x200h data bytes, plus 8x18h zero bytes).<BR>
Alternately (if the upper bit of the Chip ID is zero):  Returns 910h dummy
bytes, followed by 1000h KEY2 encrypted Secure Area bytes, presumably followed
by 18h bytes, too.<BR>
Aside from above KEY2 encryption (which is done by hardware), the first 2K of
the NDS Secure Area is additionally KEY1 encrypted; which must be resolved
after transfer by software (and the DSi Secure Area is usually modcrypted, as
specified in the cartridge header).<BR>
<BR>
<B>6lllliiijjjkkkkkh (0) - Optional KEY2 Disable</B><BR>
KEY1 encrypted command. Returns 910h dummy bytes (which are still KEY2
affected), followed by endless stream of RAW 00h bytes. KEY2 encryption is
disabled for all following commands.<BR>
This command is send only if firmware[18h] matches encrypted string "enPngOFF",
and ONLY if firmware get_crypt_keys had completed BEFORE completion of secure
area loading, this timing issue may cause unstable results.<BR>
<BR>
<B>Alllliiijjjkkkkkh (910h) - Enter Main Data Mode</B><BR>
KEY1 encrypted command. Returns 910h dummy bytes, followed by endless KEY2
encrypted stream of 00h bytes. All following commands are KEY2 encrypted.<BR>
<BR>
++++ KEY2 Encrypted Commands (Main Data Transfer) ++++<BR>
<BR>
<B>B7aaaaaaaa000000h (200h) - Get Data</B><BR>
KEY2 encrypted command. The desired ROM address is specifed, MSB first, in
parameter bytes (a). Returned data is KEY2 encrypted.<BR>
There is no alignment restriction for the address. However, the datastream
wraps to the begin of the current 4K block when address+length crosses a 4K
boundary (1000h bytes).<BR>
The command can be used only for addresses 8000h and up. Addresses 0..7FFFh are
silently redirected to address "8000h+(addr AND 1FFh)". DSi cartridges will
also reject XX00000h..XX06FFFh in the same fashion (and also XX07000h and up if
the DSi cartridge isn't unlocked via command 3Dh).<BR>
Addresses that do exceed the ROM size do mirror to the valid address range
(that includes mirroring non-loadable regions like 0..7FFFh to "8000h+(addr AND
1FFh)"; some newer games are using this behaviour for some kind of anti-piracy
checks).<BR>
<BR>
<B>B800000000000000h (4) - 3rd Get ROM Chip ID</B><BR>
KEY2 encrypted command. Returns KEY2 encrypted Chip ID repeated every 4 bytes.<BR>
<BR>
<B>xxxxxxxxxxxxxxxxh - Invalid Command</B><BR>
Any other command (anything else than above B7h and B8h) in KEY2 command mode
causes communcation failures. The invalid command returns an endless KEY2
encrypted stream of 00h bytes. After the invalid command, the KEY2 stream is
NOT advanced for further command bytes, further commands seems to return KEY2
encrypted 00h bytes, of which, the first returned byte appears to be HIGH-Z.<BR>
Ie. the cartridge seems to have switched back to a state similar to the
KEY1-phase, although it doesn't seem to be possible to send KEY1 commands.<BR>
<BR>
++++ Notes ++++<BR>
<BR>
<B>KEY1 Command Encryption / 910h Dummy Bytes</B><BR>
All KEY1 encrypted commands are followed by 910h dummy byte transfers, these
910h clock cycles are probably used to decrypt the command at the cartridge
side; communication will fail when transferring less than 910h bytes.<BR>
The return values for the dummy transfer are: A single HIGH-Z byte, followed by
90Fh KEY2-encrypted 00h bytes. The KEY2 encryption stream is advanced for all
910h bytes, including for the HIGH-Z byte.<BR>
Note: Current cartridges are using 910h bytes, however, other carts might use
other amounts of dummy bytes, the 910h value can be calculated based on ROM
Control entries in cartridge header. For the KEY1 formulas, see:<BR>
<A HREF="#dsencryptionbygamecodeidcodekey1">DS Encryption by Gamecode/Idcode (KEY1)</A><BR>
<BR>
<B>KEY2 Command/Data Encryption</B><BR>
<A HREF="#dsencryptionbyrandomseedkey2">DS Encryption by Random Seed (KEY2)</A><BR>
<BR>
<B>Cart Protocol Variants (Chip ID.Bit31)</B><BR>
There are two protocol variants for NDS carts, indicated by Bit31 of the ROM
Chip ID (aka bit7 of the 4th ID byte):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1) Chip ID.Bit31=0  Used by older/smaller carts with up to 64MB ROM
  2) Chip ID.Bit31=1  Used by newer/bigger carts with 64MB or more ROM
</TD></TR></TABLE>
The first variant (for older carts) is described above. The second second
variant includes some differences for KEY1 encrypted commands:<BR>
GAPS: The commands have the same 910h-cycle gaps, but without outputting CLK
pulses during those gaps (ie. used with ROMCTRL.Bit28=0) (the absence of the
CLKs implies that there is no dummy data transferred during gaps, and
accordingly, that the KEY2 stream isn't advanced during the 910h gap cycles).<BR>
REPEATED COMMANDS and SECURE AREA DELAY: All KEY1 encrypted commands must be
sent TWICE (or even NINE times). First, send the command with 0-byte Data
transfer length. Second, issue the Secure Area Delay (required; use the delay
specified in cart header[06Eh]).<BR>
Third, send the command once again with 0-byte or 4-byte data transfer length
(usually 0 bytes, or 4-bytes for Chip ID command), or sent it eight times with
200h-byte data transfer length (for the 1000h-byte secure area load command).<BR>
For those repeats, always resend exactly the same command (namely, kkkkk is NOT
incremented during repeats, and there is no extra index needed to select
200h-byte portions within 1000h-byte blocks; the cartridge is automatically
outputting the eight portions one after another).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dscartridgebackup"></A>&nbsp;
  DS Cartridge Backup
</FONT></TD></TR></TABLE><BR>
<B>SPI Bus Backup Memory</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Type   Total Size  Page Size  Chip/Example      Game/Example
  EEPROM 0.5K bytes   16 bytes  ST M95040-W       (eg. Metroid Demo)
  EEPROM   8K bytes   32 bytes  ST M95640-W       (eg. Super Mario DS)
  EEPROM  64K bytes  128 bytes  ST M95512-W       (eg. Downhill Jam)
  FLASH  256K bytes  256 bytes  ST M45PE20        (eg. Skateland)
  FLASH  256K bytes             Sanyo LE25FW203T  (eg. Mariokart)
  FLASH  512K bytes  256 bytes  ST M25PE40?       (eg. which/any games?)
  FLASH  512K bytes             ST 45PE40V6       (eg. DS Zelda, NTR-AZEP-0)
  FLASH 1024K bytes             ST 45PE80V6       (eg. Spirit Tracks, NTR-BKIP)
  FLASH 8192K bytes             MX25L6445EZNI-10G (Art Academy only, TWL-VAAV)
  FRAM     8K bytes   No limit  ?                 (eg. which/any games?)
  FRAM    32K bytes   No limit  Ramtron FM25L256? (eg. which/any games?)
</TD></TR></TABLE>
<BR>
<B>Lifetime Stats</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Type      Max Writes per Page    Data Retention
  EEPROM    100,000                40 years
  FLASH     100,000                20 years
  FRAM      No limit               10 years
</TD></TR></TABLE>
<BR>
SPI Bus Backup Memory is accessed via Ports 40001A0h and 40001A2h, see<BR>
<A HREF="#dscartridgeioports">DS Cartridge I/O Ports</A><BR>
<BR>
<B>Commands</B><BR>
For all EEPROM and FRAM types:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  06h WREN  Write Enable                Cmd, no parameters
  04h WRDI  Write Disable               Cmd, no parameters
  05h RDSR  Read Status Register        Cmd, read repeated status value(s)
  01h WRSR  Write Status Register       Cmd, write one-byte value
  9Fh RDID  Read JEDEC ID (not supported on EEPROM/FLASH, returns FFh-bytes)
</TD></TR></TABLE>
For 0.5K EEPROM (8+1bit Address):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  03h RDLO  Read from Memory 000h-0FFh  Cmd, addr lsb, read byte(s)
  0Bh RDHI  Read from Memory 100h-1FFh  Cmd, addr lsb, read byte(s)
  02h WRLO  Write to Memory 000h-0FFh   Cmd, addr lsb, write 1..MAX byte(s)
  0Ah WRHI  Write to Memory 100h-1FFh   Cmd, addr lsb, write 1..MAX byte(s)
</TD></TR></TABLE>
For 8K..64K EEPROM and for FRAM (16bit Address):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  03h RD    Read from Memory            Cmd, addr msb,lsb, read byte(s)
  02h WR    Write to Memory             Cmd, addr msb,lsb, write 1..MAX byte(s)
</TD></TR></TABLE>
Note: MAX = Page Size (see above chip list) (no limit for FRAM).<BR>
<BR>
For FLASH backup, commands should be same as for Firmware FLASH memory:<BR>
<A HREF="#dsfirmwareserialflashmemory">DS Firmware Serial Flash Memory</A><BR>
<BR>
<B>Status Register</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0   WIP  Write in Progress (1=Busy) (Read only) (always 0 for FRAM chips)
  1   WEL  Write Enable Latch (1=Enable) (Read only, except by WREN,WRDI)
  2-3 WP   Write Protect (0=None, 1=Upper quarter, 2=Upper Half, 3=All memory)
</TD></TR></TABLE>
For 0.5K EEPROM:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4-7 ONEs Not used (all four bits are always set to "1" each)
</TD></TR></TABLE>
For 8K..64K EEPROM and for FRAM:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4-6 ZERO Not used (all three bits are always set to "0" each)
  7   SRWD Status Register Write Disable (0=Normal, 1=Lock) (Only if /W=LOW)
</TD></TR></TABLE>
WEL gets reset on Power-up, WRDI, WRSR, WRITE/LO/HI, and on /W=LOW.<BR>
The WRSR command allows to change ONLY the two WP bits, and the SRWD bit (if
any), these bits are non-volatile (remain intact during power-down),
respectively, the WIP bit must be checked to sense WRSR completion.<BR>
<BR>
<B>Detection (by examining hardware responses)</B><BR>
The overall memory type and bus-width can be detected by RDSR/RDID commands:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  RDSR  RDID          Type         (bus-width)
  FFh,  FFh,FFh,FFh   None         (none)
  F0h,  FFh,FFh,FFh   EEPROM       (with 8+1bit address bus)
  00h,  FFh,FFh,FFh   EEPROM/FRAM  (with 16bit address bus)
  00h,  xxh,xxh,xxh   FLASH        (usually with 24bit address bus)
</TD></TR></TABLE>
And, the RD commands can be used to detect the memory size/mirrors (though that
won't work if the memory is empty).<BR>
<BR>
<B>Pin-Outs for EEPROM and FRAM chips</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Pin Name Expl.
  1  /S    Chip Select
  2  Q     Data Out
  3  /W    Write-Protect (not used in NDS, wired to VCC)
  4  VSS   Ground
  5  D     Data In
  6  C     Clock
  7  /HOLD Transfer-pause (not used in NDS, wired to VCC)
  8  VCC   Supply 2.5 to 5.5V for M95xx0-W
</TD></TR></TABLE>
<BR>
FRAM (Ferroelectric Nonvolatile RAM) is fully backwards compatible with normal
EEPROMs, but comes up with faster write/erase time (no delays), and with lower
power consumption, and unlimited number of write/erase cycles. Unlike as for
normal RAM, as far as I understand, the data remains intact without needing any
battery.<BR>
<BR>
<B>Other special save memory</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  DS Vision (NDS cart with microSD slot... and maybe ALSO with EEPROM?)
  Warioware D.I.Y. (uses a single NAND FLASH chip for both 'ROM' and 'SAVE')
    (the warioware chip is marked "SAMSUNG 004, KLC2811ANB-P204, NTR-UORE-0")
    (the warioware PCB is marked "DI X-7 C17-01")
  and, a few games are said to have "Flash - 64 Mbit" save memory?
</TD></TR></TABLE>
<BR>
<B>DSi Internal eMMC and External SD Card</B><BR>
DSi cartridges are usually (maybe always) having SD/MMC access disabled, so
they must stick using EEPROM/FLASH chips inside of the cartridges (which is
required for NDS compatibility anyways).<BR>
However, DSiware games (downloaded from DSi Shop) are allowed to save data on
eMMC, using "private.sav" or "public.sav" files in their data folder. The size
of that files is preset in cartridge header.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dscartridgeioports"></A>&nbsp;
  DS Cartridge I/O Ports
</FONT></TD></TR></TABLE><BR>
The Gamecard bus registers can be mapped to NDS7 or NDS9 via EXMEMCNT, see<BR>
<A HREF="#dsmemorycontrol">DS Memory Control</A><BR>
<BR>
<B>40001A0h - NDS7/NDS9 - AUXSPICNT - Gamecard ROM and SPI Control</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-1   SPI Baudrate        (0=4MHz/Default, 1=2MHz, 2=1MHz, 3=512KHz)
  2-5   Not used            (always zero)
  6     SPI Hold Chipselect (0=Deselect after transfer, 1=Keep selected)
  7     SPI Busy            (0=Ready, 1=Busy) (presumably Read-only)
  8-12  Not used            (always zero)
  13    NDS Slot Mode       (0=Parallel/ROM, 1=Serial/SPI-Backup)
  14    Transfer Ready IRQ  (0=Disable, 1=Enable) (for ROM, not for AUXSPI)
  15    NDS Slot Enable     (0=Disable, 1=Enable) (for both ROM and AUXSPI)
</TD></TR></TABLE>
The "Hold" flag should be cleared BEFORE transferring the LAST data unit, the
chipselect will be then automatically cleared after the transfer, the program
should issue a WaitByLoop(12) on NDS7 (or longer on NDS9) manually AFTER the
LAST transfer.<BR>
<BR>
<B>40001A2h - NDS7/NDS9 - AUXSPIDATA - Gamecard SPI Bus Data/Strobe (R/W)</B><BR>
The SPI transfer is started on writing to this register, so one must
&lt;write&gt; a dummy value (should be zero) even when intending to
&lt;read&gt; from SPI bus.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-7  Data
  8-15 Not used (always zero)
</TD></TR></TABLE>
During transfer, the Busy flag in AUXSPICNT is set, and the written DATA value
is transferred to the device (via output line), simultaneously data is received
(via input line). Upon transfer completion, the Busy flag goes off, and the
received value can be then read from AUXSPIDATA, if desired.<BR>
<BR>
<B>40001A4h - NDS7/NDS9 - ROMCTRL - Gamecard Bus ROMCTRL (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-12  KEY1 gap1 length  (0-1FFFh) (forced min 08F8h by BIOS) (leading gap)
  13    KEY2 encrypt data (0=Disable, 1=Enable KEY2 Encryption for Data)
  14     "SE" Unknown? (usually same as Bit13) (does NOT affect timing?)
  15    KEY2 Apply Seed   (0=No change, 1=Apply Encryption Seed) (Write only)
  16-21 KEY1 gap2 length  (0-3Fh)   (forced min 18h by BIOS) (200h-byte gap)
  22    KEY2 encrypt cmd  (0=Disable, 1=Enable KEY2 Encryption for Commands)
  23    Data-Word Status  (0=Busy, 1=Ready/DRQ) (Read-only)
  24-26 Data Block size   (0=None, 1..6=100h SHL (1..6) bytes, 7=4 bytes)
  27    Transfer CLK rate (0=6.7MHz=33.51MHz/5, 1=4.2MHz=33.51MHz/8)
  28    KEY1 Gap CLKs (0=Hold CLK High during gaps, 1=Output Dummy CLK Pulses)
  29     "RESB" Unknown (always 1 ?) (not read/write-able) -- R/W on DSi7 (?!)
  30     "WR"   Unknown (always 0 ?) (read/write-able)
  31    Block Start/Status (0=Ready, 1=Start/Busy) (IRQ See 40001A0h/Bit14)
</TD></TR></TABLE>
The cartridge header is booted at 4.2MHz CLK rate, and following transfers are
then using ROMCTRL settings specified in cartridge header entries [060h] and
[064h], which are usually using 6.7MHz CLK rate.<BR>
Transfer length of null, four, and 200h..4000h bytes are supported by the
console, however, regular cartridges support only max 1000h bytes.<BR>
<BR>
<B>40001A8h - NDS7/NDS9 - Gamecard bus 8-byte Command Out</B><BR>
The separate commands are described in the Cartridge Protocol chapter, however,
once when the BIOS boot procedure has completed, one would usually only need
command "B7aaaaaaaa000000h", for reading data (usually 200h bytes) from address
aaaaaaaah (which should be usually aligned by 200h).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-7   1st Command Byte (at 40001A8h) (eg. B7h) (MSB)
  8-15  2nd Command Byte (at 40001A9h) (eg. addr bit 24-31)
  16-23 3rd Command Byte (at 40001AAh) (eg. addr bit 16-23)
  24-31 4th Command Byte (at 40001ABh) (eg. addr bit 8-15) (when aligned=even)
  32-39 5th Command Byte (at 40001ACh) (eg. addr bit 0-7)  (when aligned=00h)
  40-47 6th Command Byte (at 40001ADh) (eg. 00h)
  48-57 7th Command Byte (at 40001AEh) (eg. 00h)
  56-63 8th Command Byte (at 40001AFh) (eg. 00h) (LSB)
</TD></TR></TABLE>
Observe that the command/parameter MSB is located at the smallest memory
location (40001A8h), ie. compared with the CPU, the byte-order is reversed.<BR>
<BR>
<B>4100010h - NDS7/NDS9 - Gamecard bus 4-byte Data In (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-7   1st received Data Byte (at 4100010h)
  8-15  2nd received Data Byte (at 4100011h)
  16-23 3rd received Data Byte (at 4100012h)
  24-31 4th received Data Byte (at 4100013h)
</TD></TR></TABLE>
After sending a command, data can be read from this register manually (when the
DRQ bit is set), or by DMA (with DMASAD=4100010h, Fixed Source Address,
Length=1, Size=32bit, Repeat=On, Mode=DS Gamecard).<BR>
<BR>
<B>40001B0h - 32bit - NDS7/NDS9 - Encryption Seed 0 Lower 32bit (W)</B><BR>
<B>40001B4h - 32bit - NDS7/NDS9 - Encryption Seed 1 Lower 32bit (W)</B><BR>
<B>40001B8h - 16bit - NDS7/NDS9 - Encryption Seed 0 Upper 7bit (bit7-15 unused)</B><BR>
<B>40001BAh - 16bit - NDS7/NDS9 - Encryption Seed 1 Upper 7bit (bit7-15 unused)</B><BR>
These registers are used by the NDS7 BIOS to initialize KEY2 encryption (and
there's normally no need to change that initial settings). Writes to the Seed
registers do not have direct effect on the internal encryption registers, until
the Seed gets applied by writing "1" to ROMCTRL.Bit15.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 For more info:
</TD></TR></TABLE>
<A HREF="#dsencryptionbyrandomseedkey2">DS Encryption by Random Seed (KEY2)</A><BR>
Note: There are &lt;separate&gt; Seed registers for both NDS7 and NDS9, which
can be applied by ROMCTRL on NDS7 and NDS9 respectively (however, once when
applied to the internal registers, the new internal setting is used for
&lt;both&gt; CPUs).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dscartridgenitroromandnitroarcfilesystems"></A>&nbsp;
  DS Cartridge NitroROM and NitroARC File Systems
</FONT></TD></TR></TABLE><BR>
The DS hardware, BIOS, and Firmware do NOT contain any built-in filesystem
functions. The ARM9/ARM7 boot code (together max 3903KB), and Icon/Title
information are automatically loaded on power-up.<BR>
Programs that require to load additional data from cartridge ROM may do that
either by implementing whatever functions to translate filenames to ROM
addresses, or by reading from ROM directly.<BR>
<BR>
<B>NitroROM</B><BR>
The NitroROM Filesystem is used by many NDS games (at least those that have
been developed with Nintendo's tools). It's used for ROM Cartridges, and, on
the DSi, it's also used for DSiWare games (in the latter case, NitroROM acts as
a 2nd virtual filesystem inside of the DSi's FAT16 filesystem).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  FNT = cart_hdr[040h]     ;\origin as defined in ROM cartridge header
  FAT = cart_hdr[048h]     ;/
  IMG = 00000000h          ;-origin at begin of ROM
</TD></TR></TABLE>
Aside from using filenames, NitroROM files can be alternately accessed via
Overlay IDs (see later on below).<BR>
<BR>
<B>NitroARC (Nitro Archive)</B><BR>
NARC Files are often found inside of NitroROM Filesystems (ie. NARC is a second
virtual filesystem, nested inside of the actual filesystem). The NARC Format is
very similar to the NitroROM Format, but with additional Chunk Headers (instead
of the Cartridge ROM Header).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ...  ...  Optional Header (eg. compression header, or RSA signature)
  000h 4    Chunk Name "NARC" (Nitro Archive)                   ;\
  004h 2    Byte Order (FFFEh)                                  ;
  006h 2    Version (0100h)                                     ; NARC
  008h 4    File Size (from "NARC" ID to end of file)           ; Header
  00Ch 2    Chunk Size (0010h)                                  ;
  00Eh 2    Number of following chunks (0003h)                  ;/
  010h 4    Chunk Name "BTAF" (File Allocation Table Block)     ;\
  014h 4    Chunk Size (including above chunk name)             ; File
  018h 2    Number of Files                                     ; Allocation
  01Ah 2    Reserved (0000h)                                    ; Table
  01Ch ...  FAT (see below)                                     ;/
  ...  4    Chunk Name "BTNF" (File Name Table Block)           ;\
  ...  4    Chunk Size (including above chunk name)             ; File Name
  ...  ...  FNT (see below)                                     ; Table
  ...  ..   Padding for 4-byte alignment (FFh-filled, if any)   ;/
  ...  4    Chunk Name "GMIF" (File Image Block)                ;\
  ...  4    Chunk Size (including above chunk name)             ; File Data
  ...  ...  IMG (File Data)                                     ;/
</TD></TR></TABLE>
<BR>
<B>File Allocation Table (FAT) (base/size defined in cart header)</B><BR>
Contains ROM addresses for up to 61440 files (File IDs 0000h and up).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Addr Size Expl.
  00h  4    Start address (originated at IMG base) (0=Unused Entry)
  04h  4    End address   (Start+Len...-1?)        (0=Unused Entry)
</TD></TR></TABLE>
For NitroROM, addresses must be after Secure Area (at 8000h and up).<BR>
For NitroARC, addresses can be anywhere in the IMG area (at 0 and up).<BR>
Directories are fully defined in FNT area, and do not require FAT entries.<BR>
<BR>
<B>File Name Table (FNT) (base/size defined in cart header)</B><BR>
Consists of the FNT Directory Table, followed by one or more FNT Sub-Tables.<BR>
To interprete the directory tree: Start at the 1st Main-Table entry, which is
referencing to a Sub-Table, any directories in the Sub-Table are referencing to
Main-Table entries, which are referencing to further Sub-Tables, and so on.<BR>
<BR>
<B>FNT Directory Main-Table (base=FNT+0, size=[FNT+06h]*8)</B><BR>
Consists of a list of up to 4096 directories (Directory IDs F000h and up).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Addr Size Expl.
  00h  4    Offset to Sub-table             (originated at FNT base)
  04h  2    ID of first file in Sub-table   (0000h..EFFFh)
</TD></TR></TABLE>
For first entry (ID F000h, root directory):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  06h  2    Total Number of directories     (1..4096)
</TD></TR></TABLE>
Further entries (ID F001h..FFFFh, sub-directories):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  06h  2    ID of parent directory (F000h..FFFEh)
</TD></TR></TABLE>
<BR>
<B>FNT Sub-tables (base=FNT+offset, ends at Type/Length=00h)</B><BR>
Contains ASCII names for all files and sub-directories within a directory.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Addr Size Expl.
  00h  1    Type/Length
              01h..7Fh File Entry          (Length=1..127, without ID field)
              81h..FFh Sub-Directory Entry (Length=1..127, plus ID field)
              00h      End of Sub-Table
              80h      Reserved
  01h  LEN  File or Sub-Directory Name, case-sensitive, without any ending
              zero, ASCII 20h..7Eh, except for characters \/?"&lt;&gt;*:;|
</TD></TR></TABLE>
Below for Sub-Directory Entries only:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  LEN+1 2    Sub-Directory ID (F001h..FFFFh) ;see FNT+(ID AND FFFh)*8
</TD></TR></TABLE>
File Entries do not have above ID field. Instead, File IDs are assigned in
incrementing order (starting at the "First ID" value specified in the Directory
Table).<BR>
<BR>
<B>ARM9 and ARM7 Overlay Tables (OVT) (base/size defined in cart header)</B><BR>
Somehow related to Nintendo's compiler, allows to assign compiler Overlay IDs
to filesystem File IDs, and to define additional information such like load
addresses.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Addr Size Expl.
  00h  4    Overlay ID
  04h  4    RAM Address ;Point at which to load
  08h  4    RAM Size    ;Amount to load
  0Ch  4    BSS Size    ;Size of BSS data region
  10h  4    Static initialiser start address
  14h  4    Static initialiser end address
  18h  4    File ID  (0000h..EFFFh)
  1Ch  4    Reserved (zero)
</TD></TR></TABLE>
<BR>
<B>Cartridge Header</B><BR>
The base/size of FAT, FNT, OVT areas is defined in cartridge header,<BR>
<A HREF="#dscartridgeheader">DS Cartridge Header</A><BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dscartridgepassmepassthrough"></A>&nbsp;
  DS Cartridge PassMe/PassThrough
</FONT></TD></TR></TABLE><BR>
PassMe is an adapter connected between the DS and an original NDS cartridge,
used to boot unencrypted code from a flash cartridge in the GBA slot, it
replaces the following entries in the original NDS cartridge header:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Addr  Siz Patch
  004h  4   E59FF018h  ;opcode LDR PC,[027FFE24h] at 27FFE04h
  01Fh  1   04h        ;set autostart bit
  022h  1   01h        ;set ARM9 rom offset to nn01nnnnh (above secure area)
  024h  4   027FFE04h  ;patch ARM9 entry address to endless loop
  034h  4   080000C0h  ;patch ARM7 entry address in GBA slot
  15Eh  2   nnnnh      ;adjust header crc16
</TD></TR></TABLE>
After having verified the encrypted chip IDs (from the original cartridge), the
console thinks that it has successfully loaded a NDS cartridge, and then jumps
to the (patched) entrypoints.<BR>
<BR>
<B>GBA Flashcard Format</B><BR>
Although the original PassMe requires only the entrypoint, PassMe programs
should additionally contain one (or both) of the ID values below, allowing
firmware patches to identify &amp; start PassMe games without real PassMe
hardware.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0A0h  GBA-style Title    ("DSBooter")
  0ACh  GBA-style Gamecode ("PASS")
  0C0h  ARM7 Entrypoint    (32bit ARM code)
</TD></TR></TABLE>
Of course, that applies only to early homebrew programs, newer games should use
normal NDS cartridge headers.<BR>
<BR>
<B>ARM9 Entrypoint</B><BR>
The GBA-slot access rights in the EXMEMCNT register are initially assigned to
the ARM7 CPU, so the ARM9 cannot boot from the flashcard, instead it is
switched into an endless loop in Main RAM (which contains a copy of the
cartridge header at 27FFE00h and up). The ARM7 must thus copy ARM9 code to Main
RAM, and then set the ARM9 entry address by writing to [027FFE24h].<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dscartridgegbaslot"></A>&nbsp;
  DS Cartridge GBA Slot
</FONT></TD></TR></TABLE><BR>
Aside from the 17-pin NDS slot, the DS also includes a 32-pin GBA slot. This
slot is used for GBA backwards compatibility mode. Additionally, in DS mode, it
can be as expansion port, or for importing data from GBA games.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  NDS:     Normal 32pin slot
  DS Lite: Short 32pin slot (GBA cards stick out)
  DSi:     N/A (dropped support for GBA carts, and for DS-expansions)
</TD></TR></TABLE>
In DS mode, ROM, SRAM, FLASH backup, and whatever peripherals contained in
older GBA cartridges can be accessed (almost) identically as in GBA mode,<BR>
<A HREF="#gbacartridges">GBA Cartridges</A><BR>
<BR>
<B>Addressing</B><BR>
In DS mode, only one ROM-region is present at 8000000h-9FFFFFFh (ie. without
the GBA's mirrored WS1 and WS2 regions at A000000h-DFFFFFFh). The expansion
region (for SRAM/FLASH/etc) has been moved from E000000h-E00FFFFh (GBA-mode) to
A000000h-A00FFFFh (DS-mode).<BR>
<BR>
<B>Timings</B><BR>
GBA timings are specified as "waitstates" (excluding 1 access cycle), NDS
timings are specified as (total) "access time". And, the NDS bus-clock is twice
as fast as for GBA. So, for "N" GBA waitstates, the NDS access time should be
"(N+1)*2". Timings are controlled via NDS EXMEMCNT instead GBA WAITCNT,<BR>
<A HREF="#dsmemorycontrolcartridgesandmainram">DS Memory Control - Cartridges and Main RAM</A><BR>
<BR>
<B>GBA EEPROM</B><BR>
EEPROMs in GBA carts cannot be accessed in DS mode. The EEPROMs should be
accessed with 8 waits on GBA, ie. 18 cycles on NDS on both 1st/2nd access. But,
2nd access is restricted to max 6 cycles in NDS mode, which is ways too fast.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dscartrumblepak"></A>&nbsp;
  DS Cart Rumble Pak
</FONT></TD></TR></TABLE><BR>
<B>DS Rumble Option Pak</B><BR>
The Rumble Pak comes bundled with Metroid Prime Pinball. It contains a small
actuator made by ALPS to make it rumble. The original device (NTR-008) is sized
like a normal GBA cartridge, and there's also shorter variant for the DS-Lite
(USG-006).<BR>
The rumble pak is pretty simple internally, it only wires up to a few pins on
the GBA Cartridge Port:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  VCC, GND, /WR, AD1, and IRQ (grounded)
</TD></TR></TABLE>
AD1 runs into a little 8 pin chip, which is probably just a latch on the rising
edge of /WR. A line runs from this chip to a transistor that is directly
connected to the actuator. The only other chip on the board is a 5 pin jobber,
probably a power component.<BR>
For detection, AD1 seems to be pulled low when reading from it, the other AD
lines are open bus (containing the halfword address), so one can do:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  for i=0 to 0FFFh
    if halfword[8000000h+i*2]&lt;&gt;(i and FFFDh) then &lt;not_a_ds_rumble_pak&gt;
  next i
</TD></TR></TABLE>
The actuator doesn't have an on/off setting like a motor, it rumbles when you
switch it between the two settings. Switch frequently for a fast rumble, and
fairly slowly for more of a 'tick' effect. That should be done via timer irq:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  rumble_state = rumble_state xor 0002h
  halfword[8000000h]=rumble_state
</TD></TR></TABLE>
Unknown if one of the two states has higher power-consumption than the other,
ie. if it's a "pull/release" mechanism, if so, then disabling rumble should be
done by using the "release" state, which would be AD1=0, or AD1=1...?<BR>
Note: The v3 firmware can detect the Rumble Pak as an option pak, but it does
not provide an enable/disable rumble option in the alarm menu.<BR>
<BR>
<B>Other DS Rumble device</B><BR>
There's also another DS add-on with rumble. That device uses AD8 (instead AD1)
to control rumble, and, it's using a classic motor (ie. it's rumbling while and
as long as the latched AD8 value is "1").<BR>
<A HREF="#dscartsliderwithrumble">DS Cart Slider with Rumble</A><BR>
<BR>
<B>GBA Rumble Carts</B><BR>
There are also a few GBA games that contain built-in Rumble, and which could be
used by NDS games as well. To be user friendly, best support both types.<BR>
<A HREF="#gbacartrumble">GBA Cart Rumble</A><BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dscartsliderwithrumble"></A>&nbsp;
  DS Cart Slider with Rumble
</FONT></TD></TR></TABLE><BR>
Add-on device for the japanese title Magukiddo. The optical sensor is attached
underneath of the console (connected to the GBA slot).<BR>
The sensor is an Agilent ADNS-2030 Low Power Optical Mouse Sensor (16pin DIP
chip with built-in optical sensor, and external LED light source) with two-wire
serial bus (CLK and DTA).<BR>
<BR>
<B>ADNS-2030 Registers (write 1 byte index, then read/write 1 byte data)</B><BR>
Index (Bit7=Direction; 0=Read, 1=Write):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h Product_ID (R) (03h)
  01h Revision_ID (R) (10h=Rev. 1.0) (20h=Used in DS-option-pak)
  02h Motion/Status Flags (R)
  03h Delta_X (R) (signed 8bit) (automatically reset to 00h after reading)
  04h Delta_Y (R) (signed 8bit) (automatically reset to 00h after reading)
  05h SQUAL (R) (surface quality) (unsigned 8bit)
  06h Average_Pixel (R) (unsigned 6bit, upper 2bit unused)
  07h Maximum_Pixel (R) (unsigned 6bit, upper 2bit unused)
  08h Reserved
  09h Reserved
  0Ah Configuration_bits (R/W)
  0Bh Reserved
  0Ch Data_Out_Lower (R)
  0Dh Data_Out_Upper (R)
  0Eh Shutter_Lower (R)
  0Fh Shutter_Upper (R)
  10h Frame_Period_Lower (R/W)
  11h Frame_Period_Upper (R/W)
</TD></TR></TABLE>
Motion/Status Flags:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7 Motion since last report or PD (0=None, 1=Motion occurred)
  6 Reserved
  5 LED Fault detected (0=No fault,  1=Fault detected)
  4 Delta Y Overflow (0=No overflow, 1=Overflow occured)
  3 Delta X Overflow (0=No overflow, 1=Overflow occured)
  2 Reserved
  1 Reserved
  0 Resolution in counts per inch (0=400, 1=800)
</TD></TR></TABLE>
Configuration_bits:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7 Reset Power up defaults (W) (0=No, 1=Reset)
  6 LED Shutter Mode (0=LED always on, 1=LED only on when shutter is open)
  5 Self Test (W) (0=No, 1=Perform all self tests)
  4 Resolution in counts per inch (0=400, 1=800)
  3 Dump 16x16 Pixel bitmap (0=No, 1=Dump via Data_Out ports)
  2 Reserved
  1 Reserved
  0 Sleep Mode (0=Normal/Sleep after 1 second, 1=Always awake)
                          _______
                         |74273  |
  /WR -----------------&gt; |CLK    |                       _____
  AD1/SIO CLK ---------&gt; |D1   Q1|--------------&gt; CLK   |74125|
  AD2 power control ---&gt; |D2   Q2|---&gt;     ____         |     |
  AD3/SIO DIR ---------&gt; |D3   Q3|------+-|7400\________|/EN  |
  AD8 rumble on/off ---&gt; |D?   Q?|---&gt;  +-|____/        |     |
  AD0/SIO DTA ----+----&gt; |D5   Q5|----------------------|A   Y|--+--DTA
                  |      |_______|                      |- - -|  |
          ____    +-------------------------------------|Y   A|--+
  /RD ---|7400\______ ____                              |     |
  /RD ---|____/      |7400\_____________________________|/EN  |
  A19 _______________|____/                             |_____|
</TD></TR></TABLE>
<BR>
7400 Quad NAND Gate, 74273 8bit Latch<BR>
<BR>
AD0 Optical Sensor Serial Data      (0=Low, 1=High)<BR>
AD1 Optical Sensor Serial Clock     (0=Low, 1=High)<BR>
AD2 Optical Sensor Power            (0=Off, 1=On)<BR>
AD3 Optical Sensor Serial Direction (0=Read, 1=Write)<BR>
AD8 Rumble Motor                    (0=Off, 1=On)<BR>
<BR>
Thanks: Daniel Palmer<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dscartexpansionram"></A>&nbsp;
  DS Cart Expansion RAM
</FONT></TD></TR></TABLE><BR>
<B>DS Memory Expansions</B><BR>
There are several RAM expansions for the NDS. The RAM cartridge connects to the
GBA slot; can can be then accessed from cartridges in the DS slot.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Opera         (8MB RAM) (official RAM expansion for Opera browser)
  EZ3/4/3-in-1  (8-16MB RAM, plus FLASH, plus rumble)
  Supercard     (32MB)
  M3            (32MB)
  G6            (32MB)
</TD></TR></TABLE>
The recommended access time (waitstates) for all memory types is unknown.
Unknown which programs do use these expansions for which purposes (aside from
the Opera browser).<BR>
Thanks to Rick "Lick" Wong for info on detection and unlocking.<BR>
<BR>
<B>Opera / DS Memory Expansion Pak (NTR-011 or USG-007)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  base=9000000h, size=800000h (8MB)
  unlock=1, lock=0
  STRH [8240000h],lock/unlock
</TD></TR></TABLE>
<BR>
<B>EZ</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  base=8400000h, size=VAR (8MB..16MB)
  locking/unlocking/detection see below
</TD></TR></TABLE>
<BR>
<B>Supercard</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  base=8000000h, size=1FFFFFEh (32MB minus last two bytes?)
  unlock=5 (RAM_RW), lock=3 (MEDIA)
  STRH [9FFFFFEh],A55Ah
  STRH [9FFFFFEh],A55Ah
  STRH [9FFFFFEh],lock/unlock
  STRH [9FFFFFEh],lock/unlock
</TD></TR></TABLE>
<BR>
<B>M3</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  base=8000000h, size=2000000h (32MB)
  unlock=00400006h, lock=00400003h
  LDRH Rd,[8E00002h]
  LDRH Rd,[800000Eh]
  LDRH Rd,[8801FFCh]
  LDRH Rd,[800104Ah]
  LDRH Rd,[8800612h]
  LDRH Rd,[8000000h]
  LDRH Rd,[8801B66h]
  LDRH Rd,[8000000h+(lock/unlock)*2]
  LDRH Rd,[800080Eh]
  LDRH Rd,[8000000h]
  LDRH Rd,[80001E4h]
  LDRH Rd,[80001E4h]
  LDRH Rd,[8000188h]
  LDRH Rd,[8000188h]
</TD></TR></TABLE>
<BR>
<B>G6</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  base=8000000h, size=2000000h (32MB)
  unlock=6, lock=3
  LDRH Rd,[9000000h]
  LDRH Rd,[9FFFFE0h]
  LDRH Rd,[9FFFFECh]
  LDRH Rd,[9FFFFECh]
  LDRH Rd,[9FFFFECh]
  LDRH Rd,[9FFFFFCh]
  LDRH Rd,[9FFFFFCh]
  LDRH Rd,[9FFFFFCh]
  LDRH Rd,[9FFFF4Ah]
  LDRH Rd,[9FFFF4Ah]
  LDRH Rd,[9FFFF4Ah]
  LDRH Rd,[9200000h+(lock/unlock)*2]
  LDRH Rd,[9FFFFF0h]
  LDRH Rd,[9FFFFE8h]
</TD></TR></TABLE>
<BR>
<B>Detection</B><BR>
For EZ, detection works as so:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 ez_ram_test:   ;Based on DSLinux Amadeus' detection
  ez_subfunc(9880000h,8000h) ;-SetRompage (OS mode)
  ez_subfunc(9C40000h,1500h) ;-OpenNorWrite
  [08400000h]=1234h          ;\
  if [08400000h]=1234h       ; test writability at 8400000h
    [8000000h]=4321h         ; and non-writability at 8000000h
    if [8000000h]&lt;&gt;4321h     ;
      return true            ;/
  ez_subfunc(9C40000h,D200h) ;CloseNorWrite
  ez_subfunc(9880000h,0160h) ;SetRompage (0160h)
  ez_subfunc(9C40000h,1500h) ;OpenNorWrite
  [8400000h]=1234h           ;\
  if [8400000h]=1234h        ; test writability at 8400000h
    return true              ;/
  return false               ;-failed
 ez_subfunc(addr,data):
  STRH [9FE0000h],D200h
  STRH [8000000h],1500h
  STRH [8020000h],D200h
  STRH [8040000h],1500h
  STRH [addr],data
  STRH [9FC0000h],1500h
</TD></TR></TABLE>
For all other types (everything except EZ), simply verify that you can write
(when unlocked), and that you can't (when locked).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dscartunknownextras"></A>&nbsp;
  DS Cart Unknown Extras
</FONT></TD></TR></TABLE><BR>
<B>DS Cartridges with built-in Infrared Port</B><BR>
Some NDS and DSi games (those with NTR-Ixxx or TWL-Ixxx gamecodes) contain
built-in Infrared ports; used to communicate with pedometers.<BR>
The IR-port is accessed via certain SPI bus commands; that bus is also shared
to access FLASH memory via other commands.<BR>
The FLASH chip seems to return a nonsense chip ID (maybe the cartridge is using
uncommon FLASH memory, or maybe the ID command is redirected to the IR-port
hardware).<BR>
The ROM chip does also respond with an uncommon ID (with one special bit set,
which is possibly indicating the presenence of the IR-hardware) (maybe the
IR-port is contained in the ROM chip, or maybe the SPI-bus sharing is handled
inside of the ROM chip.<BR>
The IR-related SPI commands are mostly unknown. Except that: command 08h should
return 55h (or some other non-FFh value), otherwise the game won't work in
emulators; this might be some IR-status byte.<BR>
<BR>
<B>DS Cartridges with NAND memory</B><BR>
Some NDS games (eg. Warioware D.I.Y.) contain NAND memory, this memory contains
both the game and save memory (normal NDS games contain separate ROM and
FLASH/EEPROM chips for that purposes) (the advantage is that NAND allows more
storage than the usual FLASH chips).<BR>
The Warioware D.I.Y. PCB is marked "DI X-7 C17-01", and it does contain only
one single chip, marked "SAMSUNG 004, KLC2811ANB-P204, NTR-UORE-0".<BR>
That NAND chip connects directly to the NDS parallel bus (the serial SPI
chipselect is left unconnected). Unknown how to write to the chip, and unknown
if certain regions are write-protected.<BR>
<BR>
<B>DS Cartridges with built-in MicroSD Card Slot</B><BR>
The DS Vision cartridge contains a built-in microSD card slot. Users can
download videos from internet (against a few), store the videos on microSD
cards, and then view them on the NDS via DS Vision cartridge.<BR>
Unknown how the microSD is accessed; via parallel 'ROM' bus and/or via serieal
SPI bus; by which commands? Also unknown if the thing contains built-in video
decoder hardware, or if videos are decoded on ARM cpus.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dscartcheatactionreplayds"></A>&nbsp;
  DS Cart Cheat Action Replay DS
</FONT></TD></TR></TABLE><BR>
The first commercial DS cheat code solution, this device was developed by
Datel. It supports swapping out cartridges after loading the AR software. For
updating, the user may either manually enter codes or use the included
proprietary USB cable that comes with the device. The user has been able to
manually update codes since firmware version 1.52.<BR>
<BR>
<B>Action Replay DS Codes</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ABCD-NNNNNNNN       Game ID ;ASCII Gamecode [00Ch] and CRC32 across [0..1FFh]
  00000000 XXXXXXXX   manual hook codes (rarely used) (default is auto hook)
  0XXXXXXX YYYYYYYY   word[XXXXXXX+offset] = YYYYYYYY
  1XXXXXXX 0000YYYY   half[XXXXXXX+offset] = YYYY
  2XXXXXXX 000000YY   byte[XXXXXXX+offset] = YY
  3XXXXXXX YYYYYYYY   IF YYYYYYYY &gt; word[XXXXXXX]   ;unsigned    ;\
  4XXXXXXX YYYYYYYY   IF YYYYYYYY &lt; word[XXXXXXX]   ;unsigned    ; for v1.54,
  5XXXXXXX YYYYYYYY   IF YYYYYYYY = word[XXXXXXX]                ; when X=0,
  6XXXXXXX YYYYYYYY   IF YYYYYYYY &lt;&gt; word[XXXXXXX]               ; uses
  7XXXXXXX ZZZZYYYY   IF YYYY &gt; ((not ZZZZ) AND half[XXXXXXX])   ; [offset]
  8XXXXXXX ZZZZYYYY   IF YYYY &lt; ((not ZZZZ) AND half[XXXXXXX])   ; instead of
  9XXXXXXX ZZZZYYYY   IF YYYY = ((not ZZZZ) AND half[XXXXXXX])   ; [XXXXXXX]
  AXXXXXXX ZZZZYYYY   IF YYYY &lt;&gt; ((not ZZZZ) AND half[XXXXXXX])  ;/
  BXXXXXXX 00000000   offset = word[XXXXXXX+offset]
  C0000000 YYYYYYYY   FOR loopcount=0 to YYYYYYYY  ;execute Y+1 times
  C4000000 00000000   offset = address of the C4000000 code           ;v1.54
  C5000000 XXXXYYYY   counter=counter+1, IF (counter AND YYYY) = XXXX ;v1.54
  C6000000 XXXXXXXX   [XXXXXXXX]=offset                               ;v1.54
  D0000000 00000000   ENDIF
  D1000000 00000000   NEXT loopcount
  D2000000 00000000   NEXT loopcount, and then FLUSH everything
  D3000000 XXXXXXXX   offset = XXXXXXXX
  D4000000 XXXXXXXX   datareg = datareg + XXXXXXXX
  D5000000 XXXXXXXX   datareg = XXXXXXXX
  D6000000 XXXXXXXX   word[XXXXXXXX+offset]=datareg, offset=offset+4
  D7000000 XXXXXXXX   half[XXXXXXXX+offset]=datareg, offset=offset+2
  D8000000 XXXXXXXX   byte[XXXXXXXX+offset]=datareg, offset=offset+1
  D9000000 XXXXXXXX   datareg = word[XXXXXXXX+offset]
  DA000000 XXXXXXXX   datareg = half[XXXXXXXX+offset]
  DB000000 XXXXXXXX   datareg = byte[XXXXXXXX+offset] ;bugged on pre-v1.54
  DC000000 XXXXXXXX   offset = offset + XXXXXXXX
  EXXXXXXX YYYYYYYY   Copy YYYYYYYY parameter bytes to [XXXXXXXX+offset...]
  44332211 88776655   parameter bytes 1..8 for above code  (example)
  0000AA99 00000000   parameter bytes 9..10 for above code (padded with 00s)
  FXXXXXXX YYYYYYYY   Copy YYYYYYYY bytes from [offset..] to [XXXXXXX...]
</TD></TR></TABLE>
IF/ENDIF can be nested up to 32 times. FOR/NEXT cannot be nested, any FOR
statement does forcefully terminate any prior loop. FOR does backup the current
IF condidition flags, and NEXT does restore these flags, so ENDIF(s) aren't
required inside of the loop. The NEXT+FLUSH command does (after finishing the
loop) reset offset=0, datareg=0, and does clear all condition flags, so further
ENDIF(s) aren't required after the loop.<BR>
Before v1.54, the DB000000 code did accidently set offset=offset+XXXXXXX after
execution of the code. For all word/halfword accesses, the address should be
aligned accordingly. For the COPY commands, addresses should be aligned by four
(all data is copied with ldr/str, except, on odd lengths, the last 1..3 bytes
do use ldrb/strb).<BR>
offset, datareg, loopcount, and counter are internal registers in the action
replay software.<BR>
<BR>
&gt; The condition register is checked, for all code types<BR>
&gt; but the D0, D1 and D2 code type<BR>
Makes sense.<BR>
<BR>
&gt; and for the C5 code type it's checked AFTER the counter has<BR>
&gt; been incremented (so the counter is always incremented<BR>
I love that exceptions ;-)<BR>
<BR>
<B>Hook</B><BR>
The hook codes consist of a series of nine 00000000 XXXXXXXX codes, and must be
marked as (M) code (for not being confused with normal 0XXXXXXX YYYYYYYY
codes). For all nine codes, the left 32bit are actually don't care (but should
be zero), the meaning of the right 32bit varies from 1st to 9th code.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1st: Address used prior to launching game (eg. 23xxxxxh)
  2nd: Address to write the hook at (inside the ARM7 executable)
  3rd: Hook final address (huh?)
  4th: Hook mode selection (0=auto, 1=mode1, 2=mode2)
  5th: Opcode that replaces the hooked one (eg. E51DE004h)
  6th: Address to store important stuff  (default 23FE000h)
  7th: Address to store the code handler (default 23FE074h)
  8th: Address to store the code list    (default 23FE564h)
  9th: Must be 1 (00000001h)
</TD></TR></TABLE>
For most games, the AR does automatically hook code on the ARM7. Doing that
automatically is nice, but hooking ARM7 means that there is no access to VRAM,
TCM and Cache, which &lt;might&gt; cause problems since efficient games
&lt;should&gt; store all important data in TCM or Cache (though, in practice,
I'd doubt that any existing NDS games are that efficient).<BR>
<BR>
<B>Thanks</B><BR>
To Kenobi and Dualscreenman from Kodewerx for above ARDS cheat info.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dscartcheatcodebreakerds"></A>&nbsp;
  DS Cart Cheat Codebreaker DS
</FONT></TD></TR></TABLE><BR>
This is Pelican's entry into the DS cheat-device industry. It supports swapping
out the cartridges, and alternately, also gives the user the option of
connecting another gamecard onto it. For updating, the user may either manually
enter codes, or use Wifi to connect to the Codebreaker update site (that
updating will overwrite all manually entered codes though).<BR>
<BR>
<B>Codebreaker DS Codes</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ---Initialization---
  0000CR16 GAMECODE                    Specify Game ID, use Encrypted codes
  8000CR16 GAMECODE                    Specify Game ID, use Unencrypted codes
  BEEFC0DE XXXXXXXX                    Change Encryption Keys
  A0XXXXXX YYYYYYYY                    Bootup-Hook 1, X=Address, Y=Value
  A8XXXXXX YYYYYYYY                    Bootup-Hook 2, X=Address, Y=Value
  F0XXXXXX TYYYYYYY         Code-Hook 1 (T=Type,Y=CheatEngineAddr,X=HookAddr)
  F8XXXXXX TPPPPPPP         Code-Hook 2 (T=Type,X=CheatEngineHookAddr,P=Params)
  ---General codes---
  00XXXXXX 000000YY                    [X]=YY
  10XXXXXX 0000YYYY                    [X]=YYYY
  20XXXXXX YYYYYYYY                    [X]=YYYYYYYY
  60XXXXXX 000000YY ZZZZZZZZ 00000000  [[X]+Z]=YY
  60XXXXXX 0000YYYY ZZZZZZZZ 10000000  [[X]+Z]=YYYY
  60XXXXXX YYYYYYYY ZZZZZZZZ 20000000  [[X]+Z]=YYYYYYYY
  30XXXXXX 000000YY                    [X]=[X] + YY
  30XXXXXX 0001YYYY                    [X]=[X] + YYYY
  38XXXXXX YYYYYYYY                    [X]=[X] + YYYYYYYY
  70XXXXXX 000000YY                    [X]=[X] OR  YY
  70XXXXXX 001000YY                    [X]=[X] AND YY
  70XXXXXX 002000YY                    [X]=[X] XOR YY
  70XXXXXX 0001YYYY                    [X]=[X] OR  YYYY
  70XXXXXX 0011YYYY                    [X]=[X] AND YYYY
  70XXXXXX 0021YYYY                    [X]=[X] XOR YYYY
  ---Memory fill/copy---
  40XXXXXX 2NUMSTEP 000000YY 000000ZZ  byte[X+(0..NUM-1)*STEP*1]=Y+(0..NUM-1)*Z
  40XXXXXX 1NUMSTEP 0000YYYY 0000ZZZZ  half[X+(0..NUM-1)*STEP*2]=Y+(0..NUM-1)*Z
  40XXXXXX 0NUMSTEP YYYYYYYY ZZZZZZZZ  word[X+(0..NUM-1)*STEP*4]=Y+(0..NUM-1)*Z
  50XXXXXX YYYYYYYY ZZZZZZZZ 00000000  copy Y bytes from [X] to [Z]
  ---Conditional codes (bugged)---
  60XXXXXX 000000YY ZZZZZZZZ 01c100VV  IF [[X]+Z] .. VV   THEN [[X]+Z]=YY
  60XXXXXX 000000YY ZZZZZZZZ 01c0VVVV  IF [[X]+Z] .. VVVV THEN [[X]+Z]=YY
  60XXXXXX 0000YYYY ZZZZZZZZ 11c100VV  IF [[X]+Z] .. VV   THEN [[X]+Z]=YYYY
  60XXXXXX 0000YYYY ZZZZZZZZ 11c0VVVV  IF [[X]+Z] .. VVVV THEN [[X]+Z]=YYYY
  60XXXXXX YYYYYYYY ZZZZZZZZ 21c100VV  IF [[X]+Z] .. VV   THEN [[X]+Z]=YYYYYYYY
  60XXXXXX YYYYYYYY ZZZZZZZZ 21c0VVVV  IF [[X]+Z] .. VVVV THEN [[X]+Z]=YYYYYYYY
  ---Conditional codes (working)---
  D0XXXXXX NNc100YY                    IF [X] .. YY   THEN exec max(1,NN) lines
  D0XXXXXX NNc0YYYY                    IF [X] .. YYYY THEN exec max(1,NN) lines
</TD></TR></TABLE>
The condition digits (c=0..7), have the following functions:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0 IF [mem] =  imm THEN ...              4 IF ([mem] AND imm) =  0   THEN ...
  1 IF [mem] &lt;&gt; imm THEN ...              5 IF ([mem] AND imm) &lt;&gt; 0   THEN ...
  2 IF [mem] &lt;  imm THEN ... (unsigned)   6 IF ([mem] AND imm) =  imm THEN ...
  3 IF [mem] &gt;  imm THEN ... (unsigned)   7 IF ([mem] AND imm) &lt;&gt; imm THEN ...
</TD></TR></TABLE>
Notes<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  GAMECODE  Cartridge Header[00Ch] (32bit in reversed byte-order)
  CR16      Cartridge Header[15Eh] (16bit in normal byte-order)
  XXXXXX    27bit addr (actually 7 digits, XXXXXXX, overlaps 5bit code number)
</TD></TR></TABLE>
The "bugged" conditional codes (60XXXXXX) are accidently skipping NN lines when
the condition is false, where NN is taken from the upper 8bit of the code's
last 32bit values (ie. exactly as for the D0XXXXXX codes). For byte-writes,
that would be NN=01h, which can be eventually dealt with, although there may be
compatibility problems which future versions that might fix that bug. For
halfword/word writes, NN would be 11h or 21h, so that codes are about totally
unusable.<BR>
<BR>
<B>Codebreaker DS / Encrypted Codes</B><BR>
The overall "address value" decryption works like so:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  for i=4Fh to 00h
    y=77628ECFh
    if i&gt;13h then y=59E5DC8Ah
    if i&gt;27h then y=054A7818h
    if i&gt;3Bh then y=B1BF0855h
    address = (Key0-value) xor address
    value   = value - Key1 - (address ror 1Bh)
    address = (address xor (value + y)) ror 13h
    if (i&gt;13h) then
      if (i&lt;=27h) or (i&gt;3Bh) then x=Key2 xor Key1 xor Key0
      else x=((Key2 xor Key1) and Key0) xor (Key1 and Key2)
      value=value xor (x+y+address)
      x = Secure[((i*4+00h) and FCh)+000h]
      x = Secure[((i*4+34h) and FCh)+100h] xor x
      x = Secure[((i*4+20h) and FCh)+200h] xor x
      x = Secure[((i*4+08h) and FCh)+300h] xor x
      address = address - (x ror 19h)
  next i
</TD></TR></TABLE>
Upon startup, the initial key settings are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Secure[0..7FFh] = Copy of the ENCRYPTED 1st 2Kbytes of the game's Secure Area
  Key0 = 0C2EAB3Eh, Key1 = E2AE295Dh, Key2 = E1ACC3FFh, Key3 = 70D3AF46h
  scramble_keys
</TD></TR></TABLE>
Upon BEEFC0DE XXXXXXXX, the keys get changed like so:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Key0 = Key0 + (XXXXXXXX ror 1Dh)
  Key1 = Key1 - (XXXXXXXX ror 05h)
  Key2 = Key2 xor (Key3 xor Key0)
  Key3 = Key3 xor (Key2  -  Key1)
  scramble_keys
</TD></TR></TABLE>
The above scramble_keys function works like so:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  for i=0 to FFh
    y = byte(xlat_table[i])
    Secure[i*4+000h] = (Secure[i*4+000h] xor Secure[y*4]) + Secure[y*4+100h]
    Secure[i*4+400h] = (Secure[i*4+400h] xor Secure[y*4]) - Secure[y*4+200h]
  next i
  for i=0 to 63h
    Key0 = Key0 xor (Secure[i*4] + Secure[i*4+190h])
    Key1 = Key1 xor (Secure[i*4] + Secure[i*4+320h])
    Key2 = Key2 xor (Secure[i*4] + Secure[i*4+4B0h])
    Key3 = Key3 xor (Secure[i*4] + Secure[i*4+640h])
  next i
  Key0 = Key0  -  Secure[7D0h]
  Key1 = Key1 xor Secure[7E0h]
  Key2 = Key2  +  Secure[7F0h]
  Key3 = Key3 xor Secure[7D0h] xor Secure[7F0h]
</TD></TR></TABLE>
the xlat_table consists of 256 fixed 8bit values:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  34h,59h,00h,32h,7Bh,D3h,32h,C9h,9Bh,77h,75h,44h,E0h,73h,46h,06h
  0Bh,88h,B3h,3Eh,ACh,F2h,BAh,FBh,2Bh,56h,FEh,7Ah,90h,F7h,8Dh,BCh
  8Bh,86h,9Ch,89h,00h,19h,CDh,4Ch,54h,30h,01h,93h,30h,01h,FCh,36h
  4Dh,9Fh,FDh,D7h,32h,94h,AEh,BCh,2Bh,61h,DFh,B3h,44h,EAh,8Bh,A3h
  2Bh,53h,33h,54h,42h,27h,21h,DFh,A9h,DDh,C0h,35h,58h,EFh,8Bh,33h
  B4h,D3h,1Bh,C7h,93h,AEh,32h,30h,F1h,CDh,A8h,8Ah,47h,8Ch,70h,0Ch
  17h,4Eh,0Eh,A2h,85h,0Dh,6Eh,37h,4Ch,39h,1Fh,44h,98h,26h,D8h,A1h
  B6h,54h,F3h,AFh,98h,83h,74h,0Eh,13h,6Eh,F4h,F7h,86h,80h,ECh,8Eh
  EEh,4Ah,05h,A1h,F1h,EAh,B4h,D6h,B8h,65h,8Ah,39h,B3h,59h,11h,20h
  B6h,BBh,4Dh,88h,68h,24h,12h,9Bh,59h,38h,06h,FAh,15h,1Dh,40h,F0h
  01h,77h,57h,F5h,5Dh,76h,E5h,F1h,51h,7Dh,B4h,FAh,7Eh,D6h,32h,4Fh
  0Eh,C8h,61h,C1h,EEh,FBh,2Ah,FCh,ABh,EAh,97h,D5h,5Dh,E8h,FAh,2Ch
  06h,CCh,86h,D2h,8Ch,10h,D7h,4Ah,CEh,8Fh,EBh,03h,16h,ADh,84h,98h
  F5h,88h,2Ah,18h,ACh,7Fh,F6h,94h,FBh,3Fh,00h,B6h,32h,A2h,ABh,28h
  64h,5Ch,0Fh,C6h,23h,12h,0Ch,D2h,BAh,4Dh,A3h,F2h,C9h,86h,31h,57h
  0Eh,F8h,ECh,E1h,A0h,9Ah,3Ch,65h,17h,18h,A0h,81h,D0h,DBh,D5h,AEh
</TD></TR></TABLE>
all used operations are unsigned 32bit integer.<BR>
<BR>
<B>Thanks</B><BR>
To Kenobi and Dualscreenman from Kodewerx for above CBDS cheat info.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsencryptionbygamecodeidcodekey1"></A>&nbsp;
  DS Encryption by Gamecode/Idcode (KEY1)
</FONT></TD></TR></TABLE><BR>
<B>KEY1 - Gamecode / Idcode Encryption</B><BR>
The KEY1 encryption relies only on the gamecode (or firmware idcode), it does
not contain any random components. The fact that KEY1 encrypted commands appear
random is just because the &lt;unencrypted&gt; commands contain random values,
so the encryption result looks random.<BR>
<BR>
KEY1 encryption is used for KEY1 encrypted gamecart commands (ie. for loading
the secure area). It is also used for resolving the extra decryption of the
first 2K of the secure area, and for firmware decryption, and to decode some
encrypted values in gamecart/firmware header.<BR>
<BR>
<B>Initial Encryption Values</B><BR>
Below formulas can be used only with a copy of the 1048h-byte key tables from
NDS/DSi BIOS. The values can be found at:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  NDS.ARM7 ROM: 00000030h..00001077h (values 99 D5 20 5F ..) Blowfish/NDS-mode
  DSi.ARM9 ROM: FFFF99A0h..FFFFA9E7h (values 99 D5 20 5F ..) ""
  DSi.TCM Copy: 01FFC894h..01FFD8DBh (values 99 D5 20 5F ..) ""
  DSi.ARM7 ROM: 0000C6D0h..0000D717h (values 59 AA 56 8E ..) Blowfish/DSi-mode
  DSi.RAM Copy: 03FFC654h..03FFD69Bh (values 59 AA 56 8E ..) ""
</TD></TR></TABLE>
The DSi ROM sections are disabled after booting, but the RAM/TCM copies can be
dumped (at least with some complex main memory hardware mods).<BR>
<BR>
<B>encrypt_64bit(ptr) / decrypt_64bit(ptr)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Y=[ptr+0]
  X=[ptr+4]
  FOR I=0 TO 0Fh (encrypt), or FOR I=11h TO 02h (decrypt)
    Z=[keybuf+I*4] XOR X
    X=[keybuf+048h+((Z SHR 24) AND FFh)*4]
    X=[keybuf+448h+((Z SHR 16) AND FFh)*4] + X
    X=[keybuf+848h+((Z SHR  8) AND FFh)*4] XOR X
    X=[keybuf+C48h+((Z SHR  0) AND FFh)*4] + X
    X=Y XOR X
    Y=Z
  NEXT I
  [ptr+0]=X XOR [keybuf+40h] (encrypt), or [ptr+0]=X XOR [keybuf+4h] (decrypt)
  [ptr+4]=Y XOR [keybuf+44h] (encrypt), or [ptr+4]=Y XOR [keybuf+0h] (decrypt)
</TD></TR></TABLE>
<BR>
<B>apply_keycode(modulo)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  encrypt_64bit(keycode+4)
  encrypt_64bit(keycode+0)
  [scratch]=0000000000000000h   ;S=0 (64bit)
  FOR I=0 TO 44h STEP 4         ;xor with reversed byte-order (bswap)
    [keybuf+I]=[keybuf+I] XOR bswap_32bit([keycode+(I MOD modulo)])
  NEXT I
  FOR I=0 TO 1040h STEP 8
    encrypt_64bit(scratch)      ;encrypt S (64bit) by keybuf
    [keybuf+I+0]=[scratch+4]    ;write S to keybuf (first upper 32bit)
    [keybuf+I+4]=[scratch+0]    ;write S to keybuf (then lower 32bit)
  NEXT I
</TD></TR></TABLE>
<BR>
<B>init_keycode(idcode,level,modulo,key)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  if key=nds then copy [nds_arm7bios+0030h..1077h] to [keybuf+0..1047h]
  if key=dsi then copy [dsi_arm7bios+C6D0h..D717h] to [keybuf+0..1047h]
  [keycode+0]=[idcode]
  [keycode+4]=[idcode]/2
  [keycode+8]=[idcode]*2
  IF level&gt;=1 THEN apply_keycode(modulo) ;first apply (always)
  IF level&gt;=2 THEN apply_keycode(modulo) ;second apply (optional)
  [keycode+4]=[keycode+4]*2
  [keycode+8]=[keycode+8]/2
  IF level&gt;=3 THEN apply_keycode(modulo) ;third apply (optional)
</TD></TR></TABLE>
<BR>
<B>firmware_decryption</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  init_keycode(firmware_header+08h,1,0Ch,nds) ;idcode (usually "MACP"), level 1
  decrypt_64bit(firmware_header+18h)          ;rominfo
  init_keycode(firmware_header+08h,2,0Ch,nds) ;idcode (usually "MACP"), level 2
  decrypt ARM9 and ARM7 bootcode by decrypt_64bit (each 8 bytes)
  decompress ARM9 and ARM7 bootcode by LZ77 function (swi)
  calc CRC16 on decrypted/decompressed ARM9 bootcode followed by ARM7 bootcode
</TD></TR></TABLE>
Note: The sizes of the compressed/encrypted bootcode areas are unknown (until
they are fully decompressed), one way to solve that problem is to decrypt the
next 8 bytes each time when the decompression function requires more data.<BR>
<BR>
<B>gamecart_decryption</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  init_keycode(cart_header+0Ch,1,08h,nds)   ;gamecode, level 1, modulo 8
  decrypt_64bit(cart_header+78h)            ;rominfo (secure area disable)
  init_keycode(cart_header+0Ch,2,08h,nds)   ;gamecode, level 2, modulo 8
  encrypt_64bit all NDS KEY1 commands (1st command byte in MSB of 64bit value)
  after loading the secure_area, calculate secure_area crc, then
  decrypt_64bit(secure_area+0)              ;first 8 bytes of secure area
  init_keycode(cart_header+0Ch,3,08h,nds)   ;gamecode, level 3, modulo 8
  decrypt_64bit(secure_area+0..7F8h)        ;each 8 bytes in first 2K of secure
  init_keycode(cart_header+0Ch,1,08h,dsi)   ;gamecode, level 1, modulo 8
  encrypt_64bit all DSi KEY1 commands (1st command byte in MSB of 64bit value)
</TD></TR></TABLE>
After secure area decryption, the ID field in the first 8 bytes should be
"encryObj", if it matches then first 8 bytes are filled with E7FFDEFFh,
otherwise the whole 2K are filled by that value.<BR>
<BR>
<B>Gamecart Command Register</B><BR>
Observe that the byte-order of the command register [40001A8h] is reversed. The
way how the CPU stores 64bit data in memory (and the way how the
"encrypt_64bit" function for KEY1-encrypted commands expects data in memory) is
LSB at [addr+0] and MSB at [addr+7]. This value is to be transferred MSB first.
However, the DS hardware transfers [40001A8h+0] first, and [40001A8h+7] last.
So, the byte order must be reversed when copying the value from memory to the
command register.<BR>
<BR>
<B>Note</B><BR>
The KEY1 encryption is based on Bruce Schneier's "Blowfish Encryption
Algorithm".<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsencryptionbyrandomseedkey2"></A>&nbsp;
  DS Encryption by Random Seed (KEY2)
</FONT></TD></TR></TABLE><BR>
<B>KEY2 39bit Seed Values</B><BR>
The pre-initialization settings at cartridge-side (after reset) are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Seed0 = 58C56DE0E8h
  Seed1 = 5C879B9B05h
</TD></TR></TABLE>
The post-initialization settings (after sending command 4llllmmmnnnkkkkkh to
the cartridge, and after writing the Seed values to Port 40001Bxh) are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Seed0 = (mmmnnn SHL 15)+6000h+Seedbyte
  Seed1 = 5C879B9B05h
</TD></TR></TABLE>
The seedbyte is selected by Cartridge Header [013h].Bit0-2, this index value
should be usually in range 0..5, however, possible values for index 0..7 are:
E8h,4Dh,5Ah,B1h,17h,8Fh,99h,D5h.<BR>
The 24bit random value (mmmnnn) is derived from the real time clock setting,
and also scattered by KEY1 encryption, anyways, it's just random and doesn't
really matter where it comes from.<BR>
<BR>
<B>KEY2 Encryption</B><BR>
Relies on two 39bit registers (x and y), which are initialized as such:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  x = reversed_bit_order(seed0)  ;ie. LSB(bit0) exchanged with MSB(bit38), etc.
  y = reversed_bit_order(seed1)
</TD></TR></TABLE>
During transfer, x, y, and transferred data are modified as such:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  x = (((x shr 5)xor(x shr 17)xor(x shr 18)xor(x shr 31)) and 0FFh)+(x shl 8)
  y = (((y shr 5)xor(y shr 23)xor(y shr 18)xor(y shr 31)) and 0FFh)+(y shl 8)
  data = (data xor x xor y) and 0FFh
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsfirmwareserialflashmemory"></A>&nbsp;
  DS Firmware Serial Flash Memory
</FONT></TD></TR></TABLE><BR>
<B>ST Microelectronics SPI Bus Compatible Serial FLASH Memory</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ID 20h,40h,12h - ST M45PE20 - 256 KBytes (Nintendo DS) (in my old DS)
  ID 20h,50h,12h - ST M35PE20 - 256 KBytes (Nintendo DS) (in my DS-Lite)
  ID 20h,80h,13h - ST M25PE40 - 512 KBytes (iQue DS, with chinese charset)
  ID 20h,40h,11h - ST 45PE10V6 - 128 Kbytes (Nintendo DSi) (in my DSi)
  ID 20h,40h,13h - ST 45PE40V6 - 512 KBytes (DS Zelda, NTR-AZEP-0)
  ID 20h,40h,14h - ST 45PE80V6 - 1024 Kbytes (eg. Spirit Tracks, NTR-BKIP)
 +ID 62h,11h,00h - Sanyo ?          - 512 Kbytes (P-Letter Diamond, ADAE)
  ID 62h,16h,00h - Sanyo LE25FW203T - 256 KBytes (Mariokart backup)
 +ID 62h,26h,11h - Sanyo ?          - ? Kbytes (3DS: CTR-P-AXXJ)
 +ID 62h,26h,13h - Sanyo ?          - ? Kbytes (3DS: CTR-P-APDJ)
  ID C2h,22h,11h - Macronix MX25L1021E? 128 Kbytes (eg. 3DS Starfox)
  ID C2h,22h,13h - Macronix ...? 512 Kbytes (eg. 3DS Kid Icarus, 3DS Sims 3)
  ID C2h,20h,17h - Macronix MX25L6445EZNI-10G 8192 Kbytes (DSi Art Academy)
  ID 01h,F0h,00h - Garbage/Infrared on SPI-bus? (eg. P-Letter White)
  ID 03h,F8h,00h - Garbage/Infrared on SPI-bus? (eg. P-Letter White 2)
</TD></TR></TABLE>
FLASH has more than 100,000 Write Cycles, more than 20 Year Data Retention<BR>
The Firmware Flash Memory is accessed via SPI bus,<BR>
<A HREF="#dsserialperipheralinterfacebusspi">DS Serial Peripheral Interface Bus (SPI)</A><BR>
<BR>
<B>Instruction Codes</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  06h  WREN Write Enable (No Parameters)
  04h  WRDI Write Disable (No Parameters)
  9Fh  RDID Read JEDEC Identification (Read 1..3 ID Bytes)
             (Manufacturer, Device Type, Capacity)
  05h  RDSR Read Status Register (Read Status Register, endless repeated)
             Bit7-2  Not used (zero)
             Bit1    WEL Write Enable Latch             (0=No, 1=Enable)
             Bit0    WIP Write/Program/Erase in Progess (0=No, 1=Busy)
  03h  READ Read Data Bytes (Write 3-Byte-Address, read endless data stream)
  0Bh  FAST Read Data Bytes at Higher Speed (Write 3-Byte-Address, write 1
             dummy-byte, read endless data stream) (max 25Mbit/s)
  0Ah  PW   Page Write (Write 3-Byte-Address, write 1..256 data bytes)
             (changing bits to 0 or 1) (reads unchanged data, erases the page,
             then writes new &amp; unchanged data) (11ms typ, 25ms max)
  02h  PP   Page Program (Write 3-Byte-Address, write 1..256 data bytes)
             (changing bits from 1 to 0) (1.2ms typ, 5ms max)
  DBh  PE   Page Erase 100h bytes (Write 3-Byte-Address) (10ms typ, 20ms max)
  D8h  SE   Sector Erase 10000h bytes (Write 3-Byte-Address) (1s typ, 5s max)
  B9h  DP   Deep Power-down (No Parameters) (consumption 1uA typ, 10uA max)
             (3us) (ignores all further instructions, except RDP)
  ABh  RDP  Release from Deep Power-down (No Parameters) (30us)
</TD></TR></TABLE>
Write/Program may not cross page-boundaries. Write/Program/Erase are rejected
during first 1..10ms after power up. The WEL bit is automatically cleared on
Power-Up, on /Reset, and on completion of WRDI/PW/PP/PE/SE instructions. WEL is
set by WREN instruction (which must be issued before any write/program/erase
instructions). Don't know how RDSR behaves when trying to write to the
write-protected region?<BR>
<BR>
<B>Communication Protocol</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Set Chip Select LOW to invoke the command
  Transmit the instruction byte
  Transmit any parameter bytes
  Transmit/receive any data bytes
  Set Chip Select HIGH to finish the command
</TD></TR></TABLE>
All bytes (and 3-byte addresses) transferred most significant bit/byte first.<BR>
<BR>
<B>Pin-Outs</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1   D    Serial Data In (latched at rising clock edge)          _________
  2   C    Serial Clock (max 25MHz)                             /|o        |
  3   /RES Reset                                            1 -| |         |- 8
  4   /S   Chip Select (instructions start at falling edge) 2 -| |         |- 7
  5   /W   Write Protect (makes first 256 pages read-only)  3 -| |_________|- 6
  6   VCC  Supply (2.7V..3.6V typ) (4V max) (DS:VDD3.3)     4 -|/          |- 5
  7   VSS  Ground                                              |___________|
  8   Q    Serial Data Out (changes at falling clock edge)
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsfirmwareheader"></A>&nbsp;
  DS Firmware Header
</FONT></TD></TR></TABLE><BR>
<B>Firmware Memory Map</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00000h-00029h  Firmware Header
  0002Ah-001FFh  Wifi Settings
  00200h-3F9FFh  Firmware Code/Data
  3FA00h-3FAFFh  Wifi Access Point 1
  3FB00h-3FBFFh  Wifi Access Point 2
  3FC00h-3FCFFh  Wifi Access Point 3
  3FD00h-3FDFFh  Not used
  3FE00h-3FEFFh  User Settings Area 1
  3FF00h-3FFFFh  User Settings Area 2
</TD></TR></TABLE>
On iQue DS (with 512K flash memory), user settings are moved to 7FE00h and up,
and, there seems to be some unknown stuff at 200h..27Fh.<BR>
<BR>
<B>Firmware Header (00000h-001FFh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Addr Size Expl.
  000h 2    part3 romaddr/8 (arm9 gui code) (LZ/huffman compression)
  002h 2    part4 romaddr/8 (arm7 wifi code) (LZ/huffman compression)
  004h 2    part3/4 CRC16 arm9/7 gui/wifi code
  006h 2    part1/2 CRC16 arm9/7 boot code
  008h 4    firmware identifier (usually nintendo "MAC",nn) (or nocash "XBOO")
            the 4th byte (nn) occassionally changes in different versions
  00Ch 2    part1 arm9 boot code romaddr/2^(2+shift1) (LZSS compressed)
  00Eh 2    part1 arm9 boot code 2800000h-ramaddr/2^(2+shift2)
  010h 2    part2 arm7 boot code romaddr/2^(2+shift3) (LZSS compressed)
  012h 2    part2 arm7 boot code 3810000h-ramaddr/2^(2+shift4)
  014h 2    shift amounts, bit0-2=shift1, bit3-5=shift2, bit6-8=shift3,
            bit9-11=shift4, bit12-15=firmware_chipsize/128K
  016h 2    part5 data/gfx romaddr/8 (LZ/huffman compression)
  018h 8    Optional KEY1-encrypted "enPngOFF"=Cartridge KEY2 Disable
            (feature isn't used in any consoles, instead contains timestamp)
  018h 5    Firmware version built timestamp (BCD minute,hour,day,month,year)
  01Dh 1    Console type
              FFh=Nintendo DS
              20h=Nintendo DS-lite
              57h=Nintendo DSi
              43h=iQueDS
              63h=iQueDS-lite
            The entry was unused (FFh) in older NDS, ie. replace FFh by 00h)
              Bit0   seems to be DSi/iQue related
              Bit1   seems to be DSi/iQue related
              Bit2   seems to be DSi related
              Bit3   zero
              Bit4   seems to be DSi related
              Bit5   seems to be DS-Lite related
              Bit6   indicates presence of "extended" user settings (DSi/iQue)
              Bit7   zero
  01Eh 2    Unused (FFh-filled)
  020h 2    User Settings Offset (div8) (usually last 200h flash bytes)
  022h 2    Unknown (7EC0h or 0B51h)
  024h 2    Unknown (7E40h or 0DB3h)
  026h 2    part5 CRC16 data/gfx
  028h 2    unused (FFh-filled)
  02Ah-1FFh Wifi Calibration Data (see next chapter)
</TD></TR></TABLE>
<BR>
<B>DSi</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h..01Ch=Zerofilled (bootcode is in new NAND chip, not on old FLASH chip)
  01Dh..021h=Same as on DS (header: Console Type and User Settings Offset)
  022h..027h=Zerofilled (bootcode is in new NAND chip, not on old FLASH chip)
  028h..1FCh=Same as on DS (wifi calibration)
  1FDh      =01h for DWM-W015, 02h for DWM-W024 ;\
  1FEh      =20h                                ; this was FFh-filled on DS
  1FFh      =Same as on DS (FFh)                ;/
  200h..2FEh=00h-filled                         ;\
  2FFh      =80h                                ; this was bootcode on DS
  3FFh..1F3FFh=FFh-filled                       ;/
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsfirmwarewificalibrationdata"></A>&nbsp;
  DS Firmware Wifi Calibration Data
</FONT></TD></TR></TABLE><BR>
<B>Wifi Calibration/Settings (located directly after Firmware Header)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Addr Size Expl.
  000h-029h Firmware Header (see previous chapter)
  02Ah 2    CRC16 (with initial value 0) of [2Ch..2Ch+config_length-1]
  02Ch 2    config_length (usually 0138h, ie. entries 2Ch..163h)
  02Eh 1    Unused        (00h)
  02Fh 1    Wifi version  (00h=v1..v4, 03h=v5, 05h=v6..v7, 0Fh=DSi)
  030h 6    Unused        (00h-filled)
  036h 6    48bit MAC address (v1-v5: 0009BFxxxxxx, v6-v7: 001656xxxxxx)
  03Ch 2    list of enabled channels ANDed with 7FFE (Bit1..14 = Channel 1..14)
            (usually 3FFEh, ie. only channel 1..13 enabled)
  03Eh 2    Whatever Flags (usually FFFFh)
  040h 1    RF Chip Type (usually 02h)
  041h 1    RF Bits per entry at 0CEh (usually 18h=24bit=3byte) (Bit7=?)
  042h 1    RF Number of entries at 0CEh (usually 0Ch)
  043h 1    Unknown (usually 01h)
  044h 2    Initial Value for [4808146h]
  046h 2    Initial Value for [4808148h]
  048h 2    Initial Value for [480814Ah]
  04Ah 2    Initial Value for [480814Ch]
  04Ch 2    Initial Value for [4808120h]
  04Eh 2    Initial Value for [4808122h]
  050h 2    Initial Value for [4808154h]
  052h 2    Initial Value for [4808144h]
  054h 2    Initial Value for [4808130h]
  056h 2    Initial Value for [4808132h]
  058h 2    Initial Value for [4808140h]
  05Ah 2    Initial Value for [4808142h]
  05Ch 2    Initial Value for [4808038h]
  05Eh 2    Initial Value for [4808124h]
  060h 2    Initial Value for [4808128h]
  062h 2    Initial Value for [4808150h]
  064h 69h  Initial 8bit values for BB[0..68h]
  0CDh 1    Unused (00h)
</TD></TR></TABLE>
Below for Type2 (ie. when [040h]=2) (Mitsumi MM3155 and RF9008):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0CEh 24h  Initial 24bit values for RF[0,4,5,6,7,8,9,0Ah,0Bh,1,2,3]
  0F2h 54h  Channel 1..14 2x24bit values for RF[5,6]
  146h 0Eh  Channel 1..14 8bit values for BB[1Eh] (usually somewhat B1h..B7h)
  154h 0Eh  Channel 1..14 8bit values for RF[9].Bit10..14 (usually 10h-filled)
</TD></TR></TABLE>
Below for Type3 (ie. when [040h]=3) (Mitsumi MM3218):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  --- Type3 values are originated at 0CEh, following addresses depend on:  ---
  1) number of initial values, found at [042h]        ;usually 29h
  2) number of BB indices,     found at [0CEh+[042h]] ;usually 02h
  3) number of RF indices,     found at [043h]        ;usually 02h
  --- Below example addresses assume above values to be set to 29h,02h,02h ---
  0CEh 29h  Initial 8bit values for RF[0..28h]
  0F7h 1    Number of BB indices per channel
  0F8h 1    1st BB index
  0F9h 14   1st BB data for channel 1..14
  107h 1    2nd BB index
  108h 14   2nd BB data for channel 1..14
  116h 1    1st RF index
  117h 14   1st RF data for channel 1..14
  125h 1    2nd RF index
  126h 14   2nd RF data for channel 1..14
  134h 46   Unused (FFh-filled)
</TD></TR></TABLE>
Below for both Type2 and Type3:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  162h 1    Unknown (usually 19h..1Ch)
  163h 1    Unused (FFh) (Inside CRC16 region, with config_length=138h)
  164h 9Ch  Unused (FFh-filled) (Outside CRC16 region, with config_length=138h)
</TD></TR></TABLE>
Most of the Wifi settings seem to be always the same values on all currently
existing consoles. Except for:<BR>
Values that are (obviously) different are the CRC16, and 4th-6th bytes of the
MAC address. Also, initial values for BB[01h] and BB[1Eh], and channel 1..14
values for BB[1Eh], and unknown entry [162h] contain different calibration
settings on all consoles.<BR>
Firmware v5 is having a new wifi ID [2Fh]=03h, and different RF[9] setting.<BR>
Firmware v6 (dslite) has wifi ID [2Fh]=05h, and same RF[9] setting as v5,
additionally, v6 and up have different 2nd-3rd bytes of the MAC address.<BR>
<BR>
Moreover, a LOT of values are different with Type3 chips (ie. when [040h]=3).<BR>
<BR>
<B>Note</B><BR>
Unlike for Firmware User Settings, the Firmware Header (and Wifi Settings)
aren't stored in RAM upon boot. So the data must be retrieved via SPI bus by
software.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsfirmwarewifiinternetaccesspoints"></A>&nbsp;
  DS Firmware Wifi Internet Access Points
</FONT></TD></TR></TABLE><BR>
<B>NDS (three 100h-byte regions) (also exists on DSi)</B><BR>
These three 100h byte regions are used to memorize known internet access
points. The firmware doesn't use these regions, but games that support internet
seem to be allowed to read (and write) them.<BR>
03FA00-03FAFF: connection data 1<BR>
03FB00-03FBFF: connection data 2<BR>
03FC00-03FCFF: connection data 3<BR>
(07Fxxx for iQue DS)<BR>
(01Fxxx for DSi)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Addr Siz Expl.
  000h 64  Unknown (usually 00h-filled) (no Proxy supported on NDS)
  040h 32  SSID (ASCII name of the access point) (padded with 00h's) see [0E8h]
  060h 32  SSID for WEP64 on AOSS router (each security level has its own SSID)
  080h 16  WEP Key 1 (for type/size, see entry E6h)
  090h 16  WEP Key 2  ;\
  0A0h 16  WEP Key 3  ; (usually 00h-filled)
  0B0h 16  WEP Key 4  ;/
  0C0h 4   IP Address           (0=Auto/DHCP)
  0C4h 4   Gateway              (0=Auto/DHCP)
  0C8h 4   Primary DNS Server   (0=Auto/DHCP)
  0CCh 4   Secondary DNS Server (0=Auto/DHCP)
  0D0h 1   Subnet Mask (0=Auto/DHCP, 1..1Ch=Leading Ones) (eg. 6 = FC.00.00.00)
  0D1h ..  Unknown (usually 00h-filled)
  0E6h 1   WEP Mode (0=None, 1/2/3=5/13/16 byte hex, 5/6/7=5/13/16 byte ascii)
  0E7h 1   Status (00h=Normal, 01h=AOSS, FFh=connection not configured/deleted)
  0E8h 1   SSID Length in characters
  0E9h 1   Unknown (usually 00h)
  0EAh 2   MTU Value (Max transmission unit) (576..1500, usually 1400)
  0ECh 3   Unknown (usually 00h-filled)
  0EFh 1   bit0/1/2 - connection 1/2/3 (1=Configured, 0=Not configured)
  0F0h 6   Nintendo Wifi Connection (WFC) 43bit User ID
           (ID=([F0h] AND 07FFFFFFFFFFFFh)*1000, shown as decimal string
           NNNN-NNNN-NNNN-N000) (the upper 5bit of the last byte are
           containing additional/unknown nonzero data)
  0F6h 8   Unknown (nonzero stuff !?!)
  0FEh 2   CRC16 for Entries 00h..FDh (with initial value 0000h)
</TD></TR></TABLE>
For connection 3: entries [EFh..FDh] - always zero-filled?<BR>
The location of the first data block seems to be at the User Settings address
(see Firmware Header [020h]) minus 400h.<BR>
<BR>
<B>DSi (three new 200h-byte regions)</B><BR>
The DSi has three extra regions (for use DSi games, with the new WPA encryption
support, and with additional proxy support), these extra regions are found
under "Advanced Setup" in the DSi firmware's "Internet" configuration menu.<BR>
01F400-01F5FF: new DSi connection data 4<BR>
01F600-01F7FF: new DSi connection data 5<BR>
01F800-01F9FF: new DSi connection data 6<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Addr Siz Expl.
  000h 32  Proxy Authentication Username (ASCII string, padded with 00's)
  000h 32  Proxy Authentication Password (ASCII string, padded with 00's)
  040h ..  SSID (ASCII string, padded with 00's) (see [0E8h] for length)
  0xxh ..  Maybe same as NDS
  080h ..  WEP Key (zerofilled for WPA)
  0xxh ..  Maybe same as NDS
  0C0h 4   IP Address           (0=Auto/DHCP)
  0C4h 4   Gateway              (0=Auto/DHCP)
  0C8h 4   Primary DNS Server   (0=Auto/DHCP)
  0CCh 4   Secondary DNS Server (0=Auto/DHCP)
  0D0h 1   Subnet Mask (0=Auto/DHCP, 1..1Ch=Leading Ones) (eg. 6 = FC.00.00.00)
  0D1h ..  Unknown (zerofilled)
  0E6h 1   WEP (00h=None/WPA/WPA2, 01h=WEP/5byteHEX)
  0E7h 1   00h=Normal, 10h=WPA/WPA2 (or FFh=unused/deleted)
  0E8h 1   SSID Length in characters
  0E9h 1   Unknown (usually 00h)
  0EAh 2   MTU Value (Max transmission unit) (576..1500, usually 1400)
  0ECh 3   Unknown (usually 00h-filled)
  0EFh 1   bit0/1/2 - connection 1/2/3 (1=Configured, 0=Not configured)
  0F0h 14  Zerofilled (or maybe ID as on NDS, if any such ID exists for DSi?)
  0FEh 2   Maybe CRC16 ?         (93h,88h)
  100h 32  Some big random hex number? (FEh,72h,...)      ;\all zero for WEP
  120h 16  WPA/WPA2 key (ASCII string, padded with 00's)  ;/
  130h ..  Zerofilled
  181h 1   WPA (0=None or WEP, 4=WPA-TKIP, 5=WPA2-TKIP, 6=WPA-AES, 7=WPA2-AES)
  182h 1   Proxy Enable         (00h=None, 01h=Yes)
  183h 1   Proxy Authentication (00h=None, 01h=Yes)
  184h ..  Proxy Name (ASCII string, padded with 00's)
  1xxh ..  Zerofilled
  1E8h 2   Proxy Port (16bit)
  1EAh ..  Zerofilled
  1FEh 2   Maybe another CRC16 ? (this one is 0000h if unused/deleted)
</TD></TR></TABLE>
The location of the first data block (aka settings number 4) seems to be at the
User Settings address (see Firmware Header [020h]) minus A00h.<BR>
Observe that NDS consoles do have Firmware bootcode/data in that area, so those
new regions exist on DSi only.<BR>
There is probably also some flag in Firmware Header that indicates the presence
of the new wifi regions (or as a general rule: All DSi consoles should have
them).<BR>
Note that the Proxy feature can be used to redirect internet access (when using
a custom proxy server, one could redirect commercial games to homebrew servers;
as done by the http://pbsds.net/ project) (actually the same should be possible
with the DNS server entry, possibly with less traffic).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsfirmwareusersettings"></A>&nbsp;
  DS Firmware User Settings
</FONT></TD></TR></TABLE><BR>
<B>Current Settings (RAM 27FFC80h-27FFCEFh)</B><BR>
<B>User Settings 0 (Firmware 3FE00h-3FEFFh) ;(DSi &amp; iQue use different address,</B><BR>
<B>User Settings 1 (Firmware 3FF00h-3FFFFh) ;see Firmware Header [020h])</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Addr Size Expl.
  000h  2   Version (5) (Always 5, for all NDS/DSi Firmware versions)
  002h  1   Favorite color (0..15) (0=Gray, 1=Brown, etc.)
  003h  1   Birthday month (1..12) (Binary, non-BCD)
  004h  1   Birthday day   (1..31) (Binary, non-BCD)
  005h  1   Not used (zero)
  006h  20  Nickname string in UTF-16 format
  01Ah  2   Nickname length in characters    (0..10)
  01Ch  52  Message string in UTF-16 format
  050h  2   Message length in characters     (0..26)
  052h  1   Alarm hour     (0..23) (Binary, non-BCD)
  053h  1   Alarm minute   (0..59) (Binary, non-BCD)
  054h  2
  056h  1   80h=enable alarm (huh?), bit 0..6=enable?
  057h  1   Zero (1 byte)
  058h  2x2 Touch-screen calibration point (adc.x1,y1) 12bit ADC-position
  05Ch  2x1 Touch-screen calibration point (scr.x1,y1) 8bit pixel-position
  05Eh  2x2 Touch-screen calibration point (adc.x2,y2) 12bit ADC-position
  062h  2x1 Touch-screen calibration point (scr.x2,y2) 8bit pixel-position
  064h  2   Language and Flags (see below)
  066h  1   Year (2000..2255) (when having entered date in the boot menu)
  067h  1   Unknown (usually 00h...08h or 78h..7Fh or so)
  068h  4   RTC Offset (difference in seconds when RTC time/date was changed)
  06Ch  4   Not used (FFh-filled, sometimes 00h-filled)
</TD></TR></TABLE>
Below not stored in RAM (found only in FLASH memory)...<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  070h  2   update counter (used to check latest) (must be 0000h..007Fh)
  072h  2   CRC16 of entries 00h..6Fh
  074h  8Ch Not used (FFh-filled) (or extended data, see below)
</TD></TR></TABLE>
Below extended data was invented for iQue DS (for adding the chinese language
setting), and is also included in Nintendo DSi models. Presence of extended
data is indicated in Firmware Header entry [1Dh].Bit6.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  074h  1   Unknown (01h) (maybe version?)
  075h  1   Extended Language (0..5=Same as Entry 064h, plus 6=Chinese)
            (for language 6, entry 064h defaults to english; for compatibility)
            (for language 0..5, both entries 064h and 075h have same value)
  076h  2   Bitmask for Supported Languages (Bit0..6)
            (007Eh for iQue DS, ie. with chinese, but without japanese)
            (003Eh for DSi/EUR, ie. without chinese, and without japanese)
  078h  86h Not used (FFh-filled on iQue DS, 00h-filled on DSi)
  0FEh  2   CRC16 of entries 74h..FDh
</TD></TR></TABLE>
Note: The DSi has some more settings (eg. Country (additionally to Language),
Parental Controls, and a surreal fake Wireless-Disable option; which does only
disable the Wifi LED, the actual Wifi transmission does still work). Unknown
where those settings are stored, maybe on eMMC). DSi Backlight level and DSi
sound volume seem to be stored in the BPTWL chip (or possibly in its attached
I2C potentiometer).<BR>
<BR>
<B>Language and Flags (Entry 064h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit
  0..2 Language (0=Japanese, 1=English, 2=French, 3=German,
       4=Italian, 5=Spanish, 6..7=Reserved) (for Chinese see Entry 075h)
       (the language setting also implies time/data format)
  3    GBA mode screen selection (0=Upper, 1=Lower)
  4-5  Backlight Level    (0..3=Low,Med,High,Max) (DS-Lite only)
  6    Bootmenu Disable   (0=Manual/bootmenu, 1=Autostart Cartridge)
  9    Settings Lost (1=Prompt for User Info, and Language, and Calibration)
  10   Settings Okay (0=Prompt for User Info)
  11   Settings Okay (0=Prompt for User Info) (Same as Bit10)
  12   No function
  13   Settings Okay (0=Prompt for User Info, and Language)
  14   Settings Okay (0=Prompt for User Info) (Same as Bit10)
  15   Settings Okay (0=Prompt for User Info) (Same as Bit10)
</TD></TR></TABLE>
The Health and Safety message is skipped if Bit9=1, or if one or more of the
following bits is zero: Bits 10,11,13,14,15. However, as soon as entering the
bootmenu, the Penalty-Prompt occurs.<BR>
<BR>
Note: There are two User Settings areas in the firmware chip, at offset 3FE00h
and 3FF00h, if both areas have valid CRCs, then the current/newest area is that
whose Update Counter is one bigger than in the other/older area.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  IF count1=((count0+1) AND 7Fh) THEN area1=newer ELSE area0=newer
</TD></TR></TABLE>
When changing settings, the older area is overwritten with new data (and
incremented Update Counter). The two areas allow to recover previous settings
in case of a write-error (eg. on a battery failure during write).<BR>
<BR>
<B>Battery Removal</B><BR>
Even though the battery is required only for the RTC (not for the firmware
flash memory), most of the firmware user settings are reset when removing the
battery. This appears to be a strange bug-or-feature of the DS bios, at least,
fortunately, it still keeps the rest of the firmware intact.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsfirmwareextendedsettings"></A>&nbsp;
  DS Firmware Extended Settings
</FONT></TD></TR></TABLE><BR>
Extended Settings contain some additional information which is not supported by
the original firmware (current century, date/time formats, temperature
calibration, etc.), the settings are supported by Nocash Firmware, by the
no$gba emulator, and may be eventually also supported by other emulators. If
present, the values can be used by games, otherwise games should use either
whatever default settings, or contain their own configuration menu.<BR>
<BR>
<B>Extended Settings - loaded to 23FEE00h (aka fragments of NDS9 boot code)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Addr Siz Expl.
  00h  8  ID "XbooInfo"
  08h  2  CRC16 Value [0Ch..0Ch+Length-1]
  0Ah  2  CRC16 Length (from 0Ch and up)
  0Ch  1  Version (currently 01h)
  0Dh  1  Update Count (newer = (older+1) AND FFh)
  0Eh  1  Bootmenu Flags
            Bit6   Important Info  (0=Disable, 1=Enable)
            Bit7   Bootmenu Screen (0=Upper, 1=Lower)
  0Fh  1  GBA Border (0=Black, 1=Gray Line)
  10h  2  Temperature Calibration TP0 ADC value  (x16) (sum of 16 ADC values)
  12h  2  Temperature Calibration TP1 ADC value  (x16) (sum of 16 ADC values)
  14h  2  Temperature Calibration Degrees Kelvin (x100) (0=none)
  16h  1  Temperature Flags
            Bit0-1 Format (0=Celsius, 1=Fahrenheit, 2=Reaumur, 3=Kelvin)
  17h  1  Backlight Intensity (0=0ff .. FFh=Full)
  18h  4  Date Century Offset       (currently 20, for years 2000..2099)
  1Ch  1  Date Month Recovery Value (1..12)
  1Dh  1  Date Day Recovery Value   (1..31)
  1Eh  1  Date Year Recovery Value  (0..99)
  1Fh  1  Date/Time Flags
            Bit0-1 Date Format   (0=YYYY-MM-DD, 1=MM-DD-YYYY, 2=DD-MM-YYYY)
            Bit2   Friendly Date (0=Raw Numeric, 1=With Day/Month Names)
            Bit5   Time DST      (0=Hide DST, 1=Show DST=On/Off)
            Bit6   Time Seconds  (0=Hide Seconds, 1=Show Seconds)
            Bit7   Time Format   (0=24 hour, 1=12 hour)
  20h  1  Date Separator      (Ascii, usually Slash, or Dot)
  21h  1  Time Separator      (Ascii, usually Colon, or Dot)
  22h  1  Decimal Separator   (Ascii, usually Comma, or Dot)
  23h  1  Thousands Separator (Ascii, usually Comma, or Dot)
  24h  1  Daylight Saving Time (Nth)
             Bit 0-3 Activate on (0..4 = Last,1st,2nd,3rd,4th)
             Bit 4-7 Deactivate on (0..4 = Last,1st,2nd,3rd,4th)
  25h  1  Daylight Saving Time (Day)
             Bit 0-3 Activate on (0..7 = Mon,Tue,Wed,Thu,Fri,Sat,Sun,AnyDay)
             Bit 4-7 Deactivate on (0..7 = Mon,Tue,Wed,Thu,Fri,Sat,Sun,AnyDay)
  26h  1  Daylight Saving Time (of Month)
             Bit 0-3 Activate DST in Month   (1..12)
             Bit 4-7 Deactivate DST in Month (1..12)
  27h  1  Daylight Saving Time (Flags)
             Bit 0   Current DST State (0=Off, 1=On)
             Bit 1   Adjust DST Enable (0=Disable, 1=Enable)
</TD></TR></TABLE>
Note: With the original firmware, the memory region at 23FEE00h and up contains
un-initialized, non-zero-filled data (fragments of boot code).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dswirelesscommunications"></A>&nbsp;
  DS Wireless Communications
</FONT></TD></TR></TABLE><BR>
<A HREF="#dswifiiomap">DS Wifi I/O Map</A><BR>
<A HREF="#dswificontrol">DS Wifi Control</A><BR>
<A HREF="#dswifiinterrupts">DS Wifi Interrupts</A><BR>
<A HREF="#dswifipowerdownregisters">DS Wifi Power-Down Registers</A><BR>
<A HREF="#dswifireceivecontrol">DS Wifi Receive Control</A><BR>
<A HREF="#dswifireceivebuffer">DS Wifi Receive Buffer</A><BR>
<A HREF="#dswifireceivestatistics">DS Wifi Receive Statistics</A><BR>
<A HREF="#dswifitransmitcontrol">DS Wifi Transmit Control</A><BR>
<A HREF="#dswifitransmitbuffers">DS Wifi Transmit Buffers</A><BR>
<A HREF="#dswifitransmiterrors">DS Wifi Transmit Errors</A><BR>
<A HREF="#dswifistatus">DS Wifi Status</A><BR>
<A HREF="#dswifitimers">DS Wifi Timers</A><BR>
<A HREF="#dswifimultiplaymaster">DS Wifi Multiplay Master</A><BR>
<A HREF="#dswifimultiplayslave">DS Wifi Multiplay Slave</A><BR>
<A HREF="#dswificonfigurationports">DS Wifi Configuration Ports</A><BR>
<A HREF="#dswifibasebandchipbb">DS Wifi Baseband Chip (BB)</A><BR>
<A HREF="#dswifirfchip">DS Wifi RF Chip</A><BR>
<A HREF="#dswifirf9008registers">DS Wifi RF9008 Registers</A><BR>
<A HREF="#dswifiunknownregisters">DS Wifi Unknown Registers</A><BR>
<A HREF="#dswifiunusedregisters">DS Wifi Unused Registers</A><BR>
<A HREF="#dswifiinitialization">DS Wifi Initialization</A><BR>
<A HREF="#dswififlowcharts">DS Wifi Flowcharts</A><BR>
<A HREF="#dswifihardwareheaders">DS Wifi Hardware Headers</A><BR>
<A HREF="#dswifimultiboot">DS Wifi Multiboot</A><BR>
<A HREF="#dswifiieee80211frames">DS Wifi IEEE802.11 Frames</A><BR>
<A HREF="#dswifiieee80211managmentframestype0">DS Wifi IEEE802.11 Managment Frames (Type=0)</A><BR>
<A HREF="#dswifiieee80211controlanddataframestype1and2">DS Wifi IEEE802.11 Control and Data Frames (Type=1 and 2)</A><BR>
<BR>
2.4GHz band, Wireless LAN (WLAN) IEEE802.11b protocol<BR>
<BR>
<B>Credits</B><BR>
A very large part of the DS Wifi chapters is based on Stephen Stair's great DS
Wifi document, thanks there.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dswifiiomap"></A>&nbsp;
  DS Wifi I/O Map
</FONT></TD></TR></TABLE><BR>
<B>Notice</B><BR>
Wifi Registers &amp; RAM cannot be written to by STRB opcodes (ignored).<BR>
<BR>
<B>Registers - NDS7 - 4808000h..4808FFFh</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Address  Dir   Name            r/w  [Init] Description
  4808000h R     W_ID            ---- [1440] Chip ID (1440h=DS, C340h=DS-Lite)
  4808004h R/W   W_MODE_RST      9fff [0000] Mode/Reset
  4808006h R/W   W_MODE_WEP      --7f [0000] Mode/Wep modes
  4808008h R/W   W_TXSTATCNT     ffff [0000] Beacon Status Request
  480800Ah R/W   W_X_00Ah        ffff [0000] [bit7 - ingore rx duplicates]
  4808010h R/W   W_IF            ackk [0000] Wifi Interrupt Request Flags
  4808012h R/W   W_IE            ffff [0000] Wifi Interrupt Enable
  4808018h R/W   W_MACADDR_0     ffff [0000] Hardware MAC Address, 1st 2 bytes
  480801Ah R/W   W_MACADDR_1     ffff [0000] Hardware MAC Address, next 2 bytes
  480801Ch R/W   W_MACADDR_2     ffff [0000] Hardware MAC Address, last 2 bytes
  4808020h R/W   W_BSSID_0       ffff [0000] BSSID (first 2 bytes)
  4808022h R/W   W_BSSID_1       ffff [0000] BSSID (next 2 bytes)
  4808024h R/W   W_BSSID_2       ffff [0000] BSSID (last 2 bytes)
  4808028h R/W   W_AID_LOW       ---f [0000] usually as lower 4bit of AID value
  480802Ah R/W   W_AID_FULL      -7ff [0000] AID value assigned by a BSS.
  480802Ch R/W   W_TX_RETRYLIMIT ffff [0707] Tx Retry Limit (set from 0x00-0xFF)
  480802Eh R/W   W_INTERNAL      ---1 [0000]
  4808030h R/W   W_RXCNT         ff0e [0000] Receive control
  4808032h R/W   W_WEP_CNT       ffff [0000] WEP engine enable
  4808034h R?    W_INTERNAL      0000 [0000] bit0,1 (see ports 004h,040h,1A0h)
</TD></TR></TABLE>
<B>Power-Down Registers (and Random Generator)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4808036h R/W   W_POWER_US      ---3 [0001]
  4808038h R/W   W_POWER_TX      ---7 [0003]
  480803Ch R/W   W_POWERSTATE    -r-2 [0200]
  4808040h R/W   W_POWERFORCE    8--1 [0000]
  4808044h R     W_RANDOM        0xxx [0xxx]
  4808048h R/W   W_POWER_?       ---3 [0000]
</TD></TR></TABLE>
<B>WLAN Memory Ports</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4808050h R/W   W_RXBUF_BEGIN   ffff [4000]
  4808052h R/W   W_RXBUF_END     ffff [4800]
  4808054h R     W_RXBUF_WRCSR   0rrr [0000]
  4808056h R/W   W_RXBUF_WR_ADDR -fff [0000]
  4808058h R/W   W_RXBUF_RD_ADDR 1ffe [0000]
  480805Ah R/W   W_RXBUF_READCSR -fff [0000]
  480805Ch R/W   W_RXBUF_COUNT   -fff [0000]
  4808060h R     W_RXBUF_RD_DATA rrrr [xxxx]
  4808062h R/W   W_RXBUF_GAP     1ffe [0000]
  4808064h R/W   W_RXBUF_GAPDISP -fff [0000]
  4808068h R/W   W_TXBUF_WR_ADDR 1ffe [0000]
  480806Ch R/W   W_TXBUF_COUNT   -fff [0000]
  4808070h W     W_TXBUF_WR_DATA xxxx [xxxx]
  4808074h R/W   W_TXBUF_GAP     1ffe [0000]
  4808076h R/W   W_TXBUF_GAPDISP 0fff [0000]
</TD></TR></TABLE>
<B>xxx</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4808078h W     W_INTERNAL      mirr [mirr] Read: Mirror of 068h
  4808080h R/W   W_TXBUF_BEACON  ffff [0000] Beacon Transmit Location
  4808084h R/W   W_TXBUF_TIM     --ff [0000] Beacon TIM Index in Frame Body
  4808088h R/W   W_LISTENCOUNT   --ff [0000] Listen Count
  480808Ch R/W   W_BEACONINT     -3ff [0064] Beacon Interval
  480808Eh R/W   W_LISTENINT     --ff [0000] Listen Interval
  4808090h R/W   W_TXBUF_CMD     ffff [0000]    (used by firmware part4)
  4808094h R/W   W_TXBUF_REPLY1  ffff [0000]    (used by firmware part4)
  4808098h R     W_TXBUF_REPLY2  0000 [0000]    (used by firmware part4)
  480809Ch R/W   W_INTERNAL      ffff [0050] value 4x00h --&gt; preamble+x*12h us?
  48080A0h R/W   W_TXBUF_LOC1    ffff [0000]
  48080A4h R/W   W_TXBUF_LOC2    ffff [0000]
  48080A8h R/W   W_TXBUF_LOC3    ffff [0000]
  48080ACh W     W_TXREQ_RESET   fixx [0050]
  48080AEh W     W_TXREQ_SET     fixx [0050]
  48080B0h R     W_TXREQ_READ    --1f [0010]
  48080B4h W     W_TXBUF_RESET   0000 [0000]    (used by firmware part4)
  48080B6h R     W_TXBUSY        0000 [0000]    (used by firmware part4)
  48080B8h R     W_TXSTAT        0000 [0000]
  48080BAh ?     W_INTERNAL      0000 [0000]
  48080BCh R/W   W_PREAMBLE      ---3 [0001]
  48080C0h R/W x W_CMD_TOTALTIME ffff [0000]    (used by firmware part4)
  48080C4h R/W x W_CMD_REPLYTIME ffff [0000]    (used by firmware part4)
  48080C8h ?     W_INTERNAL      0000 [0000]
  48080D0h R/W   W_RXFILTER      1fff [0401]
  48080D4h R/W   W_CONFIG_0D4h   ---3 [0001]
  48080D8h R/W   W_CONFIG_0D8h   -fff [0004]
  48080DAh R/W   W_CONFIG_0DAh   ffff [0602]
  48080E0h R/W   W_RXFILTER2     ---f [0008]
</TD></TR></TABLE>
<B>Wifi Timers</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  48080E8h R/W   W_US_COUNTCNT   ---1 [0000] Microsecond counter enable
  48080EAh R/W   W_US_COMPARECNT ---1 [0000] Microsecond compare enable
  48080ECh R/W   W_CONFIG_0ECh   3f1f [3F03]
  48080EEh R/W   W_CMD_COUNTCNT  ---1 [0001]
  48080F0h R/W   W_US_COMPARE0   fc-- [FC00] Microsecond compare, bits 0-15
  48080F2h R/W   W_US_COMPARE1   ffff [FFFF] Microsecond compare, bits 16-31
  48080F4h R/W   W_US_COMPARE2   ffff [FFFF] Microsecond compare, bits 32-47
  48080F6h R/W   W_US_COMPARE3   ffff [FFFF] Microsecond compare, bits 48-63
  48080F8h R/W   W_US_COUNT0     ffff [0000] Microsecond counter, bits 0-15
  48080FAh R/W   W_US_COUNT1     ffff [0000] Microsecond counter, bits 16-31
  48080FCh R/W   W_US_COUNT2     ffff [0000] Microsecond counter, bits 32-47
  48080FEh R/W   W_US_COUNT3     ffff [0000] Microsecond counter, bits 48-63
  4808100h ?     W_INTERNAL      0000 [0000]
  4808102h ?     W_INTERNAL      0000 [0000]
  4808104h ?     W_INTERNAL      0000 [0000]
  4808106h ?     W_INTERNAL      0000 [0000]
  480810Ch R/W   W_CONTENTFREE   ffff [0000] ...
  4808110h R/W   W_PRE_BEACON    ffff [0000]
  4808118h R/W   W_CMD_COUNT     ffff [0000]
  480811Ch R/W   W_BEACONCOUNT1  ffff [0000] reloaded with W_BEACONINT
</TD></TR></TABLE>
<B>Configuration Ports (and some other Registers)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4808120h R/W   W_CONFIG_120h   81ff [0048] init from firmware[04Ch]
  4808122h R/W   W_CONFIG_122h   ffff [4840] init from firmware[04Eh]
  4808124h R/W   W_CONFIG_124h   ffff [0000] init from firmware[05Eh], or 00C8h
  4808126h ?     W_INTERNAL      fixx [ 0080]
  4808128h R/W   W_CONFIG_128h   ffff [0000] init from firmware[060h], or 07D0h
  480812Ah ?     W_INTERNAL      fixx [1000] lower 12bit same as W_CONFIG_128h
  4808130h R/W   W_CONFIG_130h   -fff [0142] init from firmware[054h]
  4808132h R/W   W_CONFIG_132h   8fff [8064] init from firmware[056h]
  4808134h R/W   W_BEACONCOUNT2  ffff [FFFF] ...
  4808140h R/W   W_CONFIG_140h   ffff [0000] init from firmware[058h], or xx
  4808142h R/W   W_CONFIG_142h   ffff [2443] init from firmware[05Ah]
  4808144h R/W   W_CONFIG_144h   --ff [0042] init from firmware[052h]
  4808146h R/W   W_CONFIG_146h   --ff [0016] init from firmware[044h]
  4808148h R/W   W_CONFIG_148h   --ff [0016] init from firmware[046h]
  480814Ah R/W   W_CONFIG_14Ah   --ff [0016] init from firmware[048h]
  480814Ch R/W   W_CONFIG_14Ch   ffff [162C] init from firmware[04Ah]
  4808150h R/W   W_CONFIG_150h   ff3f [0204] init from firmware[062h], or 202h
  4808154h R/W   W_CONFIG_154h   7a7f [0058] init from firmware[050h]
</TD></TR></TABLE>
<B>Baseband Chip Ports</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4808158h W     W_BB_CNT        mirr [00B5] BB Access Start/Direction/Index
  480815Ah W     W_BB_WRITE      ???? [0000] BB Access data byte to write
  480815Ch R     W_BB_READ       00rr [00B5] BB Access data byte read
  480815Eh R     W_BB_BUSY       000r [0000] BB Access Busy flag
  4808160h R/W   W_BB_MODE       41-- [0100] BB Access Mode
  4808168h R/W   W_BB_POWER      8--f [800D] BB Access Powerdown
</TD></TR></TABLE>
<B>Internal Stuff</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  480816Ah ?     W_INTERNAL      0000 [0001] (or 0000h?)
  4808170h ?     W_INTERNAL      0000 [0000]
  4808172h ?     W_INTERNAL      0000 [0000]
  4808174h ?     W_INTERNAL      0000 [0000]
  4808176h ?     W_INTERNAL      0000 [0000]
  4808178h W     W_INTERNAL      fixx [0800] Read: mirror of 17Ch
</TD></TR></TABLE>
<B>RF Chip Ports</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  480817Ch R/W   W_RF_DATA2      ffff [0800]
  480817Eh R/W   W_RF_DATA1      ffff [C008]
  4808180h R     W_RF_BUSY       000r [0000]
  4808184h R/W   W_RF_CNT        413f [0018]
</TD></TR></TABLE>
<B>xxx</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4808190h R/W   W_INTERNAL      ffff [0000]
  4808194h R/W   W_TX_HDR_CNT    ---7 [0000] used by firmware part4 (0 or 6)
  4808198h R/W   W_INTERNAL      ---f [0000]
  480819Ch R     W_RF_PINS       fixx [0004]
  48081A0h R/W   W_X_1A0h        -933 [0000] used by firmware part4 (0 or 823h)
  48081A2h R/W   W_X_1A2h        ---3 [0001] used by firmware part4
  48081A4h R/W   W_X_1A4h        ffff [0000] "Rate used when signal test..."
</TD></TR></TABLE>
<B>Wifi Statistics</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  48081A8h R     W_RXSTAT_INC_IF rrrr [0000] Stats Increment Flags
  48081AAh R/W   W_RXSTAT_INC_IE ffff [0000] Stats Increment IRQ Enable
  48081ACh R     W_RXSTAT_OVF_IF rrrr [0000] Stats Half-Overflow Flags
  48081AEh R/W   W_RXSTAT_OVF_IE ffff [0000] Stats Half-Overflow IRQ Enable
  48081B0h R/W   W_RXSTAT        --ff [0000]
  48081B2h R/W   W_RXSTAT        ffff [0000] RX_LengthRateErrorCount
  48081B4h R/W   W_RXSTAT        rrff [0000] ... firmware uses also MSB ... ?
  48081B6h R/W   W_RXSTAT        ffff [0000]
  48081B8h R/W   W_RXSTAT        --ff [0000]
  48081BAh R/W   W_RXSTAT        --ff [0000]
  48081BCh R/W   W_RXSTAT        ffff [0000]
  48081BEh R/W   W_RXSTAT        ffff [0000]
  48081C0h R/W   W_TX_ERR_COUNT  --ff [0000] TransmitErrorCount
  48081C4h R     W_RX_COUNT      fixx [0000]
</TD></TR></TABLE>
[1D0 - 1DE are 15 entries related to multiplayer response errors]<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  48081D0h R/W   W_CMD_STAT      ff-- [0000]
  48081D2h R/W   W_CMD_STAT      ffff [0000]
  48081D4h R/W   W_CMD_STAT      ffff [0000]
  48081D6h R/W   W_CMD_STAT      ffff [0000]
  48081D8h R/W   W_CMD_STAT      ffff [0000]
  48081DAh R/W   W_CMD_STAT      ffff [0000]
  48081DCh R/W   W_CMD_STAT      ffff [0000]
  48081DEh R/W   W_CMD_STAT      ffff [0000]
</TD></TR></TABLE>
<B>Internal Diagnostics Registers (usually not used for anything)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  48081F0h R/W   W_INTERNAL      ---3 [0000]
  4808204h ?     W_INTERNAL      fixx [0000]
  4808208h ?     W_INTERNAL      fixx [0000]
  480820Ch W     W_INTERNAL      fixx [0050]
  4808210h R     W_TX_SEQNO      fixx [0000]
  4808214h R     W_RF_STATUS     XXXX [0009]    (used by firmware part4)
  480821Ch W     W_IF_SET        fbff [0000] Force Interrupt (set bits in W_IF).
  4808220h R/W   W_INTERNAL      ffff [0000] Bit0-1: Enable/Disable WifiRAM
                                             (locks memory at 4000h-5FFFh)
  4808224h R/W   W_INTERNAL      ---3 [0003]
  4808228h W     W_X_228h        fixx [0000]    (used by firmware part4) (bit3)
  4808230h R/W   W_INTERNAL      --ff [0047]
  4808234h R/W   W_INTERNAL      -eff [0EFF]
  4808238h R/W   W_INTERNAL      ffff [0000] ;rx_seq_no-60h+/-x   ;why that?
                                   ;other day: fixed value, not seq_no related?
  480823Ch ?     W_INTERNAL      fixx [0000] like W_TXSTAT... ONLY for beacons?
  4808244h R/W   W_X_244h        ffff [0000]    (used by firmware part4)
  4808248h R/W   W_INTERNAL      ffff [0000]
  480824Ch R     W_INTERNAL      fixx [0000] ;rx_mac_addr_0
  480824Eh R     W_INTERNAL      fixx [0000] ;rx_mac_addr_1
  4808250h R     W_INTERNAL      fixx [0000] ;rx_mac_addr_2
  4808254h ?     W_CONFIG_254h   fixx [0000] (read: FFFFh=DS, EEEEh=DS-Lite)
  4808258h ?     W_INTERNAL      fixx [0000]
  480825Ch ?     W_INTERNAL      fixx [0000]
  4808260h ?     W_INTERNAL      fixx [ 0FEF]
  4808264h R     W_INTERNAL      fixx [0000] ;rx_addr_1 (usually "rxtx_addr-x")
  4808268h R     W_RXTX_ADDR     fixx [0005] ;rxtx_addr
  4808270h R     W_INTERNAL      fixx [0000] ;rx_addr_2 (usually "rx_addr_1-1")
  4808274h ?     W_INTERNAL      fixx [ 0001]
  4808278h R/W   W_INTERNAL      ffff [000F]
  480827Ch ?     W_INTERNAL      fixx [ 000A]
  4808290h (R/W) W_X_290h        fixx [FFFF] bit 0 = ?  (used by firmware part4)
  4808298h W     W_INTERNAL      fixx [0000]
  48082A0h R/W   W_INTERNAL      ffff [0000]
  48082A2h R     W_INTERNAL      XXXX [7FFF] 15bit shift reg (used during tx?)
  48082A4h R     W_INTERNAL      fixx [0000] ;rx_rate_1 not ALWAYS same as 2C4h
  48082A8h W     W_INTERNAL      fixx [0000]
  48082ACh ?     W_INTERNAL      fixx [ 0038]
  48082B0h W     W_INTERNAL      fixx [0000]
  48082B4h R/W   W_INTERNAL      -1-3 [0000]
  48082B8h ?     W_INTERNAL      fixx [0000]
  48082C0h R/W   W_INTERNAL      ---1 [0000]
  48082C4h R     W_INTERNAL      fixx [000A] ;rx_rate_2 (0Ah,14h = 1,2 Mbit/s)
  48082C8h R     W_INTERNAL      fixx [0000] ;rx_duration/length/rate (or so?)
  48082CCh R     W_INTERNAL      fixx [0000] ;rx_framecontrol; from ieee header
  48082D0h DIS   W_INTERNAL                  ;"W_POWERACK" (internal garbage)
                                             ;normally DISABLED (unless FORCE)
  48082F0h R/W   W_INTERNAL      ffff [0000]
  48082F2h R/W   W_INTERNAL      ffff [0000]
  48082F4h R/W   W_INTERNAL      ffff [0000]
  48082F6h R/W   W_INTERNAL      ffff [0000]
</TD></TR></TABLE>
All other ports in range 4808000h..4808FFFh are unused.<BR>
All registers marked as "W_INTERNAL" aren't used by Firmware part4, and are
probably unimportant, except for whatever special diagnostics purposes.<BR>
Reading from write-only ports (W) often mirrors to data from other ports.<BR>
<BR>
Additionally, there are 69h Baseband Chip Registers (BB), and 0Fh RF Chip
Registers (see BB and RF chapters).<BR>
<BR>
For Wifi Power Managment (POWCNT2), for Wifi Waitstates (WIFIWAITCNT), and for
the Power LED Blink Feature (conventionally used to indicate Wifi activity)
see:<BR>
<A HREF="#dspowermanagement">DS Power Management</A><BR>
<BR>
For Wifi Configuration and Calibration data in Firmware Header, see:<BR>
<A HREF="#dscartridgesencryptionfirmware">DS Cartridges, Encryption, Firmware</A><BR>
<BR>
<B>Wifi RAM - NDS7 - Memory (4804000h..4805FFFh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4804000h W_MACMEM RX/TX Buffers (2000h bytes) (excluding below specials)
  4805F60h Used for something, not included in the rx circular buffer.
  4805F80h W_WEPKEY_0 (32 bytes)
  4805FA0h W_WEPKEY_1 (32 bytes)
  4805FC0h W_WEPKEY_2 (32 bytes)
  4805FE0h W_WEPKEY_3 (32 bytes)
</TD></TR></TABLE>
Unlike all other NDS memory, Wifi RAM is left uninitialized after boot.<BR>
<BR>
<B>5F80h - W_WEPKEY_0 thru W_WEPKEY_3 - Wifi WEP keys (R/W)</B><BR>
These WEP key slots store the WEP keys that are used for encryption for 802.11
keys IDs 0-3.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dswificontrol"></A>&nbsp;
  DS Wifi Control
</FONT></TD></TR></TABLE><BR>
<B>4808000h - W_ID - Wifi Chip ID (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15   Chip ID (1440h on NDS, C340h on NDS-lite)
</TD></TR></TABLE>
The NDS-lite is more or less backwards compatible with the original NDS (the
W_RXBUF_GAPDISP and W_TXBUF_GAPDISP are different, and most of the garbage
effects on unused/mirrored ports are different, too).<BR>
<BR>
<B>4808004h - W_MODE_RST - Wifi Hardware mode / reset (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Adjust some ports (0/1=see lists below) (R/W)
        TX Master Enable for LOC1..3 and Beacon  (0=Disable, 1=Enable)
  1-12  Unknown (R/W)
  13    Reset some ports (0=No change, 1=Reset/see list below) (Write-Only)
  14    Reset some ports (0=No change, 1=Reset/see list below) (Write-Only)
  15    Unknown (R/W)
</TD></TR></TABLE>
<BR>
<B>4808006h - W_MODE_WEP - Wifi Software mode / Wep mode (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-2   specify a software mode for wifi operation
        (may be related to hardware but a correlation has not yet been found)
  3-5   specify the hardware WEP mode
        0=no WEP, 1=64bit WEP (48bit key), and 3=128bit WEP.
        (Values 2 and 4 exist too, but are nonstandard)
  6     Unknown
  8-15  Always zero
</TD></TR></TABLE>
<BR>
<B>4808018h - W_MACADDR_0 - MAC Address (R/W)</B><BR>
<B>480801Ah - W_MACADDR_1 - MAC Address (R/W)</B><BR>
<B>480801Ch - W_MACADDR_2 - MAC Address (R/W)</B><BR>
48bit MAC Address of the console. Should be initialized from firmware[036h].
The hardware receives only packets that are sent to this address (or to group
addresses, like FF:FF:FF:FF:FF:FF).<BR>
<BR>
<B>4808020h - W_BSSID_0 - BSSID (R/W)</B><BR>
<B>4808022h - W_BSSID_1 - BSSID (R/W)</B><BR>
<B>4808024h - W_BSSID_2 - BSSID (R/W)</B><BR>
48bit BSSID stored here. Ie. the MAC address of the host, obtained from Beacon
frames (on the host itself, that should be just same as W_MACADDR). See
W_RXFILTER.<BR>
<BR>
<B>4808028h - W_AID_LOW (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-3   Maybe player-number, assuming that HW supports such? (1..15, or 0)
  Bit4-15  Not used
</TD></TR></TABLE>
Usually set equal to the lower 4bit of the W_AID_FULL value.<BR>
<BR>
<B>480802Ah - W_AID_FULL - Association ID (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-10  Association ID (AID) (1..2007, or zero)
  Bit11-15 Not used
</TD></TR></TABLE>
<BR>
<B>4808032h - W_WEP_CNT -  WEP Engine Enable (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-14  Unknown (usually zero)
  15    WEP Engine Enable  (0=Disable, 1=Enable)
</TD></TR></TABLE>
[expl. I - bit15 enables/disables WEP processing of sent/received packets]<BR>
[expl. II - bit15 enables wep processing on packets which bear the WEP flag in
the 802.11 header]<BR>
[expl. III - bit15 seems to react on 0-to-1 transitions]<BR>
<BR>
<B>4808044h - W_RANDOM - Random Generator (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-10  Random
  11-15 Not used (zero)
</TD></TR></TABLE>
The random generator is updated at 33.51MHz rate, as such:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  X = (X AND 1) XOR (X ROL 1)  ;(rotation within 11bit range)
</TD></TR></TABLE>
That random sequence goes through 5FDh different values before it restarts.<BR>
When reading from the random register, the old latched value is returned to the
CPU, and the new current random value is then latched, so reads always return
the older value, timed from the previous read.<BR>
Occassionally, about once every some thousand reads, the latching appears to
occur 4 cycles earlier than normally, so the value on the next read will be 4
cycles older than expected.<BR>
The random register has ACTIVE mirrors.<BR>
<BR>
<B>48080BCh - W_PREAMBLE - Preamble Control (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Dir  Expl.
  0     R/W  Unknown                    (this does NOT affect TX)
  1     R/W  Preamble (0=Long, 1=Short) (this does NOT affect TX)
  2     W    Preamble (0=Long, 1=Short) (this does affect TX) (only at 2Mbit/s)
  3-15  -    Always zero
</TD></TR></TABLE>
Short preamble works only with 2Mbit/s transfer rate (ie. when set like so in
TX hardware header). 1Mbit/s rate always uses long preamble.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Type   Carrier Signal  SFD Value     PLCP Header     Data
  Long   128bit, 1Mbit   16bit, 1Mbit  48bit, 1Mbit    N bits, 1Mbit or 2Mbit
  Short  56bit, 1Mbit    16bit, 1Mbit  48bit, 2Mbit    N bits, 2Mbit
</TD></TR></TABLE>
Length of the Carrier+SFD+PLCP part is thus 192us (long) or 96us (short).<BR>
Note: The Carrier+SFD+PLCP part is sent between IRQ14 and IRQ07 (not between
IRQ07 and IRQ01).<BR>
<BR>
<B>Writing "0-then-1" to W_MODE_RST.Bit0 does reset following ports:</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  [4808034h]=0002h ;W_INTERNAL
  [480819Ch]=0046h ;W_RF_PINS
  [4808214h]=0009h ;W_RF_STATUS
  [480827Ch]=0005h ;W_INTERNAL
  [48082A2h]=?     ;...unstable?
</TD></TR></TABLE>
<BR>
<B>Writing "1-then-0" to W_MODE_RST.Bit0 does reset following ports:</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  [480827Ch]=000Ah ;W_INTERNAL
</TD></TR></TABLE>
<BR>
<B>Writing "1" to W_MODE_RST.Bit13 does reset following ports:</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  [4808056h]=0000h ;W_RXBUF_WR_ADDR
  [48080C0h]=0000h ;W_CMD_TOTALTIME
  [48080C4h]=0000h ;W_CMD_REPLYTIME
  [48081A4h]=0000h ;W_X_1A4h
  [4808278h]=000Fh ;W_INTERNAL
  ...Also, following may be affected (results are unstable though)...
  [48080AEh]=?     ;or rather the actual port (which it is an mirror of)
  [48080BAh]=?     ;W_INTERNAL (occassionally unstable)
  [4808204h]=?     ;W_INTERNAL
  [480825Ch]=?     ;W_INTERNAL
  [4808268h]=?     ;W_RXTX_ADDR
  [4808274h]=?     ;W_INTERNAL
</TD></TR></TABLE>
<BR>
<B>Writing "1" to W_MODE_RST.Bit14 does reset following ports:</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  [4808006h]=0000h ;W_MODE_WEP
  [4808008h]=0000h ;W_TXSTATCNT
  [480800Ah]=0000h ;W_X_00Ah
  [4808018h]=0000h ;W_MACADDR_0
  [480801Ah]=0000h ;W_MACADDR_1
  [480801Ch]=0000h ;W_MACADDR_2
  [4808020h]=0000h ;W_BSSID_0
  [4808022h]=0000h ;W_BSSID_1
  [4808024h]=0000h ;W_BSSID_2
  [4808028h]=0000h ;W_AID_LOW
  [480802Ah]=0000h ;W_AID_FULL
  [480802Ch]=0707h ;W_TX_RETRYLIMIT
  [480802Eh]=0000h ;W_INTERNAL
  [4808050h]=4000h ;W_RXBUF_BEGIN
  [4808052h]=4800h ;W_RXBUF_END
  [4808084h]=0000h ;W_TXBUF_TIM
  [48080BCh]=0001h ;W_PREAMBLE
  [48080D0h]=0401h ;W_RXFILTER
  [48080D4h]=0001h ;W_CONFIG_0D4h
  [48080E0h]=0008h ;W_RXFILTER2
  [48080ECh]=3F03h ;W_CONFIG_0ECh
  [4808194h]=0000h ;W_TX_HDR_CNT
  [4808198h]=0000h ;W_INTERNAL
  [48081A2h]=0001h ;W_X_1A2h
  [4808224h]=0003h ;W_INTERNAL
  [4808230h]=0047h ;W_INTERNAL
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dswifiinterrupts"></A>&nbsp;
  DS Wifi Interrupts
</FONT></TD></TR></TABLE><BR>
<B>4808010h - W_IF - Wifi Interrupt Request Flags (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0   Receive Complete  (packet received and stored in the RX fifo)
  1   Transmit Complete (packet is done being transmitted) (no matter if error)
  2   Receive Event Increment      (IRQ02, see W_RXSTAT_INC_IE)
  3   Transmit Error Increment     (IRQ03, see W_TX_ERR_COUNT)
  4   Receive Event Half-Overflow  (IRQ04, see W_RXSTAT_OVF_IE)
  5   Transmit Error Half-Overflow (IRQ05, see W_TX_ERR_COUNT.Bit7)
  6   Start Receive     (IRQ06, a packet has just started to be received)
  7   Start Transmit    (IRQ07, a packet has just started to be transmitted)
  8   Txbuf Count Expired  (IRQ08, see W_TXBUF_COUNT)
  9   Rxbuf Count Expired  (IRQ09, see W_RXBUF_COUNT)
  10  Not used (always zero, even when trying to set it with W_IF_SET)
  11  RF Wakeup            (IRQ11, see W_POWERSTATE)
  12  Multiplay ...?       (IRQ12, see W_CMD_COUNT)
  13  Post-Beacon Timeslot (IRQ13, see W_BEACONCOUNT2)
  14  Beacon Timeslot      (IRQ14, see W_BEACONCOUNT1/W_US_COMPARE)
  15  Pre-Beacon Timeslot  (IRQ15, see W_BEACONCOUNT1/W_PRE_BEACON)
</TD></TR></TABLE>
Write a '1' to a bit to clear it.<BR>
The Transmit Start/Complete bits (Bit7,1) are set for EACH packet (including
beacons, and including retries).<BR>
<BR>
<B>4808012h - W_IE - Wifi Interrupt Enable Flags (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15  Enable Flags, same bits as W_IF  (0=Disable, 1=Enable)
</TD></TR></TABLE>
In W_IE, Bit10 is R/W, but seems to have no function since IRQ10 doesn't exist.<BR>
<BR>
<B>480821Ch - W_IF_SET (W_INTERNAL) - Force Wifi Interrupt Flags (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15  Set corresponding bits in W_IF  (0=No change, 1=Set Bit)
</TD></TR></TABLE>
Notes: Bit10 cannot be set since no IRQ10 exists. This register does only set
IRQ flags, but without performing special actions (such like W_BEACONCOUNT1 and
W_BEACONCOUNT2 reloads that occur on real IRQ14's).<BR>
<BR>
<B>Wifi Primary IRQ Flag (IF.Bit24, Port 4000214h)</B><BR>
IF.Bit24 gets set &lt;only&gt; when (W_IF AND W_IE) changes from 0000h to
non-zero.<BR>
IF.Bit24 can be reset (ack) &lt;even&gt; when (W_IF AND W_IE) is still
non-zero.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
<B>  Caution  Caution  Caution  Caution  Caution</B>
  That means, when acknowledging IF.Bit24, then NO FURTHER wifi IRQs
  will be executed whilst and as long as (W_IF AND W_IE) is non-zero.
</TD></TR></TABLE>
One work-around is to process/acknowledge ALL wifi IRQs in a loop, including
further IRQs that may occur inside of that loop, until (W_IF AND W_IE) becomes
0000h.<BR>
Another work-around (for single IRQs) would be to acknowledge IF and W_IF, and
then to set W_IE temporarily to 0000h, and then back to the old W_IE setting.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dswifipowerdownregisters"></A>&nbsp;
  DS Wifi Power-Down Registers
</FONT></TD></TR></TABLE><BR>
<B>4808036h - W_POWER_US (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Disable W_US_COUNT and W_BB_ports  (0=Enable, 1=Disable)
  1     Unknown (usually 0)
  2-15  Always zero
</TD></TR></TABLE>
Bit0=0 enables RFU by setting RFU.Pin11=HIGH, which activates the 22.000MHz
oscillator on the RFU board, the 22MHz clock is then output to RFU.Pin26.<BR>
<BR>
<B>4808038h - W_POWER_TX (R/W)</B><BR>
transmit-related power save or sth<BR>
init from firmware[05Ch]<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Auto Wakeup (1=Leave Idle Mode a while after IRQ15)
  1     Auto Sleep  (0=Enter Idle Mode on IRQ13)
  2     Unknown
  3     Unknown (Write-only) (used by firmware)
  4-15  Always zero
</TD></TR></TABLE>
<BR>
<B>480803Ch - W_POWERSTATE (R/W)/(R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Unknown (usually 0)                         (R/W)
  1     Request Power Enable (0=No, 1=Yes/queued)   (R/W, but not always)
  2-7   Always zero
  8     Indicates that Bit9 is about the be cleared (Read only)
  9     Current power state (0=Enabled, 1=Disabled) (Read only)
  10-15 Always zero
</TD></TR></TABLE>
[value =1: queue disable power state]     ;&lt;-- seems to be incorrect<BR>
[value =2: queue enable power state]      ;&lt;-- seems to be correct<BR>
Enabling causes wakeup interrupt (IRQ11).<BR>
Note: That queue stuff seems to work only if W_POWER_US=0 and W_MODE_RST=1.<BR>
<BR>
<B>4808040h - W_POWERFORCE - Force Power State (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     New value for W_POWERSTATE.Bit9  (0=Clear/Delayed, 1=Set/Immediately)
  1-14  Always zero
  15    Apply Bit0 to W_POWERSTATE.Bit9  (0=No, 1=Yes)
</TD></TR></TABLE>
Setting W_POWERFORCE=8001h whilst W_POWERSTATE.Bit9=0 acts immediately:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  (Doing this is okay. Switches to power down mode. Similar to IRQ13.)
  [4808034h]=0002h ;W_INTERNAL
  [480803Ch]=02xxh ;W_POWERSTATE
  [48080B0h]=0000h ;W_TXREQ_READ
  [480819Ch]=0046h ;W_RF_PINS
  [4808214h]=0009h ;W_RF_STATUS (idle)
</TD></TR></TABLE>
Setting W_POWERFORCE=8000h whilst W_POWERSTATE.Bit9=1 acts delayed:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  (Don't do this. After that sequence, the hardware seems to be messed up)
  W_POWERSTATE.Bit8 gets set to indicate the pending operation,
  while pending, changes to W_POWERFORCE aren't applied to W_POWERSTATE,
  while pending, W_POWERACK becomes Read/Write-able,
  writing 0000h to W_POWERACK does clear W_POWERSTATE.Bit8,
  and does apply POWERFORCE.Bit0 to W_POWERSTATE.Bit9
  and does deactivate Port W_POWERACK again.
</TD></TR></TABLE>
<BR>
<B>4808048h - W_POWER_? (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Unknown
  1     Unknown
  2-15  Always zero
</TD></TR></TABLE>
At whatever time (during transmit or so) it gets set to 0003h by hardware.<BR>
<BR>
See also: POWCNT2, W_BB_POWER.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dswifireceivecontrol"></A>&nbsp;
  DS Wifi Receive Control
</FONT></TD></TR></TABLE><BR>
<B>4808030h - W_RXCNT - Wifi Receive Control (parts R/W and W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Copy W_RXBUF_WR_ADDR to W_RXBUF_WRCSR                        (W)
  1-3   Unknown                                                      (R/W)
  4-6   Always zero
  7     Copy [4808094h] to [4808098h], and reset [4808094h] to 0000h (W)
          Ie. Copy W_TXBUF_REPLY1 to W_TXBUF_REPLY2,
          and reset W_TXBUF_REPLY1 to 0000h
  8-14  Unknown                                                      (R/W)
  15    Enable Queuing received data to RX FIFO                      (R/W)
</TD></TR></TABLE>
<BR>
<B>48080D0h - W_RXFILTER - (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     (0=Insist on W_BSSID, 1=Accept no matter of W_BSSID)
  1-6   Unknown (usually zero)
  7     Unknown (0 or 1)
  8     Unknown (0 or 1)
  9     Unknown (0 or 1)
  10    Unknown (0 or 1)       (when set, receives beacons, and maybe others)
  11    Unknown (usually zero)
  12    (0=Normal, 1=Accept even whatever garbage)
  13-15 Not used (always zero)
</TD></TR></TABLE>
Specifies what packets to allow.<BR>
0000h = Disable receive.<BR>
FFFFh = Enable receive.<BR>
0400h = Receives managment frames (and possibly others, too)<BR>
<BR>
<B>48080E0h - W_RXFILTER2 - (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Unknown (0=Receive Data Frames, 1=Ignore Data Frames) (?)
  1     Unknown
  2     Unknown
  3     Unknown (usually set)
  4-15  Not used (always zero)
</TD></TR></TABLE>
Firmware writes values 08h, 0Bh, 0Dh (aka 1000b, 1011b, 1101b).<BR>
Firmware usually has bit0 set, even when receiving data frames, so, in some
situations data frames seem to pass-through even when bit0 is set...? Possibly
that situation is when W_BSSID matches...?<BR>
Control/PS-Poll frames seem to be passed always (even if W_RXFILTER2=0Fh).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dswifireceivebuffer"></A>&nbsp;
  DS Wifi Receive Buffer
</FONT></TD></TR></TABLE><BR>
The dimensions of the circular Buffer are set with BEGIN/END values, hardware
automatically wraps to BEGIN when an incremented pointer hits END address.<BR>
<BR>
<B>Write Area</B><BR>
Memory between WRCSR and READCSR is free for receiving data, the hardware
writes incoming packets to this region (to WRCSR and up) (but without exceeding
READCSR), once when it has successfully received a complete packet, the
hardware moves WRCSR after the packet (aligned to a 4-byte boundary).<BR>
<BR>
<B>Read Area</B><BR>
Memory between READCSR and WRCSR contains received data, which can be read by
the CPU via RD_ADDR and RD_DATA registers (or directly from memory). Once when
having processed that data, the CPU must set READCSR to the end of it.<BR>
<BR>
<B>4808050h - W_RXBUF_BEGIN - Wifi RX Fifo start location (R/W)</B><BR>
<B>4808052h - W_RXBUF_END - Wifi RX Fifo end location (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15  Byte-offset in Wifi Memory (usually 4000h..5FFEh)
</TD></TR></TABLE>
Although the full 16bit are R/W, only the 12bit halfword offset in Bit1-12 is
actually used, the other bits seem to have no effect.<BR>
Some or all (?) of the below incrementing registers are automatically matched
to begin/end, that is, after incrementing, IF adr=end THEN adr=begin.<BR>
<BR>
<B>4808054h - W_RXBUF_WRCSR - Wifi RX Fifo Write or "end" cursor (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-11  Halfword Address in RAM
  12-15 Always zero
</TD></TR></TABLE>
This is a hardware controlled write location - it shows where the next packet
will be written..<BR>
<BR>
<B>4808056h - W_RXBUF_WR_ADDR - Wifi RX Fifo Write Cursor Latch value (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-11  Halfword Address in RAM
  12-15 Always zero
</TD></TR></TABLE>
This is a value that is latched into W_RXBUF_WRCSR, when the W_RXCNT latch bit
(W_RXCNT.Bit0) is written.<BR>
<BR>
<B>4808058h - W_RXBUF_RD_ADDR - Wifi CircBuf Read Address (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Always zero
  1-12  Halfword Address in RAM for reading via W_RXBUF_RD_DATA
  13-15 Always zero
</TD></TR></TABLE>
The circular buffer limits are the same as the range specified for the receive
FIFO, however the address can be set outside of that range and will only be
affected by the FIFO boundary if it crosses the FIFO end location by reading
from the circular buffer.<BR>
<BR>
<B>480805Ah - W_RXBUF_READCSR - Wifi RX Fifo Read or "start" cursor (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-11  Halfword Address in RAM
  12-15 Always zero
</TD></TR></TABLE>
This value is specified the same as W_RXBUF_WRCSR - it's purely software
controlled so it's up to the programmer to move the start cursor after loading
a packet. if W_RXBUF_READCSR != W_RXBUF_WRCSR, then one or more packets exist
in the FIFO that need to be processed. (See the section on HW RX Headers, for
information on calculating packet lengths) Once a packet has been processed,
the software should advance the read cursor to the beginning of the next
packet.<BR>
<BR>
<B>4808060h - W_RXBUF_RD_DATA - Wifi CircBuf Read Data (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15  Data
</TD></TR></TABLE>
returns the 16bit value at the address specified by W_RXBUF_RD_ADDR, and
increments W_RXBUF_RD_ADDR by 2. If the increment causes W_RXBUF_RD_ADDR to
equal the address specified in W_RXBUF_END, W_RXBUF_RD_ADDR will be reset to
the address specified in W_RXBUF_BEGIN.<BR>
Ports 1060h, 6060h, 7060h are PASSIVE mirrors of 0060h, reading from these
mirrors returns the old latched value from previous read from 0060h, but
without reading a new value from RAM, and without incrementing the address.<BR>
<BR>
<B>4808062h - W_RXBUF_GAP - Wifi RX Gap Address (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Always zero
  1-12  Halfword Address in RAM
  13-15 Always zero
</TD></TR></TABLE>
Seems to be intended to define a "gap" in the circular buffer, done like so:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Addr=Addr+2 and 1FFEh  ;address increment (by W_RXBUF_RD_DATA read)
  if Addr=RXBUF_END then ;normal begin/end wrapping (done before gap wraps)
     Addr=RXBUF_BEGIN
  if Addr=RXBUF_GAP then ;now gap-wrap (may include further begin/end wrap)
     Addr=RXBUF_GAP+RXBUF_GAPDISP*2
     if Addr&gt;=RXBUF_END then Addr=Addr+RXBUF_BEGIN-RXBUF_END  ;wrap more
</TD></TR></TABLE>
To disable the gap stuff, set both W_RXBUF_GAP and W_RXBUF_GAPDISP to zero.<BR>
<BR>
<B>4808064h - W_RXBUF_GAPDISP - Wifi RX Gap Displacement Offset (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-11  Halfword Offset, used with W_RXBUF_GAP (see there)
  12-15 Always zero
</TD></TR></TABLE>
Caution: On the DS-Lite, after adding it to W_RXBUF_RD_ADDR, the
W_RXBUF_GAPDISP setting is destroyed (reset to 0000h) by hardware. The original
DS leaves W_RXBUF_GAPDISP intact.<BR>
<BR>
<B>480805Ch - W_RXBUF_COUNT (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-11  Decremented on reads from W_RXBUF_RD_DATA
  12-15 Always zero
</TD></TR></TABLE>
Triggers IRQ09 when it reaches zero, and does then stay at zero (without
further decrementing, and without generating further IRQs).<BR>
Note: Also decremented on (accidental) writes to read-only W_RXBUF_RD_DATA.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dswifireceivestatistics"></A>&nbsp;
  DS Wifi Receive Statistics
</FONT></TD></TR></TABLE><BR>
<B>48081A8h - W_RXSTAT_INC_IF - Statistics Increment Flags (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-12   Increment Flags (see Port 48081B0h..1BFh)
  13-15  Always zero
</TD></TR></TABLE>
Bitmask for which statistics have been increased at least once.<BR>
Unknown how to reset/acknowledge these bits... possibly by reading from
48081A8h, or by reading from 48081B0h..1BFh, or eventually/obscurely by writing
to 48081ACh.<BR>
<BR>
<B>48081AAh - W_RXSTAT_INC_IE - Statistics Increment Interrupt Enable (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-12   Counter Increment Interrupt Enable (see 48081B0h..1BFh) (1=Enable)
  13-15  Unknown (usually zero)
</TD></TR></TABLE>
Statistic Interrupt Enable Control register for Count Up.<BR>
Note: ------&gt; seems to trigger IRQ02 ...?<BR>
<BR>
<B>48081ACh - W_RXSTAT_OVF_IF - Statistics Half-Overflow Flags (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-12   Half-Overflow Flags (see Port 48081B0h..1BFh)
  13-15  Always zero
</TD></TR></TABLE>
The W_RXSTAT_OVF_IF bits are simply containing the current bit7-value of the
corresponding counters, setting or clearing that counter bits is directly
reflected to W_RXSTAT_OVF_IF.<BR>
The recommended way to acknowledge W_RXSTAT_OVF_IF is to read the corresponding
counters (which are reset to 00h after reading). For some reason, the firmware
is additionally writing FFFFh to W_RXSTAT_OVF_IF (that is possibly a bug, or it
does acknowlege something internally?).<BR>
<BR>
<B>48081AEh - W_RXSTAT_OVF_IE - Statistics Half-Overflow Interrupt Enable (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-12   Half-Overflow Interrupt Enable (see Port 48081B0h..1BFh) (1=Enable)
  13-15  Unknown (usually zero)
</TD></TR></TABLE>
Statistic Interrupt Enable for Overflow, bits same as in W_RXSTAT_INC_IE<BR>
Note: ------&gt; seems to trigger IRQ04 ...?<BR>
<BR>
<B>48081B0h..1BFh - W_RXSTAT - Receive Statistics (R/W, except 1B5h: Read-only)</B><BR>
W_RXSTAT is a collection of 8bit counters, which are incremented upon certain
events. These entries are automatically reset to 0000h after reading. Should be
accessed with LDRH opcodes (using LDRB to read only 8bits does work, but the
read is internally expanded to 16bit, and so, the whole 16bit value will be
reset to 0000h).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Port      Dir  Bit  Expl.
  48081B0h  R/W  0    W_RXSTAT  ?
  48081B1h  -    -    Always 0  -
  48081B2h  R/W  1    W_RXSTAT  ?    "RX_RateErrorCount"
  48081B3h  R/W  2    W_RXSTAT  Length&gt;2348 error
  48081B4h  R/W  3    W_RXSTAT  RXBUF Full error
  48081B5h  R    4?   W_RXSTAT  ?    (R) (but seems to exist; used by firmware)
  48081B6h  R/W  5    W_RXSTAT  Length=0 or Wrong FCS Error
  48081B7h  R/W  6    W_RXSTAT  Packet Received Okay
                             (also increments on W_MACADDR mis-match)
                             (also increments on internal ACK packets)
                             (also increments on invalid IEEE type=3)
                             (also increments TOGETHER with 1BCh and 1BEh)
                             (not incremented on RXBUF_FULL error)
  48081B8h  R/W  7    W_RXSTAT  ?
  48081B9h  -    -    Always 0  -
  48081BAh  R/W  8    W_RXSTAT  ?
  48081BBh  -    -    Always 0  -
  48081BCh  R/W  9    W_RXSTAT  WEP Error (when FC.Bit14 is set)
  48081BDh  R/W  10   W_RXSTAT  ?
  48081BEh  R/W  11   W_RXSTAT  (duplicated sequence control)
  48081BFh  R/W  12   W_RXSTAT  ?
</TD></TR></TABLE>
<BR>
<B>48081C4h - W_RX_COUNT (W_INTERNAL) (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-?   Receive Okay Count (increments together with ports 48081B4h, 48081B7h)
  8-?   Receive Error Count (increments together with ports 48081B3h, 48081B6h)
</TD></TR></TABLE>
Increments when receiving a packet. Automatically reset to zero after reading.<BR>
<BR>
<B>48081D0h..1DFh - W_CMD_STAT - Multiplay Response Error Counters (R/W)</B><BR>
The multiplay error counters are only used when sending a multiplay command
(via W_TXBUF_CMD) to any connected slaves (which must be indicated by flags
located in the second halfword of the multiplay command's frame body).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  48081D0h        Not used (always zero)
  48081D1h..1DFh  Client 1..15 Response Error (increments on missing replies)
</TD></TR></TABLE>
If one or more of those slaves fail to respond, then the corresponding error
counters get incremented (at the master side). Automatically reset to zero
after reading.<BR>
Unknown if these counters do also increment at the slave side?<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dswifitransmitcontrol"></A>&nbsp;
  DS Wifi Transmit Control
</FONT></TD></TR></TABLE><BR>
<B>48080ACh - W_TXREQ_RESET - Reset Transfer Request Bits (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-3   Reset corresponding bits in W_TXREQ_READ (0=No change, 1=Reset)
  4-15  Unknown (if any)
</TD></TR></TABLE>
Firmware writes values 01h,02h,08h,0Dh, and FFFFh.<BR>
<BR>
<B>48080AEh - W_TXREQ_SET - Set Transfer Request Bits (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-3   Set corresponding bits in W_TXREQ_READ (0=No change, 1=Set)
  4-15  Unknown (if any)
</TD></TR></TABLE>
Firmware writes values 01h,02h,05h,08h,0Dh.<BR>
<BR>
<B>48080B0h - W_TXREQ_READ - Get Transfer Request Bits (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Send W_TXBUF_LOC1  (1=Transfer, if enabled in W_TXBUF_LOC1.Bit15)
  1     Send W_TXBUF_CMD   (1=Transfer, if enabled in W_TXBUF_CMD.Bit15)
  2     Send W_TXBUF_LOC2  (1=Transfer, if enabled in W_TXBUF_LOC2.Bit15)
  3     Send W_TXBUF_LOC3  (1=Transfer, if enabled in W_TXBUF_LOC3.Bit15)
  4     Unknown (seems to be always 1) (never used by firmware part4)
          Ah, except... Bit4 can be cleared via W_POWERFORCE
  5-15  Unknown/Not used
</TD></TR></TABLE>
Bit0-3 can be set/reset via W_TXREQ_SET/W_TXREQ_RESET. The setting in
W_TXREQ_READ remains intact even after the transfer(s) have completed.<BR>
If more than one of the LOC1,2,3 bits is set, then LOC3 is transferred first,
LOC1 last. Beacons are transferred in every Beacon Timeslot (if enabled in
W_TXBUF_BEACON.Bit15).<BR>
Bit0,2,3 are automatically reset upon IRQ14 (by hardware).<BR>
<BR>
<B>48080B6h - W_TXBUSY (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     W_TXBUF_LOC1  (1=Requested Transfer busy, or not yet started at all)
  1     W_TXBUF_CMD   (1=Requested Transfer busy, or not yet started at all)
  2     W_TXBUF_LOC2  (1=Requested Transfer busy, or not yet started at all)
  3     W_TXBUF_LOC3  (1=Requested Transfer busy, or not yet started at all)
  4     W_TXBUF_BEACON  (1=Beacon Transfer busy)
  5-15  Unknown (if any)
</TD></TR></TABLE>
Busy bits. If all three W_TXBUF_LOC's are sent, then it goes through values
0Dh,05h,01h,00h; ie. LOC3 is transferred first, LOC1 last. The register is
updated upon IRQ01 (by hardware).<BR>
Bit4 is set only in Beacon Timeslots.<BR>
<BR>
<B>48080B8h - W_TXSTAT - RESULT - Status of transmitted frame (R)</B><BR>
For LOC1-3, this register is updated at the end of a transfer (upon the IRQ01
request), if retries occur then it is updated only after the final retry.<BR>
For BEACON, this register is updated only if enabled in W_TXSTATCNT.Bit15, and
only after successful transfers (since beacon errors result in infinite
retries).<BR>
For CMD, this register is updated only if enabled in W_TXSTATCNT.Bit13,14).<BR>
Bit0/1 act similar to W_IF Bit1/3, however, the W_IF Bits are set after each
transmit (including retries).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     One (or more) Packet has Completed (1=Yes)
        (No matter if successful, for that info see Bit1)
        (No matter if ALL packets are done, for that info see Bit12-13)
  1     Packet Failed (1=Error)
  2-7   Unknown/Not used
  8-11  Usually 0, ...but firmware is checking for values 03h,08h,0Bh
        (gets set to 07h when transferred W_TXBUF_LOC1/2/3 did have Bit12=set)
        (gets set to 00h otherwise)
        (gets set to 03h after beacons; if enabled in W_TXSTATCNT.Bit15)
        (gets set to 08h or 0Bh after CMD; depending on W_TXSTATCNT.Bit13,14)
  12-13 Packet which has updated W_TXSTAT (0=LOC1/BEACON/CMD, 1=LOC2, 2=LOC3)
  14-15 Unknown/Not used
</TD></TR></TABLE>
No idea how to reset bit0/1 once when they are set?<BR>
<BR>
<B>4808008h - W_TXSTATCNT (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-12  Unknown (usually zero)
  13    Update W_TXSTAT=0B01h and trigger IRQ01 after CMD transmits  (1=Yes)
  14    Update W_TXSTAT=0800h and trigger IRQ01 after CMD transmits  (1=Yes)
  15    Update W_TXSTAT and trigger IRQ01 after BEACON transmits (0=No, 1=Yes)
</TD></TR></TABLE>
If both Bit13 and Bit14 are set, then Bit13 is having priority.<BR>
Note: LOC1..3 transmits are always updating W_TXSTAT and triggering IRQ01.<BR>
<BR>
<B>4808194h - W_TX_HDR_CNT - Disable Transmit Header Adjustments (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     IEEE FC.Bit12 and Duration (0=Auto/whatever, 1=Manual/Wifi RAM)
  1     IEEE Frame Check Sequence  (0=Auto/FCS/CRC32, 1=Manual/Wifi RAM)
  2     IEEE Sequence Control      (0=Auto/W_TX_SEQNO, 1=Manual/Wifi RAM)
  3-15  Always zero
</TD></TR></TABLE>
Allows to disable automatic adjustments of the IEEE header and checksum.<BR>
Note: W_TX_SEQNO can be also disabled by W_TXBUF_LOCn.Bit13 and by TXHDR[04h].<BR>
<BR>
<B>4808210h - W_TX_SEQNO - Transmit Sequence Number (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-11   Increments on IRQ07 (Transmit Start Interrupt)
  12-15  Always zero
</TD></TR></TABLE>
Also incremented shortly after IRQ12.<BR>
When enabled in W_TXBUF_LOCn.Bit13, this value replaces the upper 12bit of the
IEEE Frame Header's Sequence Control value (otherwise, when disabled, the
original value in Wifi RAM is used, and, in that case, W_TX_SEQNO is NOT
incremented).<BR>
Aside from W_TXBUF_LOCn.Bit13, other ways to disable W_TX_SEQNO are: Transmit
Hardware Header entry TXHDR[04h], and W_TX_HDR_CNT.Bit2.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dswifitransmitbuffers"></A>&nbsp;
  DS Wifi Transmit Buffers
</FONT></TD></TR></TABLE><BR>
<B>4808068h - W_TXBUF_WR_ADDR - Wifi CircBuf Write Address (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Always zero
  1-12  Halfword Address in RAM for Writes via W_TXBUF_WR_DATA
  13-15 Always zero
</TD></TR></TABLE>
<BR>
<B>4808070h - W_TXBUF_WR_DATA - Wifi CircBuf Write Data (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15  Data to be written to address specified in W_TXBUF_WR_ADDR
</TD></TR></TABLE>
After writing to this register, W_TXBUF_WR_ADDR is automatically incremented by
2, and, if it gets equal to W_TXBUF_GAP, then it gets additonally incremented
by W_TXBUF_GAPDISP*2.<BR>
<BR>
<B>4808074h - W_TXBUF_GAP - Wifi CircBuf Write Top (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Always zero
  1-12  Halfword Address
  13-15 Always zero
</TD></TR></TABLE>
<BR>
<B>4808076h - W_TXBUF_GAPDISP - CircBuf Write Offset from Top to Bottom (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-11  Halfword Offset (added to; if equal to W_TXBUF_GAP)
  12-15 Always zero
</TD></TR></TABLE>
Should be "0-write_buffer_size" (wrap from end to begin), or zero (no
wrapping).<BR>
Caution: On the DS-Lite, after adding it to W_TXBUF_WR_ADDR, the
W_TXBUF_GAPDISP setting is destroyed (reset to 0000h) by hardware. The original
DS leaves W_TXBUF_GAPDISP intact.<BR>
<BR>
Note: W_TXBUF_GAP and W_TXBUF_GAPDISP may be (not TOO probably) also used by
transmits via W_TXBUF_LOCn and W_TXBUF_BEACON (not tested).<BR>
<BR>
<B>4808080h - W_TXBUF_BEACON - Beacon Transmit Location (R/W)</B><BR>
<B>4808090h - W_TXBUF_CMD - Multiplay Command Transmit Location (R/W)</B><BR>
<B>48080A0h - W_TXBUF_LOC1 - Transmit location 1 (R/W)</B><BR>
<B>48080A4h - W_TXBUF_LOC2 - Transmit location 2 (R/W)</B><BR>
<B>48080A8h - W_TXBUF_LOC3 - Transmit location 3 (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-11  Halfword Address of TX Frame Header in RAM
  12    For LOC1-3: When set, W_TXSTAT.bit8-10 are set to 07h after transfer
                    And, when set, the transferred frame-body gets messed up?
        For BEACON: Unknown, no effect on W_TXSTAT
        For CMD: Unknown, no effect on W_TXSTAT
  13    IEEE Sequence Control (0=From W_TX_SEQNO, 1=Value in Wifi RAM)
        For BEACON: Unknown (always uses W_TX_SEQNO) (no matter of bit13)
  14    Unknown
  15    Transfer Request (1=Request/Pending)
</TD></TR></TABLE>
For LOC1..3 and CMD, Bit15 is automatically cleared after (or rather: during?)
transfer (no matter if the transfer was successful). For Beacons, bit15 is kept
unchanged since beacons are intended to be transferred repeatedly.<BR>
The purpose of W_TXBUF_CMD is unknown... maybe for automatic replies...?
Pictochat seems to use it for host-to-client data frames. W_TXBUF_CMD.Bit15 can
be set ONLY while W_CMD_COUNT is non-zero.<BR>
<BR>
<B>48080B4h - W_TXBUF_RESET (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Disable LOC1    (0=No change, 1=Reset W_TXBUF_LOC1.Bit15)
  1     Disable CMD     (0=No change, 1=Reset W_TXBUF_CMD.Bit15)
  2     Disable LOC2    (0=No change, 1=Reset W_TXBUF_LOC2.Bit15)
  3     Disable LOC3    (0=No change, 1=Reset W_TXBUF_LOC3.Bit15)
  4-5   Unknown/Not used
  6     Disable REPLY2  (0=No change, 1=Reset W_TXBUF_REPLY2.Bit15)
  7     Disable REPLY1  (0=No change, 1=Reset W_TXBUF_REPLY1.Bit15)
  8-15  Unknown/Not used
</TD></TR></TABLE>
Firmware writes values FFFFh, 40h, 02h, xxxx, 09h, 01h, 02h, C0h.<BR>
<BR>
<B>4808084h - W_TXBUF_TIM - Beacon TIM Index in Frame Body (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-7   Location of TIM parameters within Beacon Frame Body
  8-15  Not used/zero
</TD></TR></TABLE>
Usually set to 15h, that assuming that preceding Frame Body content is:
Timestamp(8), BeaconInterval(2), Capability(2), SuppRatesTagLenParams(4),
ChannelTagLenParam(3), TimTagLen(2); so the value points to TimParams (ie.
after TimTagLen).<BR>
<BR>
<B>480806Ch - W_TXBUF_COUNT (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-11  Decremented on writes to W_TXBUF_WR_DATA
  12-15 Always zero
</TD></TR></TABLE>
Triggers IRQ08 when it reaches zero, and does then stay at zero (without
further decrementing, and without generating further IRQs).<BR>
Note: Not affected by (accidental) reads from write-only W_TXBUF_WR_DATA.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dswifitransmiterrors"></A>&nbsp;
  DS Wifi Transmit Errors
</FONT></TD></TR></TABLE><BR>
<B>Automatic ACKs</B><BR>
Transmit errors occur on missing ACKs. The NDS hardware is automatically
responding with an ACK when receiving a packet (if it has been addressed to the
receipients W_MACADDR setting). And, when sending a packet, the NDS hardware is
automatically checking for ACK responses.<BR>
The only exception are packets that are sent to group addresses (ie. Bit0 of
the 48bit MAC address being set to "1", eg. Beacons sent to FF:FF:FF:FF:FF:FF),
the receipient(s) don't need to respond to such packets, and the sender always
passes okay without checking for ACKs.<BR>
<BR>
<B>480802Ch - W_TX_RETRYLIMIT (R/W)</B><BR>
Specifies the maximum number of retries on Transmit Errors (eg. 07h means one
initial transmit, plus up to 7 retries, ie. max 8 transmits in total).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-7   Retry Count (usually 07h)
  8-15  Unknown     (usually 07h)
</TD></TR></TABLE>
The Retry Count value is decremented on each Error (unless it is already 00h).
There's no automatic reload, so W_TX_RETRYLIMIT should be reinitialized by
software prior to each transmit (or, actually, there IS a reload?).<BR>
When sending multiple packets (by setting more than one bit with W_TXREQ_SET),
then the first packet may eat-up all retries, leaving only a single try to the
other packet(s).<BR>
<BR>
<B>48081C0h - W_TX_ERR_COUNT - TransmitErrorCount (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-7   TransmitErrorCount
  8-15  Always zero
</TD></TR></TABLE>
Increments on Transmit Errors. Automatically reset to zero after reading.<BR>
IRQ03 triggered when W_TX_ERR_COUNT is incremented (for NON-beacons ONLY).<BR>
IRQ05 triggered when W_TX_ERR_COUNT &gt; 7Fh (happens INCLUDING for beacons).<BR>
<BR>
<B>Error Notification</B><BR>
Transmit Errors can be sensed via W_TX_ERR_COUNT, IRQ03, IRQ05, TX Hardware
Header entry [00h], and W_TXSTAT.Bit1.<BR>
<BR>
<B>W_TXBUF_BEACON Errors</B><BR>
As the name says, W_TXBUF_BEACON is intended for sending Beacons to group
addresses (which do not require to respond by ACKs). So, transmit errors would
occur only when mis-using W_TXBUF_BEACON to send packets to individual
addresses, but the W_TXBUF_BEACON error handling isn't fully implemented:<BR>
First of, W_TX_RETRYLIMIT isn't used, instead, W_TXBUF_BEACON errors will
result in infinite retries.<BR>
Moreover, W_TXBUF_BEACON errors seem to increment W_TX_ERR_COUNT, but without
generating IRQ03, however, IRQ05 is generated when W_TX_ERR_COUNT&gt;7Fh.<BR>
<BR>
<B>Other Errors</B><BR>
The NDS transmit hardware seems to do little error checking on the packet
headers. The only known error-checked part is byte [04h] in the TX hardware
header (which must be 00h, 01h, or 02h). Aside from that, when sent to a group
address, it is passing okay even with invalid IEEE type/subtypes, and even with
Length/Rate entries set to zero. However, when sending such data to an
individual address, the receiving NDS won't respond by ACKs.<BR>
<BR>
<B>Note</B><BR>
Received ACKs aren't stored in WifiRAM (or, possibly, they ARE stored, but
without advancing W_RXBUF_WRCSR, so that the software won't see them, and so
that they will be overwritten by the next packet).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dswifistatus"></A>&nbsp;
  DS Wifi Status
</FONT></TD></TR></TABLE><BR>
<B>480819Ch - W_RF_PINS - Status of RF-Chip Control Signals (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0    Reportedly "carrier sense" (maybe 1 during RX.DTA?) (usually 0)
  1    TX.MAIN (RFU.Pin17) Transmit Data Phase          (0=No, 1=Active)
  2    Unknown (RFU.Pin3)  Seems to be always high      (Always 1=high?)
  3-5  Not used                                         (Always zero)
  6    TX.ON   (RFU.Pin14) Transmit Preamble+Data Phase (0=No, 1=Active)
         Uhhh, no that seems to be still wrong...
         Bit6 is often set, even when not transmitting anything...
  7    RX.ON   (RFU.Pin15) Receive Mode                 (0=No, 1=Enabled)
  8-15 Not used                                         (Always zero)
</TD></TR></TABLE>
Physical state of the RFU board's RX/TX pins. Similar to W_RF_STATUS.<BR>
<BR>
<B>4808214h - W_RF_STATUS - Current Transmit/Receive State (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-3  Current Transmit/Receive State:
        0 = Initial Value on power-up (before raising W_MODE_RST.Bit0)
        1 = RX Mode enabled (waiting for incoming data)
        2 = Switching from RX to TX (takes a few clock cycles)
        3 = TX Mode active  (sending preamble and data)
        4 = Switching from TX to RX (takes a few clock cycles)
        5 = Unknown, firmware checks for that value (maybe RX busy)
        6 = Unknown, firmware checks for that value (maybe RX busy)
        9 = Idle (upon IRQ13, and upon raising W_MODE_RST.Bit0)
        ----
        5 = Receive ACK phase ?
        6 =
        7 =
        8 = Multiplay related ? (when sending through W_TXBUF_CMD ?)
  4-15 Always zero?
</TD></TR></TABLE>
Numeric Status Code. Similar to W_RF_PINS.<BR>
<BR>
<B>4808268h - W_RXTX_ADDR - Current Receive/Transmit Address (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-11   Halfword address
  12-15  Always zero
</TD></TR></TABLE>
Indicates the halfword that is currently transmitted or received. Can be used
by Start Receive IRQ06 handler to determine how many halfwords of the packet
have been already received (allowing to pre-examine portions of the packet
header even when the whole packet isn't fully received). Can be also used in
Transmit Start IRQ07 handler to determine which packet is currently
transmitted.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dswifitimers"></A>&nbsp;
  DS Wifi Timers
</FONT></TD></TR></TABLE><BR>
<B>48080E8h - W_US_COUNTCNT - Microsecond counter enable (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Counter Enable (0=Disable, 1=Enable)
  1-15  Always zero
</TD></TR></TABLE>
Activates W_US_COUNT, and also W_BEACONCOUNT1 and W_BEACONCOUNT2 (which are
decremented when lower 10bit of W_US_COUNT wrap from 3FFh to 000h). Note:
W_POWER_US must be enabled, too.<BR>
<BR>
<B>48080F8h - W_US_COUNT0 - Microsecond counter, bits 0-15 (R/W)</B><BR>
<B>48080FAh - W_US_COUNT1 - Microsecond counter, bits 16-31 (R/W)</B><BR>
<B>48080FCh - W_US_COUNT2 - Microsecond counter, bits 32-47 (R/W)</B><BR>
<B>48080FEh - W_US_COUNT3 - Microsecond counter, bits 48-63 (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-63  Counter Value in microseconds (incrementing)
</TD></TR></TABLE>
Clocked by the 22.00MHz oscillator on the RFU board (ie. not by the 33.51MHz
system clock). The 22.00MHz are divided by a 22-step prescaler.<BR>
<BR>
<B>48080EAh - W_US_COMPARECNT - Microsecond compare enable (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Compare Enable (0=Disable, 1=Enable) (IRQ14/IRQ15)
  1     Force IRQ14    (0=No, 1=Force Now)   (Write-only)
  2-15  Always zero
</TD></TR></TABLE>
Activates IRQ14 on W_US_COMPARE matches, and IRQ14/IRQ15 on W_BEACONCOUNT1.<BR>
<BR>
<B>48080F0h - W_US_COMPARE0 - Microsecond compare, bits 0-15 (R/W)</B><BR>
<B>48080F2h - W_US_COMPARE1 - Microsecond compare, bits 16-31 (R/W)</B><BR>
<B>48080F4h - W_US_COMPARE2 - Microsecond compare, bits 32-47 (R/W)</B><BR>
<B>48080F6h - W_US_COMPARE3 - Microsecond compare, bits 48-63 (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Always zero... firmware writes 1 though (maybe write-only flag?)
  1-9   Always zero
  10-63 Compare Value in milliseconds (aka microseconds/1024)
</TD></TR></TABLE>
Triggers IRQ14 (see IRQ14 notes below) when W_US_COMPARE matches W_US_COUNT.<BR>
Usually set to FFFFFFFFFFFFFC00h (ie. almost/practically never). Instead, IRQ14
is usually derived via W_BEACONCOUNT1.<BR>
<BR>
<B>480811Ch - W_BEACONCOUNT1 (R/W)</B><BR>
Triggers IRQ14 and IRQ15 (see IRQ14/IRQ15 notes below) when it reaches 0000h
(if W_PRE_BEACON is non-zero, then IRQ15 occurs that many microseconds in
advance).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15  Decrementing Millisecond Counter (reloaded with W_BEACONINT upon IRQ14)
</TD></TR></TABLE>
Set to W_BEACONINT upon IRQ14 events (unlike the other W_US_COMPARE related
actions, this is done always, even if W_US_COMPARECNT is zero).<BR>
When reaching 0000h, it is immediately reloaded (as for US_COUNT matches), so
the counting sequence is ..,3,2,1,BEACONINT,.. (not 3,2,1,ZERO,BEACONINT).<BR>
<BR>
<B>4808134h - W_BEACONCOUNT2 - Post-Beacon Counter (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15  Decrementing Millisecond Counter (reloaded with FFFFh upon IRQ14)
</TD></TR></TABLE>
Triggers IRQ13 when it reaches 0000h (no matter of W_US_COMPARECNT), and does
then stay fixed at 0000h (without any further decrement/wrapping to FFFFh).<BR>
Set to FFFFh upon IRQ14 (by hardware), the IRQ14 handler should then adjust the
register (by software) by adding the Tag DDh Beacon header's Stepping value
(usually 000Ah) to it.<BR>
Seems to be used to indicate beacon transmission time (possible including
additional time being reserved for responses)?<BR>
<BR>
<B>480808Ch - W_BEACONINT - Beacon Interval (R/W)</B><BR>
Reload value for W_BEACONCOUNT1.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-9   Frequency in milliseconds of beacon transmission
  10-15 Always zero
</TD></TR></TABLE>
Should be initialized randomly to 0CEh..0DEh or so. The random setting reduces
risk of repeated overlaps with beacons from other hosts.<BR>
<BR>
<B>4808110h - W_PRE_BEACON - Pre-Beacon Time (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15  Pre-Beacon Time in microseconds (static value, ie. NOT decrementing)
</TD></TR></TABLE>
Allows to define the distance between IRQ15 and IRQ14. The setting doesn't
affect the IRQ14 timing (which occurs at the W_BEACONCOUNT1'th millisecond
boundary), but IRQ15 occurs in advance (at the W_BEACONCOUNT1'th millisecond
boundary minus W_PRE_BEACON microseconds). If W_PRE_BEACON is zero, then both
IRQ14 and IRQ15 occur exactly at the same time.<BR>
<BR>
<B>4808088h - W_LISTENCOUNT - Listen Count (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-7   Decremented by hardware at IRQ14 events (ie. once every beacon)
  8-15  Always zero
</TD></TR></TABLE>
Reload occurs immediately BEFORE decrement, ie. with W_LISTENINT=04h, it will
go through values 03h,02h,01h,00h,03h,02h,01h,00h,etc.<BR>
<BR>
<B>480808Eh - W_LISTENINT - Listen Interval (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-7   Listen Interval, counted in beacons (usually 02h)
  8-15  Always zero
</TD></TR></TABLE>
Reload value for W_LISTENCOUNT.<BR>
<BR>
<B>480810Ch - W_CONTENTFREE (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15  Decrementing microsecond counter
</TD></TR></TABLE>
Operated always (no matter of W_US_COUNTCNT).<BR>
Once when it has reached 0000h, it seems to stay fixed at 0000h.<BR>
"[Set to the remaining duration of contention-free period when<BR>
receiving beacons - only *really* necessary for powersaving mode]"<BR>
<BR>
<B>IRQ13 Notes (Post-Beacon Interrupt)</B><BR>
IRQ13 is generated by W_BEACONCOUNT2. It's simply doing:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  W_IF.Bit13=1      ;interrupt request
</TD></TR></TABLE>
If W_POWER_TX.Bit1=0, then additionally enter sleep mode:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  [4808034h]=0002h ;W_INTERNAL   ;(similar to W_POWERFORCE=8001h)
  [480803Ch]=02xxh ;W_POWERSTATE ;(W_TXREQ_READ.Bit4 is kept intact though)
  [480819Ch]=0046h ;W_RF_PINS.7=0;disable receive (enter idle mode) (RX.ON=Low)
  [4808214h]=0009h ;W_RF_STATUS=9;indicate idle mode
</TD></TR></TABLE>
Unlike for IRQ14/IRQ15, that's done no matter of W_US_COMPARECNT.<BR>
<BR>
<B>IRQ14 Notes (Beacon Interrupt)</B><BR>
IRQ14 is generated by W_US_COMPARE, and by W_BEACONCOUNT1.<BR>
Aside from just setting the IRQ flag in W_IF, the hardware does:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  W_BEACONCOUNT1=W_BEACONINT                             ;next IRQ15/IRQ14
  (Above is NOT done when IRQ14 was forced via W_US_COMPARECNT.Bit1)
</TD></TR></TABLE>
If W_US_COMPARECNT is 1, then the hardware does additionally:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  (Below IS ALSO DONE when IRQ14 was forced via W_US_COMPARECNT.Bit1)
  W_IF.Bit14=1
  W_BEACONCOUNT2=FFFFh ;about 64 secs (ie. almost never) ;next IRQ13 ("never")
  W_TXREQ_READ=W_TXREQ_READ AND FFF2h
  if W_TXBUF_BEACON.15 then W_TXBUSY.Bit4=1
  if W_LISTENCOUNT=00h then W_LISTENCOUNT=W_LISTENINT
  W_LISTENCOUNT=W_LISTENCOUNT-1
</TD></TR></TABLE>
If W_TXBUF_BEACON.Bit15=1, then following is done shortly after IRQ14:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  W_RF_PINS.Bit7=0  ;disable receive (RX.ON=Low)
  W_RF_STATUS=2     ;indicate switching from RX to TX mode
</TD></TR></TABLE>
If W_TXBUF_BEACON.Bit15=1, then following is done a bit later:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  W_RF_PINS.Bit6=1  ;transmit preamble start (TX.ON=High)
  W_RF_STATUS=3     ;indicate TX mode
</TD></TR></TABLE>
The IRQ14 handler should then do the following (by software):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  W_BEACONCOUNT2 = W_BEACONCOUNT2 + TagDDhSteppingValue  ;next IRQ13
</TD></TR></TABLE>
For using only ONE of the two IRQ14 sources: W_BEACONCOUNT1 can be disabled by
setting both W_BEACONCOUNT1 and W_BEACONINT to zero. W_US_COMPARE can be sorts
of "disabled" by setting it to value distant from W_US_COUNT, such like
compare=count-400h.<BR>
<BR>
<B>IRQ07 Notes (Transmit Start Data; occurs after preamble)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  W_IF.Bit7=1       ;interrupt request
  W_RF_PINS.Bit1=1  ;start data transfer (preamble finished now) (TX.MAIN=High)
</TD></TR></TABLE>
Below only if packet was sent through W_TXBUF_BEACON, or if it was sent via
W_TXBUF_LOCn, with W_TXBUF_LOCn.Bit13 being zero:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  [TXBUF...] = W_TX_SEQNO*10h   ;auto-adjust IEEE Sequence Control
  W_TX_SEQNO=W_TX_SEQNO+1       ;increase sequence number
</TD></TR></TABLE>
<BR>
<B>IRQ01 Notes (Transmit Done)</B><BR>
The following happens shortly before IRQ01:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  W_RF_PINS.Bit6=0  ;disable TX (TX.ON=Low)
  W_RF_STATUS=4     ;indicate switching from TX to RX mode
</TD></TR></TABLE>
Then, upon IRQ01, the following happens:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  W_IF.Bit1=1       ;interrupt request
  W_RF_PINS.Bit1=0  ;disable TX (TX.MAIN=Low)
  W_RF_PINS.Bit7=1  ;enable RX (RX.ON=High)
  W_RF_STATUS=1     ;indicate RX mode
</TD></TR></TABLE>
<BR>
<B>IRQ15 Notes (Pre-Beacon Interrupt)</B><BR>
IRQ15 is generated via W_BEACONCOUNT1 and W_PRE_BEACON. It's simply doing:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  if W_US_COMPARECNT=1 then W_IF.Bit15=1
</TD></TR></TABLE>
If W_POWER_TX.Bit0=1, then additionally wakeup from sleep mode:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  W_RF_PINS.Bit7=1  ;enable RX (RX.ON=High) ;\gets set like so a good while
  W_RF_STATUS=1     ;indicate RX mode       ;/after IRQ15 (but not immediately)
</TD></TR></TABLE>
<BR>
<B>Beacon IRQ Sequence</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  IRQ15  Pre-Beacon  (beacon will be transferred soon)
  IRQ14  Beacon      (beacon will be transferred very soon) (carrier starts)
  IRQ07  Tx Start    (beacon transfer starts) (if enabled in W_TXBUF_BEACON.15)
  IRQ01  Tx End      (beacon transfer done) (if enabled in W_TXSTATCNT.15)
  IRQ13  Post-Beacon (beacon transferred) (unless next IRQ14 occurs earlier)
</TD></TR></TABLE>
That, for tranmitting beacons. (For receiving, IRQ07/IRQ01 would be replaced by
Rx IRQ's, provided that a remote unit is sending beacons).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dswifimultiplaymaster"></A>&nbsp;
  DS Wifi Multiplay Master
</FONT></TD></TR></TABLE><BR>
These registers are used for multiplay host-to-client (aka master to slave)
commands.<BR>
<BR>
<B>48080EEh - W_CMD_COUNTCNT (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Enable W_CMD_COUNT (0=Disable, 1=Enable)
  1-15  Always Zero
</TD></TR></TABLE>
<BR>
<B>4808118h - W_CMD_COUNT (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15  Decremented once every 10 microseconds (Stopped at 0000h)
</TD></TR></TABLE>
Written by firmware. Firmware IRQ14 handler checks for read value&lt;=0Ah.<BR>
When it reaches zero, W_TXBUF_CMD is transferred (if enabled in
W_TXBUF_CMD.Bit15, and in W_TXREQ_READ.Bit1), it does then trigger two (!)
transfer start interrupts (IRQ07), transfer end is then indicated by a single
IRQ12, optionally (when enabled in W_TXSTATCNT, IRQ01 (transfer done) is
additionally generated (simultaneously with above IRQ12).<BR>
NOPE, above isn't quite right..... when W_CMD_COUNT is set to a very small
value, then ONLY IRQ12 is triggered (so it might specify the duration during
which the IRQ07's for W_TXBUF_CMD are allowed?)<BR>
<BR>
<B>48080C0h - W_CMD_TOTALTIME - (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15  Duration per ALL slave response packet(s) in microseconds
</TD></TR></TABLE>
Before sending a MASTER packet, this port should be set to the same value as
the MASTER packet's IEEE header's Duration/ID entry.<BR>
<BR>
<B>48080C4h - W_CMD_REPLYTIME - (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15  Duration per SINGLE slave response packet in microseconds
</TD></TR></TABLE>
Before sending a MASTER packet, this port should be set to the expected per
slave response time.<BR>
Note: Nintendo's multiboot/pictochat code is also putting this value in the 1st
halfword of the MASTER packet's frame body.<BR>
<BR>
<B>At 2MBit/s transfer rate, the values should be set up sorts of like so:</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  master_time = (master_bytes*4)+(60h)     ;60h = 96 decimal = short preamble
  slave_time = (slave_bytes*4)+(0D0h..0D2h)
  all_slave_time = (EAh..F0h)+(slave_time+0Ah)*num_slaves
  txhdr[2]   = slave_bits      ;hardware header (*)
  ieee[2]    = all_slave_time  ;ieee header (duration/id)
  body[0]    = slave_time      ;duration per slave (for multiboot/pictochat)
  body[2]    = slave_bits      ;frame body -- required (*)
  [48080C0h] = all_slave_time  ;
  [48080C4h] = slave_time      ;duration per slave
  [4808118h] = (388h+(num_slaves*slave_time)+master_time+32h)/10
  [4808090h] = 8000h+master_packet_address   ;start transmit
</TD></TR></TABLE>
With the byte values counting the ieee frame header+body+fcs.<BR>
(*) The hardware doesn't actually seem to use the "slave_bits" entry in the
hardware header, instead, it is using the "slave_bits" entry in the frame
body(!)<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dswifimultiplayslave"></A>&nbsp;
  DS Wifi Multiplay Slave
</FONT></TD></TR></TABLE><BR>
These registers are used for multiplay client-to-host (aka slave to master)
responses.<BR>
<BR>
<B>4808094h - W_TXBUF_REPLY1 - Multiplay Response Transmit Location 1 (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-11  Halfword address
  12-14 Unknown (the bits can be set, ie. they DO exist)
  15    Enable
</TD></TR></TABLE>
Response packet address. The register setting probably doesn't directly affect
the hardware, it's sole purpose seems to initialize 4808098h (see there).<BR>
<BR>
<B>4808098h - W_TXBUF_REPLY2 - Multiplay Response Transmit Location 2 (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-11  Halfword address
  12-14 Unknown (the bits can be set, ie. they DO exist)
  15    Enable
</TD></TR></TABLE>
This register seems to contain the actual response packet address. However,
since it's read-only, software cannot set it directly. Instead, software must
write the address to 4808094h, and then latch it from 4808094h to 4808098h
(via. W_RXCNT.Bit7).<BR>
<BR>
<B>Notes</B><BR>
Not sure if there's also auto-latching (similar to manual W_RXCNT.Bit7)?<BR>
Unknown if W_TXBUF_REPLY2.Bit15 is automatically reset after transfer?<BR>
Not sure if/how the hardware determines WHEN to send reply packets (eg. it
should NOT send them after receiving Beacons) (eventually the Start Receive IRQ
handler must examine the incoming packet, and then software must decide if it
wants to respond by sending the reply) (if there are multiple slaves, the
response order is probably automatically handled in respect to the local
W_AID_LOW setting) (although, if, for example, ONLY slave 5 exists, then it
ought to know that slave 5 is the &lt;first&gt; slave; that might happen if
slave 1..4 have left the communication; that, unless the slaves would be
automatically renumbered by software (?), so slave 5 would be become slave 1).
Some of the Unknown Registers (namely Ports W_X_244h and W_X_228h) are probably
also related to the REPLY function.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dswificonfigurationports"></A>&nbsp;
  DS Wifi Configuration Ports
</FONT></TD></TR></TABLE><BR>
<B>4808120h - W_CONFIG_120h (R/W)  ;81ff 0048-&gt;SAME ...init from firmware[04Ch]</B><BR>
<B>4808122h - W_CONFIG_122h (R/W)  ;ffff 4840-&gt;SAME ...init from firmware[04Eh]</B><BR>
<B>4808124h - W_CONFIG_124h (R/W)  ;ffff 0000-&gt;0032 ...init from firmware[05Eh]</B><BR>
<B>4808128h - W_CONFIG_128h (R/W)  ;ffff 0000-&gt;01F4 ...init from firmware[060h]</B><BR>
<B>4808130h - W_CONFIG_130h (R/W)  ;0fff 0142-&gt;0140 ...init from firmware[054h]</B><BR>
<B>4808132h - W_CONFIG_132h (R/W)  ;8fff 8064-&gt;SAME ...init from firmware[056h]</B><BR>
<B>4808140h - W_CONFIG_140h (R/W)  ;ffff 0000-&gt;E0E0 ...init from firmware[058h]</B><BR>
<B>4808142h - W_CONFIG_142h (R/W)  ;ffff 2443-&gt;SAME ...init from firmware[05Ah]</B><BR>
<B>4808144h - W_CONFIG_144h (R/W)  ;00ff 0042-&gt;SAME ...init from firmware[052h]</B><BR>
<B>4808146h - W_CONFIG_146h (R/W)  ;00ff 0016-&gt;0002 ...init from firmware[044h]</B><BR>
<B>4808148h - W_CONFIG_148h (R/W)  ;00ff 0016-&gt;0017 ...init from firmware[046h]</B><BR>
<B>480814Ah - W_CONFIG_14Ah (R/W)  ;00ff 0016-&gt;0026 ...init from firmware[048h]</B><BR>
<B>480814Ch - W_CONFIG_14Ch (R/W)  ;ffff 162C-&gt;1818 ...init from firmware[04Ah]</B><BR>
<B>4808150h - W_CONFIG_150h (R/W)  ;ff3f 0204-&gt;0101 ...init from firmware[062h]</B><BR>
<B>4808154h - W_CONFIG_154h (R/W)  ;7a7f 0058-&gt;SAME ...init from firmware[050h]</B><BR>
These ports are to be initialized from firmware settings.<BR>
Above comments show the R/W bits (eg. 81FFh means bit15 and bit8-0 are R/W,
bit14-9 are always zero), followed by the initial value on Reset (eg. 0048h),
followed by new value after initialization from firmware settings (eg. 0032h,
or SAME if the Firmware value is equal to the Reset value), followed by the
location in firmware where the new value comes from (these values seem to be
identical in all currently existing consoles).<BR>
Note: Firmware part4 changes W_CONFIG_124h to C8h, and W_CONFIG_128h to 7D0h,
and W_CONFIG_150h to 202h, and W_CONFIG_140h depending on tx rate and preamble:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  W_CONFIG_140h = firmware[058h]+0202h             ;1Mbit/s
  W_CONFIG_140h = firmware[058h]+0202h-6161h       ;2Mbit/s with long preamble
  W_CONFIG_140h = firmware[058h]+0202h-6161h-6060h ;2Mbit/s with short preamble
</TD></TR></TABLE>
<BR>
<B>48080ECh - W_CONFIG_0ECh (R/W) ;firmware writes 3F03h (same as on power-up)</B><BR>
<B>48080D4h - W_CONFIG_0D4h (R/W) ;firmware writes 0003h (affectd by W_MODE_RST)</B><BR>
<B>48080D8h - W_CONFIG_0D8h (R/W) ;firmware writes 0004h (same as on power-up)</B><BR>
<B>48080DAh - W_CONFIG_0DAh (R/W) ;firmware writes 0602h (same as on power-up)</B><BR>
<B>4808254h - W_CONFIG_254h (?) ;firmware writes 0000h (read: EEEEh on DS-Lite)</B><BR>
Firmware just initializes these ports with fixed values, without further using
them after initialization.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dswifibasebandchipbb"></A>&nbsp;
  DS Wifi Baseband Chip (BB)
</FONT></TD></TR></TABLE><BR>
BB-Chip Mitsumi MM3155 (DS), or BB/RF-Chip Mitsumi MM3218 (DS-Lite)<BR>
<BR>
<B>4808158h - W_BB_CNT - Baseband serial transfer control (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-7   Index     (00h-68h)
  8-11  Not used  (should be zero)
  12-15 Direction (5=Write BB_WRITE to Chip, 6=Read from Chip to BB_READ)
</TD></TR></TABLE>
Transfer is started after writing to this register.<BR>
<BR>
<B>480815Ah - W_BB_WRITE - Baseband serial write data (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-7   Data to be sent to chip (by following W_BB_CNT transfer)
  8-15  Not used (should be zero)
</TD></TR></TABLE>
<BR>
<B>480815Ch - W_BB_READ - Baseband serial read data (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-7   Data received from chip (from previous W_BB_CNT transfer)
  8-15  Not used (always zero)
</TD></TR></TABLE>
<BR>
<B>480815Eh - W_BB_BUSY - Baseband serial busy flag (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Transfer Busy (0=Ready, 1=Busy)
  1-15  Always zero
</TD></TR></TABLE>
Used to sense transfer completion after writes to W_BB_CNT.<BR>
Not sure if I am doing something wrong... but the busy flag doesn't seem to get
set immediately after W_BB_CNT writes, and works only after waiting a good
number of clock cycles?<BR>
<BR>
<B>4808160h - W_BB_MODE (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-7   Always zero
  8     Unknown (usually 1) (no effect no matter what setting?)
  9-13  Always zero
  14    Unknown (usually 0) (W_BB_READ gets unstable when set)
  15    Always zero
</TD></TR></TABLE>
This register is initialized by firmware bootcode - don't change.<BR>
<BR>
<B>4808168h - W_BB_POWER (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-3   Disable whatever   (usually 0Dh=disable)
  4-14  Always zero
  15    Disable W_BB_ports (usually 1=Disable)
</TD></TR></TABLE>
Must be set to 0000h before accessing BB registers.<BR>
<BR>
<B>Read-Write-Ability of the BB-Chip Mitsumi MM3155 registers (DS)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Index    Num Dir Expl.
  00h        1 R   always 6Dh (R) (Chip ID)
  01h..0Ch  12 R/W 8bit R/W
  0Dh..12h   6 -   always 00h
  13h..15h   3 R/W 8bit R/W
  16h..1Ah   5 -   always 00h
  1Bh..26h  12 R/W 8bit R/W
  27h        1 -   always 00h
  28h..4Ch     R/W 8bit R/W
  4Dh        1 R   always 00h or BFh (depending on other regs)
  4Eh..5Ch     R/W 8bit R/W
  5Dh        1 R   always 01h (R)
  5Eh..61h     -   always 00h
  62h..63h   2 R/W 8bit R/W
  64h        1 R   always FFh or 3Fh (depending on other regs)
  65h        1 R/W 8bit R/W
  66h        1 -   always 00h
  67h..68h   2 R/W 8bit R/W
  69h..FFh     -   always 00h
</TD></TR></TABLE>
<BR>
<B>Read-Write-Ability of the BB/RF-Chip Mitsumi MM3218 (DS-Lite)</B><BR>
Same as above. Except that reading always seems to return [5Dh]=00h. And, for
whatever reason, Nintendo initializes DS-Lite registers by writing [00h]=03h
and [66h]=12h. Nethertheless, the registers always read as [00h]=6Dh and
[66h]=00h, ie. same as on original DS.<BR>
<BR>
<B>Important BB Registers</B><BR>
Registers 0..68h are initialized by firmware bootcode, and (most) of these
settings do not need to be changed by other programs, except for:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Addr Initial Meaning
  01h 0x9E    [unsetting/resetting bit 7 initializes/resets the system?]
  02h         unknown (firmware is messing with this register)
  06h         unknown (firmware is messing with this register, too)
  13h 0x00    CCA operation - criteria for receiving
                    0=only use Carrier Sense (CS)
                    1=only use Energy Detection (ED)
                    2=receive if CS OR ED
                    3=receive only if CS AND ED
  1Eh 0xBB    see change channels flowchart (Ext. Gain when RF[09h].bit16=0)
  35h 0x1F    Energy Detection (ED) criteria
              value 0..61 (representing energy levels of -60dBm to -80dBm)
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dswifirfchip"></A>&nbsp;
  DS Wifi RF Chip
</FONT></TD></TR></TABLE><BR>
RF-Chip RF9008 (compatible to RF2958 from RF Micro Devices, Inc.) (Original DS)<BR>
BB/RF-Chip Mitsumi MM3218 (DS-Lite)<BR>
<BR>
<B>480817Ch - W_RF_DATA2 - RF chip serial data/transfer enable (R/W)</B><BR>
For Type2 (ie. firmware[040h]&lt;&gt;3):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-1   Upper 2bit of 18bit data
  2-6   Index   (00h..1Fh) (firmware uses only 00h..0Bh)
  7     Command (0=Write data, 1=Read data)
  8-15  Should be zero (not used with 24bit transfer)
</TD></TR></TABLE>
For Type3 (ie. firmware[040h]=3):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-3   Command (5=Write data, 6=Read data)
  4-15  Should be zero (not used with 20bit transfer)
</TD></TR></TABLE>
Writing to this register starts the transfer.<BR>
<BR>
<B>480817Eh - W_RF_DATA1 - RF chip serial data (R/W)</B><BR>
For Type2 (ie. firmware[040h]&lt;&gt;3):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15  Lower 16bit of 18bit data
</TD></TR></TABLE>
For Type3 (ie. firmware[040h]=3):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-7   Data (to be written to chip) (or being received from chip)
  8-15  Index (usually 00h..28h) (index 40h..FFh are mirrors of 00h..3Fh)
</TD></TR></TABLE>
This value should be set before setting W_RF_DATA2.<BR>
<BR>
<B>4808180h - W_RF_BUSY - RF chip serial busy flag (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Transfer Busy (0=Ready, 1=Busy)
  1-15  Always zero
</TD></TR></TABLE>
Used to sense transfer completion after writes to W_RF_DATA2.<BR>
<BR>
<B>4808184h - W_RF_CNT - RF chip serial control (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-5   Transfer length (init from firmware[041h].Bit0-5)
  6-7   Always zero
  8     Unknown         (init from firmware[041h].Bit7)
  9-13  Always zero
  14    Unknown         (usually 0)
  15    Always zero
</TD></TR></TABLE>
This register is initialized by firmware bootcode - don't change.<BR>
Usually, Type2 has length=24bit and flag=0. Type3 uses length=20bit and flag=1.<BR>
<BR>
<B>Caution For Type2 (ie. firmware[040h]&lt;&gt;3)</B><BR>
Before accessing Type2 RF Registers, first BB[01h] must have been properly
initialized (ie. BB[01h].Bit7 must have been toggled from 0-to-1).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dswifirf9008registers"></A>&nbsp;
  DS Wifi RF9008 Registers
</FONT></TD></TR></TABLE><BR>
<B>RF9008 (RF2958 compatible)</B><BR>
2.4GHz Spread-Spectrum Transceiver - RF Micro Devices, Inc.<BR>
<BR>
<B>RF chip data (Type2) (initial NDS settings from firmware, example)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Firmware   Index   Data
  (24bit)    (4bit)  (18bit)
  00C007h  =  00h  + 0C007h ;-also set to 0C008h for power-down
  129C03h  =  04h  + 29C03h
  141728h  =  05h  + 01728h ;\these are also written when changing channels
  1AE8BAh  =  06h  + 2E8BAh ;/
  1D456Fh  =  07h  + 1456Fh
  23FFFAh  =  08h  + 3FFFAh
  241D30h  =  09h  + 01D30h ;-bit10..14 should be also changed per channel?
  """"50h  =  """  + """50h ;firmware v5 and up uses narrower tx filter
  280001h  =  0Ah  + 00001h
  2C0000h  =  0Bh  + 00000h
  069C03h  =  01h  + 29C03h
  080022h  =  02h  + 00022h
  0DFF6Fh  =  03h  + 1FF6Fh
</TD></TR></TABLE>
<BR>
<B>RF[00h] - Configuration Register 1 (CFG1) (Power on: 00007h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  17-16 Reserved, program to zero (0)
  15-14 Reference Divider Value (0=Div2, 1=Div3, 2=Div44, 3=Div1)
  3     Sleep Mode Current      (0=Normal, 1=Very Low)
  2     RF VCO Regulator Enable (0=Disable, 1=Enable)
  1     IF VCO Regulator Enable (0=Disable, 1=Enable)
  0     IF VGA Regulator Enable (0=Disable, 1=Enable)
</TD></TR></TABLE>
<BR>
<B>RF[01h] - IF PLL Register 1 (IFPLL1) (Power on: 09003h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  17    IF PLL Enable                      (0=Disable, 1=Enable)
  16    IF PLL KV Calibration Enable       (0=Disable, 1=Enable)
  15    IF PLL Coarse Tuning Enable        (0=Disable, 1=Enable)
  14    IF PLL Loop Filter Select          (0=Internal, 1=External)
  13    IF PLL Charge Pump Leakage Current (0=Minimum value, 1=2*Minimum value)
  12    IF PLL Phase Detector Polarity     (0=Positive, 1=Negative)
  11    IF PLL Auto Calibration Enable     (0=Disable, 1=Enable)
  10    IF PLL Lock Detect Enable          (0=Disable, 1=Enable)
  9     IF PLL Prescaler Modulus           (0=4/5 Mode, 1=8/9 Mode)
  8-4   Reserved, program to zero (0)
  3-0   IF VCO Coarse Tuning Voltage       (N=Voltage*16/VDD)
</TD></TR></TABLE>
<BR>
<B>RF[02h] - IF PLL Register 2 (IFPLL2) (Power on: 00022h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  17-16 Reserved, program to zero (0)
  15-0  IF PLL divide-by-N value
</TD></TR></TABLE>
<BR>
<B>RF[03h] - IF PLL Register 3 (IFPLL3) (Power on: 1FF78h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  17    Reserved, program to zero (0)
  16-8  IF VCO KV Calibration, delta N value (signed)  ;DeltaF=(DN/Fr)
  7-4   IF VCO Coarse Tuning Default Value
  3-0   IF VCO KV Calibration Default Value
</TD></TR></TABLE>
<BR>
<B>RF[04h] - RF PLL Register 1 (RFPLL1) (Power on: 09003h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  17-10 Same as for RF[01h] (but for RF, not for IF)
  9     RF PLL Prescaler Modulus (0=8/9 Mode, 1=8/10 Mode)
  8-0   Same as for RF[01h] (but for RF, not for IF)
</TD></TR></TABLE>
<BR>
<B>RF[05h] - RF PLL Register 2 (RFPLL2) (Power on: 01780h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  17-6  RF PLL Divide By N Value
  5-0   RF PLL Numerator Value (Bits 23-18)
</TD></TR></TABLE>
<BR>
<B>RF[06h] - RF PLL Register 3 (RFPLL3) (Power on: 00000h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  17-0  RF PLL Numerator Value (Bits 17-0)
</TD></TR></TABLE>
<BR>
<B>RF[07h] - RF PLL Register 4 (RFPLL4) (Power on: 14578h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  17-10 Same as for RF[03h] (but for RF, not for IF) ;and, DN=(deltaF/Fr)*256
</TD></TR></TABLE>
<BR>
<B>RF[08h] - Calibration Register 1 (CAL1) (Power on: 1E742h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  17-13  VCO1 Warm-up Time  ;TVCO1=(approximate warm-up time)*(Fr/32)
  12-8   VCO1 Tuning Gain Calibration ;TLOCK1=(approximate lock time)*(Fr/128)
  7-3    VCO1 Coarse Tune Calibration Reference  ;VALUE=(average time)*(Fr/32)
  2-0    Lock Detect Resolution (0..7)
</TD></TR></TABLE>
<BR>
<B>RF[09h] - TXRX Register 1 (TXRX1) (Power on: 00120h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  17    Receiver DC Removal Loop          (0=Enable DC Removal Loop, 1=Disable)
  16    Internal Variable Gain for VGA  (0=Disable/External, 1=Enable/Internal)
  15    Internal Variable Gain Source (0=From TXVGC Bits, 1=From Power Control)
  14-10 Transmit Variable Gain Select (TXVGC)   (0..1Fh = High..low gain)
  9-7   Receive Baseband Low Pass Filter     (0=Wide Bandwidth, 7=Narrow)
  6-4   Transmit Baseband Low Pass Filter    (0=Wide Bandwidth, 7=Narrow)
  3     Mode Switch            (0=Single-ended mode, 1=Differential mode)
  2     Input Buffer Enable TX (0=Input Buffer Controlled by TXEN, 1=By BBEN)
  1     Internal Bias Enable   (0=Disable/External, 1=Enable/Internal)
  0     TX Baseband Filters Bypass        (0=Not Bypassed, 1=Bypassed)
</TD></TR></TABLE>
<BR>
<B>RF[0Ah] - Power Control Register 1 (PCNT1) (Power on: 00000h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  17-15 Select MID_BIAS Level                          (1.6V through 2.6V)
  14-9  Desired output power at antenna                (N*0.5dBm)
  8-3   Power Control loop-variation-adjustment Offset (signed, N*0.5dB)
  2-0   Desired delay for using a single TX_PE line    (N*0.5us)
</TD></TR></TABLE>
<BR>
<B>RF[0Bh] - Power Control Register 2 (PCNT2) (Power on: 00000h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  17-12 Desired MAX output power when PABIAS=MAX=2.6V (N*0.5dBm)
  11-6  Desired MAX output power when PABIAS=MID_BIAS (N*0.5dBm)
  5-0   Desired MAX output power when PABIAS=MIN=1.6V (N*0.5dBm)
</TD></TR></TABLE>
<BR>
<B>RF[0Ch] - VCOT Register 1 (VCOT1) (Power on: 00000h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  17    IF VCO Band Current Compensation (0=Disable, 1=Enable)
  16    RF VCO Band Current Compensation (0=Disable, 1=Enable)
  15-0  Reserved, program to zero (0)
</TD></TR></TABLE>
<BR>
<B>RF[0Dh..1Ah] - N/A (Power on: 00000h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Not used.
</TD></TR></TABLE>
<BR>
<B>RF[1Bh] - Test Register 1 (TEST) (Power on: 0000Fh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  17-0  This is a test register for internal use only.
</TD></TR></TABLE>
<BR>
<B>RF[1Ch..1Eh] - N/A (Power on: 00000h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Not used.
</TD></TR></TABLE>
<BR>
<B>RF[1Fh] - Reset Register (Power on: 00001h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  17-0  Don't care (writing any value resets the chip)
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dswifiunknownregisters"></A>&nbsp;
  DS Wifi Unknown Registers
</FONT></TD></TR></TABLE><BR>
<B>480800Ah - W_X_00Ah (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15  Unknown (usually zero)
</TD></TR></TABLE>
"[bit7 - ingore rx duplicates]" &lt;--- that is NOT correct (no effect).<BR>
Firmware writes 0000h to it. That, done many times. So, eventually some bits in
this register are automatically set by hardware in whatever situations,
otherwise repeatedly writing 0000h to it would be kinda useless...?<BR>
<BR>
---<BR>
<BR>
Below Ports W_X_244h and W_X_228h might be related to deciding when to send
multiplay replies...?<BR>
<BR>
<B>4808244h - W_X_244h (R/W) x     ffff [0000]    (used by firmware part4)</B><BR>
Unknown. Seems to be W_IF/W_IE related. Firmware sets 4808Port 244h bits 6,7,12
to 1-then-0 upon IRQ06,IRQ07,IRQ12 respectively.<BR>
<BR>
<B>4808228h - W_X_228h (W)     fixx [0000]    (used by firmware part4) (bit3)</B><BR>
Unknown. Firmware writes 8-then-0 (done in IRQ06 handler, after Port 4808244h
access).<BR>
<BR>
---<BR>
<BR>
Below Ports 48081A0h, 48081A2h, 48081A4h are somehow related to BB[02h]...<BR>
<BR>
<B>48081A0h - W_X_1A0h - (R/W)      -933 [0000]</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-1   Unknown
  2-3   Always zero
  4-5   Unknown
  6-7   Always zero
  8     Unknown
  9-10  Always zero
  11    Unknown
  12-15 Always zero
</TD></TR></TABLE>
Firmware writes values 000h, 823h. Seems to be power-related. The following
experimental code toggles RXTX.ON (RFU.Pin4): "x=0 / @@lop: / [48081A0h]=x /
[4808036h]=0 / x=x XOR 3 / wait_by_loop(1000h) / b @@lop".<BR>
Also, writing to port 48081A0h affects ports 4808034h, 480819Ch, 480821Ch, and
48082A2h.<BR>
<BR>
<B>48081A2h - W_X_1A2h - (R/W)      ---3 [0001] (used by firmware part4)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-1   Unknown. Firmware writes values 03h, 01h, and VAR.
  2-15  Always zero
</TD></TR></TABLE>
Used in combination with Port 48081A0h, so it's probably power-related, too.<BR>
<BR>
<B>48081A4h - W_X_1A4h - (R/W)      ffff [0000]</B><BR>
"Rate used when signal test is enabled (0x0A or 0x14 for 1 or 2 mbit)"<BR>
(Not too sure if that's correct, there is no visible relation to any rate.)<BR>
(This register seems to be R/W only on certain Port 48081A0h settings.)<BR>
Unknown. Firmware writes whatever.<BR>
<BR>
---<BR>
<BR>
<B>4808290h - W_X_290h - (R/W or Disabled)</B><BR>
Reportedly, this is the "antenna" register, which should exist on official
devkits, allowing to switch between wired Ethernet, and wireless Wifi mode.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Unknown (R/W) (if present)
  1-15  Not used
</TD></TR></TABLE>
On normal NDS release versions, this register seems to be disabled (if it is
implemented at all), and trying to read from it acts as for unused registers,
ie. reads return FFFFh (or probably 0000h on NDS-lite). The NDS firmware
contains code for accessing this port, even in release versions.<BR>
<BR>
<B>W_INTERNAL</B><BR>
All registers marked as "W_INTERNAL" aren't used by Firmware part4, and are
probably unimportant, except for whatever special diagnostics purposes.<BR>
<BR>
<B>Wifi DMA</B><BR>
Wifi RAM can be accessed with normal "Start Immediately" DMA transfers
(typically by reading through W_RXBUF_RD_DATA, so the DMA automatically wraps
from END to BEGIN).<BR>
Additionally, DMA0 and DMA2 can be reportedly synchronized to "Wireless
Interrupt" (rather than using "Start Immediately" timing), no idea if/how
that's working though... and if it gets started on any Wifi IRQ, or only on
specific IRQs...?<BR>
Possibly some of the above unknown registers, or some unknown bits in other
registers, are DMA related...?<BR>
Reportedly, early firmwares did use "Wireless Interrupt" DMAs (that'd be
firmware v1/v2... or, only earlier unreleased prototype versions?).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dswifiunusedregisters"></A>&nbsp;
  DS Wifi Unused Registers
</FONT></TD></TR></TABLE><BR>
<B>Wifi WS0 and WS1 Regions in NDS7 I/O Space</B><BR>
Wifi hardware occupies two 32K slots, but most of it is filled with unused or
duplicated regions. The timings (waitstates) for WS0 and WS1 are initialized in
WIFIWAITCNT (by firmware).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4800000h-4807FFFh Wifi WS0 Region (32K)
  4808000h-4808000h Wifi WS1 Region (32K)
  4810000h-4FFFFFFh Not used (00h-filled)
</TD></TR></TABLE>
Structure of the 32K Wifi Regions (WS0 and WS1)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Wifi-WS0-Region    Wifi-WS1-Region    Content
  4800000h-4800FFFh  4808000h-4808FFFh  Registers
  4801000h-4801FFFh  4809000h-4809FFFh  Registers (mirror)
  4802000h-4803FFFh  480A000h-480BFFFh  Unused
  4804000h-4805FFFh  480C000h-480DFFFh  Wifi RAM  (8K)
  4806000h-4806FFFh  480E000h-480EFFFh  Registers (mirror)
  4807000h-4807FFFh  480F000h-480FFFFh  Registers (mirror)
</TD></TR></TABLE>
Wifi Registers (recommended 4808000h-4808FFFh) appear more stable in WS1?<BR>
Wifi RAM (recommended 4804000h-4805FFFh) appears more stable in WS0?<BR>
<BR>
<B>Unused Ports (Original NDS)</B><BR>
Aside from those ports listed in the Wifi I/O Map, all other ports in range
4808000h..4808FFFh are unused. On the original DS, reading from these ports
returns FFFFh.<BR>
<BR>
<B>Unused Ports (NDS-Lite)</B><BR>
Reading from unused I/O ports acts as PASSIVE mirror of W_RXBUF_RD_DATA.
Exceptions are: Ports 4808188h, and 48082D8h..48082E6h; which always return
0000h.<BR>
<BR>
<B>Unused Memory (Original NDS)</B><BR>
Unused Wifi Memory is at 2000h..3FFFh. On the original DS, reading from that
region returns FFFFh.<BR>
<BR>
<B>Unused Memory (NDS-Lite)</B><BR>
Reading from unused memory acts as PASSIVE mirror of WifiRAM (ie. reading from
it returns the value being most recently read from 4000h..5FFFh) (that not
affected by indirect WifiRAM reads via W_RXBUF_RD_DATA) (and, that not affected
by writes to wifi memory, including writes that do overwrite the most recent
read value) (and, that only if WifiRAM is properly enabled, ie. Port
220h.Bits0-1 should be 0).<BR>
Moreover, certain addresses are additionally ORed with mirrored I/O Ports. That
addresses are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  2030h, 2044h, 2056h, 2080h, 2090h, 2094h, 2098h, 209Ch, 20A0h, 20A4h,
  20A8h, 20AAh, 20B0h, 20B6h, 20BAh, 21C0h, 2208h, 2210h, 2244h, 31D0h,
  31D2h, 31D4h, 31D6h, 31D8h, 31DAh, 31DCh, 31DEh.
</TD></TR></TABLE>
For example, 2044h is a PASSIVE mirror of WifiRAM, ORed with an ACTIVE mirror
of W_RANDOM (Port 044h). Note that some mirrors are at 2000h-2FFFh, and some at
3000h-3FFFh. The W_CMD_STAT mirrors are PASSIVE (that, in unused memory region
only) (in normal port-mirror regions like 1000h-1FFF, W_CMD_STAT mirrors are
ACTIVE).<BR>
<BR>
<B>Known (W) Mirrors (when reading from Write-only ports)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Read from (W)           Mirrors to (NDS)       Or to (NDS-Lite)
  070h W_TXBUF_WR_DATA    060h W_RXBUF_RD_DATA   074h W_TXBUF_GAP
  078h W_INTERNAL         068h W_TXBUF_WR_ADDR   074h W_TXBUF_GAP
  0ACh W_TXREQ_RESET      09Ch W_INTERNAL        ? (zero)
  0AEh W_TXREQ_SET        09Ch W_INTERNAL        ? (zero)
  0B4h W_TXBUF_RESET      0B6h W_TXBUSY          ? (zero)
  158h W_BB_CNT           15Ch W_BB_READ         ? (zero)
  15Ah W_BB_WRITE         ? (zero)               ? (zero)
  178h W_INTERNAL         17Ch W_RF_DATA2        ? (zero)
  20Ch W_INTERNAL         09Ch W_INTERNAL        ? (zero)
  21Ch W_IF_SET           010h W_IF              010h-OR-05Ch-OR-more?
  228h W_X_228h           ? (zero)               ? (zero)
  298h W_INTERNAL         084h W_TXBUF_TIM       084h W_TXBUF_TIM
  2A8h W_INTERNAL         238h W_INTERNAL        238h W_INTERNAL
  2B0h W_INTERNAL         084h W_TXBUF_TIM       084h W_TXBUF_TIM
</TD></TR></TABLE>
Notes: The mirror to W_RXBUF_RD_DATA is a passive mirror.<BR>
The DS-Lite mirror at 21Ch consists of several ports ORed with each other
(known components are Ports 010h and 05Ch, but there seem to be even more
values ORed with it).<BR>
<BR>
<B>Port Mirror Regions</B><BR>
The Wifi Port region at 000h..FFFh is mirrored to 1000h..1FFFh, 6000h..6FFFh,
and 7000h..7FFFh. Many of that mirrored ports are PASSIVE mirrors. Eg. reading
from 1060h (mirror of Port 060h, W_RXBUF_RD_DATA) returns the old
W_RXBUF_RD_DATA value (but without loading a new value from Wifi RAM, and
without incrementing W_RXBUF_RD_ADDR). However, other registers, like W_RANDOM
do have ACTIVE mirrors.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dswifiinitialization"></A>&nbsp;
  DS Wifi Initialization
</FONT></TD></TR></TABLE><BR>
<B>Initialization sequence</B><BR>
These events must be done somewhat in sequence. There is some flexibility as to
how they can be ordered but it's best to follow this order:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  [4000304h].Bit1 = 1 ;POWCNT2  ;-Enable power to the wifi system
  W_MACADDR = firmware[036h]    ;-Set 48bit Mac address
  reg[012h] = 0000h   ;W_IE     ;-Disable interrupts
</TD></TR></TABLE>
Wake Up the wireless system:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  reg[036h] = 0000h ;W_POWER_US ;\clear all powerdown bits
  delay 8 ms                    ; (works without that killer-delay ?)
  reg[168h] = 0000h ;W_BB_POWER ;/
  IF firmware[040h]=02h         ;\
    temp=BB[01h]                ; for wifitype=02h only:
    BB[01h]=temp AND 7Fh        ; reset BB[01h].Bit7, then restore old BB[01h]
    BB[01h]=temp                ; (that BB setting enables the RF9008 chip)
  ENDIF                         ;/
  delay 30 ms                   ;-(more killer-delay now getting REALLY slow)
  call init_sub_functions       ;- same as "Init 16 registers by firmware[..]"
                                ;  and "Init RF registers", below.
                                ;  this or the other one probably not necessary
</TD></TR></TABLE>
Init the Mac system:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  reg[004h] = 0000h   - W_MODE_RST       ;set hardware mode
  reg[008h] = 0000h   - W_TXSTATCNT      ;
  reg[00Ah] = 0000h   - ? W_X_00Ah       ;(related to rx filter)
  reg[012h] = 0000h   - W_IE             ;disable interrupts (again)
  reg[010h] = FFFFh   - W_IF             ;acknowledge/clear any interrupts
  reg[254h] = 0000h   - W_CONFIG_254h    ;
  reg[0B4h] = FFFFh   - W_TXBUF_RESET    ;--reset all TXBUF_LOC's
  reg[080h] = 0000h   - W_TXBUF_BEACON   ;disable automatic beacon transmission
  reg[02Ah] = 0000h   - W_AID_FULL       ;\clear AID
  reg[028h] = 0000h   - W_AID_LOW        ;/
  reg[0E8h] = 0000h   - W_US_COUNTCNT    ;disable microsecond counter
  reg[0EAh] = 0000h   - W_US_COMPARECNT  ;disable microsecond compare
  reg[0EEh] = 0001h   - W_CMD_COUNTCNT   ;(is 0001h on reset anyways)
  reg[0ECh] = 3F03h   - W_CONFIG_0ECh    ;
  reg[1A2h] = 0001h   - ?                ;
  reg[1A0h] = 0000h   - ?                ;
  reg[110h] = 0800h   - W_PRE_BEACON     ;
  reg[0BCh] = 0001h   - W_PREAMBLE       ;disable short preamble
  reg[0D4h] = 0003h   - W_CONFIG_0D4h    ;
  reg[0D8h] = 0004h   - W_CONFIG_0D8h    ;
  reg[0DAh] = 0602h   - W_CONFIG_0DAh    ;
  reg[076h] = 0000h   - W_TXBUF_GAPDISP  ;disable gap/skip (offset=zero)
</TD></TR></TABLE>
Init 16 registers by firmware[044h..063h]<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  reg[146h] = firmware[044h] ;W_CONFIG_146h
  reg[148h] = firmware[046h] ;W_CONFIG_148h
  reg[14Ah] = firmware[048h] ;W_CONFIG_14Ah
  reg[14Ch] = firmware[04Ah] ;W_CONFIG_14Ch
  reg[120h] = firmware[04Ch] ;W_CONFIG_120h
  reg[122h] = firmware[04Eh] ;W_CONFIG_122h
  reg[154h] = firmware[050h] ;W_CONFIG_154h
  reg[144h] = firmware[052h] ;W_CONFIG_144h
  reg[130h] = firmware[054h] ;W_CONFIG_130h
  reg[132h] = firmware[056h] ;W_CONFIG_132h
  reg[140h] = firmware[058h] ;W_CONFIG_140h
  reg[142h] = firmware[05Ah] ;W_CONFIG_142h
  reg[038h] = firmware[05Ch] ;W_POWER_TX
  reg[124h] = firmware[05Eh] ;W_CONFIG_124h
  reg[128h] = firmware[060h] ;W_CONFIG_128h
  reg[150h] = firmware[062h] ;W_CONFIG_150h
</TD></TR></TABLE>
Init RF registers<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  numbits = BYTE firmware[041h]    ;usually 18h
  numbytes = (numbits+7)/8         ;usually 3
  reg[0x184] = (numbits+80h) AND 017Fh  -- W_RF_CNT
  for i=0 to BYTE firmware[042h]-1 ;number of entries (usually 0Ch) (0..0Bh)
   if BYTE firmware[040h]=3
    RF[i]=firmware[0CEh+i]
   else
    RF_Write(numbytes at firmware[0CEh+i*numbytes])
   endif
</TD></TR></TABLE>
Init the BaseBand System<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  (this should be not required, already set by firmware bootcode)
  reg[160h] = 0100h  ;W_BB_MODE
  BB[0..68h] = firmware[64h+(0..68h)]
</TD></TR></TABLE>
Set Mac address<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  copy 6 bytes from firmware[036h] to mac address at 0x04800018  (why again ?)
</TD></TR></TABLE>
Now just set some default varibles<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  reg[02Ch]=0007h  ;W_TX_RETRYLIMIT - XXX needs to be set for every transmit?
  Set channel (see section on changing channels)
  Set Mode 2 -- sets bottom 3 bits of W_MODE_WEP to 2
  Set Wep Mode / key -- Wep mode is bits 3..5 of W_MODE_WEP
  BB[13h] = 00h  ;CCA operation (use only carrier sense, without ED)
  BB[35h] = 1Fh  ;Energy Detection Threshold (ED)
</TD></TR></TABLE>
-- To further init wifi to the point that you can properly send<BR>
-- and receive data, there are some more variables that need to be set.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  reg[032h] = 8000h -- W_WEP_CNT     ;Enable WEP processing
  reg[134h] = FFFFh -- W_BEACONCOUNT2;reset post-beacon counter to LONG time
  reg[028h] = 0000h -- W_AID_LOW     ;\clear W_AID value, again?!
  reg[02Ah] = 0000h -- W_AID_FULL    ;/
  reg[0E8h] = 0001h -- W_US_COUNTCNT ;enable microsecond counter
  reg[038h] = 0000h -- W_POWER_TX    ;disable transmit power save
  reg[020h] = 0000h -- W_BSSID_0     ;\
  reg[022h] = 0000h -- W_BSSID_1     ; clear BSSID
  reg[024h] = 0000h -- W_BSSID_2     ;/
</TD></TR></TABLE>
-- TX prepare<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  reg[0AEh] = 000Dh -- W_TXREQ_SET   ;flush all pending transmits (uh?)
</TD></TR></TABLE>
-- RX prepare<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  reg[030h] = 8000h    W_RXCNT         ;enable RX system (done again below)
  reg[050h] = 4C00h    W_RXBUF_BEGIN   ;(example values)
  reg[052h] = 5F60h    W_RXBUF_END     ;(length = 4960 bytes)
  reg[056h] = 0C00h/2  W_RXBUF_WR_ADDR ;fifo begin latch address
  reg[05Ah] = 0C00h/2  W_RXBUF_READCSR     ;fifo end, same as begin at start.
  reg[062h] = 5F60h-2  W_RXBUF_GAP     ;(set gap&lt;end) (zero should work, too)
  reg[030h] = 8001h    W_RXCNT  ;enable, and latch new fifo values to hardware
</TD></TR></TABLE>
--<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  reg[030h] = 8000h    W_RXCNT       enable receive (again?)
  reg[010h] = FFFFh    W_IF          clear interrupt flags
  reg[012h] = whatever W_IE          set enabled interrupts
  reg[1AEh] = 1FFFh    W_RXSTAT_OVF_IE desired STAT Overflow interrupts
  reg[1AAh] = 0000h    W_RXSTAT_INC_IE desired STAT Increase interrupts
  reg[0D0h] = 0181h    W_RXFILTER set to 0x581 when you successfully connect
                        to an access point and fill W_BSSID with a mac
                        address for it. (W_RXFILTER) [not sure on the values
                        for this yet]
  reg[0E0h] = 000Bh  -- W_RXFILTER2     ;
  reg[008h] = 0000h  -- ? W_TXSTATCNT   ;(again?)
  reg[00Ah] = 0000h  -- ? W_X_00Ah      ;(related to rx filter) (again?)
  reg[004h] = 0001h  -- W_MODE_RST      ;hardware mode
  reg[0E8h] = 0001h  -- W_US_COUNTCNT   ;enable microsecond counter (again?)
  reg[0EAh] = 0001h  -- W_US_COMPARECNT ;enable microsecond compare
  reg[048h] = 0000h  -- W_POWER_?    ;[disabling a power saving technique]
  reg[038h].Bit1 = 0 -- W_POWER_TX   ;[this too]
  reg[048h] = 0000h  -- W_POWER_?    ;[umm, it's done again. necessary?]
  reg[0AEh] = 0002h  -- W_TXREQ_SET  ;
  reg[03Ch].Bit1 = 1 -- W_POWERSTATE ;queue enable power (RX power, we believe)
  reg[0ACh] = FFFFh  -- W_TXREQ_RESET;reset LOC1..3
</TD></TR></TABLE>
That's it, the DS should be now happy to send and receive packets.<BR>
It's very possible that there are some unnecessary registers set in here.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dswififlowcharts"></A>&nbsp;
  DS Wifi Flowcharts
</FONT></TD></TR></TABLE><BR>
<B>Wifi Transmit Procedure</B><BR>
To transmit data via wifi (Assuming you've already initialized wifi and changed
channels to the channel you want):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 (1) Copy the TX Header followed by the 802.11 packet to send anywhere it
      will fit in MAC memory (halfword-aligned)
 (2) Take the offset from start of MAC memory that you put the packet,
      divide it by 2, and or with 0x8000 - store this in one of the
      W_TXBUF_LOC registers
 (3) Set W_TX_RETRYLIMIT, to allow your packet to be retried until an ack is
      received (set it to 7, or something similar)
 (4) Store the bit associated with the W_TXBUF_LOC register you used
      into W_TXREQ_SET - this will send the packet.
 (5) You can then read the result data in W_TXSTAT when the TX is over
      (you can tell either by polling or interrupt) to find out how many
      retries were used, and if the packet was ACK'd
</TD></TR></TABLE>
Of course, this is just the simplest approach, you can be a lot more clever
about it.<BR>
<BR>
<B>Wifi Receive Procedure</B><BR>
To receive data via wifi, you either need to handle the wifi received data
interrupt, or you need to poll W_RXBUF_WRCSR - whenever it is !=
W_RXBUF_READCSR, there is a new packet. When there is a new packet, take the
following approach:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 (1) Calculate the length of the new packet (read "received frame length"
      which is +8 bytes from the start of the packet) - total frame length
      is (12 + received frame length) padded to a multiple of 4 bytes.
 (2) Read the data out of the RX FIFO area (keep in mind it's a circular
      buffer and you may have to wrap around the end of the buffer)
 (3) Set the value of W_RXBUF_READCSR to the location of the next packet
      (add the length of the packet, and wrap around if necessary)
</TD></TR></TABLE>
Keep in mind, W_RXBUF_READCSR and W_RXBUF_WRCSR must be multiplied by 2 to get
a byte offset from the start of MAC memory.<BR>
<BR>
<B>Wifi Change Channels Procedure (ch=1..14)</B><BR>
For Type2 or Type5 (ie. firmware[040h]&lt;&gt;3):  ;(Type2, used in
Original-DS)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  RF[firmware[F2h+(ch-1)*6]/40000h] = firmware[F2h+(ch-1)*6] AND 3FFFFh
  RF[firmware[F5h+(ch-1)*6]/40000h] = firmware[F5h+(ch-1)*6] AND 3FFFFh
  delay a few milliseconds  ;huh?
  IF RF[09h].bit16=0     ;External Gain (default)
   BB[1Eh]=firmware[146h+(ch-1)]                         ;set BB.Gain register
  ELSEIF RF[09h].bit15=0 ;Internal Gain from TXVGC Bits
   RF[09h].Bit10..14 = (firmware[154h+(ch-1)] AND 1Fh)   ;set RF.TXVGC Bits
  ENDIF
</TD></TR></TABLE>
For Type3 (ie. firmware[040h]=3):            ;(Type3, used in DS-Lite)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  num_initial_regs = firmware[042h]
  addr=0CEh+num_initial_regs
  num_bb_writes = firmware[addr]
  num_rf_writes = firmware[43h]
  addr=addr+1
  for i=1 to num_bb_writes
    BB[firmware[addr]] = firmware[addr+ch]
    addr=addr+15
  next i
  for i=1 to num_rf_writes
    RF[firmware[addr]] = firmware[addr+ch]
    addr=addr+15
  next i
</TD></TR></TABLE>
Congrats, you are now ready to transmit/receive on whatever channel you picked.<BR>
<BR>
<B>Channels</B><BR>
The IEEE802.11b standard (and the NDS hardware) support 14 channels (1..14).<BR>
Channels 1..13 use frequencies 2412MHz..2472MHz (in 5MHz steps). Channel 14
uses frequency 2484MHz. Which channels are allowed to be used varies from
country to country, as indicated by Bit1..14 of firmware[03Ch]. Channel 14 is
rarely used (dated back to an older japanese standard).<BR>
<BR>
Caution: Nearby channels do overlap, you'll get transmission errors on packets
that are transferred simultaneously with packets on nearby channels. But, you
won't successfully receive packets from nearby channels (so you won't even
"see" that they are there, which is bad, as it doesn't allow you to share the
channel synchronized with other hosts; ie. it'd be better if two hosts are
using the SAME channel, rather than to use nearby channels).<BR>
To avoid that problem, conventionally only channels 1,6,11 are used - however
Nintendo uses channels 1,7,13 - which is causing conflicts between channel 6,7,
and maybe also between 11,13.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dswifihardwareheaders"></A>&nbsp;
  DS Wifi Hardware Headers
</FONT></TD></TR></TABLE><BR>
<B>Hardware TX Header (12 bytes) (TXHDR)</B><BR>
The TX header immediately precedes the data to be sent, and should be put at
the location that will be given to the register activating a transmission.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Addr Siz Expl.
  00h  2   Status - In: Don't care - Out: Status (0000h=Failed, 0001h=Okay)
  02h  2   Unknown - In: Don't care
             Bit0: Usually zero.
             Bit1..15 --------&gt; flags for multiboot slaves number 1..15
             (Should be usually zero, except when sending multiplay commands
             via W_TXBUF_CMD. In that case, the slave flags should be ALSO
             stored in the second halfword of the FRAME BODY. Actually, the
             hardware seems to use only that entry (in the BODY), rather than
             using this entry (in the hardware header)).
  04h  1   Unknown - In: Must be 00h..02h (should be 00h)
             (03h..FFh result in error: W_TXSTAT.Bit1 gets set, but
             nethertheless header entry[00h] is kept set to 0001h=Okay)
             ;00h = use W_TX_SEQNO (if enabled in TXBUF_LOCn)
             ;01h = force NOT to use W_TX_SEQNO (even if it is enabled in LOCn)
             ;02h = seems to behave same as 01h
  05h  1   Unknown - In: Don't care - Out: Set to 00h
  06h  2   Unknown - In: Don't care
  08h  1   Transfer Rate (0Ah=1Mbit/s, 14h=2Mbit/s) (other values=1MBit/s, too)
  09h  1   Unknown - In: Don't care
  0Ah  2   Length of IEEE Frame Header+Body+checksum(s) in bytes
           (14bits, upper 2bits are unused/don't care)
</TD></TR></TABLE>
The eight "Don't care" bytes should be usually set to zero (although setting
them to FFh seems to be working as well). Entries [00h] and [05h] are modified
by hardware, all other entries are kept unchanged.<BR>
<BR>
Important note! TX length includes the length of a 4-byte "FCS" (checksum) for
the packet. The hardware generates the FCS for you, but you still must include
it in the packet length. Also note that if the 802.11 WEP enabled bit is set in
the header, the packet will be automatically encrypted via the wep algorithm -
however, the software is responsible for providing the 4-byte IV block with the
WEP key ID and the 24bit IV value. - ALSO, you must include the length of the
*encrypted* FCS used in packets that have wep enabled (increase the tx length
by another 4 bytes) - this value is calculated automaticly for you, but you are
responsible for including it in the length of your packet (if you have data
there, it'll be replaced by the FCS.)<BR>
<BR>
<B>Hardware RX Header (12 bytes) (RXHDR)</B><BR>
The RX header is an informational structure that provides needed information
about a received packet. It is written right before the received packet data in
the rx circular buffer.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Addr Siz Expl.
  00h  2   Flags
             Bit0-3: Frame type/subtype:
               0  managment/any frame (except beacon and invalid subtypes)
               1  managment/beacon frame
               5  control/ps-poll frame
               8  data/any frame (subtype0..7) (ie. except invalid subtypes)
               C,D,E,F  unknown (firmware is checking for that values)
               ---
               C    firmware uses it for data/cf-poll frame, FromDs (*)
               D    firmware uses it for data/cf-ack frame, FromDs
               E,F  firmware uses it for data/cf-ack frame, ToDs
               (*) with DA=broadcast
               ---
             Bit4:   Seems to be always set
             Bit5-7: Seems to be always zero
             Bit8: Set when FC.Bit10 is set (more fragments)
             Bit9: Set when the lower-4bit of Sequence Control are nonzero,
                   it is also set when FC.Bit10 is set (more fragments)
                   So, probably, it is set on fragment-mismatch-errors
             Bit10-14: Seems to be always zero
             Bit15: Set when Frame Header's BSSID value equals W_BSSID register
  02h  2   Unknown (usually 0040h)
  04h  2   Time since last packet (eg. when receiving beacons: total random on
            first some packets, but later on it gets equal to Beacon Interval)
            In other cases, this value is equal to the 1st 2 bytes of the DA ?
            [Above time/da effects might be explained by other reason: maybe
            this entry is left unchanged, simply containing old WifiRAM value?]
  06h  2   Transfer Rate (N*100kbit/s) (ie. 14h for 2Mbit/s)
  08h  2   Length of IEEE Frame Header+Body in bytes (excluding FCS checksum)
  0Ah  1   MAX RSSI
  0Bh  1   MIN RSSI
</TD></TR></TABLE>
Important Note: Received frame lengths are always multiples of 4 bytes. While
the actual header length + received frame length may be less, when incrementing
the read cursor you must pad the length to a multiple of 4 bytes.<BR>
<BR>
<B>IEEE Header</B><BR>
The above Hardware headers should (must) be followed by valid IEEE headers.
Although that headers are to be generated by software, the hardware does do
some interaction with the IEEE headers, such like comparing address fields with
W_MACADDR and W_BSSID. And, it does modify some entries of it:<BR>
1) The sequence control value is replaced by W_TX_SEQNO*10h (when enabled in
W_TXBUF_LOCn.Bit13), this replacement does also overwrite the local TXBUF
value.<BR>
2) The frame control value is modified, namely, the hardware tends to set Bit12
of it. This replacement does NOT modify the local TXBUF, but the remote RXBUF
will receive the modified value. Also, Bit0-1 (protocol version) are forcefully
set to 0.<BR>
3) Transmits via W_TXBUF_BEACON do additionally modify the 64bit timestamp (so
W_TXBUF_BEACON should be used ONLY for packets WITH timestamp, ie. Beacons or
Probe-Responses). The local TXBUF seems to be left unchanged, but the remote
RXBUF will contain the (sender's) W_US_COUNT value.<BR>
C) For Control Frames, the hardware headers Length value is transferred as
normally (ie. excluding the FCS length, remote RXBUF will contain TXBUF length
minus 4), but - no matter of that length value - only 10 or 16 bytes (depending
on the subtype) of the IEEE frame are actually transferred and/or stored in
RXBUF.<BR>
X) For Control Frames with Subtype 0Ah, the AID entry is set to C000h, that,
probably ORed with original value in WifiRAM, or with the W_AID_FULL register?<BR>
XX) No idea if it's possible to send Control Frames with subtype 0Bh..0Fh, as
for now, it seems that either they aren't sent, or the receipient is ignoring
them (or processing them internally, but without storing them in RXBUF).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dswifimultiboot"></A>&nbsp;
  DS Wifi Multiboot
</FONT></TD></TR></TABLE><BR>
Available Game Advertisement<BR>
WMB uses beacon frames to advertise available games for download. The beacon
frames are normally used to advertise available access points in most 802.11
systems, but there is nothing preventing their use in this capacity. The
advertisement data is fragmented and stored partially in each beacon frame as
the payload of a custom information element (tag: 0xDD).<BR>
<BR>
The DS Download Play menu only lists games when the beacons are broadcasted on
one of the following channels: 1, 3, 4, 5, 7, 9, 10, 11, 13, and 14 (that is
WRONG, firmware_v3 checks only channels 1,7,13). However, the DS hosting
mechanism only seems to transmit on channels 1, 7, and 13 (apparently selected
at random).<BR>
<BR>
All beacon frames transmitted by a DS host have the following format:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  802.11 management frame
  802.11 beacon header
  Supported rates (tagged IE, advertises 1 Mbit and 2 Mbit)
  DS parameter set (tagged IE, note: Distribution System, not Nintendo DS)
  TIM vector (tagged IE, transmitted as empty)
  Custom extension (tagged IE, tag 0xDD)
</TD></TR></TABLE>
<BR>
Nintendo specific beacon fragment format (information element code 0xDD):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Offset Description
  00h  Nintendo Beacon ID (00h,09h,BFh,00h)
  04h  Stepping Offset for 4808134h/W_BEACONCOUNT2 (always 000Ah)
  06h  Strange Timestamp (W_US_COUNT*2-VCOUNT*7Fh)/128 (0000h for multiboot)
  08h  01 00
  0Ah  40 00
  0Ch  24 00
  0Eh  40 00
  10h  Randomly generated stream code
  12h  Number of bytes from entry 18h and up (70h for multiboot) (0 if Empty)
  13h  Beacon Type    (0Bh=Multiboot, 01h=Multicart/Pictochat, 09h=Empty)
  14h  0100 0008    (some kind of max,min values?)
</TD></TR></TABLE>
For Empty (length zero, is used at very begin of multiboot)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  18h  No data.
</TD></TR></TABLE>
For Multicart (variable length)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  18h  Custom data, usually containing the host name, either in 8bit ascii,
       or 16bit unicode format. Sometimes taken from Firmware User Settings,
       and sometimes from Cartridge Backup Memory.
</TD></TR></TABLE>
For Pictochat (length 8)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  18h  Fixed (always 2348h)
  1Ah  xxxx
  1Ch  Chatroom number (00h..03h for Chatroom A..D)
  1Dh  Number of users already connected (01h..10h) (including host)
  1Eh  Fixed (always 0004h)
</TD></TR></TABLE>
For Multiboot (always 70h bytes)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  18h  24 00 40 00 (varies from game to game)
  1Ch  End of advertisement flag (00 for non-end, 02 for end packets)
  1Dh  Always 00, 01, 02, or 04
  1Eh  Number of players already connected
  1Fh  Sequence number (0 .. total_advertisement_length)
  20h  Checksum (on entries 22h and up)
         chksum=0, for i=22h to 86h step 2, chksum=chksum+halfword[i], next i,
         chksum=FFFFh AND NOT (chksum+chksum/10000h)
  22h  Sequence number in non-final packet, # of players in final packet
  23h  Total advertisement length - 1 (in beacons)
  24h  Datasize in bytes (2 byte little-endian)
           (0062h for seq 0..7, 0048h for seq 8, 0001h for seq 9)
  26h  Data (always 62h bytes, padded with 00h if Datasize&lt;62h)
</TD></TR></TABLE>
<BR>
The advertisement fragments are reordered and assembled according to their
internal sequence number, to form the overall advertisement payload, as defined
below:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Offset Size Description
  000h  32  Icon Palette (same as for ROM Cartridge Icon)
  020h  512 Icon Bitmap  (same as for ROM Cartridge Icon)
  220h  1   Unknown (0Bh)
  221h  1   Length of hosting name          ;(probably same as firmware
  222h  20  Name of hosting DS (10 UCS-2)   ;user name?)
  236h  1   Max number of players
  237h  1   Unknown (00h)
  238h  96  Game name (48 UCS-2)   (same as 1st line of ROM Cartridge Title)
  298h  192 Description (96 UCS-2) (same as further lines of ROM Cart Title)
  358h  64  00's if no users are connected  &lt;---WRONG: LEN=1, not 64
  398h  0   End of data if no users are connected
</TD></TR></TABLE>
<BR>
<B>Authentication process</B><BR>
Once a user B chooses a download offered by a host A, the following standard
802.11 authentication process observed.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Host A advertises a game in beacon frames as described above
  Client B sends an authentication request (sequence 1) to A
  Host A replies with an ACK
  Host A sends an authentication reply (sequence 2) to B
  Client B replies with an association request
  Host A replies with an ACK
  Host A sends an association response
  Client B responds with an ACK
</TD></TR></TABLE>
After this, the two are associated, and will remain so until the transfer is
complete or one is idle for several seconds, at which point they will
de-associate. For more information on the association process, see the 802.11
standard.<BR>
<BR>
<B>Download process (after authentication)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Host sends Pings (type 0x01, replies are 0x00, 0x07)
  Host sends RSA frame (type 0x03, replies 0x08)
  Host sends NDS header (type 0x04, replies 0x09)
  Host sends ARM9 binary (type 0x04, replies 0x09)
  Host sends ARM7 binary (type 0x04, replies 0x09)
  Host terminates transfer (type 0x05, no replies)
</TD></TR></TABLE>
<BR>
The WMB protocol ostensibly implements layers 3 to 7 of the OSI network model,
but does not define a new type of network addresses. However, it does define a
couple of special broadcast-like MAC addresses within the assigned Nintendo
namespace (00:09:BF).<BR>
<BR>
The three channels or flows used for all communications after the MAC broadcast
beacons take the form 03:09:BF:00:00:xx, where xx is:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00 for the main data flow, from host to client    (sent via Port 4808090h)
  10 for the client to host replies                 (sent via Port 4808094h)
  03 for the feedback flow, host to client (acknowledges the replies)
</TD></TR></TABLE>
<BR>
Observed commands:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Command   Description
  0x01      Ping / Name request
  0x03      RSA signature frame
  0x04      Data packet
  0x05      Post-idle / unknown
</TD></TR></TABLE>
<BR>
Observed replies<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Reply ID  Description
  0x00      Pong (ping reply)
  0x07      Name reply
  0x08      RSA frame reply
  0x09      Data packet reply
</TD></TR></TABLE>
<BR>
The host does something unusual with the 802.11 sequence control field, each
packet sent out on the 00 flow has a sequence control number 2 greater than the
previous one, even if they are sent sequentially. When the host acknowledges a
reply (on flow 03) from the client about a particular packet, it uses the
sequence number one after the original packet number it sent out on 00. This is
the root of one of the major problems in finding a PC card that can transmit
WMB packets, as very few cards provide user control over it. Even when a card
is capable of 'raw' 802.11 transmission, it typically takes care of the
sequence control field in hardware or firmware, filling it with a constantly
incrementing number.<BR>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  -------------------
</TD></TR></TABLE>
<BR>
Host-to-client packets (on the 0x00 flow)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0  1  2  3  4    5     6..e-3   e-2  e-1  e-0
  06 01 02 00 Size Flags Payload  00   02   00
</TD></TR></TABLE>
Above first two bytes are W_CMD_REPLYTIME.<BR>
Above next two bytes are slave flags (bit1..15 for slave 1..15) (1=connected).<BR>
The size field is in terms of half-words (16 bits), and includes the flags byte
along with the payload (so a size of 0x03 represents a flag byte, a command
byte, and 4 bytes of payload).<BR>
When flags is 0x11, the first byte of the payload is a command. There seems to
be no important data when flags is not 0x11 (seen occasionally as 0x01), and
ignoring them still results in a complete dump.<BR>
<BR>
The Ping messages (type 0x00) have a payload size of 0x03, but always contain
zeroes in the payload. They seem to be used only to keep the connection alive
while waiting for the host DS to start the transfer, to prevent a time-out
de-association.<BR>
<BR>
<B>RSA signature frame payload (type 0x03)</B><BR>
The RSA frame format (type 0x03) sends a table of information about the game
being downloaded (most of it redundant with the NDS header, see Appendix), as
well as the RSA signature for the DS. I have not looked into computing the
signature, as homebrew developers are not privy to Nintendo's private key,
making signing a fruitless activity, but it is my understanding that the
signature is a 128 byte public key and an 8 byte SHA-1 message digest over the
NDS header, ARM9 binary, and ARM7 binary. Notably: the RSA frame itself is not
included as part of the data being signed, bringing up various security issues
and making Nintendo's firmware engineers look amateurish at best.<BR>
There are several abortive sendings of empty RSA frames with a size field of
0x03, before the real frame is sent (always with a size field of 0x75).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Offset Size Description
  0x00 4   ARM9 execute address
  0x04 4   ARM7 execute address
  0x08 4   0x00
  0x0C 4   Header destination
  0x10 4   Header destination
  0x14 4   Header size (0x160)
  0x18 4   0x00
  0x1C 4   ARM9 destination address
  0x20 4   ARM9 destination address
  0x24 4   ARM9 binary size
  0x28 4   0x00
  0x2C 4   0x022C0000
  0x30 4   ARM7 destination address
  0x34 4   ARM7 binary size
  0x38 4   0x01
  0x3C 136 Signature block
  0xC4 36  0x00's
  0xE8 0   End of frame payload
</TD></TR></TABLE>
The offsets in the table are from after the command byte, i.e. two bytes into
the 234 bytes of payload including the flags.<BR>
The unknown address 0x022C0000 is probably ARM7 related, by comparison with the
duplicated header and ARM9 destination addresses 32 and 16 bytes before it,
although it has no known significance according to the NDS header.<BR>
<BR>
<B>Data packet (type 0x04)</B><BR>
The data packets (type 0x04) include a transport-layer sequence number inside
of the data packet itself, but no destination offset or other mechanism to
allow the packets to be processed out-of-order. The only way to place the data
at the correct location in memory is to re-order the packets according to the
sequence number and process them sequentially.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0  1     2       3   ..  End
  00 [Sequence #]  xx  ..  yy
</TD></TR></TABLE>
The sequence number is a zero based little-endian number. Each packet only
contains data for one of the three destination blocks (header, ARM9, ARM7), so
the change-of-destination check only needs to be made on packet boundaries.<BR>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  -------------------
</TD></TR></TABLE>
<BR>
Client to Host Replies (on the 0x10 flow)<BR>
The replies from client to host are sent on the 0x10 flow. The client uses an
incrementing sequence control number for all of its packets, with no unusual
trickery. Each reply is sent as a standard 802.11 data frame (typically as a
Data + CF-Acknowledgement), consisting of 10 data bytes for the WMB payload.
The first two are always 0x04 0x81, with the third byte indicating the type of
reply, and the remaining 7 bytes being reply-specific.<BR>
<BR>
<BR>
<B>Idle / Pong reply (type 0x00)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0  1  2  3  4  5  6  7  8  9
  04 81 00 00 00 00 00 00 00 00
</TD></TR></TABLE>
One type of packet frequently sent before a download gets underway is what I
have termed the Idle or Pong packet (in response to 0x00 'Pings'). It has a
reply type field of 0x00, and does not contribute any additional information.<BR>
<BR>
<B>Name reply (type 0x07)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0  1  2  3  4     5      6     7      8     9
  04 81 07 01 [Character0] [Character1] [Character2]
  04 81 07 02 [Character3] [Character4] [Character5]
  04 81 07 03 [Character6] [Character7] [Character8]
  04 81 07 04 [Character9] 01    00     00    00
</TD></TR></TABLE>
The name reply (type 0x07) is sent shortly after association is completed,
although I am not certain what triggers it. There are a variable number of
pings preceding this reply, but most are replied via Pongs. The name reply
sends the user-configured DS name (set in the firmware menu) split over four
messages (with the 4th byte of the packet specifying which message fragment
this is, 1 based). This can be a total length of 10 UCS-2 characters, although
all four messages are still sent if it is shorter (padded with nulls to 10
characters, and then 01 and then nulls until the end of the frame).<BR>
<BR>
<B>RSA frame receipt reply (type 0x08)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0  1  2  3  4  5  6  7  8  9
  04 81 08 xx xx xx xx xx xx xx
</TD></TR></TABLE>
The RSA frame receipt reply contains no extra information; it only acknowledges
receipt of a type 0x03 host packet on the main flow (0x00). Bizarrely, the xx
bytes in the above table are not driven to a particular value when replying to
an RSA frame, and usually contain the same data as the second (of four) name
response frames.<BR>
<BR>
<B>Data packet receipt reply (type 0x09)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0  1  2    3    4        5     6     7  8  9
  04 81 09 [Last packet] [Best packet] 00 00 00
</TD></TR></TABLE>
[last packet] is the packet number being acknowledged<BR>
[best packet] is the highest continuous packet number seen so far<BR>
Packet IDs are little-endian numbers, like other Nintendo provided data.<BR>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  -------------------
</TD></TR></TABLE>
<BR>
Host to client acknowledgements (on the 0x03 flow)<BR>
<BR>
These packets contain four data bytes, but three are always zero. The first
seems to be random, with no connection to the acknowledged data. The actual
indication of acknowledgement is the sequence control number of the packet. It
is set to be one greater than the sequence control number of the initial host
packet (sent on flow 0x00) that the client has just responded to, to indicate
that the reply was received.<BR>
<BR>
<B>Host-to-client acknowledgement</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0  1  2  3
  ?? 00 00 00
</TD></TR></TABLE>
<BR>
The .NDS format is the standard format for Nintendo DS programs; it originated
on original game cards and also appears to a limited extent in WMB binaries.
The WMB process only transfers the first 0x160 bytes of the header, the ARM9
binary, and the ARM7 binary (in that order), ignoring the file name and file
allocation tables, the overlay data, and some information stored in the banner
(the rest is transmitted partially via the beacon advertisement process).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dswifiieee80211frames"></A>&nbsp;
  DS Wifi IEEE802.11 Frames
</FONT></TD></TR></TABLE><BR>
<B>MAC Frame Format</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  10..30 bytes    MAC Header
  0..2312 bytes   Frame Body
  4 bytes         Frame Check Sequence (FCS) (aka checksum)
</TD></TR></TABLE>
<BR>
<B>MAC Header (10..30 bytes)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Size Content
  2    Frame Control Field (FC)
  2    Duration/ID
  6    Address 1
 (6)   Address 2 (if any)
 (6)   Address 3 (if any)
 (2)   Sequence Control (if any)
 (6)   Address 4 (if any)
</TD></TR></TABLE>
<BR>
<B>Frame Control Field (FC)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit  Expl.
  0-1  Protocol Version   (0=Current, 1..3=Reserved)
  2-3  Type               (0=Managment, 1=Control, 2=Data, 3=Reserved)
  4-7  Subtype            (see next chapters) (meaning depends on above Type)
  8    To Distribution System (DS)
  9    From Distribution System (DS)
  10   More Fragments
  11   Retry
  12   Power Managment    (0=Active, 1=STA will enter Power-Safe mode after..)
  13   More Data
  14   Wired Equivalent Privacy (WEP) Encryption (0=No, 1=Yes)
  15   Order
</TD></TR></TABLE>
Bit 8-11 and Bit 13-15 are always 0 in Control Frames.<BR>
<BR>
<B>Duration/ID Field (16bit)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0000h..7FFFh  Duration (0-32767)
  8000h         Fixed value within frames transmitted during the CFP
                (CFP=Contention Free Period)
  8001h..BFFFh  Reserved
  C000h         Reserved
  C001h..C7D7h  Association ID (AID) (1..2007) in PS-Poll frames
  C7D8h..FFFFh  Reserved
</TD></TR></TABLE>
<BR>
<B>48bit MAC Addresses</B><BR>
MAC Addresses are 48bit (6 bytes) (Bit0 is the LSB of the 1st byte),<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Group Flag (0=Individual Address, 1=Group Address)
  1     Local Flag (0=Universally Administered Address, 1=Locally Administered)
  2-23  22bit Manufacturer ID (assigned by IEEE)
  24-47 24bit Device ID (assigned by the Manufacturer)
</TD></TR></TABLE>
Special NDS related Addresses:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00 09 BF xx xx xx  NDS-Consoles (Original NDS with firmware v1-v5)
  00 16 56 xx xx xx  NDS-Consoles (Newer NDS-Lite with firmware v6 and up)
  00 23 CC xx xx xx  DSi-Consoles (Original DSi with early mainboard; nocash)
  00 24 1E xx xx xx  DSi-Consoles (Another DSi; scanlime)
  03 09 BF 00 00 00  NDS-Multiboot: host to client (main data flow)
  03 09 BF 00 00 10  NDS-Multiboot: client to host (replies)
  03 09 BF 00 00 03  NDS-Multiboot: host to client (acknowledges replies)
  FF FF FF FF FF FF  Broadcast to all stations (eg. Beacons)
</TD></TR></TABLE>
<BR>
<B>Sequence Control Field</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit  Expl.
  0-3  Fragment Number (0=First (or only) fragment)
  4-15 Sequence Number
</TD></TR></TABLE>
(increment by 1, except on retransmissions, ie. retries)<BR>
<BR>
<B>WEP Frame Body</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  3 bytes     Initialization Vector
  1 byte      Pad (6bit, all zero), Key ID (2bit)
  1..? bytes  Data (encrypted data)
  4 bytes     ICV (encrypted CRC32 across Data)
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dswifiieee80211managmentframestype0"></A>&nbsp;
  DS Wifi IEEE802.11 Managment Frames (Type=0)
</FONT></TD></TR></TABLE><BR>
All Managment Frames have 24-byte Frame Header, with following values:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  FC(2), Duration(2), DA(6), SA(6), BSSID(6), Sequence Control(2)
</TD></TR></TABLE>
The content of the Frame Body depends on the FC's Subtype:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Subtype                   Frame Body
  0 Association request     Capability, ListenInterval, SSID, SuppRates
  1 Association response    Capability, Status, AID, SuppRates
  2 Reassociation request   Capability, ListenInterval, CurrAP, SSID, SuppRates
  3 Reassociation response  Capability, Status, AID, SuppRates
  4 Probe request           SSID, SuppRates
  5 Probe response          Same as for Beacon (but without TIM)
  8 Beacon                  Timestamp,BeaconInterval,Capability,SSID,SuppRates,
                             FH Parameter Set (when using Frequency Hopping),
                             DS Parameter Set (when using Direct Sequence),
                             CF Parameter Set (when supporting PCF),
                             IBSS Parameter Set (when in an IBSS),
                             TIM (when generated by AP)
  9 Announcement traffic indication message (ATIM)    Body is "null" (=none?)
  A Disassociation          ReasonCode
  B Authentication          AuthAlgorithm, AuthSequence, Status, ChallengeText
  C Deauthentication        ReasonCode
</TD></TR></TABLE>
Subtypes 6..7, and D..F are Reserved.<BR>
<BR>
<B>The separate components of the Frame Body are...</B><BR>
64bit Parameters (8 bytes)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Timestamp: value of the TSFTIMER (see 11.1) of a frame's source. Uh?
</TD></TR></TABLE>
48bit Parameters (6 bytes)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Current AP (Access Point): MAC Address of AP with which station is associated
</TD></TR></TABLE>
16bit Parameters (2 bytes)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Capability Information (see list below)
  Status code (see list below) (0000h=Successful, other=Error code)
  Reason code (see list below) (Error code)
  Association ID (AID) (C000h+1..2007)
  Authentication Algorithm (0=Open System, 1=Shared Key, 2..FFFFh=Reserved)
  Authentication Transaction Sequence Number (Open System:1-2, Shared Key:1-4)
  Beacon Interval (Time between beacons, N*1024 us)
  Listen Interval (see note below)
</TD></TR></TABLE>
Information elements (1byte ID, 1byte LEN, followed by LEN byte(s) data)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ID      LEN      Expl.
  00h     00h-20h  SSID (LEN=0 for broadcast SSID)
  01h     01h-08h  Supported rates; each (nn AND 7Fh)*500kbit/s, bit7=flag
  02h     05h      FH (Frequency Hopping) Parameter Set
                     DwellTime(16bit), HopSet, HopPattern, HopIndex
  03h     01h      DS (Distribution System) Parameter Set; Channel (01h..0Eh)
  04h     06h      CF Parameter Set; Count, Period, MaxDuration, RemainDuration
  05h     04h..FEh TIM; Count,Period,Control, 1-251 bytes PartialVirtualBitmap
  06h     02h      IBSS Parameter Set; ATIM Window length (16bit)
  07h-0Fh -        Reserved
  10h     02h..FEh Challenge text; 1-253 bytes Authentication data
                    (Used only for Shared Key sequence no 2,3)
                    (none such for Open System)
                    (none such for Shared key sequence no 1,4)
  11h-1Fh -        Reserved for challenge text extension
  20h-FFh -        Reserved
  DDh     var      Reserved but used by Nintendo for NDS-Multiboot beacons
</TD></TR></TABLE>
IDs 20h-FFh are commonly used; I've received values 2xh..3xh and DDh (from
non-nintendo network routers in the neighborhood); no idea if these "Reserved"
IDs are somewhere officially documented?<BR>
<BR>
<B>Capability Information</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0    ESS
  Bit1    IBSS
  Bit2    CF-Pollable
  Bit3    CF-Poll Request
  Bit4    Privacy
  Bit5    Short Preamble  (IEEE802.11b only)
  Bit6    PBCC            (IEEE802.11b only)
  Bit7    Channel Agility (IEEE802.11b only)
  Bit5-7  Reserved (0) (original IEEE802.11 specs)
  Bit8-15 Reserved (0)
</TD></TR></TABLE>
<BR>
<B>Listen Interval</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ... used to indicate to the AP how often an STA wakes to listen to Beacon
  management frames. The value of this parameter is the STA's Listen Interval
  parameter of the MLME-Associate. request primitive and is expressed in
  units of Beacon Interval.
</TD></TR></TABLE>
<BR>
<B>Reason codes</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h Reserved
  01h Unspecified reason
  02h Previous authentication no longer valid
  03h Deauthenticated because sending station is leaving (or has left) IBSS
       or ESS
  04h Disassociated due to inactivity
  05h Disassociated because AP is unable to handle all currently associated
       stations
  06h Class 2 frame received from nonauthenticated station
  07h Class 3 frame received from nonassociated station
  08h Disassociated because sending station is leaving (or has left) BSS
  09h Station requesting (re)association is not authenticated with responding
       station
  0Ah..FFFFh Reserved
</TD></TR></TABLE>
<BR>
<B>Status codes</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h Successful
  01h Unspecified failure
  02h..09h Reserved
  0Ah Cannot support all requested cap's in the Capability Information field
  0Bh Reassociation denied due to inability to confirm that association exists
  0Ch Association denied due to reason outside the scope of this standard
  0Dh Responding station doesn't support the specified authentication algorithm
  0Eh Received an Authentication frame with authentication transaction sequence
       number out of expected sequence
  0Fh Authentication rejected because of challenge failure
  10h Authentication rejected due to timeout waiting for next frame in sequence
  11h Association denied because AP is unable to handle additional associated
       stations
  12h Association denied due to requesting station not supporting all of the
       data rates in the BSSBasicRateSet parameter
  13h Association denied due to requesting station not supporting
       the Short Preamble option (IEEE802.11b only)
  14h Association denied due to requesting station not supporting
       the PBCC Modulation option (IEEE802.11b only)
  15h Association denied due to requesting station not supporting
       the Channel Agility option (IEEE802.11b only)
  13h-15h Reserved (original IEEE802.11 specs)
  16h..FFFFh Reserved
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dswifiieee80211controlanddataframestype1and2"></A>&nbsp;
  DS Wifi IEEE802.11 Control and Data Frames (Type=1 and 2)
</FONT></TD></TR></TABLE><BR>
<B>Control Frames (Type=1)</B><BR>
All Control Frames have 10-byte or 16-byte headers, depending on the Subtype:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Subtype                          Frame Header
  A   Power Save (PS)-Poll         FC  AID       BSSID  TA
  B   Request To Send (RTS)        FC  Duration  RA     TA
  C   Clear To Send (CTS)          FC  Duration  RA     -
  D   Acknowledgment (ACK)         FC  Duration  RA     -
  E   Contention-Free (CF)-End     FC  Duration  RA     BSSID
  F   CF-End + CF-Ack              FC  Duration  RA     BSSID
</TD></TR></TABLE>
Subtypes 0..9 are Reserved. Control Frames do not have a Frame Body, so the
Header is directly followed by the FCS.<BR>
<BR>
<B>Data Frames (Type=2)</B><BR>
All Data Frames consist of the following components:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  FC, Duration/ID, Address 1, Address 2, Address 3, Sequence Control,
  Address 4 (only on From DS to DS), Frame Body, FCS.
</TD></TR></TABLE>
The meaning of the 3 or 4 addresses depends on Frame Control FromDS/ToDS bits:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Frame Control    Address 1  Address 2  Address 3  Address 4
  From STA to STA  DA         SA         BSSID      -
  From DS  to STA  DA         BSSID      SA         -
  From STA to DS   BSSID      SA         DA         -
  From DS  to DS   RA         TA         DA         SA
</TD></TR></TABLE>
Frame Control Subtypes for Data Frames (Type=2) are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0   Data
  1   Data + CF-Ack
  2   Data + CF-Poll
  3   Data + CF-Ack + CF-Poll
  4   Null function (no data)
  5   CF-Ack (no data)
  6   CF-Poll (no data)
  7   CF-Ack + CF-Poll (no data)
  8-F Reserved
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsxboo"></A>&nbsp;
  DS Xboo
</FONT></TD></TR></TABLE><BR>
The DS Xboo cable allows to upload NDS ROM-Images (max 3.9MBytes) to the
console via parallel port connection. Should be the best, simpliest, easiest,
and fastest way to test code on real hardware. And, at a relative decent price
of 11 cents per diode it should be by far the least expensive way. You'll have
to touch classic tools (screwdrivers, knifes, saws, tweezers, and solder) which
will probably scare most of you to hell.<BR>
<BR>
<B>DS XBOO Connection Schematic</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Console Pin/Names             Parallel Port Pin/Names
  RFU.9    FMW.1 D    ---|&gt;|--- DSUB.14    CNTR.14    AutoLF
  RFU.6    FMW.2 C    ---|&gt;|--- DSUB.1     CNTR.1     Strobe
  RFU.10   FMW.3 /RES ---|&gt;|--- DSUB.16    CNTR.31    Init
  RFU.7    FMW.4 /S   ---|&gt;|--- DSUB.17    CNTR.36    Select
  RFU.5    FMW.5 /W   --. SL1A  -          -          N.C.
  RFU.28   FMW.6 VCC  __| SL1B  -          -          N.C.
  RFU.2,12 FMW.7 VSS  --------- DSUB.18-25 CNTR.19-30 Ground
  RFU.8    FMW.8 Q    --------- DSUB.11    CNTR.11    Busy
  P00 Joypad-A        ---|&gt;|--- DSUB.2     CNTR.2     D0
  P01 Joypad-B        ---|&gt;|--- DSUB.3     CNTR.3     D1
  P02 Joypad-Select   ---|&gt;|--- DSUB.4     CNTR.4     D2
  P03 Joypad-Start    ---|&gt;|--- DSUB.5     CNTR.5     D3
  P04 Joypad-Right    ---|&gt;|--- DSUB.6     CNTR.6     D4
  P05 Joypad-Left     ---|&gt;|--- DSUB.7     CNTR.7     D5
  P06 Joypad-Up       ---|&gt;|--- DSUB.8     CNTR.8     D6
  P07 Joypad-Down     ---|&gt;|--- DSUB.9     CNTR.9     D7
  RTC.1 INT aka SI    --------- DSUB.10    CNTR.10    /Ack
</TD></TR></TABLE>
Parts List: 15 wires, four (DS) or twelve (DS-Lite) "BAT 85" diodes, 1 parallel
port socket.<BR>
<BR>
<B>DS XBOO Connection Notes</B><BR>
The Firmware chip (FMW.Pins) hides underneath of the RFU shielding plate, so
it'd be easier to connect the wires to the RFU.Pins (except DS-Lite: The RFU
pins are terribly small (and have different pin-numbers), so either using
FMW.Pins, or using mainboard vias (see below GIF) would be easier). The easiest
way for the /W-to-VCC connection is to shortcut SL1 by putting some solder onto
it.<BR>
The P00..P07 and INT signals are labeled on the switch-side of the mainboard,
however, there should be more room for the cables when connecting them to via's
at the bottom-side (except DS-Lite: P01 is found only at switch-side) image
below may help to locate that pins,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  http://problemkaputt.de/nds-pins.gif (GIF-Image, 7.5KBytes)
</TD></TR></TABLE>
At the parallel port side, DSUB.Pins or CNTR.Pins can be used for 25pin DSUB or
36pin Centronics sockets, the latter one allowing to use a standard printer
cable.<BR>
The ring printed on the diodes is pointing towards parallel port side, the 4
diodes are required to prevent the parallel port to pull-up LOW levels on the
NDS side, be sure to use BAT85 diodes, cheaper ones like 1N4148 are loosing too
much voltage and won't gain stable LOW levels.<BR>
The power managment chip in the DS-Lite simply refuses to react to the Power-On
button when P00..P07 are dragged high by the parallel port (even if it is in
HighZ state), the 8 diodes in the data-lines are solving that problem (they are
required on DS-Lite only, not on original DS).<BR>
<BR>
<B>DS XBOO Operation Notes</B><BR>
The main Upload function is found in no$gba Utility menu, together with further
functions in Remote Access sub-menu.<BR>
Before uploading anything: download the original firmware, the file is saved as
FIRMnnnn.BIN, whereas "nnnn" is equal to the last 16bit of the consoles 48bit
MAC address, so Firmware-images from different consoles are having unique
filenames. If you don't already have, also download the NDS BIOS, the BIOS
contains encryption seed data required to encrypt/decrypt secure area; without
having downloaded the BIOS, no$gba will be working only with unencrypted
ROM-images. Next, select Patch Firmware to install the nocash firmware.<BR>
<BR>
<B>DS XBOO Troubleshooting</B><BR>
Be sure that the console is switched on, and that the XBOO cable is connected,
and that you have selected the correct parallel port in no$gba setup (the
"multiboot" options in Various Options screen), and, of course, try avoid to be
fiddling with the joypad during uploads.<BR>
I've tested the cable on two computers, the overall upload/download stuff
should work stable. The firmware access functions - which are required only for
(un-)installation - worked only with one of the two computers; try using a
different computer/parallel port in case of problems.<BR>
<BR>
<B>Nocash Firmware</B><BR>
The primary purpose is to receive uploaded NDS-images via parallel port
connection, additionally it's containing bootmenu and setup screens similar to
the original firmware. The user interface is having less cryptic symbols and
should be alltogether faster and easier to use. Important Information about
Whatever is supported (but it can be disabled). The setup contains a couple of
additional options like automatic daylight saving time adjustment.<BR>
The bootmenu allows to boot normal NDS and GBA carts, it does additionally
allow to boot NDS-images (or older PassMe-images) from flashcards in GBA slot.
Furthermore, benefits of asm coding, the nocash firmware occupies less than
32KBytes, allowing to store (and boot) smaller NDS-images in the unused portion
of the firmware memory (about 224KBytes), the zero-filled region between cart
header and secure area, at 200h..3FFFh, is automatically excluded, so the image
may be slightly bigger than the available free memory space.<BR>
<BR>
<B>Missing</B><BR>
Unlike the original firmware, the current version cannot yet boot via WLAN.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsireference"></A>&nbsp;
  DSi Reference
</FONT></TD></TR></TABLE><BR>
<B>Basic Hardware Features (mostly same as NDS)</B><BR>
<A HREF="#ndsreference">NDS Reference</A><BR>
<A HREF="#dsibasicdifferencestonds">DSi Basic Differences to NDS</A><BR>
<BR>
<B>New Hardware Features</B><BR>
<A HREF="#dsiiomap">DSi I/O Map</A><BR>
<A HREF="#dsicontrolregistersscfg">DSi Control Registers (SCFG)</A><BR>
<A HREF="#dsixpertteakdsp">DSi XpertTeak (DSP)</A><BR>
<A HREF="#dsinewsharedwramforarm7arm9dsp">DSi New Shared WRAM (for ARM7, ARM9, DSP)</A><BR>
<A HREF="#dsinewdma">DSi New DMA</A><BR>
<A HREF="#dsisoundext">DSi SoundExt</A><BR>
<A HREF="#dsiadvancedencryptionstandardaes">DSi Advanced Encryption Standard (AES)</A><BR>
<A HREF="#dsicartridgeheader">DSi Cartridge Header</A><BR>
<A HREF="#dsitouchscreensoundcontroller">DSi Touchscreen/Sound Controller</A><BR>
<A HREF="#dsii2cbus">DSi I2C Bus</A><BR>
<A HREF="#dsicameras">DSi Cameras</A><BR>
<A HREF="#dsisdmmcprotocolandioports">DSi SD/MMC Protocol and I/O Ports</A><BR>
<A HREF="#dsisdmmcfilesystem">DSi SD/MMC Filesystem</A><BR>
<A HREF="#dsigpioregisters">DSi GPIO Registers</A><BR>
<A HREF="#dsiconsoleids">DSi Console IDs</A><BR>
<A HREF="#dsiunknownregisters">DSi Unknown Registers</A><BR>
<A HREF="#dsinotes">DSi Notes</A><BR>
<A HREF="#dsiexploits">DSi Exploits</A><BR>
<A HREF="#dsiregions">DSi Regions</A><BR>
<BR>
<B>General Info</B><BR>
<A HREF="#armcpureference">ARM CPU Reference</A><BR>
<A HREF="#biosfunctions">BIOS Functions</A><BR>
<A HREF="#externalconnectors">External Connectors</A><BR>
<BR>
Credits: http://www.dsibrew.org/wiki/Special:AllPages (now spammed)<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsibasicdifferencestonds"></A>&nbsp;
  DSi Basic Differences to NDS
</FONT></TD></TR></TABLE><BR>
<B>Interrupts</B><BR>
There are several new interrupt sources in IE/IF registers, plus further ones
in new IE2/IF2 registers.<BR>
<A HREF="#dsinterrupts">DS Interrupts</A><BR>
<BR>
<B>Video</B><BR>
Essentially same as for NDS. Some details can be changed in SCFG_EXT. For the
2D Engine, DISPSTAT.Bit6 contains a new "LCD Initialization Ready" flag on both
ARM7 and ARM9 side (the bit is checked by DSi System Menu) (the bit is
supposedly used at power-up, maybe also for wake-up from certain sleep modes).<BR>
<BR>
<B>BIOS SWI Functions</B><BR>
Some SWI Functions are changed (bugged in some cases), new SHA1 and RSA
functions are added, and the initial RAM contents are moved from 27FFxxxh to
2FFFxxxh (with some extra fields, eg. a copy of extended DSi cart header).<BR>
<A HREF="#biosfunctions">BIOS Functions</A><BR>
<BR>
<B>Revised Hardware Functions</B><BR>
Some hardware features have been slightly revised (for example, the division by
0 flag was fixed). The revised functions can be enabled/disabled via SCFG
registers.<BR>
<A HREF="#dsicontrolregistersscfg">DSi Control Registers (SCFG)</A><BR>
<BR>
<B>NDS Slot / Cartridges</B><BR>
DSi carts are using an extended cart header (1000h bytes), with RSA signature
(making it problematic to run unlicensed/homebrew code), the icon/title format
has been also extended, and the cartridge protocol contains a new command
(command 3Dh, for unlocking extra DSi regions on the cartridge, and for reading
new DSi secure area blocks).<BR>
The NDS Slot's Reset signal can be controlled by software (required because
otherwise one could use only command 3Ch or 3Dh, but not both). The Power
supply pin can be also controlled by software (yet not 100% confirmed how?).
Moreover, there's new cartridge inserted sensor. And, DSi prototypes did have
two NDS slots; DSi retail consoles do have only one slot, but they do still
contain prototype relicts internally (like extra registers and extra irq
sources for second slot) (there appear to be also unused extra pins on the CPU,
but they couldn't be used without desoldering the whole chip).<BR>
<BR>
<B>Enable Bits</B><BR>
One new DSi invention is that setting Enable Bits (eg. for NDMA or CAM
registers) is write-protecting the corresponding registers (ie. those registers
can be initialized only while the Enable Bits are off).<BR>
<BR>
<B>SPI Touchscreen Controller</B><BR>
This chip is working entirely different in DSi mode. It's still accessed via
SPI bus, but with some new MODE/INDEX values.<BR>
<A HREF="#dsitouchscreensoundcontroller">DSi Touchscreen/Sound Controller</A><BR>
The NDS Touchscreen controller did additionally allow to read Temperature and
Touchscreen Pressure - unknown if the DSi is also supporting such stuff (via
whatever DSi-specific registers).<BR>
The touchscreen hardware can be switched to NDS compatibility mode (for older
games), but unknown how to do that.<BR>
<BR>
<B>SPI Power Managment Device</B><BR>
The Power Managment Device contains some changed register, and some new extra
registers. Internally, it is actually split to two devices: The power managment
chipselect signal connects to U3 and U4 chips. Ie. some SPI registers are
processed by U3 (power down, and backlight enable), and others by R4 (audio out
and microphone).<BR>
Further functions like LED control and backlight brightness are moved to the
BPTWL chip, accessed via I2C bus instead of SPI bus - the power LED blink
feature (which was used on Wifi access) seems to be no longer working, however,
the Wifi LED seems to blink automatically on Wifi access; the changed backlight
brightness mechanism shouldn't cause compatibility issuses since that feature
is somewhat reserved for being controlled by the firmware.<BR>
<BR>
<B>SPI FLASH Memory (Wifi Calibration, User Settings, Firmware)</B><BR>
This memory does still exist, but it's only 128Kbytes in DSi (instead 256K),
and most of it is empty (since the DSi Firmware is stored in the eMMC chip).<BR>
Reportedly, newer DSi consoles are somehow disabling access to the FLASH memory
and to the Wifi hardware (unknown if that's true; it might actually disable
both the SPI chipselect and Wifi hardware, or there might be just some issue
with a different/smaller FLASH chip being used - and problems with reading the
Wifi Calibration would indirectly cause problems to use the Wifi hardware).<BR>
<BR>
<B>RTC</B><BR>
Should be compatible with NDS. But seems to contain extra registers?<BR>
One of the RTC outputs does also seem to supply some (32kHz?) clock to some
other mainboard components?<BR>
[XXX see Seiko S-35199A01 datasheet].<BR>
<BR>
<B>Wifi</B><BR>
Supports new WPA and WPA2 encryption (unknow how to use them yet), and supports
higher transfer rates (unknown how yet too, maybe just by changing the
10=1Mbit/s and 20=2MBit/s settings to higher values).<BR>
As said above (see SPI FLASH), the Wifi hardware can be reportedly disabled.<BR>
SPI FLASH contains three new access point settings (for WPA/WPA2/proxy
support):<BR>
<A HREF="#dsfirmwarewifiinternetaccesspoints">DS Firmware Wifi Internet Access Points</A><BR>
The access point configuration can be done via Firmware (unlike as on NDS,
where it needed to be done by the games).<BR>
<BR>
<B>GBA Slot</B><BR>
The GBA Slot has been removed. The memory regions and IRQ bits do still exist
internally, but the DSi does basically behave as if there is no GBA cartridge
inserted. Reading GBA ROM areas does return FFFFh halfwords instead of the
usual open bus values though.<BR>
<BR>
<B>NDS Mode</B><BR>
In NDS mode, the DSi is basically working same as NDS: The new extra hardware
is disabled, original NDS BIOS ROMs are mapped, and the hardware is simulating
the old touchscreen controller.<BR>
Nonetheless, there are still a some small differences to real NDS consoles:<BR>
- Unlicensed NDS carts don't work (requires RSA, or whitelist for older games)<BR>
- GBA Slot is removed (more or less behaves as if no cart inserted)<BR>
- DSi ports 4004700h and 4004C0xh can be read (and written?) even in DS mode<BR>
- SPI Power Managment has some added/removed/changed registers<BR>
- SPI Touchscreen controller doesn't support pressure &amp; temperature<BR>
- SPI FLASH exists, but it's smaller, and has extra access point info, etc.<BR>
- ARM7 BIOS has only first 20h bytes locked (instead first 1204h bytes)<BR>
- Power Button issues a Reset (goes to boot menu) (instead of plain power off)<BR>
- Maybe some new Wifi features are available even in DS mode (?)<BR>
- RTC extra registers (if they do really exist) should exist in DS mode (?)<BR>
Unknown: does hot-swapping auto-power-off the nds-cart-slot in nds mode?<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsiiomap"></A>&nbsp;
  DSi I/O Map
</FONT></TD></TR></TABLE><BR>
<B>DSi Memory Map</B><BR>
The overall memory map is same as on NDS. New/changed areas are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0000000h  64Kbyte ARM7 BIOS   (unlike NDS which had only 16KB)
  2000000h  16MByte Main RAM    (unlike NDS which had only 4MB)
  3000000h  800Kbyte Shared RAM (unlike NDS which had only 32KB)
  4004000h  New DSi I/O Ports
  8000000h  Fake GBA Slot (32MB+64KB) (FFh-filled; when mapped to current CPU)
  C000000h  Mirror of 16Mbyte Main RAM
  D000000h  Open Bus? in retail version, Extra 16Mbyte MainRAM in debug version
  FFFF000h  64Kbyte ARM9 BIOS   (unlike NDS which had only 4KB)
</TD></TR></TABLE>
<BR>
<B>DSi I/O Maps</B><BR>
The overall DSi I/O Maps are same as on NDS,<BR>
<A HREF="#dsiomaps">DS I/O Maps</A><BR>
additional new/changed registers are:<BR>
<BR>
<B>ARM9 NDS Register that are changed in DSi mode</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4000004h 2   DISPSTAT (new Bit6, LCD Initialization Ready Flag)
  4000204h 2   EXMEMCNT (removed Bit0-7, ie. the GBA-slot related bits)
  4000210h 4   IE       (new interrupt sources, removed GBA-slot IRQ)
  4000214h 4   IF       (new interrupt sources, removed GBA-slot IRQ)
  40021A0h 4   Unknown, nonzero, probably same/silimar as on DSi7 side
  40021A4h 4   Unknown, zero, probably same/silimar as on DSi7 side
</TD></TR></TABLE>
<B>ARM9 DSi Control</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4004000h 2   SCFG_A9ROM DSi - NDS9 - ROM Status (R) [0000h]
  4004004h 2   SCFG_CLK   DSi - NDS9 - New Block Clock Control (R/W)
  4004006h 2   SCFG_RST   DSi - NDS9 - New Block Reset (R/W)
  4004008h 4   SCFG_EXT   DSi - NDS9 - Extended Features (R/W)
  4004010h 2   SCFG_MC    Memory Card Interface Status (16bit) (undocumented)
</TD></TR></TABLE>
<B>ARM9 DSi WRAM Bank Control</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4004040h 4   MBK1       WRAM-A Slots for Bank 0,1,2,3  ;\Global ARM7+ARM9
  4004044h 4   MBK2       WRAM-B Slots for Bank 0,1,2,3  ; Slot Mapping
  4004048h 4   MBK3       WRAM-B Slots for Bank 4,5,6,7  ; (R or R/W, depending
  400404Ch 4   MBK4       WRAM-C Slots for Bank 0,1,2,3  ; on MBK9 setting)
  4004050h 4   MBK5       WRAM-C Slots for Bank 4,5,6,7  ;/
  4004054h 4   MBK6       WRAM-A Address Range           ;\Local ARM9 Side
  4004058h 4   MBK7       WRAM-B Address Range           ; (R/W)
  400405Ch 4   MBK8       WRAM-C Address Range           ;/
  4004060h 4   MBK9       WRAM-A/B/C Slot Master Selection (R)
</TD></TR></TABLE>
<B>ARM9 DSi New DMA</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4004100h 4   NDMAGCNT   NewDMA Global Control                     ;-Control
  4004104h 4   NDMA0SAD   NewDMA0 Source Address                    ;\
  4004108h 4   NDMA0DAD   NewDMA0 Destination Address               ;
  400410Ch 4   NDMA0TCNT  NewDMA0 Total Length for Repeats          ; NewDMA0
  4004110h 4   NDMA0WCNT  NewDMA0 Logical Block Size                ;
  4004114h 4   NDMA0BCNT  NewDMA0 Block Transfer Timing/Interval    ;
  4004118h 4   NDMA0FDATA NewDMA0 Fill Data                         ;
  400411Ch 4   NDMA0CNT   NewDMA0 Control                           ;/
  4004120h 4   NDMA1SAD                                             ;\
  4004124h 4   NDMA1DAD                                             ;
  4004128h 4   NDMA1TCNT                                            ; NewDMA1
  400412Ch 4   NDMA1WCNT                                            ;
  4004130h 4   NDMA1BCNT                                            ;
  4004134h 4   NDMA1FDATA                                           ;
  4004138h 4   NDMA1CNT                                             ;/
  400413Ch 4   NDMA2SAD                                             ;\
  4004140h 4   NDMA2DAD                                             ;
  4004144h 4   NDMA2TCNT                                            ; NewDMA2
  4004148h 4   NDMA2WCNT                                            ;
  400414Ch 4   NDMA2BCNT                                            ;
  4004150h 4   NDMA2FDATA                                           ;
  4004154h 4   NDMA2CNT                                             ;/
  4004158h 4   NDMA3SAD                                             ;\
  400415Ch 4   NDMA3DAD                                             ;
  4004160h 4   NDMA3TCNT                                            ; NewDMA3
  4004164h 4   NDMA3WCNT                                            ;
  4004168h 4   NDMA3BCNT                                            ;
  400416Ch 4   NDMA3FDATA                                           ;
  4004170h 4   NDMA3CNT                                             ;/
</TD></TR></TABLE>
<B>ARM9 DSi Camera Module</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4004200h 2   CAM_MCNT   Camera Module Control (16bit)
  4004202h 2   CAM_CNT    Camera Control (16bit)
  4004204h 4   CAM_DAT    Camera Data (32bit)
  4004210h 4   CAM_SOFS   Camera Trimming Starting Position Setting (32bit)
  4004214h 4   CAM_EOFS   Camera Trimming Ending Position Setting (32bit)
</TD></TR></TABLE>
<B>ARM9 DSi DSP - XpertTeak processor</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4004300h 2   DSP_PDATA  DSP Transfer Data    (16bit)
  4004304h 2   DSP_PADR   DSP Transfer Address (16bit)
  4004308h 2   DSP_PCFG   DSP Configuration    (16bit)
  400430Ch 2   DSP_PSTS   DSP Status           (16bit)
  4004310h 2   DSP_PSEM   DSP ARM9-to-DSP Semaphore        (16bit)
  4004314h 2   DSP_PMASK  DSP DSP-to-ARM9 Semaphore Mask   (16bit)
  4004318h 2   DSP_PCLEAR DSP DSP-to-ARM9 Semaphore Clear (W) (16bit)
  400431Ch 2   DSP_SEM    DSP DSP-to-ARM9 Semaphore Data   (16bit)
  4004320h 2   DSP_CMD0   DSP Command Register 0 (16bit)
  4004324h 2   DSP_REP0   DSP Reply Register 0   (16bit)
  4004328h 2   DSP_CMD1   DSP Command Register 1 (16bit)
  400432Ch 2   DSP_REP1   DSP Reply Register 1   (16bit)
  4004330h 2   DSP_CMD2   DSP Command Register 2 (16bit)
  4004334h 2   DSP_REP2   DSP Reply Register 2   (16bit)
  4004340h 40h Unknown (looks like mirror of 4004300h..400433Fh)
  4004380h 40h Unknown (looks like mirror of 4004300h..400433Fh)
  40043C0h 40h Unknown (looks like mirror of 4004300h..400433Fh)
</TD></TR></TABLE>
<BR>
<B>ARM7 DSi</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4000004h 2   DISPSTAT (new Bit6, LCD Initialization Ready Flag) (as DSi9?)
  4000204h 2   EXMEMCNT (removed Bit0-7: GBA-slot related bits)   (as DSi9?)
  4000210h 4   IE       (new interrupt sources, removed GBA-slot IRQ)
  4000214h 4   IF       (new interrupt sources, removed GBA-slot IRQ)
  4000218h     IE2      (new register with more new interrupt sources)
  400021Ch     IF2      (new register with more new interrupt sources)
</TD></TR></TABLE>
<B>ARM7 DSi Maybe 2nd ROM slot (DSi prototypes did have 2 cartridge slots)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  40021A0h 4   Unknown, nonzero, probably related to below 40021A4h
  40021A4h 4   Unknown, related to 40001A4h (Gamecard Bus ROMCTRL)
</TD></TR></TABLE>
<B>ARM7 DSi Unknown</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4004000h 1   SCFG...? used by BIOS and SystemFlaw  (maybe A9ROM)
  4004001h 1   SCFG...? used by BIOS and SystemFlaw  (maybe A7ROM)
  4004004h ?   SCFG...? used by SystemFlaw           (maybe CLK)
  4004006h ?   SCFG...? used by SystemFlaw           (maybe RST)
  4004008h ?   SCFG...? used by SystemFlaw           (maybe EXT)
  4004010h ?   Unknown, there is something (on ARM9i side: SCFG_MC)
  4004012h ?   Unknown, there is something           (?) (SysMenu: 1988h)
  4004014h ?   Unknown, there is something           (?) (SysMenu: 264Ch)
  4004020h ?   ...?     used by SystemFlaw           (?)
  4004024h ?   ...?     used by SystemFlaw           (?)
  4004040h 20  Unknown, probably read-only mirror of ARM9's MBK1..MBK5
  4004054h 12  Unknown, probably local version of ARM9's MBK6..MBK8
  4004060h 1   MBK9...?  used by BIOS
  4004061h 1   MBK9...?  used by BIOS
  4004062h 1   MBK9...?  used by BIOS
</TD></TR></TABLE>
<B>ARM7 DSi New DMA</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4004100h 74h NewDMA (new DMA, as on ARM9i, see there)
</TD></TR></TABLE>
<B>ARM7 DSi AES Encryption Unit</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4004400h 4   AES_CNT
  4004404h 4   AES_BLKCNT
  4004408h 4   AES_WRFIFO
  400440Ch 4   AES_RDFIFO
  4004420h 16  AES_IV
  4004430h 16  AES_MAC
  4004440h 48  AES_KEY0  ;used for modcrypt?
  4004470h 48  AES_KEY1  ;used for ?
  40044A0h 48  AES_KEY2  ;used for ?
  40044D0h 48  AES_KEY3  ;used for eMMC?
</TD></TR></TABLE>
<B>ARM7 DSi I2C Bus</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4004500h 1   I2C_DATA
  4004501h 1   I2C_CNT
</TD></TR></TABLE>
<B>ARM7 DSi Microphone ?</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4004600h 2   MIC_CNT ?
  4004604h 4   MIC_DATA ?
</TD></TR></TABLE>
<B>ARM7 DSi SNDEX</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4004700h 2   SNDEXCNT             &lt;-- can be read even in DS mode!
</TD></TR></TABLE>
<B>ARM7 DSi SD/MMC Registers for Memory Card access</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4004800h ?  000D Used? SD_CMD              Command and Response/Data Type
  4004802h 2  0201 Used? SD_CARD_PORT_SELECT
  4004804h 4  0000 Used? SD_CMD_PARAM0-1     Argument (32bit, 2 halfwords)
  4004808h 2  0100 Used? SDCTL_STOP_INTERNAL_ACTION
  400480Ah 2  0008 Used? SD_DATA16_BLK_COUNT        "Transfer Sector Count"
  400480Ch 16 0900 Used? SD_RESPONSE0-7 (128bit, 8 halfwords)
  400481Ch 4  0601 Used? SD_IRQ_STATUS0-1  ;IRQ Status  (0=ack, 1=req)
  4004820h 4  0305 Used? SD_IRQ_MASK0-1    ;IRQ disable (0=enable, 1=disab)
  4004824h 2  0    Used? SDCTL_CARD_CLK_CTL Card Clock Control
  4004826h 2  0200 Used? SD_DATA16_BLK_LEN  Memory Card Transfer Data Length
  4004828h 2  40E0 Used? SD_CARD_OPTION  Memory Card Option Setup
  400482Ah 2  0    ?     ---
  400482Ch 4  2000 ?     SD_ERROR_DETAIL_STATUS0-1   Error Detail Status
  4004830h 2  0    Used? SD_DATA16_FIFO        Data Port  (SD_FIFO?)
  4004832h 2  0    ?     --- (TC6371AF:BUF1 Data MSBs?)
  4004834h 2  0    ?     SD_TRANSACTION_CTL  Transaction Control
  4004836h 2  0002 ?     ---
  4004838h 2  C007 ?     ---
  400483Ah 6  0    ?     ---
  4004840h 2  003F ?     -?-
  4004842h 2  002A ?     -?-
  ...      .. 0    ?     -?-
  40048B2h 2  FFFF ?     -?-
  ...      .. 0    ?     -?-
  40048BAh ?  0200 ?     -?-
  ...      .. 0    ?     -?-
  40048D8h 2  1012 Used? SD_DATA_CTL           (???)
  ...      .. 0    ?     -?-
  40048E0h 2  0007 Used? SD_SOFT_RESET  Software Reset (bit0=SRST=0=reset)
  40048E2h 2  0009 ?     SDCTL_RESERVED2 (TC6371AF:CORE_REV)
  40048E4h 2  0    ?     ---
  40048E6h 2  0    ?     SDCTL_RESERVED3 (TC6371AF:BUF_ADR)
  40048E8h 2  0    ?     --- (TC6371AF:Resp_Header)
  40048EAh 10 0    ?     ---
  40048F4h 2  0700 ?     ---
  40048F6h 2  0000 Used? SDCTL_RESERVED4       (??)
  40048F8h 2  0004 ?     SDCTL_RESERVED5
  40048FAh 2  0007 ?     SDCTL_RESERVED6
  40048FCh 2  00FC ?     SDCTL_RESERVED7
  40048FEh 2  00FF ?     SDCTL_RESERVED8 (TC6371AF:Revision)
  4004900h 2  0802 Used? -?- SD_DATA32_CTL       (???)
  4004902h 2  0    ?     -?-
  4004904h 2  0200 Used? -?- SD_DATA32_BLK_LEN   (?)
  4004906h 2  0    ?     -?-
  4004908h 2  0001 Used? -?- SD_DATA32_BLK_COUNT (?)
  400490Ah 2  0    ?     -?-
  400490Ch 4  0    Used? -?- SD_DATA32_FIFO      (?)
  ...      .. 0    ?     -?-
</TD></TR></TABLE>
<B>ARM7 DSi SD/MMC Registers for SDIO access</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4004A00h 2  0    ?     SDIO_CMD            Command and Response/Data Type
  4004A02h 2  0100 ?     SDIO_CARD_PORT_SELECT
  4004A04h 4  0    ?     SDIO_CMD_PARAM0-1   Argument (32bit, 2 halfwords)
  4004A08h 2  0    ?     ---
  4004A0Ah 2  0    ?     SDIO_DATA16_BLK_COUNT Transfer Block Count
  4004A0Ch 16 0    ?     SDIO_RESPONSE0-7
  4004A1Ch 4  0630 ?     SDIO_IRQ_STATUS0-1  Interrupt Status
  4004A20h 4  031D ?     SDIO_IRQ_MASK0-1    Interrupt Mask
  4004A24h 2  0020 ??    ---
  4004A26h 2  0200 ?     SDIO_BLK_LEN        Card Transfer Data Length
  4004A28h 2  40EE ?     SDIO_CARD_OPTION    Card Option Setup
  4004A2Ah 2  0    ?     ---
  4004A2Ch 4  2000 ?     SDIO_ERROR_DETAIL_STATUS0-1  Error Detail Status
  4004A30h 2  0    ?     SDIO_DATA16_FIFO    Data Port  (SD_FIFO?)
  4004A32h 2  0    ?     ---
  4004A34h 2  0    ?     SDIO_TRANSACTION_CTL Transaction Control
  4004A36h 2  0    ?     SDCTL_CARD_INTERRUPT_CONTROL
  4004A38h 2  C007 ?     SDCTL_CLK_AND_WAIT_CTL
  4004A3Ah 2  0    ?     SDCTL_SDIO_HOST_INFORMATION
  4004A3Ch 2  0    ?     SDCTL_ERROR_CONTROL
  4004A3Eh 2  0    ?     SDCTL_SDLED_CONTROL LED Control (TC6387XB only)
  4004A40h 2  003F ?     -?-
  4004A42h 2  002A ?     -?-
  ...      .. 0    ?     -?-
  4004AB2h 2  FFFF ?     -?-
  ...      .. 0    ?     -?-
  4004ABAh ?  0200 ?     -?-
  ...      .. 0    ?     -?-
  4004AD8h 2  1010 ?     -?- SDIO_DATA_CTL
  ...      .. 0    ?     -?-
  4004AE0h 2  0006 ?     SDIO_SOFT_RESET     Software Reset
  4004AE2h 2  0009 ?     SDCTL_RESERVED9
  4004AE4h 12 0    ?     ---
  4004AF0h 2  0    ?     SDCTL_RESERVED10
  4004AF2h 2  0    ?     ---
  4004AF4h 2  0700 ?     ---
  4004AF6h 2  0000 ?     SDCTL_RESERVED4
  4004AF8h 2  0    ?     SDCTL_RESERVED5
  4004AFAh 2  0    ?     SDCTL_RESERVED6
  4004AFCh 2  00FF ?     SDCTL_RESERVED7
  4004AFEh 2  00FF ?     SDCTL_RESERVED8 (TC6371AF:Revision)
  4004B00h 2  0    ?     -?- SDIO_DATA32_CTL       (???)
  4004B02h 2  0    ?     -?-
  4004B04h 2  0    ?     -?- SDIO_DATA32_BLK_LEN   (?)
  4004B06h 2  0    ?     -?-
  4004B08h 2  0001 ?     -?- SDIO_DATA32_BLK_COUNT (?)
  4004B0Ah 2  0    ?     -?-
  4004B0Ch 4  0    ?     -?- SDIO_DATA32_FIFO      (?)
  ...      .. 0    ?     -?-
</TD></TR></TABLE>
<B>ARM7 DSi General Purpose I/O (GPIO) (headphone connect, power button)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4004C00h 1  GPIO Data In               (R)  (even in DS mode)
  4004C00h 1  GPIO Data Out              (W)
  4004C01h 1  GPIO Data Direction        (R/W)
  4004C02h 1  GPIO Interrupt Edge Select (R/W)
  4004C03h 1  GPIO Interrupt Enable      (R/W)
  4004C04h 1  GPIO? Unknown  ;\maybe GPIO related, or something else
  4004C05h 1  GPIO? Unknown  ;/
</TD></TR></TABLE>
<B>ARM7 DSi CPU/Console ID (used as eMMC key)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4004D00h 8  CPU/Console ID Code (64bit)
  4004D08h 2  CPU/Console ID Flag (1bit)
</TD></TR></TABLE>
Unknown, expected features are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  DSi7 control (similar to DSi9 SCFG_xxx)
  new sound/microphone "CODEC" or so
  wifi: faster and with new encryption
  NDS-slot-swap-bit (would allow to boot NDS carts from 2nd NDS-slot)
</TD></TR></TABLE>
<BR>
<B>TEAK DSi Ports</B><BR>
The Teak processor should also contain whatever I/O ports:<BR>
Some counterpart to the ARM9 ports (eg. semaphores).<BR>
And possibly direct access to sound/microphone hardware?<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsicontrolregistersscfg"></A>&nbsp;
  DSi Control Registers (SCFG)
</FONT></TD></TR></TABLE><BR>
<B>4004000h - DSi9 - SCFG_A9ROM - ROM Status (R) [0000h]</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-1   System ROM Status (0=NITRO, 1=TWL, 2-3=?) (somehow controlled via NDS7)
  2-15  Unused (0)
  16-31 Unspecified (0)
</TD></TR></TABLE>
<BR>
<B>4004004h - DSi9 - SCFG_CLK - New Block Clock Control (R/W) [0084h]</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     ARM9 CPU Clock         (0=NITRO/67.03MHz, 1=TWL/134.06MHz) (TCM/Cache)
  1     DSP Block Clock        (0=Stop, 1=Run)
  2     Camera Interface Clock (0=Stop, 1=Run)
  3-6   Unused (0)
  7     New Shared RAM Clock   (0=Stop, 1=Run)   (R?) (always set?)
  8     Camera External Clock  (0=Disable, 1=Enable) ("outputs at 16.76MHz")
  9-15  Unused (0)
  16-31 See below (Port 4004006h)
</TD></TR></TABLE>
Change ARM9 clock only from code within ITCM (and wait at least 8 cycles before
accessing any non-ITCM memory).<BR>
Disable the corresponding modules before stopping their clocks.<BR>
<BR>
<B>4004006h - DSi9 - SCFG_RST - New Block Reset (R/W) [0000h]</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     DSP Block Reset (0=Apply Reset, 1=Release Reset)
  1-15  Unused (0)
</TD></TR></TABLE>
<BR>
<B>4004008h - DSi9 - SCFG_EXT - Extended Features (R/W) [8307F100h]</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Revised DMA Circuit            (0=NITRO, 1=Revised)
  1     Revised Geometry Circuit       (0=NITRO, 1=Revised)
  2     Revised Renderer Circuit       (0=NITRO, 1=Revised)
  3     Revised 2D Engine Circuit      (0=NITRO, 1=Revised)
  4     Revised Divider Circuit        (0=NITRO, 1=Revised)
  5-6   Unused (0)
  7     Revised Card Interface Circuit (0=NITRO, 1=Revised)
  8     Extended Interrupt Circuit     (0=NITRO, 1=Extended)
  9-11  Unused (0)
  12    Extended LCD Circuit           (0=NITRO, 1=Extended)
  13    Extended VRAM Access           (0=NITRO, 1=Extended)
  14-15 Main Memory RAM Limit (0..1=4MB/DS, 2=16MB/DSi, 3=32MB/DSiDebugger)
  16    Access to New DMA Controller   (0=Disable, 1=Enable)
  17    Access to Camera Interface     (0=Disable, 1=Enable)
  18    Access to DSP Block            (0=Disable, 1=Enable)
  19-23 Unused (0)
  24    Access to New Shared WRAM      (0=Disable, 1=Enable)
  25    Undocumented/Unknown (can be set)
  26-30 Unused (0)
  31    System Control Block Access (0=Disable, 1=Enable) (lock 4004000h-4063h)
</TD></TR></TABLE>
Main RAM mapping depending on bit14-15:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Mode         2000000h-2FFFFFFh   C000000h-CFFFFFFh   D000000h-DFFFFFFh
  4MB (0 or 1) 1st 4MB (+mirrors)  Zerofilled          Zerofilled
  16MB (2)     1st 16MB            1st 16MB (mirror)   1st 16MB (mirror)
  32MB (3)     1st 16MB            1st 16MB (mirror)   Open bus (or 2nd 16MB)
</TD></TR></TABLE>
DSi9 SCFG_EXT.bit14-15 affect the Main RAM mapping on &lt;both&gt; ARM9 and
ARM7 side. The 32MB mode requires an extra RAM chip (present in DSi debug
version only; DSi retail consoles return 16bit open bus values instead of extra
memory). RAM Size/Openbus detection is conventionally done by trying to
read/write a BYTE at [0DFFFFFAh].<BR>
<BR>
<B>4004010h - DSi9 - SCFG_MC - Memory Card Interface Status (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Game Cartridge   (0=Inserted, 1=Ejected)                    (R)
  1     Unknown/Undocumented (0)
  2     Unknown/Undocumented (0) (used/maybe power busy?)
  3     Unknown/Undocumented (1) (maybe power? cleared upon eject!) (R)
  4     Unknown/Undocumented (1)  ;\maybe same as bit0-3, for 2nd NDS-slot?
  5-7   Unknown/Undocumented (0)  ;/(ie. DSi prototype relict)
  8-15  Unknown/Undocumented (0)
  16-31 Unspecified (0)
</TD></TR></TABLE>
NDS-Slot related. Bit3 (and maybe Bit2) are probably R/W on ARM7 side (though
the register is disabled on ARM7 side in cooking coach exploit, so R/W isn't
possible in practice).<BR>
Note: Additionally, the NDS slot Reset pin can be toggled (via ROMCTRL.Bit29;
that bit is writeable on ARM7 side on DSi; which wasn't supported on NDS).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsixpertteakdsp"></A>&nbsp;
  DSi XpertTeak (DSP)
</FONT></TD></TR></TABLE><BR>
<B>Unknown DSP Stuff - XXX</B><BR>
As by now, there aren't any DSi games known to use the XpertTeak.<BR>
* DSP Instructions Set (opcodes) are unknown<BR>
* DSP Clock speed is unknown<BR>
* DSP I/O ports (at DSP side) are unknown<BR>
* DSP Memory Map is unknown<BR>
* DSP somehow connects to Audio Mixer and to Audio I2S<BR>
The DSP is a XpertTeak processor from CEVA, there seems to be no official
datasheet/programming manual in the internet, however, there is a TeakLite
manual which might contain useful info (in CEVA's product line, the XpertTeak
was created somewhere between TeakLite and CEVA-X).<BR>
The Nintendo 3DS is said to use a TeakLite, so XpertTeak and TeakLite should be
probably more or less compatible.<BR>
<BR>
<B>Usage</B><BR>
The XpertTeak hardware seems to be left unused by most DSi games.<BR>
It is used by the "Nintendo DSi Sound" and "Nintendo Zone" system utilities.<BR>
<BR>
======= DSP I/O Ports (on ARM9 Side) =======<BR>
<BR>
<B>4004300h - DSi9 - DSP_PDATA - DSP Transfer Data Read FIFO (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15  Data (one stage of the 16-stage Read FIFO)
</TD></TR></TABLE>
<BR>
<B>4004300h - DSi9 - DSP_PDATA - DSP Transfer Data Write FIFO (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15  Data (one stage of the 16-stage Write FIFO)
</TD></TR></TABLE>
<BR>
<B>4004304h - DSi9 - DSP_PADR - DSP Transfer Address (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15  Lower 16bit of Address in DSP Memory
</TD></TR></TABLE>
Note: The upper 16bit of Address must be configued in the DMA register (inside
of the DSP).<BR>
<BR>
<B>4004308h - DSi9 - DSP_PCFG - DSP Configuration (R/W)   (16bit)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     DSP Reset (0=Release, 1=Reset)  ;should be held "1" for 8 DSP clks
  1     Address Auto-Increment (0=Off, 1=On)
  2-3   DSP Read Data Length (0=1 word, 1=8 words, 2=16 words, 3=Free-Run)
  4     DSP Read Start Flag (mem transfer via Read FIFO) (1=Start)
  5     Interrupt Enable Read FIFO Full      (0=Off, 1=On)
  6     Interrupt Enable Read FIFO Not-Empty (0=Off, 1=On)
  7     Interrupt Enable Write FIFO Full     (0=Off, 1=On)
  8     Interrupt Enable Write FIFO Empty    (0=Off, 1=On)
  9     Interrupt Enable Reply Register 0    (0=Off, 1=On)
  10    Interrupt Enable Reply Register 1    (0=Off, 1=On)
  11    Interrupt Enable Reply Register 2    (0=Off, 1=On)
  12-15 DSP Memory Transfer (0=Data Memory, 1=MMIO Register, 5=Program Memory)
</TD></TR></TABLE>
<BR>
<B>400430Ch - DSi9 - DSP_PSTS - DSP Status (R)          (16bit)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Read Transfer Underway Flag  (0=No, 1=Yes/From DSP Memory)
  1     Write Transfer Underway Flag (0=No, 1=Yes/To DSP Memory)
  2     Peripheral Reset Flag (0=No/Ready, 1=Reset/Busy)
  3-4   Unused
  5     Read FIFO Full Flag      (0=No, 1=Yes)
  6     Read FIFO Not-Empty Flag (0=No, 1=Yes) ;ARM9 may read DSP_PDATA
  7     Write FIFO Full Flag     (0=No, 1=Yes)
  8     Write FIFO Empty Flag    (0=No, 1=Yes)
  9     Semaphore IRQ Flag (0=None, 1=IRQ)
  10    Reply Register 0 Update Flag (0=Was Written by DSP, 1=No)
  11    Reply Register 1 Update Flag (0=Was Written by DSP, 1=No)
  12    Reply Register 2 Update Flag (0=Was Written by DSP, 1=No)
  13    Command Register 0 Read Flag (0=Was Read by DSP, 1=No)
  14    Command Register 1 Read Flag (0=Was Read by DSP, 1=No)
  15    Command Register 2 Read Flag (0=Was Read by DSP, 1=No)
</TD></TR></TABLE>
Unknown if/when bit10-15 get reset... maybe after reading the status?<BR>
<BR>
<B>4004310h - DSi9 - DSP_PSEM - ARM9-to-DSP Semaphore (R/W) (16bit)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15  ARM9-to-DSP Semaphore 0..15 Flags (0=Off, 1=On)
</TD></TR></TABLE>
Reportedly these flags are sent in ARM9-to-DSP direction (=seems correct).<BR>
Confusingly, the other DSP_Pxxx registers are for opposite direction?<BR>
<BR>
<B>4004314h - DSi9 - DSP_PMASK - DSP-to-ARM9 Semaphore Mask (R/W) (16bit)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15  DSP-to-ARM9 Semaphore 0..15 Interrupt Disable (0=Enable, 1=Disable)
</TD></TR></TABLE>
<BR>
<B>4004318h - DSi9 - DSP_PCLEAR - DSP-to-ARM9 Semaphore Clear (W) (16bit)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15  DSP-to-ARM9 Semaphore 0..15 Clear (0=No Change, 1=Clear)
</TD></TR></TABLE>
Reportedly clears bits in DSP_PSEM/4004310h. [that's probably nonsense,
clearing bits in DSP_SEM/400431Ch would make more sense]<BR>
<BR>
<B>400431Ch - DSi9 - DSP_SEM - DSP-to-ARM9 Semaphore Data (R) (16bit)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15  DSP-to-ARM9 Semaphore 0..15 Flags (0=Off, 1=On)
</TD></TR></TABLE>
Reportedly these flags are received in DSP-to-ARM9 direction.<BR>
<BR>
<B>4004320h - DSi9 - DSP_CMD0 - DSP Command Reg. 0 (R/W) (ARM9 to DSP) (16bit)</B><BR>
<B>4004328h - DSi9 - DSP_CMD1 - DSP Command Reg. 1 (R/W) (ARM9 to DSP) (16bit)</B><BR>
<B>4004330h - DSi9 - DSP_CMD2 - DSP Command Reg. 2 (R/W) (ARM9 to DSP) (16bit)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15  Command/Data to DSP
</TD></TR></TABLE>
<BR>
<B>4004324h - DSi9 - DSP_REP0 - DSP Reply Register 0 (R) (DSP to ARM9) (16bit)</B><BR>
<B>400432Ch - DSi9 - DSP_REP1 - DSP Reply Register 1 (R) (DSP to ARM9) (16bit)</B><BR>
<B>4004334h - DSi9 - DSP_REP2 - DSP Reply Register 2 (R) (DSP to ARM9) (16bit)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15  Reply/Data from DSP
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsinewsharedwramforarm7arm9dsp"></A>&nbsp;
  DSi New Shared WRAM (for ARM7, ARM9, DSP)
</FONT></TD></TR></TABLE><BR>
<B>Shared WRAM (total 800Kbytes)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Old WRAM-0/1 32Kbytes (2x16K), mappable to ARM7, or ARM9
  New WRAM-A  256Kbytes (4x64K), mappable to ARM7, or ARM9
  New WRAM-B  256Kbytes (8x32K), mappable to ARM7, ARM9, or DSP-program memory
  New WRAM-C  256Kbytes (8x32K), mappable to ARM7, ARM9, or DSP-data memory
</TD></TR></TABLE>
New WRAM mapping is done in two steps: First, mapping the physical banks to
logical slots. And then, mapping those slots to actual memory addresses.<BR>
<BR>
<B>4004040h - DSi9 - MBK1.0, WRAM-A0 - 64K, mappable to ARM7, or ARM9</B><BR>
<B>4004041h - DSi9 - MBK1.1, WRAM-A1 - 64K, mappable to ARM7, or ARM9</B><BR>
<B>4004042h - DSi9 - MBK1.2, WRAM-A2 - 64K, mappable to ARM7, or ARM9</B><BR>
<B>4004043h - DSi9 - MBK1.3, WRAM-A3 - 64K, mappable to ARM7, or ARM9</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0    Master (0=ARM9, 1=ARM7)
  1    Not used
  2-3  Offset (0..3) (slot 0..3) (LSB of address in 64Kbyte units)
  4-6  Not used
  7    Enable (0=Disable, 1=Enable)
</TD></TR></TABLE>
In cooking coach, above four bytes are locked via MBK9 (not write-able, always
81h,85h,89h,8Dh)?<BR>
<BR>
<B>4004044h - DSi9 - MBK2.0, WRAM-B0 - 32K, mappable to ARM7, ARM9, or DSP/code</B><BR>
<B>4004045h - DSi9 - MBK2.1, WRAM-B1 - 32K, mappable to ARM7, ARM9, or DSP/code</B><BR>
<B>4004046h - DSi9 - MBK2.2, WRAM-B2 - 32K, mappable to ARM7, ARM9, or DSP/code</B><BR>
<B>4004047h - DSi9 - MBK2.3, WRAM-B3 - 32K, mappable to ARM7, ARM9, or DSP/code</B><BR>
<B>4004048h - DSi9 - MBK3.0, WRAM-B4 - 32K, mappable to ARM7, ARM9, or DSP/code</B><BR>
<B>4004049h - DSi9 - MBK3.1, WRAM-B5 - 32K, mappable to ARM7, ARM9, or DSP/code</B><BR>
<B>400404Ah - DSi9 - MBK3.2, WRAM-B6 - 32K, mappable to ARM7, ARM9, or DSP/code</B><BR>
<B>400404Bh - DSi9 - MBK3.3, WRAM-B7 - 32K, mappable to ARM7, ARM9, or DSP/code</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-1  Master (0=ARM9, 1=ARM7, 2 or 3=DSP/code)
  2-4  Offset (0..7) (slot 0..7) (LSB of address in 32Kbyte units)
  5-6  Not used (0)
  7    Enable (0=Disable, 1=Enable)
</TD></TR></TABLE>
<BR>
<B>400404Ch - DSi9 - MBK4.0, WRAM-C0 - 32K, mappable to ARM7, ARM9, or DSP/data</B><BR>
<B>400404Dh - DSi9 - MBK4.1, WRAM-C1 - 32K, mappable to ARM7, ARM9, or DSP/data</B><BR>
<B>400404Eh - DSi9 - MBK4.2, WRAM-C2 - 32K, mappable to ARM7, ARM9, or DSP/data</B><BR>
<B>400404Fh - DSi9 - MBK4.3, WRAM-C3 - 32K, mappable to ARM7, ARM9, or DSP/data</B><BR>
<B>4004050h - DSi9 - MBK5.0, WRAM-C4 - 32K, mappable to ARM7, ARM9, or DSP/data</B><BR>
<B>4004051h - DSi9 - MBK5.1, WRAM-C5 - 32K, mappable to ARM7, ARM9, or DSP/data</B><BR>
<B>4004052h - DSi9 - MBK5.2, WRAM-C6 - 32K, mappable to ARM7, ARM9, or DSP/data</B><BR>
<B>4004053h - DSi9 - MBK5.3, WRAM-C7 - 32K, mappable to ARM7, ARM9, or DSP/data</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-1  Master (0=ARM9, 1=ARM7, 2 or 3=DSP/data)
  2-4  Offset (0..7) (slot 0..7) (LSB of address in 32Kbyte units)
  5-6  Not used (0)
  7    Enable (0=Disable, 1=Enable)
</TD></TR></TABLE>
<BR>
<B>4004054h - DSi9 - MBK6, WRAM-A, 64K..256K mapping</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-3   Not used (0)
  4-11  Start Address (3000000h+N*10000h)     ;=3000000h..3FF0000h
  12-13 Image Size (0 or 1=64KB/Slot0, 2=128KB/Slot0+1+2??, 3=256KB/Slot0..3)
  14-19 Not used (0)
  20-28 End Address   (3000000h+N*10000h-1)   ;=2FFFFFFh..4FEFFFFh
  29-31 Not used (0)
</TD></TR></TABLE>
Uh, does this affect only ARM9 mapping? Or also ARM7 mapping?<BR>
Uh, but, ARM7 3800000h..3FFFFFFh contains OTHER memory (ARM7-WRAM) !?<BR>
<BR>
<B>4004058h - DSi9 - MBK7, WRAM-B</B><BR>
<B>400405Ch - DSi9 - MBK8, WRAM-C</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-2   Not used (0)
  3-11  Start Address (3000000h+N*8000h)      ;=3000000h..3FF8000h
  12-13 Image Size (0=32K/Slot0,1=64KB/Slot0-1,2=128KB/Slot0-3,3=256KB/Slot0-7)
  14-18 Not used (0)
  19-28 End Address   (3000000h+N*8000h-1)    ;=2FFFFFFh..4FF7FFFh
  29-31 Not used (0)
</TD></TR></TABLE>
Uh, does this affect only ARM9 mapping? Or also ARM7 and DSP mapping?<BR>
Uh, but, ARM7 3800000h..3FFFFFFh contains OTHER memory (ARM7-WRAM) !?<BR>
<BR>
<B>4004060h - DSi9 - MBK9, WRAM-A/B/C Slot Master Selection (undocumented) (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-3   WRAM-A, Port 4004040h-4004043h Master (0=ARM9, 1=ARM7)
  4-7   Unknown/Unused (0)
  8-15  WRAM-B, Port 4004044h-400404Bh Master (0=ARM9, 1=ARM7)
  16-23 WRAM-C, Port 400404Ch-4004053h Master (0=ARM9, 1=ARM7)
  24-31 Unknown/Unused (0)
</TD></TR></TABLE>
Selects which CPU shall control the WRAM slot registers at 4004040h-4004053h
(when selecting ARM7 as master, then the registers become Read-Only on ARM9
side).<BR>
<BR>
<B>ARM7 Side</B><BR>
WRAM-related I/O Ports at ARM7 side are unknown (if any).<BR>
GUESS: Maybe ports 4004040h..4004053h exist as mirror?<BR>
GUESS: Maybe ports 4004054h..400405Fh exist as separate ARM7 registers?<BR>
GUESS: Maybe ports 4004060h..4004063h exist as write-able mirror?<BR>
Existing DSi exploits don't permit to access those regs on ARM7 side.<BR>
<BR>
<B>Slots and Image Size vs Start/End Addresses</B><BR>
When using Image Size of 4 slots, then Memory at 3000000h..3FFFFFFh is:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Slots  0,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3,etc.
</TD></TR></TABLE>
When start=6, and End=12, then (with above example), only following is mapped:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Slots  -,-,-,-,-,-,2,3,0,1,2,3,-,-,-,-,etc.
</TD></TR></TABLE>
Observe that the mapped region starts with Slot 2 (not Slot 0) in that case.<BR>
Moreover, some slots may be empty (disabled, or mapped to another CPU), so, if
Slot 3 is empty, then memory might probably look somewhat like so: (?)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Slots  -,-,-,-,-,-,2,-,0,1,2,-,-,-,-,-,etc.
</TD></TR></TABLE>
If so, unknown what is mapped to those "empty" areas (mirrors, or underlaying
WRAM's of lower priority, or zeroes, or garbage, or whatever).<BR>
<BR>
<B>Overlapping WRAM regions</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  New Shared-WRAM-A   Highest Priority
  New Shared-WRAM-B   High Priority
  New Shared-WRAM-C   Low Priority
  Old Shared-WRAM-0/1 Lowest Priority
  Old ARM7-WRAM       Whatever Priority (unknown...)
</TD></TR></TABLE>
<B>Overlapping WRAM slots</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Unknown what happens when selecting multiple WRAM blocks to the same slot?
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsinewdma"></A>&nbsp;
  DSi New DMA
</FONT></TD></TR></TABLE><BR>
The DSi has four new DMA channels for ARM7 and ARM9 (each) (eight new DMA
channels in total). The old NDS-style DMA channels do probably still exist, too
[though unknown which priority they have in relation to new channels].<BR>
<BR>
<B>4004100h - DSi - NDMAGCNT   NewDMA Global Control (R/W) [00000000h]</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15  Unused (0)
  16-19 Cycle Selection (0=None, 1..15=1..16384 clks) ;1 SHL (N-1)
  20-30 Unused (0)
  31    DMA Arbitration Mode (0=NDMA0=HighestPriority, 1=RoundRobinPriority)
</TD></TR></TABLE>
CycleSelection is used ONLY in RoundRobin mode; if so... then it does specify
the number of cycles that can be executed by ARM9 and DSP &lt;CPUs?&gt; during
NDMA?<BR>
<BR>
<B>4004104h+x*1Ch - NDMAxSAD - NewDMAx Source Address (R/W) [00000000h]</B><BR>
<B>4004108h+x*1Ch - NDMAxDAD - NewDMAx Destination Address (R/W) [00000000h]</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-1   Unused (0)
  2-31  DMA Source/Destination Address, in 4-byte steps
</TD></TR></TABLE>
<BR>
<B>400410Ch+x*1Ch - NDMAxTCNT - NewDMAx Total Length for Repeats (R/W) [0]</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-27  Total Number of Words to Transfer (1..0FFFFFFFh, or 0=10000000h)
  28-31 Unused (0)
</TD></TR></TABLE>
Not used in "Start immediately" mode (which doesn't repeat).<BR>
Not used in "Repeat infinitely" mode (which repeats forever).<BR>
Used only in "Repeat until NDMAxTCNT" mode (for example, to define the total
size of the Camera picture).<BR>
Total Length should be a multiple of the Logical Block Size in NDMAxWCNT. (?)<BR>
<BR>
<B>4004110h+x*1Ch - NDMAxWCNT - NewDMAx Logical Block Size</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-23  Number of Words to Transfer       (1..00FFFFFFh, or 0=01000000h)
  24-31 Unused (0)
</TD></TR></TABLE>
Should be a multiple of the Physical Block Size specified in NDMAxCNT.Bit16-19.<BR>
The bus will be monopolized until the selected number of words for (physical)
block transfers has completed, a single (physical) block transfer cycle will
never be split up.<BR>
<BR>
<B>4004114h+x*1Ch - NDMAxBCNT - NewDMAx Block Transfer Timing/Interval</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15  Interval Timer (1..FFFFh, or 0=Infite/TillTransferEnd)
  16-17 Prescaler (33.514MHz SHR (n*2)) ;0=33MHz, 1=8MHz, 2=2MHz, 3=0.5MHz
  18-31 Unused (0)
</TD></TR></TABLE>
Allows to insert a delay after each (Physical?) Block.<BR>
<BR>
<B>4004118h+x*1Ch - NDMAxFDATA - NewDMAx Fill Data</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-31  Fill Data (can be used as FixedSourceAddress for memfill's)
</TD></TR></TABLE>
By selecting "FillData" (NDMAxCNT.Bit13-14=3) as the update method for the
source address, it is possible to skip the read cycle and only write the value
set for the Fill Data Register during the write cycle to the destination
address. Since this occurs only during the write cycle, this lets you clear a
region to a fixed value faster than is possible with a standard DMA transfer.<BR>
<BR>
<B>400411Ch+x*1Ch - NDMAxCNT - NewDMAx Control</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-9   Unused (0)
  10-11 Dest Address Update   (0=Increment, 1=Decrement, 2=Fixed, 3=Reserved)
  12    Dest Address Reload   (0=No, 1=Reload at (logical blk?) transfer end)
  13-14 Source Address Update (0=Increment, 1=Decrement, 2=Fixed, 3=FillData)
  15    Source Address Reload (0=No, 1=Reload at (logical blk?) transfer end)
  16-19 Physical Block Size   (0..0Fh=1..32768 words, aka (1 SHL n) words)
  20-23 Unused (0)
  24-28 DMA Startup Mode      (00h..1Fh, see ARM7/ARM9 startup lists below)
  29    DMA Repeat Mode       (0=Repeat until NDMAxTCNT, 1=Repeat infinitely)
  30    DMA Interrupt Enable  (0=Disable, 1=Enable)
  31    DMA Enable/Busy       (0=Disable, 1=Enable/Busy)
</TD></TR></TABLE>
<BR>
<B>Startup Modes for ARM9:</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h      Timer0                       ;\
  01h      Timer1                       ; new NDMA-specific modes
  02h      Timer2                       ;
  03h      Timer3                       ;/
  04h      DS Cartridge Slot
  05h      Reserved (maybe 2nd DS-Cart Slot, or GBA slot relict?)
  06h      V-Blank
  07h      H-Blank (but not during V-blank)
  08h      Display Sync (sync to H-blank drawing) ;Uh, what is BLANK-DRAWING ??
  09h      Work RAM (what?) (=probably Main memory display, as on NDS)
  0Ah      Geometry Command FIFO
  0Bh      Camera                       ;-new NDMA-specific mode
  0Ch..0Fh Reserved
  10h..1Fh Start immediately (without repeat)
</TD></TR></TABLE>
<BR>
<B>Startup Modes for ARM7:</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h      Timer0                       ;\
  01h      Timer1                       ; new NDMA-specific modes
  02h      Timer2                       ;
  03h      Timer3                       ;/
  04h      DS Cartridge Slot
  05h      Reserved? (maybe 2nd DS-Cart Slot, or GBA slot relict?)
  06h      V-Blank
  07h      Wifi
  08h      SD/MMC I/F 1    ;what "1" ?  ;\
  09h      SD/MMC I/F 2    ;what "2" ?  ;
  0Ah      AES in  (AES_WRFIFO)         ; new NDMA-specific modes
  0Bh      AES out (AES_RDFIFO) / MIC?  ;
  0Ch      MIC?                         ;/
  0Dh..0Fh Reserved?
  10h..1Fh Start immediately (without repeat)
</TD></TR></TABLE>
<BR>
<B>Start/repeat modes</B><BR>
There are three different transfer modes.<BR>
<B>1) Start immediately (without repeat):</B><BR>
the transfer ends after one Logical Block, without repeat.<BR>
<B>2) Start by Hardware events, Repeat until NDMAxTCNT:</B><BR>
the transfer repeats Logical Blocks until reaching the Total Length.<BR>
<B>3) Start by Hardware events, Repeat infinitely:</B><BR>
the transfer repeats Logical Blocks infinitely.<BR>
<BR>
<B>Read-only Effect</B><BR>
There is something that can make port 4004104h..4004173h read-only. For
example, when FFh-filling all DSi registers, and then 00h-filling them, then
most DMA bits stay set (00h-filling them another time does clear them).<BR>
Maybe, during enabled transfers, ONLY the enable/busy bit is writeable?<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisoundext"></A>&nbsp;
  DSi SoundExt
</FONT></TD></TR></TABLE><BR>
<B>4004700h - DSi7 - SNDEXCNT (16bit) (can be 0000C00Fh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-3     NITRO/DSP ratio                   (valid range is 0 to 8)       (R/W)
  4-12    Unknown/Unused (0)                                               (0?)
  13      Sound/Microphone I2S frequency (0=32.73 kHz, 1=47.61 kHz)  (R or R/W)
  14      Mute status                                (?=Mute WHAT?)       (R/W)
  15      Enable Microphone (and Sound Output?)          (1=Enable)       (R/W)
</TD></TR></TABLE>
NITRO/DSP ratio<BR>
The DSP can generate sound output aswell, alongside the old NITRO sound mixer.
The following settings configure the ratio between DSP and NITRO mixer output:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h      DSP sound 8/8, NITRO sound 0/8 (=DSP sound only)
  01h      DSP sound 7/8, NITRO sound 1/8
  02h      DSP sound 6/8, NITRO sound 2/8
  03h      DSP sound 5/8, NITRO sound 3/8
  04h      DSP sound 4/8, NITRO sound 4/8
  05h      DSP sound 3/8, NITRO sound 5/8
  06h      DSP sound 2/8, NITRO sound 6/8
  07h      DSP sound 1/8, NITRO sound 7/8
  08h      DSP sound 0/8, NITRO sound 8/8 (=NITRO sound only)
  09h..0Fh Reserved
</TD></TR></TABLE>
Uh, what is that? Hopefully, a volume-ratio? Preferably, no time-ratio!<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsiadvancedencryptionstandardaes"></A>&nbsp;
  DSi Advanced Encryption Standard (AES)
</FONT></TD></TR></TABLE><BR>
<B>AES I/O Ports</B><BR>
<A HREF="#dsiaesioports">DSi AES I/O Ports</A><BR>
<BR>
<B>AES Pseudo Code</B><BR>
Little Endian Code (as used in DSi hardware):<BR>
<A HREF="#dsiaeslittleendianhighlevelfunctions">DSi AES Little-Endian High Level Functions</A><BR>
<A HREF="#dsiaeslittleendiancorefunctionandkeyschedule">DSi AES Little-Endian Core Function and Key Schedule</A><BR>
<A HREF="#dsiaeslittleendiantablesandtestvalues">DSi AES Little-Endian Tables and Test Values</A><BR>
Big Endian Code (as used more commonly, in non-DSi implementations):<BR>
<A HREF="#dsiaesbigendianhighlevelfunctions">DSi AES Big-Endian High Level Functions</A><BR>
<A HREF="#dsiaesbigendiancorefunctionandkeyschedule">DSi AES Big-Endian Core Function and Key Schedule</A><BR>
<A HREF="#dsiaesbigendiantablesandtestvalues">DSi AES Big-Endian Tables and Test Values</A><BR>
Most AES values are endian-free byte-strings, so different "endianness" does
just mean to reverse the byte order of the 16/24/32-byte KEYs, the 16-byte data
chunks, and the 16-byte CTR/CFB/CBC/MAC registers (in some of the latter cases
it's also referring to actual endiannes, eg. for CTR increments).<BR>
<BR>
<B>AES Usage in DSi</B><BR>
AES-CCM is used for several SD/MMC files (using a custom Nintendo-specific CCM
variant; consisting of 128K-byte data blocks with 32-byte footers):<BR>
<A HREF="#dsiesblockencryption">DSi ES Block Encryption</A><BR>
AES-CTR is used for the Modcrypt areas defined in Cartridge Header, and for
eMMC Boot Sectors and for eMMC MBR/Partitions.<BR>
<BR>
<B>AES Usage in DSi-Wifi</B><BR>
DSi Wifi is also supporting AES (and TKIP and WEP) encryption, the Wifi AES
part is probably implemented via additional AES hardware in the Wifi unit?<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsiaesioports"></A>&nbsp;
  DSi AES I/O Ports
</FONT></TD></TR></TABLE><BR>
<B>4004400h - DSi7 - AES_CNT (parts R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-4   Write FIFO Count    (00h..10h words) (00h=Empty, 10h=Full)          (R)
  5-9   Read FIFO Count     (00h..10h words) (00h=Empty, 10h=Full)          (R)
  10    Write FIFO Flush    (0=No change, 1=Flush)                   (N/A or W)
  11    Read FIFO Flush     (0=No change, 1=Flush)                   (N/A or W)
  12-13 Write FIFO DMA Size (0..3 = 16,12,8,4 words) (2=Normal=8)    (R or R/W)
  14-15 Read FIFO DMA Size  (0..3 = 4,8,12,16 words) (1=Normal=8)    (R or R/W)
  16-18 CCM MAC Size, max(4,(N*2+2)) bytes, (usually 7=16 bytes)     (R or R/W)
  19    CCM Pass Associated Data to RDFIFO (0=No/Normal, 1=Yes)      (R or R/W)
          Bit19=1 is a bit glitchy: The data should theoretically arrive in
          RDFIFO immediately after writing 4 words to WRFIFO, but actually,
          Bit19=1 seems to cause 4 words held hidden in neither FIFO, until
          the first Payload block is written (at that point, the hidden
          associated words are suddenly appearing into RDFIFO)
  20    CCM MAC Verify Source (0=From AES_WRFIFO, 1=From AES_MAC)    (R or R/W)
  21    CCM MAC Verify Result (0=Invalid/Busy, 1=Verified/Okay)             (R)
  22-23 Unknown/Unused (0)                                                  (0)
  24    Key Select        (0=No change, 1=Apply key selected in Bit26-27)   (W)
  25    Key Schedule Busy (uh, always 0=ready?) (rather sth else busy?)     (R)
  26-27 Key Slot          (0..3=KEY0..KEY3, applied via Bit24)       (R or R/W)
  28-29 Mode (0=CCM/decrypt, 1=CCM/encrypt, 2=CTR, 3=Same as 2)      (R or R/W)
  30    Interrupt Enable  (0=Disable, 1=Enable IRQ on Transfer End)  (R or R/W)
  31    Start/Enable      (0=Disable/Ready, 1=Enable/Busy)                (R/W)
</TD></TR></TABLE>
Bit31 gets cleared automatically shortly after all data (as indicated in
AES_BLKCNT) is written to WRFIFO, and the IRQ is generated alongsides; the
transfer isn't fully completed at that point since there may be still data (and
CCM/encrypt MAC result) in RDFIFO.<BR>
<BR>
<B>4004404h - DSi7 - AES_BLKCNT (W)</B><BR>
Specifies the transfer length, counted in 16-byte blocks.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15  Number of Extra associated data blocks for AES-CCM (unused for AES-CTR)
  16-31 Number of Payload data blocks (0..FFFFh = 0..FFFF0h bytes)
</TD></TR></TABLE>
The length values are copied to internal counter registers on transfer start
(the value in AES_BLKCNT is left unchanged during/after transfer).<BR>
<BR>
<B>4004408h - DSi7 - AES_WRFIFO (W)</B><BR>
<B>400440Ch - DSi7 - AES_RDFIFO (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-31  Data
</TD></TR></TABLE>
Writing to WRFIFO works even when AES_CNT.bit31=0 (the data does then stay in
WRFIFO though, and doesn't arrive in RDFIFO).<BR>
<BR>
<B>4004420h - DSi7 - AES_IV (16 bytes) (W)</B><BR>
This contains the Initialization Vector (aka IV aka Nonce). The hardware does
use that value to automatically initialize the internal CTR/CBC registers when
starting encryption/decryption:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  For AES-CTR mode:  CTR[00h..0Fh] = AES_IV[00h..0Fh]
                     CBC[00h..0Fh] = not used by AES-CTR mode
  For AES-CCM mode:  CTR[00h..0Fh] = 00h,00h,00h,AES_IV[00h..0Bh],02h
                     CBC[00h..0Fh] = x0h,xxh,0xh,AES_IV[00h..0Bh],flg
</TD></TR></TABLE>
The initial CTR/CBC values for AES-CCM mode are following the CCM
specifications, but WITHOUT encoding the "extra associated data size" in upper
bytes of first block (see CCM pseudo code chapter for details).<BR>
The CTR/CBC registers are manipulated during transfer, however, the AES_IV
content is kept unchanged during/after transfer.<BR>
<BR>
<B>4004430h - DSi7 - AES_MAC (16 bytes) (W)</B><BR>
The MAC (Message Authentication Code) is an encrypted checksum, computed
alongsides with the actual data encryption/decryption, and used only in AES-CCM
mode. There are three ways how the DSi deals with MAC values:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  AES-CCM Encryption: MAC is returned in AES_RDFIFO after transfer
  AES-CCM Decryption, AES_CNT.20=0: MAC written to AES_WRFIFO after transfer
  AES-CCM Decryption, AES_CNT.20=1: MAC written to AES_MAC before transfer
</TD></TR></TABLE>
The AES_MAC register and the RDFIFO/WRFIFO blocks are always 16-byte wide; when
selecting a smaller MAC size in AES_CNT, then the lower bytes of that 16-byte
value are 00h-padded (eg. a 6-byte MAC would appear as 00000000h, 00000000h,
xxxx0000h, xxxxxxxxh), for ENCRYPT those 00h-bytes are returned in RDFIFO, for
DECRYPT those padding bytes MUST be 00h (else the verification will fail).<BR>
The minimum MAC size is 4 bytes (trying to use 2 byte by setting AES_CNT.16-18
to 00h is producing the exact same result as when setting it to 01h, ie.
4-bytes)<BR>
<BR>
<B>4004440h - DSi7 - AES_KEY0 (48 bytes) (W)</B><BR>
<B>4004470h - DSi7 - AES_KEY1 (48 bytes) (W)</B><BR>
<B>40044A0h - DSi7 - AES_KEY2 (48 bytes) (W)</B><BR>
<B>40044D0h - DSi7 - AES_KEY3 (48 bytes) (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Byte 00h-0Fh  Normal 128bit Key      ;\use either normal key,
  Byte 10h-1Fh  Special 128bit Key_X   ; or special key_x/y
  Byte 20h-2Fh  Special 128bit Key_Y   ;/
</TD></TR></TABLE>
Writing the last word of "Key_Y" (or any of its last four bytes, ie. byte(s)
2Ch..2Fh) causes the Normal Key to be overwritten by following values:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Key = ((Key_X XOR Key_Y) + FFFEFB4E295902582A680F5F1A4F3E79h) ROL 42
</TD></TR></TABLE>
After changing a key, one must (re-)apply it via AES_CNT.Bits 24,26-27.<BR>
<BR>
<B>DMA</B><BR>
The AES data would be usually transferred via two NDMA channels, one for
WRFIFO, one for RDFIFO. The NDMAs should be started BEFORE setting AES_CNT.31
(else the DMA will miss the first WRFIFO data request; and DMA won't start).
The DMAs 'Logical Block' sizes should match up with the block sizes selected in
AES_CNT (a bigger logical block size would cause FIFO overruns/underruns, a
smaller logical block size could work theoretically, but it practice it causes
the DMA to hang after the first data request; apparently data requests are
somewhat generated upon "empty-not-empty" transitions, rather than upon "enough
data/space" status).<BR>
<BR>
<B>Reading Write-Only Values</B><BR>
The AES_IV register and the AES_KEY registers are fully write-able, including
with 8bit STRB support; this allows to 'read' the write-only values via
brute-force without any noticeable delay (ie. encrypt 16 bytes with original
values, then change one byte to values 00h..FFh, and check which of those
values gives same encryption result). AES_BLKCNT can be also dumped by simple
counting.<BR>
<BR>
<B>Cartheader Key Request Byte</B><BR>
The firmware is usually destroying the AES_KEY registers before starting DSi
programs. However, bits in CartHeader[1B4h] allow to "request" certain keys to
be left intact.<BR>
<BR>
<B>DSi BIOS &amp; Firmware Keys</B><BR>
The DSi BIOS contains several AES keys in the non-dumpable upper 32K halves;
most of that keys are relocated to RAM/TCM, so they can be dumped via main
memory hacks (there might be some further keys that cannot be dumped, in case
they are exist only in early boot stages).<BR>
The purpose for most of the dump-able keys is still unknown. Aside from the
plain keys, it would be also important to know their corresponding IV values.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsiaeslittleendianhighlevelfunctions"></A>&nbsp;
  DSi AES Little-Endian High Level Functions
</FONT></TD></TR></TABLE><BR>
<B>AES-CTR (Counter)</B><BR>
aes_crypt_ctr(src,dst,len,nc_off,iv)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  aes_setkey(ENCRYPT,key,key_size]                                 ;-init key
  [ctr+0..15] = [iv+0..15]                                         ;-init ctr
  n=[nc_off]
  while len&gt;0   ;code is 100% same for ENCRYPT and DECRYPT         ;\
    if n=0                                                         ; encrypt
      aes_crypt_block(ENCRYPT,ctr,tmp)                             ; or decrypt
      littleendian(ctr)=littleendian(ctr)+1   ;increment counter   ; message
    [dst] = [src] xor [tmp+n]                                      ;
    src=src+1, dst=dst+1, len=len-1, n=(n+1) and 0Fh               ;/
  [nc_off]=n
</TD></TR></TABLE>
<BR>
<B>AES-CCM (Counter with CBC-MAC)</B><BR>
aes_ccm_crypt(mode,src,dst,msg_len,iv,iv_len,xtra,xtra_len,mac,mac_len)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  if mac_len&lt;4 or mac_len&gt;16 or (mac_len and 1)=1 then error       ;\limits
  if iv_len&lt;7 or iv_len&gt;13 then error                              ;/
  aes_setkey(ENCRYPT,key,key_size]                                 ;-init key
  ctr_len = 15-iv_len                                              ;\
  [ctr+15]=ctr_len-1          ;bit3..7=zero   ;1 byte (ctr_len)    ; init ctr
  [ctr+(15-iv_len)..14] = [iv+0..(iv_len-1)]  ;7..13 bytes (iv)    ;
  [ctr+0..(14-iv_len)]=littleendian(0)  ;8..2 bytes (counter=0)    ;/
  [cbc+0..15]=littleendian(msg_len)  ;-[(iv_len+1)..15]=msg_len    ;\
  if [cbc+15..15-iv_len]&lt;&gt;0 then error  ;msg_len overlaps iv/flags ;
  [cbc+(15-iv_len)..14]=[iv+0..iv_len-1] ;-[1..iv_len]=iv/nonce    ;
  [cbc+15].bit7=0  ;reserved/zero   ;\                             ; init cbc
  [cbc+15].bit6=(xtra_len&gt;0)        ; [15]=flags                   ;
  [cbc+15].bit5..3=(mac_len/2-1)    ;                              ;
  [cbc+15].bit2..0=(ctr_len-1)      ;/                             ;
  aes_crypt_block(ENCRYPT,cbc,cbc)      ;UPDATE_CBC_MAC            ;/
  if NintendoDSi then                                              ;\
    a=0 ;the DSi hardware doesn't support xtra_len encoding at all ;
  elseif xtra_len&lt;0FF00h then                                      ;
    [cbc+14..15]=[cbc+14..15] xor littleendian(xtra_len), a=2      ; weird
  elseif xtra_len&lt;100000000h then                                  ; encoding
    [cbc+14..15]=[cbc+14..15] xor littleendian(FFFEh)              ; for
    [cbc+10..13]=[cbc+10..13] xor littleendian(xtra_len), a=6      ; xtra_len
  else                                                             ;
    [cbc+14..15]=[cbc+14..15] xor littleendian(FFFFh)              ;
    [cbc+6..13] =[cbc+6..13]  xor littleendian(xtra_len), a=10     ;/
  while xtra_len&gt;0                                                 ;\scatter
    z=min(xtra_len,16-a)                                           ; cbc by
    [cbc+16-a-z..(15-a)]=[cbc+16-a-z..(15-a)] xor [xtra+0..(z-1)]  ; xtra
    aes_crypt_block(ENCRYPT,cbc,cbc)    ;UPDATE_CBC_MAC            ; (if any)
    xtra=xtra+z, xtra_len=xtra_len-z, a=0                          ;/
  while msg_len&gt;0                                                  ;\
    littleendian(ctr)=littleendian(ctr)+1   ;increment counter     ;
    aes_crypt_block(ENCRYPT,ctr,tmp)    ;CTR_CRYPT                 ;
    z=min(msg_len,16)                                              ; encrypt
    if mode=ENCRYPT                                                ; or decrypt
      [cbc+(16-z)..15] = [cbc+(16-z)..15] xor [src+0..(z-1)]       ; message
    [dst+0..(z-1)] = [src+0..(z-1)] xor [tmp+(16-z)..15]           ; body
    if mode=DECRYPT                                                ;
      [cbc+(16-z)..15] = [cbc+(16-z)..15] xor [dst+0..(z-1)]       ;
    aes_crypt_block(ENCRYPT,cbc,cbc)    ;UPDATE_CBC_MAC            ;
    src=src+z, dst=dst+z, msg_len=msg_len-z                        ;/
  [ctr+0..(14-iv_len)]=littleendian(0)  ;reset counter=0           ;\
  aes_crypt_block(ENCRYPT,ctr,tmp)      ;CTR_CRYPT                 ; message
  [cbc+0..15] = [cbc+0..15] xor [tmp+0..15]                        ; auth code
  z=mac_len                                                        ; (mac)
  IF mode=ENCRYPT then [mac+0..(z-1)] = [cbc+(16-z)..15]           ;
  IF mode=DECRYPT and [mac+0..(z-1)] &lt;&gt; [cbc+(16-z)..15] then error;/
</TD></TR></TABLE>
<BR>
Below are some other AES variants (just for curiosity - those variants aren't
used in DSi):<BR>
<BR>
<B>AES-CBC (Cipher-block chaining)</B><BR>
aes_crypt_cbc(mode,src,dst,len,iv)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  aes_setkey(mode,key,key_size]                                    ;-init key
  [cbc+0..15] = [iv+0..15]                                         ;-init cbc
  if (len AND 0Fh)&gt;0 then error
  while len&gt;0                                                      ;\
    if mode=ENCRYPT                                                ;
      [dst+0..15] = [src+0..15] xor [cbc+0..15]                    ;
      aes_crypt_block(mode,dst,dst)                                ; encrypt
      [cbc+0..15] = [dst+0..15]                                    ; or decrypt
    if mode=DECRYPT                                                ; message
      [tmp+0..15] = [src+0..15]                                    ;
      aes_crypt_block(mode,src,dst)                                ;
      [dst+0..15] = [dst+0..15] xor [cbc+0..15]                    ;
      [cbc+0..15] = [tmp+0..15]                                    ;
    src=src+16, dst=dst+16, len=len-16                             ;/
</TD></TR></TABLE>
<BR>
<B>AES-CFB128 (Cipher feedback on 128bits, aka 16 bytes)</B><BR>
aes_crypt_cfb128(mode,src,dst,len,iv_off,iv)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  aes_setkey(ENCRYPT,key,key_size]                                 ;-init key
  [cfb+0..15] = [iv+0..15]                                         ;-init cfb
  n=[iv_off]
  while len&gt;0                                                      ;\
    if n=0 then aes_crypt_block(ENCRYPT,cfb,cfb)                   ; encrypt
    if mode=DECRYPT then c=[src], [dst]=c xor [cfb+n], [cfb+n]=c   ; or decrypt
    if mode=ENCRYPT then c=[cfb+n] xor [src], [cfb+n]=c, [dst]=c   ; message
    src=src+1, dst=dst+1, len=len-1, n=(n+1) and 0Fh               ;/
  [iv_off]=n
</TD></TR></TABLE>
<BR>
<B>AES-CFB8 (Cipher feedback on 8bits, aka 1 byte, very inefficient)</B><BR>
aes_crypt_cfb8(mode,src,dst,len,iv)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  aes_setkey(ENCRYPT,key,key_size]                                 ;-init key
  [cfb+0..15] = [iv+0..15]                                         ;-init cfb
  n=[iv_off]
  while len&gt;0                                                      ;\
    aes_crypt_block(ENCRYPT,cfb,tmp)                               ;
    [cfb+1..15] = [cfb+0..14]   ;shift with 8-bit step             ; encrypt
    if mode=DECRYPT then [cfb+0] = [src+(n xor 0Fh)]               ; or decrypt
    [dst+(n xor 0Fh)] = [src+(n xor 0Fh)] xor [tmp+15]  ;shift-in  ; message
    if mode=ENCRYPT then [cfb+0] = [dst+(n xor 0Fh)]               ;
    len=len-1, n=n+1                                               ;/
  [iv_off]=n
</TD></TR></TABLE>
<BR>
<B>AES-ECB (Electronic codebook, very basic, very insecure)</B><BR>
aes_crypt_ecb(mode,src,dst,len)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  aes_setkey(mode,key,key_size]                                    ;-init key
  if (len AND 0Fh)&gt;0 then error
  while len&gt;0                                                      ;\encrypt
    aes_crypt_block(mode,src,dst)                                  ; or decrypt
    src=src+16, dst=dst+16, len=len-16                             ;/message
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsiaeslittleendiancorefunctionandkeyschedule"></A>&nbsp;
  DSi AES Little-Endian Core Function and Key Schedule
</FONT></TD></TR></TABLE><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
<B> aes_crypt_block(mode,src,dst):</B>
  Y0 = RK[0] xor [src+00h]
  Y1 = RK[1] xor [src+04h]
  Y2 = RK[2] xor [src+08h]
  Y3 = RK[3] xor [src+0Ch]
  ;below code depending on mode:      &lt;---ENCRYPT---&gt;  -or-  &lt;---DECRYPT---&gt;
  for i=1 to nr-1
    X0      = RK[i*4+0] xor scatter32(FT,Y1,Y2,Y3,Y0)  -or-  (RT,Y3,Y2,Y1,Y0)
    X1      = RK[i*4+1] xor scatter32(FT,Y2,Y3,Y0,Y1)  -or-  (RT,Y0,Y3,Y2,Y1)
    X2      = RK[i*4+2] xor scatter32(FT,Y3,Y0,Y1,Y2)  -or-  (RT,Y1,Y0,Y3,Y2)
    X3      = RK[i*4+3] xor scatter32(FT,Y0,Y1,Y2,Y3)  -or-  (RT,Y2,Y1,Y0,Y3)
    Y0=X0, Y1=X1, Y2=X2, Y3=X3
  [dst+00h] = RK[nr*4+0] xor scatter8(FSb,Y1,Y2,Y3,Y0) -or-  (RSb,Y3,Y2,Y1,Y0)
  [dst+04h] = RK[nr*4+1] xor scatter8(FSb,Y2,Y3,Y0,Y1) -or-  (RSb,Y0,Y3,Y2,Y1)
  [dst+08h] = RK[nr*4+2] xor scatter8(FSb,Y3,Y0,Y1,Y2) -or-  (RSb,Y1,Y0,Y3,Y2)
  [dst+0Ch] = RK[nr*4+3] xor scatter8(FSb,Y0,Y1,Y2,Y3) -or-  (RSb,Y2,Y1,Y0,Y3)
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
<B> scatter32(TAB,a,b,c,d):              scatter8(TAB,a,b,c,d):</B>
  w=      (TAB[a.bit0..7] ror 24)      w.bit0..7   = TAB[a.bit0..7]
  w=w xor (TAB[b.bit8..15] ror 16)     w.bit8..15  = TAB[b.bit8..15]
  w=w xor (TAB[c.bit16..23] ror 8)     w.bit16..23 = TAB[c.bit16..23]
  w=w xor (TAB[d.bit24..31])           w.bit24..31 = TAB[d.bit24..31]
  return w                             return w
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
<B> aes_setkey(mode,key,keysize):  ;out: RK[0..43/51/59], nr=10/12/14</B>
  aes_generate_tables   ;&lt;-- unless tables are already initialized
  if keysize&lt;&gt;128 and keysize&lt;&gt;192 and keysize&lt;&gt;256 then error  ;size in bits
  rc=01h, j=0, jj=keysize/32, nr=jj+6   ;jj=4,6,8      ;\
  for i=0 to (nr+1)*4-1                 ;nr=10,12,14   ; copy 16/24/32-byte key
    if i&lt;jj then w=[key+(jj-1-i)*4+0..3]               ; to RK[0..3/5/7]
    else w=w xor RK[(i-jj) xor 3]                      ; and, make
    RK[i xor 3]=w, j=j+1                               ; RK[4/6/8..43/51/59]
    if j=jj then                                       ;
      w=w ror 8, w=scatter8(FSb,w,w,w,w) xor (rc shl 24)
      j=0, rc=rc*2, if rc&gt;0FFh then rc=rc xor 11Bh     ;
    if j=4 and jj=8 then w=scatter8(FSb,w,w,w,w)       ;/
  if mode=DECRYPT then
    for i=0 to nr/2-1     ;swap entries (except middle one)
      for j=0 to 3
        w=RK[i*4+j], v=RK[nr*4-i*4+j]
        RK[i*4+j]=v, RK[nr*4-i*4+j]=w
    for i=4 to nr*4-1     ;modify entries (except RK[0..3] and RK[nr*4+0..3])
      w=RK[i], w=scatter8(FSb,w,w,w,w), RK[i]=scatter32(RT,w,w,w,w)
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsiaeslittleendiantablesandtestvalues"></A>&nbsp;
  DSi AES Little-Endian Tables and Test Values
</FONT></TD></TR></TABLE><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
<B> aes_generate_tables:</B>
  for i=0 to 0FFh               ;compute pow and log tables...
    if i=0 then x=01h, else x=x xor x*2, if x&gt;0FFh then x=x xor 11Bh
    pow[i]=x, log[x]=i
  for i=0 to 0FFh               ;generate the forward and reverse S-boxes...
    x=pow[0FFh-log[i]]
    x=x xor (x rol 1) xor (x rol 2) xor (x rol 3) xor (x rol 4) xor 63h
    if i=0 then x=63h
    FSb[i]=x, RSb[x]=i
  for i=0 to 0FFh               ;generate the forward and reverse tables...
    x=FSb[i]*2, if x&gt;0FFh then x=x xor 11Bh
    FT[i]=(FSb[i]*00010101h) xor (x*01000001h)
    w=00000000h, x=RSb[i]
    if x&lt;&gt;00h then   ;ie. not at i=63h
      w=w+pow[(log[x]+log[0Eh]) mod 00FFh]*1000000h
      w=w+pow[(log[x]+log[09h]) mod 00FFh]*10000h
      w=w+pow[(log[x]+log[0Dh]) mod 00FFh]*100h
      w=w+pow[(log[x]+log[0Bh]) mod 00FFh]*1h
    RT[i]=w
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
<B> aes_generate_tables_results:</B>
  pow[00h..FFh] = 01,03,05,0F,11,..,C7,52,F6,01   ;pow  ;\needed temporarily
  log[00h..FFh] = 00,FF,19,01,32,..,C0,F7,70,07   ;log  ;/for table creation
  FSb[00h..FFh] = 63,7C,77,7B,F2,..,B0,54,BB,16   ;Forward S-box
  RSb[00h..FFh] = 52,09,6A,D5,30,..,55,21,0C,7D   ;Reverse S-box
  FT[00h..FFh] = C66363A5,F87C7C84,..,2C16163A    ;Forward Table
  RT[00h..FFh] = 51F4A750,7E416553,..,D0B85742    ;Reverse Table
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
<B> aes_setkey_results:</B>
  key = "AES-Test-Key-Str-1234567-Abcdefg"  ;use only 1st bytes for 128/192bit
  128bit ENCRYPT --&gt; RK[0..9..30..43] = 2D534541..2783080F..93AF7DF0..827EE10D
  192bit ENCRYPT --&gt; RK[0..9..30..51] = 79654B2D..9708FA95..2529372B..C66C19FA
  256bit ENCRYPT --&gt; RK[0..9..30..59] = 3332312D..DF5C92A5..74174E2E..3C8ADAE6
  128bit DECRYPT --&gt; RK[0..9..30..43] = AEABCD4D..ECD33F19..8C87B246..7274532D
  192bit DECRYPT --&gt; RK[0..9..30..51] = AFA9796F..72A3EFE5..455646C7..37363534
  256bit DECRYPT --&gt; RK[0..9..30..59] = 0ED52830..4601F929..415A7D65..67666564
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
<B> aes_crypt_results:</B>
  [key+0..15]    = "AES-Test-Key-Str-1234567-Abcdefg"
  [iv+0..15]     = "Nonce/InitVector"
  [xtra+0..20]   = "Extra-Associated-Data"  ;\for CCM
  iv_len=12, mac_len=16, xtra_len=xx        ;/
  Unencrypted:   [dta+0..113Fh] = "Unencrypted-Data", 190h x "TestPadding"
  AES-ECB:       [dta+0..113Fh] = 20,24,73,88,..,44,A8,D6,A8  ;\
  AES-CBC:       [dta+0..113Fh] = A4,6F,7A,F2,..,58,C9,02,B4  ;
  AES-CFB128:    [dta+0..113Fh] = 20,C6,DB,35,..,9A,83,7F,DB  ; keysize=128
  AES-CFB8:      [dta+0..113Fh] = 55,C7,75,1C,..,24,6E,A6,D1  ;
  AES-CTR:       [dta+0..113Fh] = 20,C6,DB,35,..,AB,09,0C,75  ;
  AES-CCM:       [dta+0..113Fh] = C8,37,D7,F1,..,7B,EF,FC,12  ;
  AES-CCM (ori): [mac+0..0Fh]   = xx,xx,xx,xx,..,xx,xx,xx,xx  ;
  AES-CCM (DSi): [mac+0..0Fh]   = xx,xx,xx,xx,..,xx,xx,xx,xx  ;/
  AES-ECB:       [dta+0..113Fh] = CC,B6,4D,17,..,D3,56,3E,64  ;-keysize=192
  AES-ECB:       [dta+0..113Fh] = A9,A9,9B,3E,..,8A,C6,13,A1  ;-keysize=256
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsiaesbigendianhighlevelfunctions"></A>&nbsp;
  DSi AES Big-Endian High Level Functions
</FONT></TD></TR></TABLE><BR>
<B>AES-CTR (Counter)</B><BR>
aes_crypt_ctr(src,dst,len,nc_off,iv)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  aes_setkey(ENCRYPT,key,key_size]                                 ;-init key
  [ctr+0..15] = [iv+0..15]                                         ;-init ctr
  n=[nc_off]
  while len&gt;0   ;code is 100% same for ENCRYPT and DECRYPT         ;\
    if n=0                                                         ; encrypt
      aes_crypt_block(ENCRYPT,ctr,tmp)                             ; or decrypt
      bigendian(ctr)=bigendian(ctr)+1     ;increment counter       ; message
    [dst] = [src] xor [tmp+n]                                      ;
    src=src+1, dst=dst+1, len=len-1, n=(n+1) and 0Fh               ;/
  [nc_off]=n
</TD></TR></TABLE>
<BR>
<B>AES-CCM (Counter with CBC-MAC)</B><BR>
aes_ccm_crypt(mode,src,dst,msg_len,iv,iv_len,xtra,xtra_len,mac,mac_len)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  if mac_len&lt;4 or mac_len&gt;16 or (mac_len and 1)=1 then error       ;\limits
  if iv_len&lt;7 or iv_len&gt;13 then error                              ;/
  aes_setkey(ENCRYPT,key,key_size]                                 ;-init key
  ctr_len = 15-iv_len                                              ;\
  [ctr+0]=ctr_len-1     ;bit3..7=zero   ;1 byte (ctr_len)          ; init ctr
  [ctr+1..iv_len] = [iv+0..(iv_len-1)]  ;7..13 bytes (iv)          ;
  [ctr+(iv_len+1)..15]=bigendian(0)     ;8..2 bytes (counter=0)    ;/
  [cbc+0..15]=bigendian(msg_len)   ;-[(iv_len+1)..15]=msg_len      ;\
  if [cbc+0..iv_len]&lt;&gt;0 then error ;errif msg_len overlaps iv/flags;
  [cbc+1..iv_len]=[iv+0..iv_len-1] ;-[1..iv_len]=iv (aka nonce)    ;
  [cbc+0].bit7=0  ;reserved/zero   ;\                              ; init cbc
  [cbc+0].bit6=(xtra_len&gt;0)        ; [0]=flags                     ;
  [cbc+0].bit5..3=(mac_len/2-1)    ;                               ;
  [cbc+0].bit2..0=(ctr_len-1)      ;/                              ;
  aes_crypt_block(ENCRYPT,cbc,cbc)      ;UPDATE_CBC_MAC            ;/
  if NintendoDSi then                                              ;\
    a=0 ;the DSi hardware doesn't support xtra_len encoding at all ;
  elseif xtra_len&lt;0FF00h then                                      ;
    [cbc+0..1]=[cbc+0..1] xor bigendian(xtra_len), a=2             ; weird
  elseif xtra_len&lt;100000000h then                                  ; encoding
    [cbc+0..1]=[cbc+0..1] xor bigendian(FFFEh)                     ; for
    [cbc+2..5]=[cbc+2..5] xor bigendian(xtra_len), a=6             ; xtra_len
  else                                                             ;
    [cbc+0..1]=[cbc+0..1] xor bigendian(FFFFh)                     ;
    [cbc+2..9]=[cbc+2..9] xor bigendian(xtra_len), a=10            ;/
  while xtra_len&gt;0                                                 ;\scatter
    z=min(xtra_len,16-a)                                           ; cbc by
    [cbc+a..(a+z-1)]=[cbc+a..(a+z-1)] xor [xtra+0..(z-1)]          ; xtra
    aes_crypt_block(ENCRYPT,cbc,cbc)    ;UPDATE_CBC_MAC            ; (if any)
    xtra=xtra+z, xtra_len=xtra_len-z, a=0                          ;/
  while msg_len&gt;0                                                  ;\
    bigendian(ctr)=bigendian(ctr)+1     ;increment counter         ;
    aes_crypt_block(ENCRYPT,ctr,tmp)    ;CTR_CRYPT                 ;
    z=min(msg_len,16)                                              ; encrypt
    if mode=ENCRYPT                                                ; or decrypt
      [cbc+0..(z-1)] = [cbc+0..(z-1)] xor [src+0..(z-1)]           ; message
    [dst+0..(z-1)] = [src+0..(z-1)] xor [tmp+0..(z-1)]             ; body
    if mode=DECRYPT                                                ;
      [cbc+0..(z-1)] = [cbc+0..(z-1)] xor [dst+0..(z-1)]           ;
    aes_crypt_block(ENCRYPT,cbc,cbc)    ;UPDATE_CBC_MAC            ;
    src=src+z, dst=dst+z, msg_len=msg_len-z                        ;/
  [ctr+(iv_len+1)..15]=bigendian(0)     ;reset counter=0           ;\
  aes_crypt_block(ENCRYPT,ctr,tmp)      ;CTR_CRYPT                 ; message
  [cbc+0..15] = [cbc+0..15] xor [tmp+0..15]                        ; auth code
  z=mac_len                                                        ; (mac)
  IF mode=ENCRYPT then [mac+0..(z-1)] = [cbc+0..(z-1)]             ;
  IF mode=DECRYPT and [mac+0..(z-1)] &lt;&gt; [cbc+0..(z-1)] then error  ;/
</TD></TR></TABLE>
<BR>
Below are some other AES variants (just for curiosity - those variants aren't
used in DSi):<BR>
<BR>
<B>AES-CBC (Cipher-block chaining)</B><BR>
aes_crypt_cbc(mode,src,dst,len,iv)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  aes_setkey(mode,key,key_size]                                    ;-init key
  [cbc+0..15] = [iv+0..15]                                         ;-init cbc
  if (len AND 0Fh)&gt;0 then error
  while len&gt;0                                                      ;\
    if mode=ENCRYPT                                                ;
      [dst+0..15] = [src+0..15] xor [cbc+0..15]                    ;
      aes_crypt_block(mode,dst,dst)                                ; encrypt
      [cbc+0..15] = [dst+0..15]                                    ; or decrypt
    if mode=DECRYPT                                                ; message
      [tmp+0..15] = [src+0..15]                                    ;
      aes_crypt_block(mode,src,dst)                                ;
      [dst+0..15] = [dst+0..15] xor [cbc+0..15]                    ;
      [cbc+0..15] = [tmp+0..15]                                    ;
    src=src+16, dst=dst+16, len=len-16                             ;/
</TD></TR></TABLE>
<BR>
<B>AES-CFB128 (Cipher feedback on 128bits, aka 16 bytes)</B><BR>
aes_crypt_cfb128(mode,src,dst,len,iv_off,iv)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  aes_setkey(ENCRYPT,key,key_size]                                 ;-init key
  [cfb+0..15] = [iv+0..15]                                         ;-init cfb
  n=[iv_off]
  while len&gt;0                                                      ;\
    if n=0 then aes_crypt_block(ENCRYPT,cfb,cfb)                   ; encrypt
    if mode=DECRYPT then c=[src], [dst]=c xor [cfb+n], [cfb+n]=c   ; or decrypt
    if mode=ENCRYPT then c=[cfb+n] xor [src], [cfb+n]=c, [dst]=c   ; message
    src=src+1, dst=dst+1, len=len-1, n=(n+1) and 0Fh               ;/
  [iv_off]=n
</TD></TR></TABLE>
<BR>
<B>AES-CFB8 (Cipher feedback on 8bits, aka 1 byte, very inefficient)</B><BR>
aes_crypt_cfb8(mode,src,dst,len,iv)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  aes_setkey(ENCRYPT,key,key_size]                                 ;-init key
  [cfb+0..15] = [iv+0..15]                                         ;-init cfb
  while len&gt;0                                                      ;\
    aes_crypt_block(ENCRYPT,cfb,tmp)                               ;
    [cfb+0..14] = [cfb+1..15]   ;shift with 8-bit step             ; encrypt
    if mode=DECRYPT then [cfb+15] = [src]                          ; or decrypt
    [dst] = [src] xor [tmp+0]   ;shift-in new 8-bits               ; message
    if mode=ENCRYPT then [cfb+15] = [dst]                          ;
    src=src+1, dst=dst+1, len=len-1                                ;/
</TD></TR></TABLE>
<BR>
<B>AES-ECB (Electronic codebook, very basic, very insecure)</B><BR>
aes_crypt_ecb(mode,src,dst,len)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  aes_setkey(mode,key,key_size]                                    ;-init key
  if (len AND 0Fh)&gt;0 then error
  while len&gt;0                                                      ;\encrypt
    aes_crypt_block(mode,src,dst)                                  ; or decrypt
    src=src+16, dst=dst+16, len=len-16                             ;/message
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsiaesbigendiancorefunctionandkeyschedule"></A>&nbsp;
  DSi AES Big-Endian Core Function and Key Schedule
</FONT></TD></TR></TABLE><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
<B> aes_crypt_block(mode,src,dst):</B>
  Y0 = RK[0] xor [src+00h]
  Y1 = RK[1] xor [src+04h]
  Y2 = RK[2] xor [src+08h]
  Y3 = RK[3] xor [src+0Ch]
  ;below code depending on mode:      &lt;---ENCRYPT---&gt;  -or-  &lt;---DECRYPT---&gt;
  for i=1 to nr-1
    X0      = RK[i*4+0] xor scatter32(FT,Y0,Y1,Y2,Y3)  -or-  (RT,Y0,Y3,Y2,Y1)
    X1      = RK[i*4+1] xor scatter32(FT,Y1,Y2,Y3,Y0)  -or-  (RT,Y1,Y0,Y3,Y2)
    X2      = RK[i*4+2] xor scatter32(FT,Y2,Y3,Y0,Y1)  -or-  (RT,Y2,Y1,Y0,Y3)
    X3      = RK[i*4+3] xor scatter32(FT,Y3,Y0,Y1,Y2)  -or-  (RT,Y3,Y2,Y1,Y0)
    Y0=X0, Y1=X1, Y2=X2, Y3=X3
  [dst+00h] = RK[nr*4+0] xor scatter8(FSb,Y0,Y1,Y2,Y3) -or-  (RSb,Y0,Y3,Y2,Y1)
  [dst+04h] = RK[nr*4+1] xor scatter8(FSb,Y1,Y2,Y3,Y0) -or-  (RSb,Y1,Y0,Y3,Y2)
  [dst+08h] = RK[nr*4+2] xor scatter8(FSb,Y2,Y3,Y0,Y1) -or-  (RSb,Y2,Y1,Y0,Y3)
  [dst+0Ch] = RK[nr*4+3] xor scatter8(FSb,Y3,Y0,Y1,Y2) -or-  (RSb,Y3,Y2,Y1,Y0)
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
<B> scatter32(TAB,a,b,c,d):              scatter8(TAB,a,b,c,d):</B>
  w=      (TAB[a.bit0..7])             w.bit0..7   = TAB[a.bit0..7]
  w=w xor (TAB[b.bit8..15] rol 8)      w.bit8..15  = TAB[b.bit8..15]
  w=w xor (TAB[c.bit16..23] rol 16)    w.bit16..23 = TAB[c.bit16..23]
  w=w xor (TAB[d.bit24..31] rol 24)    w.bit24..31 = TAB[d.bit24..31]
  return w                             return w
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
<B> aes_setkey(mode,key,keysize):  ;out: RK[0..43/51/59], nr=10/12/14</B>
  aes_generate_tables   ;&lt;-- unless tables are already initialized
  if keysize&lt;&gt;128 and keysize&lt;&gt;192 and keysize&lt;&gt;256 then error  ;size in bits
  rc=01h, j=0, jj=keysize/32, nr=jj+6   ;jj=4,6,8      ;\
  for i=0 to (nr+1)*4-1                 ;nr=10,12,14   ; copy 16/24/32-byte key
    if i&lt;jj then w=[key+i*4+0..3]                      ; to RK[0..3/5/7]
    else w=w xor RK[i-jj]                              ; and, make
    RK[i]=w, j=j+1                                     ; RK[4/6/8..43/51/59]
    if j=jj then                                       ;
      w=w ror 8, w=scatter8(FSb,w,w,w,w) xor rc        ;
      j=0, rc=rc*2, if rc&gt;0FFh then rc=rc xor 11Bh     ;
    if j=4 and jj=8 then w=scatter8(FSb,w,w,w,w)       ;/
  if mode=DECRYPT then
    for i=0 to nr/2-1     ;swap entries (except middle one)
      for j=0 to 3
        w=RK[i*4+j], v=RK[nr*4-i*4+j]
        RK[i*4+j]=v, RK[nr*4-i*4+j]=w
    for i=4 to nr*4-1     ;modify entries (except RK[0..3] and RK[nr*4+0..3])
      w=RK[i], w=scatter8(FSb,w,w,w,w), RK[i]=scatter32(RT,w,w,w,w)
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsiaesbigendiantablesandtestvalues"></A>&nbsp;
  DSi AES Big-Endian Tables and Test Values
</FONT></TD></TR></TABLE><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
<B> aes_generate_tables:</B>
  for i=0 to 0FFh               ;compute pow and log tables...
    if i=0 then x=01h, else x=x xor x*2, if x&gt;0FFh then x=x xor 11Bh
    pow[i]=x, log[x]=i
  for i=0 to 0FFh               ;generate the forward and reverse S-boxes...
    x=pow[0FFh-log[i]]
    x=x xor (x rol 1) xor (x rol 2) xor (x rol 3) xor (x rol 4) xor 63h
    if i=0 then x=63h
    FSb[i]=x, RSb[x]=i
  for i=0 to 0FFh               ;generate the forward and reverse tables...
    x=FSb[i]*2, if x&gt;0FFh then x=x xor 11Bh
    FT[i]=(FSb[i]*01010100h) xor (x*01000001h)
    w=00000000h, x=RSb[i]
    if x&lt;&gt;00h then   ;ie. not at i=63h
      w=w+pow[(log[x]+log[0Eh]) mod 00FFh]*1h
      w=w+pow[(log[x]+log[09h]) mod 00FFh]*100h
      w=w+pow[(log[x]+log[0Dh]) mod 00FFh]*10000h
      w=w+pow[(log[x]+log[0Bh]) mod 00FFh]*1000000h
    RT[i]=w
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
<B> aes_generate_tables_results:</B>
  pow[00h..FFh] = 01,03,05,0F,11,..,C7,52,F6,01   ;pow  ;\needed temporarily
  log[00h..FFh] = 00,FF,19,01,32,..,C0,F7,70,07   ;log  ;/for table creation
  FSb[00h..FFh] = 63,7C,77,7B,F2,..,B0,54,BB,16   ;Forward S-box
  RSb[00h..FFh] = 52,09,6A,D5,30,..,55,21,0C,7D   ;Reverse S-box
  FT[00h..FFh] = A56363C6,847C7CF8,..,3A16162C    ;Forward Table
  RT[00h..FFh] = 50A7F451,5365417E,..,4257B8D0    ;Reverse Table
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
<B> aes_setkey_results:</B>
  key = "AES-Test-Key-Str-1234567-Abcdefg"  ;use only 1st bytes for 128/192bit
  128bit ENCRYPT --&gt; RK[0..9..30..43] = 2D534541..ED0DC6FA..43DAC81C..0F5026BB
  192bit ENCRYPT --&gt; RK[0..9..30..51] = 2D534541..4AAB3D82..29CA38D2..CA4DFE3B
  256bit ENCRYPT --&gt; RK[0..9..30..59] = 2D534541..1AA51359..CCB886C8..88956C9C
  128bit DECRYPT --&gt; RK[0..9..30..43] = F653079B..47DD8A1C..1C2070A7..7274532D
  192bit DECRYPT --&gt; RK[0..9..30..51] = 3CEC6AFF..C4F96B6F..AE36B4AE..7274532D
  256bit DECRYPT --&gt; RK[0..9..30..59] = DE7ADCD9..8C559ADD..067A387E..7274532D
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
<B> aes_crypt_results:</B>
  [key+0..15]    = "AES-Test-Key-Str-1234567-Abcdefg"
  [iv+0..15]     = "Nonce/InitVector"
  [xtra+0..20]   = "Extra-Associated-Data"  ;\for CCM
  iv_len=12, mac_len=16, xtra_len=21        ;/
  Unencrypted:   [dta+0..113Fh] = "Unencrypted-Data", 190h x "TestPadding"
  AES-ECB:       [dta+0..113Fh] = 5F,BD,04,DB,..,E4,07,F4,B6  ;\
  AES-CBC:       [dta+0..113Fh] = 0B,BB,53,FA,..,DD,28,6D,AE  ;
  AES-CFB128:    [dta+0..113Fh] = F4,75,4F,0E,..,73,B5,D7,E7  ; keysize=128
  AES-CFB8:      [dta+0..113Fh] = F4,10,6A,83,..,BF,1B,16,3E  ;
  AES-CTR:       [dta+0..113Fh] = F4,75,4F,0E,..,04,DF,EB,BA  ;
  AES-CCM:       [dta+0..113Fh] = FD,1A,6D,98,..,EE,FD,68,F6  ;
  AES-CCM (ori): [mac+0..0Fh]   = FD,F9,FE,85,..,4F,50,3C,AF  ;
  AES-CCM (DSi): [mac+0..0Fh]   = xx,xx,xx,xx,..,xx,xx,xx,xx  ;/
  AES-ECB:       [dta+0..113Fh] = 0E,69,F5,1A,..,9A,5F,7A,9A  ;-keysize=192
  AES-ECB:       [dta+0..113Fh] = C6,FB,68,C1,..,14,89,6C,E0  ;-keysize=256
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsiesblockencryption"></A>&nbsp;
  DSi ES Block Encryption
</FONT></TD></TR></TABLE><BR>
ES Block Encryption, for lack of a better name, is a Nintendo DSi specific data
encryption method. It's used for some SD/MMC files:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  FAT16:\sys\dev.kp
  SD Card: .bin files (aka Tad Files)
</TD></TR></TABLE>
<BR>
<B>Block Layout</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00000h      BLKLEN   Data Block      (AES-CCM encrypted)
  BLKLEN+00h  10h      Data Checksum   (AES-CCM MAC value on above Data)
  BLKLEN+10h  1        Fixed 3Ah       (AES-CTR encrypted)
  BLKLEN+11h  0Ch      Nonce           (unencrypted)
  BLKLEN+1Dh  1        BLKLEN.bit16-23 (AES-CTR encrypted)
  BLKLEN+1Eh  1        BLKLEN.bit8-15  (AES-CTR encrypted)
  BLKLEN+1Fh  1        BLKLEN.bit0-7   (AES-CTR encrypted)
</TD></TR></TABLE>
BLKLEN can be max 20000h. If the Data is bigger than 128Kbytes, then it's split
into multiple block(s) with BLKLEN=20000h (the last block can have smaller
BLKLEN).<BR>
<BR>
<B>Data Block Encryption/Decryption (AES-CCM)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  IV[00h..0Bh]=[BLKLEN+11h..1Ch]  ;Nonce
  IV[0Ch..0Fh]=Don't care (not used for CCM)
</TD></TR></TABLE>
With that IV value, apply AES-CCM on the Data Block:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00000h      BLKLEN   Data Block      (AES-CCM)
</TD></TR></TABLE>
Observe that some DSi files have odd BLKLEN values, so you may need to append
padding bytes to the Data Block (the DSi hardware requires full 16-byte chunks
for encryption/decryption).<BR>
<BR>
<B>Data Block Padding (16-byte alignment)</B><BR>
For encryption, it's simple: Just append 00h byte(s) as padding value.<BR>
For decryption, it's more complicated: The padding values should be ENCRYPTED
00h-bytes (required to get the same MAC result as for encryption). If you don't
want to verify the MAC, then you could append whatever dummy bytes. If you want
to verify the MAC, then you could pre-calculate the padding values as so:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  IV[00h..02h]=BLKLEN/10h + 1     ;CTR value for last 16-byte block
  IV[03h..0Eh]=[BLKLEN+11h..1Ch]  ;Nonce
  IV[0Fh]=02h                     ;Indicate 3-byte wide CTR (fixed on DSi)
</TD></TR></TABLE>
Then, use AES-CTR (not CCM) to encrypt sixteen 00h-bytes, the last bytes of the
result can be then used as padding value. The padding values should be
pre-calculated BEFORE starting the CCM decryption (the DSi hardware allows only
one AES task at once, so they cannot be calculated via AES-CTR when AES-CCM
decryption is in progress).<BR>
<BR>
<B>Verifying the Footer values (AES-CTR)</B><BR>
This step is needed only for verification purposes (encryption tools should
create these values, but decryption tools may or may not verify them).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  IV[00h]=00h                     ;Zero
  IV[01h..0Ch]=[BLKLEN+11h..1Ch]  ;Nonce
  IV[0Dh..0Fh]=00h,00h,00h        ;Zero
</TD></TR></TABLE>
With that IV value (and same Key as for AES-CCM), apply AES-CTR on the last 16
bytes of the block:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  BLKLEN+10h  1        Fixed 3Ah       (AES-CTR encrypted)
  BLKLEN+11h  0Ch      Nonce           (unencrypted)
  BLKLEN+1Dh  1        BLKLEN.bit16-23 (AES-CTR encrypted)
  BLKLEN+1Eh  1        BLKLEN.bit8-15  (AES-CTR encrypted)
  BLKLEN+1Fh  1        BLKLEN.bit0-7   (AES-CTR encrypted)
</TD></TR></TABLE>
AES-CTR is XORing the data stream (encrypted bytes will turn into unencrypted
bytes, and vice-versa), so the result would look as so:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  BLKLEN+10h  1        Fixed 3Ah       (unencrypted)       (to be verified)
  BLKLEN+11h  0Ch      Nonce           (AES-CTR encrypted) (useless/garbage)
  BLKLEN+1Dh  1        BLKLEN.bit16-23 (unencrypted)       (to be verified)
  BLKLEN+1Eh  1        BLKLEN.bit8-15  (unencrypted)       (to be verified)
  BLKLEN+1Fh  1        BLKLEN.bit0-7   (unencrypted)       (to be verified)
</TD></TR></TABLE>
Mind that BLKLEN can be odd, so data at BLKLEN+00h..1Fh isn't necessarily
located at 4-byte aligned addresses.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsicartridgeheader"></A>&nbsp;
  DSi Cartridge Header
</FONT></TD></TR></TABLE><BR>
<B>Old NDS Header Entries</B><BR>
The first 180h bytes of the DSi Header are essentially same as on NDS:<BR>
<A HREF="#dscartridgeheader">DS Cartridge Header</A><BR>
New/changed entries in DSi carts are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  012h 1    Unitcode (00h=NDS, 02h=NDS+DSi, 03h=DSi) (bit1=DSi)
  01Ch 1    NDS: Reserved / DSi: Unknown (03h=Normal, 0Bh=System Menu/Settings)
  01Dh 1    NDS: Reserved / DSi: Unknown (00h=Normal, 01h=System Settings)
  068h 4    Icon/Title offset (same as NDS, but with new extra entries)
  080h 4    Total Used ROM size, EXCLUDING DSi area
  088h 4    NDS: Reserved / DSi: Unknown (B8h,D0h,04h,00h)
  08Ch 4    NDS: Reserved / DSi: Unknown (44h,05h,00h,00h)
  090h 4    NDS: Reserved / DSi: Unknown (16h,00h,16h,00h)
</TD></TR></TABLE>
<BR>
<B>New DSi Header Entries</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  180h 20   Global MBK1..MBK5 Setting, WRAM Slots
  194h 12   Local ARM9 MBK6..MBK8 Setting, WRAM Areas
  1A0h 12   Local ARM7 MBK6..MBK8 Setting, WRAM Areas
  1ACh 3    Global MBK9 Setting, WRAM Slot Master
  1AFh 1    ... whatever, rather not 4000247h WRAMCNT ?
                 (above byte is usually 03h)
                 (but, it's FCh in System Menu?)
                 (but, it's 00h in System Settings?)
  1B0h 4    Region flags (bit0=JPN, bit1=USA, bit2=EUR, bit3=AUS, bit4=CHN,
              bit5=KOR, bit6-31=Reserved) (FFFFFFFFh=Region Free)
  1B4h 4    Access control  (uh ???)  ;whatever Flags (AES Key Select?)      ?
  1B8h 4    ARM7 SCFG EXT mask (controls which devices to enable) (uh ???)
  1BCh 3    Reserved/flags? (zerofilled)
  1BFh 1    Flags? (usually 01h) (DSiware Browser: 0Bh)
              "When bit2=1, usage of banner.sav from the title data dir is
              enabled (additional banner data)." huh?
  1C0h 4    ARM9i rom offset (usually XX03000h, XX=1MB-boundary after NDS area)
  1C4h 4    Reserved (zero-filled)
  1C8h 4    ARM9i load address
  1CCh 4    ARM9i size
  1D0h 4    ARM7i rom offset
  1D4h 4    Pointer to base address where various structures and parameters
              are passed to the title (=something passed from firmware to ram?)
  1D8h 4    ARM7i load address
  1DCh 4    ARM7i size
  1E0h 4    Digest NTR region offset (usually same as ARM9 rom offs, 0004000h)
  1E4h 4    Digest NTR region length
  1E8h 4    Digest TWL region offset (usually same as ARM9i rom offs, XX03000h)
  1ECh 4    Digest TWL region length
  1F0h 4    Digest Sector Hashtable offset ;\SHA1 HMAC's on all sectors
  1F4h 4    Digest Sector Hashtable length ;/in above NTR+TWL regions
  1F8h 4    Digest Block Hashtable offset  ;\SHA1 HMAC's on each N entries
  1FCh 4    Digest Block Hashtable length  ;/in above Sector Hashtable
  200h 4    Digest Sector size       (eg. 400h bytes per sector)
  204h 4    Digest Block sectorcount (eg. 20h sectors per block)
  208h 4    Icon/Title size (usually 23C0h)
  20Ch 4    Reserved ??? (00 00 01 00)
  210h 4    Total Used ROM size, INCLUDING DSi area
  214h 4    Reserved ?   (00 00 00 00)
  218h 4    Reserved ??? (84 D0 04 00) whatever, resembles header entry [088h]
  21Ch 4    Reserved ??? (2C 05 00 00) whatever, resembles header entry [08Ch]
  220h 4    Modcrypt area 1 offset ;usually same as ARM9i rom offs (XX03000h)
  224h 4    Modcrypt area 1 size   ;usually min(4000h,ARM9iSize+Fh AND not Fh)
  228h 4    Modcrypt area 2 offset (0=None)
  22Ch 4    Modcrypt area 2 size   (0=None)
  230h 4    Title ID, Emagcode (aka Gamecode spelled backwards)
  234h 1    Title ID, Filetype (00h=Cartridge, 04h=DSiware, 05h=DS Download
              Play, [0Fh=Non-executable datafile without cart header],
              15h=System Settings, 17h=System Menu)
  235h 1    Title ID, Zero     (00h=Normal)
  236h 1    Title ID, Three    (03h=Normal, why?)
  237h 1    Title ID, Zero     (00h=Normal)
  238h 4    SD/MMC (DSiware) "public.sav" filesize in bytes  (0=none)
  23Ch 4    SD/MMC (DSiware) "private.sav" filesize in bytes (0=none)
  240h 176  Reserved (zero-filled)
  2F0h 4    Reserved ??? (00 00 00 8C)
  2F4h 4    Reserved ??? (87 00 86 87)
  2F8h 4    Reserved ?   (00 00 00 00)
  2FCh 4    Reserved ?   (00 00 00 00)
  300h 20   SHA1 HMAC hash ARM9 (with encrypted secure area)  ;[020h,02Ch]
  314h 20   SHA1 HMAC hash ARM7                               ;[030h,03Ch]
  328h 20   SHA1 HMAC hash Digest master                      ;[1F8h,1FCh]
  33Ch 20   SHA1 HMAC hash Icon/Title                         ;[068h,208h]
  350h 20   SHA1 HMAC hash ARM9i (decrypted)                  ;[1C0h,1CCh]
  364h 20   SHA1 HMAC hash ARM7i (decrypted)                  ;[1D0h,1DCh]
  378h 40   Reserved (zero-filled)
  3A0h 20   SHA1 HMAC hash ARM9 (without 16Kbyte secure area) ;[020h,02Ch]
  3B4h 2636 Reserved (zero-filled)
  E00h 180h Reserved and unchecked region, always zero. Used for passing
              arguments in debug environment.
  F80h 80h  RSA SHA1 signature across header entries [000h..DFFh]
</TD></TR></TABLE>
Note: There should be some Age-rating (for firmware's Parental Controls).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1000h..3FFFh  Non-Load area in ROMs... but contains sth in DSiWare files!?!
</TD></TR></TABLE>
<BR>
<B>DSiware/System Utilities</B><BR>
Files saved on SD card or internal eMMC memory are having the same header, with
some differences:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  The ARM7 and ARM9 areas may exceed the 4Mbyte NDS-limit
  Entry 3A0h can be zero-filled (in LAUNCHER)
</TD></TR></TABLE>
DSiware files are usually marked as [012h]=03h=DSi (one exception is the DS
Download Play utility, which is marked [012h]=00h=NDS, since it's actually
running in NDS mode).<BR>
<BR>
<B>SHA1 HMAC</B><BR>
The SHA1 HMAC's in cart header and Digest tables are SHA1 checksums with a
40h-byte HMAC key (values 21h, 06h, C0h, DEh, BAh, ..., 24h), the key is
probably stored in encrypted areas of NAND memory and/or in undumped areas of
BIOS memory, the raw unencrypted key is also stored in most DSi cartridges
(probably used for verifying Digest values when loading additional data after
booting). The key can be used for verifying checksums, but (due to the RSA
signature) not for changing them. See BIOS chapter for SHA1/HMAC pseudo code.<BR>
<BR>
<B>RSA SHA1</B><BR>
The RSA SHA1 value is a normal SHA1 (not SHA1 HMAC) across header entries
[000h..DFFh], the 20-byte value is padded to 127-byte size (01h, 105xFFh, 00h,
followed by the 20 SHA1 bytes). It can be decrypted (via SWI 22h) using the
80h-byte RSA public keys located in ARM9BIOS (note that there are at least four
different RSA keys, one is used for games, and others for system files), and
can be then verfied against the SHA1 checksum (computed via SWI 27h).<BR>
<A HREF="#biosrsafunctionsdsionly">BIOS RSA Functions (DSi only)</A><BR>
The private key needed for encryption is unknown, which is unfortunately
preventing to boot unlicensed (homebrew) software.<BR>
<BR>
<B>Modcrypt (AES-CTR)</B><BR>
Modcrypt is a new additional way of encrypting parts of the NDS ROM executable
binary modules using AES CTR. It is mostly being used to encrypt the ARM9i and
ARM7i binaries. DSi cartridges are usually having only the ARM9i binary
encrypted (as area 1), while NAND based applications have both the ARM9i and
ARM7i binaries encrypted (as area 1 and 2).<BR>
The initial AES Counter value (IV) is:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Modcrypt Area 1 IV[0..F]: First 16 bytes of the ARM9 SHA1 HMAC   [300h..30Fh]
  Modcrypt Area 2 IV[0..F]: First 16 bytes of the ARM7 SHA1 HMAC   [314h..323h]
</TD></TR></TABLE>
The AES key depends of flags in the cartridge header:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 IF header[01Ch].Bit2 OR header[1BFh].Bit7 THEN (probably for prototypes)
  Debug KEY[0..F]: First 16 bytes of the header                    [000h..00Fh]
 ELSE (commonly used for retail software)
  Retail KEY_X[0..7]: Fixed 8-byte ASCII string                    ("Nintendo")
  Retail KEY_X[8..B]: The 4-byte gamecode, forwards                [00Ch..00Fh]
  Retail KEY_X[C..F]: The 4-byte gamecode, backwards               [00Fh..00Ch]
  Retail KEY_Y[0..F]: First 16 bytes of the ARM9i SHA1 HMAC        [350h..35Fh]
</TD></TR></TABLE>
Theoretically, the modcrypt areas can span over any of the ARM9i/ARM7i and
ARM9/ARM7 areas (in practice, cartridges should never use modcrypt for the
ARM9/ARM7 areas because older NDS consoles would leave them undecrypted).<BR>
<BR>
<B>Digests</B><BR>
The NDS format has been extended with a hash tree to verify the entire contents
of an NDS ROM. The NDS ROM is divided into sectors, and each sector will be
hashed and have its hash stored in the digest sector hashtable. The size of a
sector is defined in the header aswell. Furthermore, the sector hashtable is
partitioned and hashed again to form block hashes. This block hashtable is
hashed again into a single hash called the digest master hash. These hashtables
can be used to verify that the sectors of a NDS ROM have not been tampered
with, since the integrity of a sector hash can be verified by a block hash,
which in turn can be verified by the master hash. And this hash is part of the
header, which is signed with RSA.<BR>
The sector hashtable reaches over the NTR and TWL regions, respectively.<BR>
<BR>
<B>Cartridge Protocol</B><BR>
The DSi cartridge protocol is same as on NDS; with one new command (3Dh) for
unlocking DSi specific memory regions. For details,<BR>
<A HREF="#dscartridgeprotocol">DS Cartridge Protocol</A><BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsitouchscreensoundcontroller"></A>&nbsp;
  DSi Touchscreen/Sound Controller
</FONT></TD></TR></TABLE><BR>
<A HREF="#dsitouchscreenaccess">DSi Touchscreen Access</A><BR>
<BR>
<B>AIC3000D Registers</B><BR>
<A HREF="#dsitscregistersummary">DSi TSC, Register Summary</A><BR>
<A HREF="#dsitsc000h1ahbasicpllandtimingcontrol">DSi TSC[0:00h..1Ah], Basic PLL and Timing Control</A><BR>
<A HREF="#dsitsc01bh23hcodeccontrol">DSi TSC[0:1Bh..23h], Codec Control</A><BR>
<A HREF="#dsitsc024h32hstatusandinterruptflags">DSi TSC[0:24h..32h], Status and Interrupt Flags</A><BR>
<A HREF="#dsitsc033h3bhpincontrol">DSi TSC[0:33h..3Bh], Pin Control</A><BR>
<A HREF="#dsitsc03ch55hdacadcandbeep">DSi TSC[0:3Ch..55h], DAC/ADC and Beep</A><BR>
<A HREF="#dsitsc056h7fhagcandadc">DSi TSC[0:56h..7Fh], AGC and ADC</A><BR>
<A HREF="#dsitsc1xxhdacandadcroutingpgapowercontrolsandmisclogic">DSi TSC[1:xxh], DAC and ADC Routing, PGA, Power-Controls and MISC Logic</A><BR>
<A HREF="#dsitsc3xxhtouchscreensarcontrolandtscfchxxhbuffer">DSi TSC[3:xxh], Touchscreen/SAR Control and TSC[FCh:xxh], Buffer</A><BR>
<A HREF="#dsitsc04h05hxxhadcdigitalfiltercoefficientram">DSi TSC[04h..05h:xxh], ADC Digital Filter Coefficient RAM</A><BR>
<A HREF="#dsitsc08h0fhxxhdacdigitalfiltercoefficientram">DSi TSC[08h..0Fh:xxh], DAC Digital Filter Coefficient RAM</A><BR>
<A HREF="#dsitsc20h2bhxxhtsc40h5fhxxhadcdacinstructionram">DSi TSC[20h..2Bh:xxh], TSC[40h..5Fh:xxh] ADC/DAC Instruction RAM</A><BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsitouchscreenaccess"></A>&nbsp;
  DSi Touchscreen Access
</FONT></TD></TR></TABLE><BR>
The Touch Screen Controller (for lower LCD screen) is accessed via SPI bus,<BR>
<A HREF="#dsserialperipheralinterfacebusspi">DS Serial Peripheral Interface Bus (SPI)</A><BR>
so far, it's same as on NDS, but the SPI touchscreen commands are having an
entirely different format in DSi mode:<BR>
The DSi touchscreen registers are selected via a combination of a MODE byte and
an INDEX byte. The MODE byte is located at INDEX=00h, and it does somewhat
'bankswitch' the contents of INDEX=01h..7Fh. And INDEX can be incremented
manually, or automatically (but, confusingly, the manual increment doesn't work
for reading Y coordinates).<BR>
SPI clock should be set to 4MHz for DSi Mode touchscreen access (unlike NDS,
which used 2MHz). The PENIRQ bit in port 4000136h is always zero in DSi mode.<BR>
When reading data: Write dummy 00h-bytes in output direction.<BR>
<BR>
AIC3000D<BR>
<BR>
<B>DSi Touchscreen INDEX values</B><BR>
The INDEX/Direction byte is written as first byte after SPI chip select:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Direction for following data bytes (0=Write, 1=Read)
  1-7   INDEX (00h..7Fh) for following data bytes (auto-increasing)
</TD></TR></TABLE>
The meanining of the separate INDEX values is:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h       R/W  MODE register (should be 03h or FCh)
</TD></TR></TABLE>
When MODE=03h (Status/Control Registers)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  01h       R    Unknown (00h)
  02h..06h  mix  Unknown (18h,87h,22h,04h,20h) (writeable: FFh,BFh,F7h,E7h,EDh)
  07h..08h  R    Unknown (00h,00h)
  09h       R    State   (40h=Released, 80h=Pressed)
  0Ah..0Ch  R    Unknown (00h,00h,00h)
  0Dh       mix  Unknown (01h on 1st read, 00h thereafter?) (upper 6bit R/W)
  0Eh       mix  State   (ADh=Released, ACh=Pressed)        (upper 6bit R/W)
  0Fh       R/W  Unknown (A0h,88h,81h)
  12h..14h  mix  Unknown (usually 00h-filled) (writeable: E7h,FFh,07h)
  15h       R    Unknown (00h)
  16h..21h  R/W  Unknown Six 16bit values (0000h..1FFFh) (usually 0000h)
  22h..7Fh  R    Unknown (00h-filled)
</TD></TR></TABLE>
When MODE=FCh (Touchscreen X/Y Coordinates)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  01h..0Ah  R    Five Touchscreen X Coodinates (big-endian MSB,LSB each)
  0Bh..14h  R    Five Touchscreen Y Coodinates (big-endian MSB,LSB each)
  15h..7Fh  R    Reserved (garbage) (further Touchscreen X/Y Coodinates)
</TD></TR></TABLE>
Unknown what happens when using MODE values other than 03h and FCh (might give
access to further registers, or return somehow distorted results, or whatever).<BR>
Note: The DSi Sound utility also uses MODEs 00h, 01h, and 08h.<BR>
<BR>
When MODE=00h (?)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  01h..0Fh    00 01 44 00 00 00 00  00 00 00 00 00 00 00 00
  10h..1Fh 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
  20h..2Fh 03 00 00 00 80 99 11 08  00 00 00 00 00 00 00 00
  30h..3Fh 00 00 09 34 32 12 03 02  03 66 60 00 19 05 00 D4
  40h..4Fh 00 08 08 00 19 38 00 00  00 00 00 EE 10 D8 7E E3
  50h..5Fh 00 00 80 00 00 00 00 00  7F 00 00 00 00 00 00 00
  60h..6Fh 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
  70h..7Fh 00 00 00 00 D2 24 00 00  00 00 00 00 00 00 00 00
</TD></TR></TABLE>
After FFh-filling, this crashed, and after REBOOT it became:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  01h..0Fh    00 01 44 03 A1 15 00  00 00 00 87 83 00 80 80 ;&lt;--
  10h..1Fh 08 00 87 83 80 80 04 00  00 00 01 00 00 00 01 00 ;&lt;--
  20h..2Fh 00 00 00 00 80 99 11 08  00 00 00 00 00 00 00 00 ;&lt;-
  30h..3Fh 00 00 01 34 32 12 02 02  03 66 60 00 19 05 00 D4 ;&lt;-
  40h..4Fh 00 08 08 00 0F 38 00 00  00 00 00 EE 10 D8 7E E3 ;&lt;-
  50h..5Fh 00 00 80 00 00 00 00 00  7F 00 00 00 00 00 00 00
  60h..6Fh 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
  70h..7Fh 00 00 00 00 D2 24 00 00  00 00 00 00 00 00 00 00
  80h..    00...
</TD></TR></TABLE>
Then, after reading, many bytes changed back to 00.<BR>
<BR>
When MODE=01h (?)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  01h..0Fh    00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
  10h..1Fh 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
  20h..2Fh D6 20 F0 44 9E 9E A7 A7  4E 4E 15 15 20 86 00 43 ;
  30h..3Fh 40 40 61 00 00 00 00 00  00 00 00 00 00 00 00 00 ;
  40h..4Fh 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
  50h..5Fh 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
  60h..6Fh 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
  70h..7Fh 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
  80h..    00...
</TD></TR></TABLE>
After FFh-filling, this crashed, and after REBOOT it became:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  same as above.
</TD></TR></TABLE>
<BR>
When MODE=02h, 05h..07h, 08h(though used), 09h..FBh, FEh (?)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  All 00h-filled
</TD></TR></TABLE>
Unknown if/how coefficient RAM and instruction RAM can be enabled.<BR>
<BR>
When MODE=04h (?)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  01h..0Fh    00 01 17 01 17 7D D3  7F E1 80 1F 7F C1 7F FF
  10h..1Fh 00 00 00 00 00 00 00 00  7F FF 00 00 00 00 00 00
  20h..2Fh 00 00 7F FF 00 00 00 00  00 00 00 00 7F FF 00 00
  30h..3Fh 00 00 00 00 00 00 7F FF  00 00 00 00 00 00 00 00
  40h..4Fh 00 00 00 00 00 00 00 00  7F FF 00 00 00 00 7F FF
  50h..5Fh 00 00 00 00 00 00 00 00  7F FF 00 00 00 00 00 00
  60h..6Fh 00 00 7F FF 00 00 00 00  00 00 00 00 7F FF 00 00
  70h..7Fh 00 00 00 00 00 00 7F FF  00 00 00 00 00 00 00 00
  80h..    00...
</TD></TR></TABLE>
<BR>
Mode FCh<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  after index 7Fh, actually it REPEATs last byte (instead 00s)
</TD></TR></TABLE>
<BR>
When MODE=FDh (?)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  01h..0Fh    00 00 00 00 00 00 00  00 00 00 24 00 00 09 00 ;&lt;--
  10h..1Fh 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
  ...      00...
</TD></TR></TABLE>
<BR>
When MODE=FFh (?)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  01h..0Fh&lt;01&gt;00 00 01 00 01 00 00  00 00 00 00 00 00 00 00 ;&lt;-- !!
  10h..1Fh 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
  ...      00...
  70h..7Fh 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 FF ;&lt;--
  80h...   FF...                                            ;&lt;--
</TD></TR></TABLE>
thereafter, ALL MODES return the above values (except index0, returning<BR>
00h or 01h, depending on bit0 of the written index0 value)<BR>
<BR>
<B>Pen Down Testing</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  if (TSC[3:09h] AND 40h)&lt;&gt;0 then return(not_pressed)   ;ADC Ready Flag
  if (TSC[3:0Eh] AND 03h)&lt;&gt;0 then return(not_pressed)   ;Undocumented Flags?
  return(pressed)
</TD></TR></TABLE>
Note: On NDS, this would be done by reading port 4000136h.bit6, which isn't
supported in DSi mode.<BR>
<BR>
<B>X/Y Coordinate Reading</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  touchdata[0..19] = TSC[FCh:01h..14h]     ;read page FCh, index(1..20)
  rawx=0, rawy=0
  for i=0 to 8 step 2
    x = touchdata[i+0]*100h+touchdata[i+1]
    y = touchdata[i+10]*100h+touchdata[i+11]
    if (x or y) and F000h then return(not_pressed)
    rawx=rawx+x, rawy=rawy+y
  return(rawx/5, rawy/5)
</TD></TR></TABLE>
The resulting 12bit coordinates are same as on NDS (ie. they need to be further
processed using the Calibration Points from User Settings).<BR>
<BR>
<B>Touchscreen X/Y Coordinates</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-11   Coordinate (0..FFFh) (usually 000h when not pressed)
  12-14  State (0=Pressed, 7=Released) (or sometimes also 1 or 3=Released)
  15     State Changed (0=No, 1=Newly pressed/released; cleared after read)
</TD></TR></TABLE>
Bit12-14 are usually set to 7 when releasing the screen (though sometimes they
become 1 or 3 when releasing the screen, and do stay so until newly pressing
it).<BR>
Bit15 is cleared after reading (so it will be usually seen only in the first
MSB, ie. at INDEX=01h) (though maybe it can also occur elsewhere if it becomes
newly set during the SPI transfer).<BR>
<BR>
<B>Odd Effects</B><BR>
Touchscreen coordinates should be read by setting INDEX=01h, and then reading
20 bytes continously (ie. from automatically increasing indices 01h..14h).
Trying to increase the index manually (ie. using 1-byte reads via separate SPI
transfers) won't work: The hardware will return only X coordinates for all
indices (but no Y coordinates), ie. the upper bits of the index are ignored,
bit0 does properly select MSBs/LSBs of the 16bit values though.<BR>
Trying to read more than 20 bytes will return further touchscreen coordinates
(which might be further conversions, or just mirrors of the first 20 bytes),
basically, there will be five X coords, followed by five Y coords, with a few
odd exceptions: INDEX=0Bh..1Ch will return nine Y coords (instead of five),
INDEX=7Fh will have an incomplete 16bit value (MSB only, without LSB at
INDEX=80h). INDEX=80h and up will return 00h-bytes (ie. in MODE=FCh, the index
doesn't wrap from 7Fh to 00h; unlike as MODE=03h which is wrapping from index
7Fh to 00h).<BR>
The five normally used X/Y coordinate pairs are apparently the results from the
five most recent conversions; unknown which of the five values are newest and
which are oldest (they might sorted newest..oldest, or vice-versa, or located
at random locations in a ring-buffer; anyways, it doesn't really matter since
the values are just added together).<BR>
<BR>
<B>Microphone</B><BR>
The microphone input was part of the TSC on NDS. In DSi mode it is reportedly
somehow changed, using a new "CODEC" (whatever that means). Maybe it's accessed
directly via an ARM7 port (and/or TEAK port?), instead of via SPI bus?<BR>
<BR>
<B>NDS Backwards Compatibility Mode</B><BR>
The DSi hardware can emulate the NDS-style touchscreen protocol (with X/Y/MIC
channels and with additional PENIRQ flag; but without Pressure or Temperature
channels).<BR>
<A HREF="#dstouchscreencontrollertsc">DS Touch Screen Controller (TSC)</A><BR>
That backwards compatibility mode is used only for NDS games. DSi games are
always using the new mode (so DSi enhanced games must implement both modes, and
use the new mode on DSi consoles, and the old mode on NDS consoles).<BR>
Unknown how to activate that backwards compatibility mode (might be done via
some Touchscreen SPI register, or maybe some Powerman SPI register).<BR>
If the backwards compatibility mode isn't enabled, then trying to read the
touchscreen in NDS fashion will return nothing but zeroes for all TSC channels
(and also zero for the PENIRQ bit).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsitscregistersummary"></A>&nbsp;
  DSi TSC, Register Summary
</FONT></TD></TR></TABLE><BR>
The DSi's Touchscreen/Sound controller (AIC3000D) is essentially a Texas
Instruments TSC2117 chip (possibly with some customizations for NDS backwards
compatibility mode).<BR>
<BR>
TSC[page:index] registers are accessed via SPI bus with 15bit address space:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7bit index: selected via the first SPI byte, with direction flag in bit0
  8bit page:  selected by writing to index 00h, ie. to TSC[xxh:00h]
</TD></TR></TABLE>
<BR>
<B>TSC page select (for "TSC[page:index]" addressing)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  TSC[xxh:00h] - Page Select Register (00h)
</TD></TR></TABLE>
<B>TSC Basic PLL and Timing Control</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  TSC[0:01h] - Software Reset (00h)
  TSC[0:02h] - Reserved (xxh) (R)
  TSC[0:03h] - Overtemperature OT Flag (02h..FFh) (R)
  TSC[0:04h] - Clock-Gen Muxing (00h)
  TSC[0:05h] - PLL P and R-Values (11h)
  TSC[0:06h] - PLL J-Value (04h)
  TSC[0:07h,08h] - PLL D-Value MSB,LSB (0000h)
  TSC[0:09h,0Ah] - Reserved (xxh)
  TSC[0:0Bh] - DAC NDAC Value (01h)
  TSC[0:0Ch] - DAC MDAC Value (01h)
  TSC[0:0Dh,0Eh] - DAC DOSR Value MSB,LSB (0080h)
  TSC[0:0Fh] - DAC IDAC Value (80h)
  TSC[0:10h] - DAC miniDSP Engine Interpolation (08h)
  TSC[0:11h] - Reserved (xxh)
  TSC[0:12h] - ADC NADC Value (01h)
  TSC[0:13h] - ADC MADC Value (01h)
  TSC[0:14h] - ADC AOSR Value (80h)
  TSC[0:15h] - ADC IADC Value (80h)
  TSC[0:16h] - ADC miniDSP Engine Decimation (04h)
  TSC[0:17h,18h] - Reserved (xxh)
  TSC[0:19h] - CLKOUT MUX (00h)
  TSC[0:1Ah] - CLKOUT Divider M Value (01h)
</TD></TR></TABLE>
<B>TSC Codec Control</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  TSC[0:1Bh] - Codec Interface Control 1 (00h) (R/W)
  TSC[0:1Ch] - Data-Slot Offset Programmability (00h)
  TSC[0:1Dh] - Codec Interface Control 2 (00h)
  TSC[0:1Eh] - BCLK Divider N Value (01h)
  TSC[0:1Fh] - Codec Secondary Interface Control 1 (00h)
  TSC[0:20h] - Codec Secondary Interface Control 2 (00h)
  TSC[0:21h] - Codec Secondary Interface Control 3 (00h)
  TSC[0:22h] - I2C Bus Condition (00h)
  TSC[0:23h] - Reserved (xxh)
</TD></TR></TABLE>
<B>TSC Status and Interrupt Flags</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  TSC[0:24h] - ADC Flag Register (0xh) (R)
  TSC[0:25h] - DAC Flag Register (00h) (R)
  TSC[0:26h] - DAC Flag Register (00h) (R)
  TSC[0:27h] - Overflow Flags (00h) (R)
  TSC[0:28h..2Bh] - Reserved (xxh)
  TSC[0:2Ch] - Interrupt Flags DAC, sticky (00h..30h) (R)
  TSC[0:2Dh] - Interrupt Flags ADC, sticky (00h..18h) (R)
  TSC[0:2Eh] - Interrupt Flags DAC, non-sticky? (00h..30h) (R)
  TSC[0:2Fh] - Interrupt Flags ADC, non-sticky? (00h..18h) (R)
  TSC[0:30h] - INT1 Control Register (Select INT1 Sources) (00h)
  TSC[0:31h] - INT2 Control Register (Select INT2 Sources) (00h)
  TSC[0:32h] - INT1 and INT2 Control Register (00h)
</TD></TR></TABLE>
<B>TSC Pin Control</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  TSC[0:33h] - GPIO1 In/Out Pin Control (00h..C2h)
  TSC[0:34h] - GPIO2 In/Out Pin Control (00h..C2h)
  TSC[0:35h] - SDOUT (OUT Pin) Control (12h)
  TSC[0:36h] - SDIN (IN Pin) Control (02h or 03h)
  TSC[0:37h] - MISO (OUT Pin) Control (02h)
  TSC[0:38h] - SCLK (IN Pin) Control (02h..03h)
  TSC[0:39h] - GPI1 and GPI2 Pin Control (00h..11h)
  TSC[0:3Ah] - GPI3 Pin Control (00h..10h)
  TSC[0:3Bh] - Reserved (xxh)
</TD></TR></TABLE>
<B>TSC DAC/ADC and Beep</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  TSC[0:3Ch] - DAC Instruction Set (01h)
  TSC[0:3Dh] - ADC Instruction Set (04h)
  TSC[0:3Eh] - Programmable Instruction Mode-Control Bits (00h)
  TSC[0:3Fh] - DAC Data-Path Setup (14h)
  TSC[0:40h] - DAC Volume Control (0Ch)
  TSC[0:41h] - DAC Left Volume Control (00h)
  TSC[0:42h] - DAC Right Volume Control (00h)
  TSC[0:43h] - Headset Detection (00h..60h)
  TSC[0:44h] - DRC Control 1 (0Fh)
  TSC[0:45h] - DRC Control 2 (38h)
  TSC[0:46h] - DRC Control 3 (00h)
  TSC[0:47h] - Beep Generator and Left Beep Volume (00h)
  TSC[0:48h] - Beep Generator and Right Beep Volume (00h)
  TSC[0:49h,4Ah,4Bh] - Beep Length MSB,MID,LSB (0000EEh)
  TSC[0:4Ch,4Dh] - Beep Frequency Sin(x) MSB,LSB (10D8h)
  TSC[0:4Eh,4Fh] - Beep Frequency Cos(x) MSB,LSB (7EE3h)
  TSC[0:50h] - Reserved (xxh)
  TSC[0:51h] - ADC Digital Mic (00h)
  TSC[0:52h] - ADC Digital Volume Control Fine Adjust (80h)
  TSC[0:53h] - ADC Digital Volume Control Coarse Adjust (00h)
  TSC[0:54h,55h] - Reserved (xxh)
</TD></TR></TABLE>
<B>TSC AGC and ADC</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  TSC[0:56h] - AGC Control 1 (00h)
  TSC[0:57h] - AGC Control 2 (00h)
  TSC[0:58h] - AGC Maximum Gain (7Fh, uh that's 7Fh=Reserved?)
  TSC[0:59h] - AGC Attack Time (00h)
  TSC[0:5Ah] - AGC Decay Time (00h)
  TSC[0:5Bh] - AGC Noise Debounce (00h)
  TSC[0:5Ch] - AGC Signal Debounce (00h)
  TSC[0:5Dh] - AGC Gain-Applied Reading (xxh) (R)
  TSC[0:5Eh...65h] - Reserved (xxh)
  TSC[0:66h] - ADC DC Measurement 1 (00h)
  TSC[0:67h] - ADC DC Measurement 2 (00h)
  TSC[0:68h,69h,6Ah] - ADC DC Measurement Output MSB,MID,LSB (R) (000000h)
  TSC[0:6Bh...73h] - Reserved (xxh)
  TSC[0:74h] - VOL/MICDET-Pin SAR ADC - Volume Control (00h)
  TSC[0:75h] - VOL/MICDET-Pin Gain (xxh) (R)
  TSC[0:76h...7Fh] - Reserved (xxh)
</TD></TR></TABLE>
<B>TSC TSC, DAC and ADC Routing, PGA, Power-Controls and MISC Logic</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  TSC[1:01h..1Dh] - Reserved (xxh)
  TSC[1:1Eh] - Headphone and Speaker Amplifier Error Control (00h)
  TSC[1:1Fh] - Headphone Drivers (04h)
  TSC[1:20h] - Class-D Speaker Amplifier (06h)
  TSC[1:21h] - HP Output Drivers POP Removal Settings (3Eh)
  TSC[1:22h] - Output Driver PGA Ramp-Down Period Control (00h)
  TSC[1:23h] - DAC_L and DAC_R Output Mixer Routing (00h)
  TSC[1:24h] - Analog Volume to HPL (Left Headphone) (7Fh)
  TSC[1:25h] - Analog Volume to HPR (Right Headphone) (7Fh)
  TSC[1:26h] - Analog Volume to SPL (Left Speaker) (7Fh)
  TSC[1:27h] - Analog Volume to SPR (Right Speaker) (7Fh)
  TSC[1:28h] - HPL Driver (Left Headphone) (02h)
  TSC[1:29h] - HPR Driver (Right Headphone) (02h)
  TSC[1:2Ah] - SPL Driver (Left Speaker) (00h)
  TSC[1:2Bh] - SPR Driver (Right Speaker) (00h)
  TSC[1:2Ch] - HP Driver Control (00h)
  TSC[1:2Dh] - Reserved (xxh)
  TSC[1:2Eh] - MICBIAS (00h)
  TSC[1:2Fh] - MIC PGA (80h)
  TSC[1:30h] - P-Terminal Delta-Sigma Mono ADC Channel Fine-Gain Input (00h)
  TSC[1:31h] - M-Terminal ADC Input Selection (00h)
  TSC[1:32h] - Input CM Settings (00h)
  TSC[1:33h..FFh] - Reserved (xxh)
</TD></TR></TABLE>
<B>Reserved Page</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  TSC[2:01h..FFh] - Reserved (00h)
</TD></TR></TABLE>
<B>TSC Touchscreen/SAR Control</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  TSC[3:01h] - Reserved (xxh)
  TSC[3:02h] - SAR ADC Control 1 (00h)
  TSC[3:03h] - SAR ADC Control 2 (00h)
  TSC[3:04h] - Precharge and Sense (00h)
  TSC[3:05h] - Panel Voltage Stabilization (00h)
  TSC[3:06h] - Voltage Reference (20h)
  TSC[3:07h,08h] - Reserved (xxh)
  TSC[3:09h] - Status Bits 1 (40h) (R)
  TSC[3:0Ah] - Status Bits 2 (00h) (R)
  TSC[3:0Bh,0Ch] - Reserved (xxh)
  TSC[3:0Dh] - Buffer Mode (03h)
  TSC[3:0Eh] - Reserved / Undocumented (read by DSi for Pen Down Test) (0Fh)
  TSC[3:0Fh] - Scan Mode Timer (40h)
  TSC[3:10h] - Scan Mode Timer Clock (81h)
  TSC[3:11h] - SAR ADC Clock (81h)
  TSC[3:12h] - Debounce Time for Pen-Up Detection (00h)
  TSC[3:13h] - Auto AUX Measurement Selection (00h)
  TSC[3:14h] - Touch-Screen Pen Down (00h)
  TSC[3:15h] - Threshold Check Flags Register (00h) (R)
  TSC[3:16h,17h] - AUX1 Maximum Value Check MSB,LSB (0000h)
  TSC[3:18h,19h] - AUX1 Minimum Value Check MSB,LSB (0000h)
  TSC[3:1Ah,1Bh] - AUX2 Maximum Value Check MSB,LSB (0000h)
  TSC[3:1Ch,1Dh] - AUX2 Minimum Value Check MSB,LSB (0000h)
  TSC[3:1Eh,1Fh] - Temperature(TEMP1/TEMP2) Maximum Value Check MSB,LSB (0000h)
  TSC[3:20h,21h] - Temperature(TEMP1/TEMP2) Minimum Value Check MSB,LSB (0000h)
  TSC[3:22h...29h] - Reserved (xxh)
  TSC[3:2Ah,2Bh] - X-Coordinate Data MSB,LSB (0000h) (R)
  TSC[3:2Ch,2Dh] - Y-Coordinate Data MSB,LSB (0000h) (R)
  TSC[3:2Eh,2Fh] - Z1 Register MSB,LSB (0000h) (R)
  TSC[3:30h,31h] - Z2 Register MSB,LSB (0000h) (R)
  TSC[3:32h...35h] - Reserved (xxh)
  TSC[3:36h,37h] - AUX1 Data MSB,LSB (0000h) (R)
  TSC[3:38h,39h] - AUX2 Data MSB,LSB (0000h) (R)
  TSC[3:3Ah,3Bh] - VBAT Data MSB,LSB (0000h) (R)
  TSC[3:3Ch...41h] - Reserved (xxh)
  TSC[3:42h,43h] - TEMP1 Data Register MSB,LSB (0000h) (R)
  TSC[3:44h,45h] - TEMP2 Data Register MSB,LSB (0000h) (R)
  TSC[3:46h...7Fh] - Reserved (xxh)
</TD></TR></TABLE>
<B>TSC Coefficient RAM and Instruction RAM for ADC/DAC</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  TSC[04h..05h:xxh] - ADC Coefficient RAM (126 x 16bit)
  TSC[06h..07h:xxh] - Reserved (00h)
  TSC[08h:01h]      - DAC Coefficient RAM Control (00h)
  TSC[08h..0Bh:xxh] - DAC Coefficient RAM, DAC Buffer A (252 x 16bit)
  TSC[0Ch..0Fh:xxh] - DAC Coefficient RAM, DAC Buffer B (252 x 16bit)
  TSC[10h..1Fh:xxh] - Reserved (00h)
  TSC[20h..2Bh:xxh] - ADC DSP Engine Instruction RAM (384 x 24bit)
  TSC[2Ch..3Fh:xxh] - Reserved (00h)
  TSC[40h..5Fh:xxh] - DAC DSP Engine Instruction RAM (1024 x 24bit)
  TSC[60h..FBh:xxh] - Reserved (00h)
</TD></TR></TABLE>
<B>TSC Touchscreen/SAR Buffer</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  TSC[FCh:01h..xxh] - Buffer Mode Data MSB,LSB (xxxxh) (R)
  TSC[FCh:xxh..7Fh] - Reserved (xxh)
</TD></TR></TABLE>
<B>TSC Undocumented Registers</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  TSC[FDh:xxh] - Contains some non-zero values (DSi specific?)
  TSC[FEh:xxh] - Reserved (00h)
  TSC[FFh:xxh] - Accessing this page changes operation (DSi specific?)
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsitsc000h1ahbasicpllandtimingcontrol"></A>&nbsp;
  DSi TSC[0:00h..1Ah], Basic PLL and Timing Control
</FONT></TD></TR></TABLE><BR>
<B>TSC[xxh:00h] - Page Select Register (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-0   Page Select (00h..FEh) (FFh=Undocumented, enter special mode?)
</TD></TR></TABLE>
Selects the "page" for the TSC[page:index] addresses.<BR>
<BR>
<B>TSC[0:01h] - Software Reset (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-1   Reserved. Write only zeros to these bits.
  0     Software Reset (0=No change, 1=Reset)
</TD></TR></TABLE>
<BR>
<B>TSC[0:02h] - Reserved (xxh) (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-0   Reserved. Do not write to this register.
</TD></TR></TABLE>
<BR>
<B>TSC[0:03h] - Overtemperature OT Flag (02h..FFh) (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-2   Reserved. Do not write to these bits. (R)
  1     Overtemperature protection flag (0=Alert, 1=Normal) (R)
  0     Reserved. Do not write to these bits. (R/W?)
</TD></TR></TABLE>
Bit1 is valid only if speaker amplifier is powered up.<BR>
<BR>
<B>TSC[0:04h] - Clock-Gen Muxing (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-4   Reserved. Write only zeros to these bits.
  3-2   Select PLL_CLKIN   (0=MCLK, 1=BCLK, 2=GPIO1, 3=SDIN)
  1-0   Select CODEC_CLKIN (0=MCLK, 1=BCLK, 2=GPIO1, 3=PLL_CLK)
</TD></TR></TABLE>
See Section 5.8 for more details on clock generation mutiplexing and dividers.<BR>
<BR>
<B>TSC[0:05h] - PLL P and R-Values (11h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     PLL Enable        (0=Power down, 1=Power up)
  6-4   PLL Divider P     (1..7=Div1..7, or 0=Div8)
  3-0   PLL Multiplier R  (1..15=Mul1..15, or 0=Mul16)
</TD></TR></TABLE>
<BR>
<B>TSC[0:06h] - PLL J-Value (04h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-6   Reserved. Write only zeros to these bits.
  5-0   PLL Multiplier J  (1..63=Mul1..63, or 0=Reserved)
</TD></TR></TABLE>
<BR>
<B>TSC[0:07h,08h] - PLL D-Value MSB,LSB (0000h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-14 Reserved. Write only zeros to these bits.
  13-0  PLL fractional multiplier D-Val (14bit)
</TD></TR></TABLE>
Note that LSB register must be written to immediately after writing to MSB.<BR>
<BR>
<B>TSC[0:09h,0Ah] - Reserved (xxh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-0   Reserved. Write only zeros to these bits.
</TD></TR></TABLE>
<BR>
<B>TSC[0:0Bh] - DAC NDAC Value (01h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     DAC NDAC Divider Enable (0=Power down, 1=Power up)
  6-0   DAC NDAC Divider (1..127=Div1..127, or 0=Div128)
</TD></TR></TABLE>
<BR>
<B>TSC[0:0Ch] - DAC MDAC Value (01h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     DAC MDAC Divider Enable (0=Power down, 1=Power up)
  6-0   DAC MDAC Divider (1..127=Div1..127, or 0=Div128)
</TD></TR></TABLE>
<BR>
<B>TSC[0:0Dh,0Eh] - DAC DOSR Value MSB,LSB (0080h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-10 Reserved
  9-0   DAC OSR value "DOSR" (1..1023, or 0=1024)
</TD></TR></TABLE>
DOSR should be an integral multiple of the interpolation ratio in TSC[0:10h].<BR>
Note that LSB register must be written to immediately after writing to MSB.<BR>
<BR>
<B>TSC[0:0Fh] - DAC IDAC Value (80h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-0   Number of instructions for DAC miniDSP engine (IDAC=N*4)
        (1..255 = 4..1020 (N*4), or 0=1024)
</TD></TR></TABLE>
IDAC should be an integral multiple of the interpolation ratio in TSC[0:10h].<BR>
<BR>
<B>TSC[0:10h] - DAC miniDSP Engine Interpolation (08h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-4   Reserved. Do not write to these registers.
  3-0   Interpolation ratio in DAC miniDSP engine (1..15, or 0=16)
</TD></TR></TABLE>
<BR>
<B>TSC[0:11h] - Reserved (xxh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-0   Reserved. Do not write to this register.
</TD></TR></TABLE>
<BR>
<B>TSC[0:12h] - ADC NADC Value (01h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     ADC NADC divider is powered
          0: ADC NADC divider is powered down and ADC_DSP_CLK = DAC_DSP_CLK.
          1: ADC NADC divider is powered up.
  6-0   ADC NADC divider  (1..127, or 0=128)
</TD></TR></TABLE>
<BR>
<B>TSC[0:13h] - ADC MADC Value (01h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     ADC MADC divider is powered
          0: ADC MADC divider is powered down and ADC_MOD_CLK = DAC_MOD_CLK.
          1: ADC MADC divider is powered up.
  6-0   ADC MADC divider  (1..127, or 0=128)
</TD></TR></TABLE>
<BR>
<B>TSC[0:14h] - ADC AOSR Value (80h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-0   ADC OSR "AOSR" divider  (1..255, or 0=256)
</TD></TR></TABLE>
AOSR should be an integral multiple of the decimation ratio in TSC[0:16h].<BR>
<BR>
<B>TSC[0:15h] - ADC IADC Value (80h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-0   Number of instruction for ADC miniDSP engine (IADC=N*2)
        (1..192 = 2..384 (N*2), or 0,193..255=Reserved)
</TD></TR></TABLE>
IADC should be an integral multiple of the decimation ratio in TSC[0:16h].<BR>
<BR>
<B>TSC[0:16h] - ADC miniDSP Engine Decimation (04h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-4   Reserved
  3-0   Decimation ratio in ADC miniDSP engine  (1..15, or 0=16)
</TD></TR></TABLE>
<BR>
<B>TSC[0:17h,18h] - Reserved (xxh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-0   Reserved. Do not write to these registers.
</TD></TR></TABLE>
<BR>
<B>TSC[0:19h] - CLKOUT MUX (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-3   Reserved
  2-0   CDIV_CLKIN (0=MCLK, 1=BCLK, 2=SDIN, 3=PLL_CLK, 4=DAC_CLK(DSP),
        5=DAC_MOD_CLK, 6=ADC_CLK(DSP), 7=ADC_MOD_CLK)
</TD></TR></TABLE>
<BR>
<B>TSC[0:1Ah] - CLKOUT Divider M Value (01h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     CLKOUT divider M Enable (0=Powered down, 1=Powered up)
  6-0   CLKOUT divider M        (1..127, or 0=128)
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsitsc01bh23hcodeccontrol"></A>&nbsp;
  DSi TSC[0:1Bh..23h], Codec Control
</FONT></TD></TR></TABLE><BR>
<B>TSC[0:1Bh] - Codec Interface Control 1 (00h) (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-6   Codec interface type        (0=I2S, 1=DSP, 2=RJF, 3=LJF)
  5-4   Codec interface word length (0..3=16,20,24,32 bits)
  3     BCLK Direction              (0=Input, 1=Output)
  2     WCLK Direction              (0=Input, 1=Output)
  1     Reserved
  0     Driving SDOUT to High-Impedance for the Extra BCLK
         Cycle When Data Is Not Being Transferred (0=Disabled, 1=Enabled)
</TD></TR></TABLE>
<BR>
<B>TSC[0:1Ch] - Data-Slot Offset Programmability (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-0   Offset (0..255 = 0..255 BCLKs)
</TD></TR></TABLE>
Note: Measured with respect to WCLK Rising Edge in DSP Mode.<BR>
<BR>
<B>TSC[0:1Dh] - Codec Interface Control 2 (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-6   Reserved
  5     SDIN-to-SDOUT loopback (0=Disable, 1=Enable)
  4     ADC-to-DAC loopback    (0=Disable, 1=Enable)
  3     BCLK Invert            (0=No, 1=Invert)
  2     BCLK and WCLK active even with Codec powered down (0=No, 1=Yes)
  1-0   BDIV_CLKIN     (0=DAC_CLK, 1=DAC_MOD_CLK, 2=ADC_CLK, 3=ADC_MOD_CLK)
</TD></TR></TABLE>
The BCLK settings in Bit2,3 do apply to both Primary and Secondary BCLK.<BR>
<BR>
<B>TSC[0:1Eh] - BCLK Divider N Value (01h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     BCLK divider N Enable (0=Powered down, 1=Powered up)
  6-0   BCLK divider N        (1..127, or 0=128)
</TD></TR></TABLE>
<BR>
<B>TSC[0:1Fh] - Codec Secondary Interface Control 1 (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-5   Secondary BCLK is obtained from    ;\(0=GPIO1, 1=SCLK, 2=MISO, 3=SDOUT,
  4-2   Secondary WCLK is obtained from    ;/ 4=GPIO2, 5=GPI1, 6=GPI2, 7=GPI3)
  1-0   Secondary SDIN is obtained from (0=GPIO1, 1=SCLK, 2=GPIO2, 3=GPI1)
</TD></TR></TABLE>
<BR>
<B>TSC[0:20h] - Codec Secondary Interface Control 2 (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-5   ADC_WCLK is obtained from  (0=GPIO1, 1=SCLK, 2=MISO, 3=Reserved,
  4     Reserved                        4=GPIO2, 5=GPI1, 6=GPI2, 7=GPI3)
  3     Codec/ClockGen BCLK source (0=Primary BCLK, 1=Secondary BCLK)
  2     Codec WCLK source          (0=Primary WCLK, 1=Secondary WCLK)
  1     Codec ADC_WCLK source      (0=DAC_WCLK, 1=ADC_WCLK)
  0     Codec SDIN source          (0=Primary SDIN, 1=Secondary SDIN)
</TD></TR></TABLE>
<BR>
<B>TSC[0:21h] - Codec Secondary Interface Control 3 (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     Primary BCLK output   (0=Internally generated BCLK, 1=Secondary BCLK)
  6     Secondary BCLK output (0=Primary BCLK, 1=Internally generated BCLK)
  5-4   Primary WCLK output  (0=DAC_fS, 1=ADC_fS, 2=Secondary WCLK, 3=Reserved)
  3-2   Secondary WCLK output (0=Primary WCLK, 1=DAC_fS, 2=ADC_fS, 3=Reserved)
  1     Primary SDOUT         (0=SDOUT from codec, 1=Secondary SDIN)
  0     Secondary SDOUT       (0=Primary SDIN, 1=SDOUT from codec)
</TD></TR></TABLE>
<BR>
<B>TSC[0:22h] - I2C Bus Condition (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-6   Reserved. Write only the reset value to these bits.
  5     Accept I2C general-call address  (0=No/Ignore, 1=Yes/Accept)
  4-0   Reserved. Write only zeros to these bits.
</TD></TR></TABLE>
<BR>
<B>TSC[0:23h] - Reserved (xxh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-0   Reserved. Write only zeros to these bits.
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsitsc024h32hstatusandinterruptflags"></A>&nbsp;
  DSi TSC[0:24h..32h], Status and Interrupt Flags
</FONT></TD></TR></TABLE><BR>
<B>TSC[0:24h] - ADC Flag Register (0xh) (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     ADC PGA applied gain = programmed gain (0=Differs, 1=Equal) (R)
  6     ADC powered                  (0=Powered down, 1=Powered up) (R)
  5     AGC saturated        (0=No/inrange, 1=Yes/saturated to max) (R)
  4-0   Reserved. Write only zeros to these bits.
</TD></TR></TABLE>
Note on D5(?): Sticky flag bIts. These are read-only bits. They are
automatically cleared once they are read and are set only if the source trigger
occurs again.<BR>
<BR>
<B>TSC[0:25h] - DAC Flag Register (00h) (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     Left-channel DAC powered             (0=Powered down, 1=Powered up) (R)
  6     Reserved. Write only zero to this bit.
  5     Left Headphone HPL driver powered    (0=Powered down, 1=Powered up) (R)
  4     Left-channel class-D driver powered  (0=Powered down, 1=Powered up) (R)
  3     Right-channel DAC powered            (0=Powered down, 1=Powered up) (R)
  2     Reserved. Write only zero to this bit.
  1     Right Headphone HPR driver powered   (0=Powered down, 1=Powered up) (R)
  0     Right-channel class-D driver powered (0=Powered down, 1=Powered up) (R)
</TD></TR></TABLE>
<BR>
<B>TSC[0:26h] - DAC Flag Register (00h) (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-5   Reserved. Do not write to these bits.
  4     Left-channel DAC PGA applied gain=programmed gain  (0=Differs, 1=Equal)
  3-1   Reserved. Write only zeros to these bits.
  0     Right-channel DAC PGA applied gain=programmed gain (0=Differs, 1=Equal)
</TD></TR></TABLE>
<BR>
<B>TSC[0:27h] - Overflow Flags (00h) (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     Left-Channel DAC Overflow Flag           (0=None, 1=Overflow) (R)
  6     Right-Channel DAC Overflow Flag          (0=None, 1=Overflow) (R)
  5     DAC Barrel Shifter Output Overflow Flag  (0=None, 1=Overflow) (R)
  4     Reserved. Write only zeros to these bits.
  3     Delta-Sigma Mono ADC Overflow Flag       (0=None, 1=Overflow) (R)
  2     Reserved. Write only zero to this bit.
  1     ADC Barrel Shifter Output Overflow Flag  (0=None, 1=Overflow) (R)
  0     Reserved. Write only zero to this bit.
</TD></TR></TABLE>
Sticky flag bIts. These are read-only bits. They are automatically cleared once
they are read and are set only if the source trigger occurs again.<BR>
<BR>
<B>TSC[0:28h..2Bh] - Reserved (xxh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-0   Reserved. Write only the reset value to these bits.
</TD></TR></TABLE>
<BR>
<B>TSC[0:2Ch] - Interrupt Flags DAC, sticky (00h..30h) (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     Short-circuit detected at HPL/left class-D driver         (0=No, 1=Yes)
  6     Short-circuit detected at HPR/right class-D driver        (0=No, 1=Yes)
  5     Headset button pressed                                    (0=No, 1=Yes)
  4     Headset insertion/removal is detected                     (0=No, 1=Yes)
  3     Left DAC signal power vs signal threshold of DRC (0=Less/Equal,1=Above)
  2     Right DAC signal power vs signal threshold of DRC(0=Less/Equal,1=Above)
  1     DAC miniDSP Engine Standard Interrupt-Port Output  (0=Read 0, 1=Read 1)
  0     DAC miniDSP Engine Auxiliary Interrupt-Port Output (0=Read 0, 1=Read 1)
</TD></TR></TABLE>
Sticky flag bIts. These are read-only bits. They are automatically cleared once
they are read and are set only if the source trigger occurs again.<BR>
<BR>
<B>TSC[0:2Dh] - Interrupt Flags ADC, sticky (00h..18h) (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     Reserved. Write only zero to this bit.
  6     ADC signal power vs noise threshold for AGC (0=Greater, 1=Less)
  5     Reserved. Write only zeros to these bits.
  4     ADC miniDSP Engine Standard Interrupt Port Output  (0=Read 0, 1=Read 1)
  3     ADC miniDSP Engine Auxiliary Interrupt Port Output (0=Read 0, 1=Read 1)
  2     DC measurement using Delta Sigma Audio ADC
          (0=Not available, 1=Not available, too, uh?)
  1-0   Reserved. Write only zeros to these bits.
</TD></TR></TABLE>
Sticky flag bIts. These are read-only bits. They are automatically cleared once
they are read and are set only if the source trigger occurs again.<BR>
<BR>
<B>TSC[0:2Eh] - Interrupt Flags DAC, non-sticky? (00h..30h) (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     Short circuit detected at HPL/left class-D driver         (0=No, 1=Yes)
  6     Short circuit detected at HPR/right class-D driver        (0=No, 1=Yes)
  5     Headset button pressed                                    (0=No, 1=Yes)
  4     Headset removal/insertion detected             (0=Removal, 1=Insertion)
  3     Left DAC signal power vs signal threshold of DRC     (0=Below, 1=Above)
  2     Right DAC signal power vs signal threshold of DRC    (0=Below, 1=Above)
  1     DAC miniDSP Engine Standard Interrupt Port Output  (0=Read 0, 1=Read 1)
  0     DAC miniDSP Engine Auxiliary Interrupt Port Output (0=Read 0, 1=Read 1)
</TD></TR></TABLE>
This is (almost?) same as TSC[0:2Ch]. Maybe this is current state (non-sticky)?<BR>
<BR>
<B>TSC[0:2Fh] - Interrupt Flags ADC, non-sticky? (00h..18h) (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     Reserved
  6     Delta-sigma mono ADC signal power vs noise threshold for left AGC
  5     Reserved                                       (0=Greater, 1=Less)
  4     ADC miniDSP Engine Standard Interrupt Port Output  (0=Read 0, 1=Read 1)
  3     ADC miniDSP Engine Auxiliary Interrupt Port Output (0=Read 0, 1=Read 1)
  2     DC measurement using Delta Sigma Audio ADC
          (0=Not available, 1=Not available, too, uh?)
  1-0   Reserved. Write only zeros to these bits.
</TD></TR></TABLE>
This is (almost?) same as TSC[0:2Dh]. Maybe this is current state (non-sticky)?<BR>
<BR>
<B>TSC[0:30h] - INT1 Control Register (Select INT1 Sources) (00h)</B><BR>
<B>TSC[0:31h] - INT2 Control Register (Select INT2 Sources) (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     Headset-insertion detect                                  (0=Off, 1=On)
  6     Button-press detect                                       (0=Off, 1=On)
  5     DAC DRC signal-power                                      (0=Off, 1=On)
  4     ADC AGC noise                                             (0=Off, 1=On)
  3     Short-circuit                                             (0=Off, 1=On)
  2     Engine-generated                                          (0=Off, 1=On)
  1     DC measurement using Delta Sigma Audio ADC data-available (0=Off, 1=On)
  0     INT duration (0=Pulse Once, 1=Pulse Repeatedly until Acknowledge)
</TD></TR></TABLE>
Bit1-7 select which sources shall trigger INT1/INT2, a few more sources can be
selected in TSC[0:32h].Bit5-7.<BR>
Bit0 selects how the INT1/INT2 signal shall be pulsed (once with 2ms length, or
repeating every 4ms with 50% duty, until it gets acknowledged by reading
TSC[0:2Ch,2Dh,32h]).<BR>
<BR>
<B>TSC[0:32h] - INT1 and INT2 Control Register (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     INT1 upon SAR measurement data-out-of-threshold range   (0=Off, 1=Off?)
  6     INT1 upon Pen touch/SAR data-available                    (0=Off, 1=On)
  5     INT2 upon SAR measurement data-out-of-threshold range   (0=Off, 1=Off?)
  4     Reserved
  3     Pen touch detected                          (0=No, 1=Touch)     (R)
  2     Data available for read                     (0=No, 1=Available) (R)
  1     SAR data out of programmed threshold range  (0=No, 1=Out)       (R)
  0     Reserved. Write only the default value to this bit.             (R)
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsitsc033h3bhpincontrol"></A>&nbsp;
  DSi TSC[0:33h..3Bh], Pin Control
</FONT></TD></TR></TABLE><BR>
<B>TSC[0:33h] - GPIO1 In/Out Pin Control (00h..C2h)</B><BR>
<B>TSC[0:34h] - GPIO2 In/Out Pin Control (00h..C2h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-6   Reserved. Do not write any value other than reset value.
  5-2   GPIOx Mode                                                 (R/W)
          0 = GPIOx disabled (input and output buffers powered down)
          1 = GPIOx input mode (as secondary BCLK/WCLK/SDIN input, or
                   as ADC_WCLK input, Dig_Mic_In or in ClockGen block)
          2 = GPIOx input mode (as GPI general-purpose input)
          3 = GPIOx output = general-purpose output
          4 = GPIOx output = CLKOUT output
          5 = GPIOx output = INT1 output
          6 = GPIOx output = INT2 output
          7 = GPIOx output = ADC_WCLK output for codec interface
          8 = GPIOx output = secondary BCLK output for codec interface
          9 = GPIOx output = secondary WCLK output for codec interface
          10 = GPIOx output = ADC_MOD_CLK output for the digital microphone
          11 = GPIOx output = secondary SDOUT for codec interface
          12 = GPIOx output = TouchScreen/SAR ADC interrupt (active-low),
          13-15 = Reserved                              as PINTDAV signal
  1     GPIOx input buffer value (0 or 1)                         (R)
  0     GPIOx general-purpose output value (0 or 1)               (R/W)
</TD></TR></TABLE>
<BR>
<B>TSC[0:35h] - SDOUT (OUT Pin) Control (12h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-5   Reserved
  4     SDOUT bus keeper (0=Enabled, 1=Disabled)
  3-1   SDOUT Mode
          0 = SDOUT disabled (output buffer powered down)
          1 = SDOUT = primary SDOUT output for codec interface
          2 = SDOUT = general-purpose output
          3 = SDOUT = CLKOUT output
          4 = SDOUT = INT1 output
          5 = SDOUT = INT2 output
          6 = SDOUT = secondary BCLK output for codec interface
          7 = SDOUT = secondary WCLK output for codec interface
  0     SDOUT general-purpose output value (0 or 1)
</TD></TR></TABLE>
<BR>
<B>TSC[0:36h] - SDIN (IN Pin) Control (02h or 03h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-3   Reserved
  2-1   SDIN Mode
          0 = SDIN disabled (input buffer powered down)
          1 = SDIN enabled (as codec SDIN, Dig_Mic_In, or in ClockGen block)
          2 = SDIN enabled (as GPI general-purpose input)
          3 = Reserved
  0     SDIN input-buffer value (0 or 1)                          (R)
</TD></TR></TABLE>
<BR>
<B>TSC[0:37h] - MISO (OUT Pin) Control (02h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-5   Reserved
  4-1   MISO Mode
          0 = MISO disabled (output buffer powered down)
          1 = MISO = MISO output for SPI interface (or disabled for I2C)
          2 = General-purpose output
          3 = MISO = CLKOUT output
          4 = MISO = INT1 output
          5 = MISO = INT2 output
          6 = MISO = ADC_WCLK output for codec interface
          7 = MISO = ADC_MOD_CLK output for the digital microphone
          8 = MISO = secondary SDOUT for codec interface
          9 = MISO = secondary BCLK output for codec interface
          10 = MISO = secondary WCLK output for codec interface
          11-15 = Reserved
  0     MISO general-purpose output value (0 or 1)
</TD></TR></TABLE>
<BR>
<B>TSC[0:38h] - SCLK (IN Pin) Control (02h..03h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-3   Reserved
  2-1   SCLK Mode
          0 = SCLK disabled (input buffer powered down)
          1 = SCLK enabled (for the SPI interface)
          2 = SCLK enabled (as a GPI general-purpose input)
          3 = SCLK enabled (as secondary SDIN/BCLK/WCLK input,
                            or as ADC_WCLK input, or Dig_Mic_In)
  0     SCLK input buffer value (0 or 1)                         (R)
</TD></TR></TABLE>
<BR>
<B>TSC[0:39h] - GPI1 and GPI2 Pin Control (00h..11h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     Reserved. Write only zero to this bit.
  6-5   GPI1 Mode
          0 = GPI1 disabled (input buffer powered down)
          1 = GPI1 enabled (as secondary SDIN/BCLK/WCLK input, or ADC_WCLK inp)
          2 = GPI1 enabled (as a GPI general-purpose input)
          3 = Reserved (unlike below GPI2)
  4     GPI1 pin value (0 or 1)         (R)
  3     Reserved. Write only zero to this bit.
  2-1   GPI2 Mode
          0 = GPI2 disabled (input buffer powered down)
          1 = GPI2 enabled (as secondary BCLK/WCLK input, or ADC_WCLK input)
          2 = GPI2 enabled (as a GPI general-purpose input)
          3 = GPI2 enabled (as an HP_SP input)
  0     GPI2 pin value (0 or 1)         (R)
</TD></TR></TABLE>
<BR>
<B>TSC[0:3Ah] - GPI3 Pin Control (00h..10h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     Reserved. Write only zero to this bit.
  6-5   GPI3 Mode
          0 = GPI3 disabled (input buffer powered down)
          1 = GPI3 enabled (as secondary BCLK/WCLK input, or ADC_WCLK input)
          2 = GPI3 enabled (as a GPI general purpose input)
          3 = Reserved (Undocumented - used by DSi?)
  4     GPI3 pin value (0 or 1)         (R)
  3-0   Reserved. Write only zeros to these bits.
</TD></TR></TABLE>
<BR>
<B>TSC[0:3Bh] - Reserved (xxh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-0   Reserved. Write only zeros to these bits.
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsitsc03ch55hdacadcandbeep"></A>&nbsp;
  DSi TSC[0:3Ch..55h], DAC/ADC and Beep
</FONT></TD></TR></TABLE><BR>
<B>TSC[0:3Ch] - DAC Instruction Set (01h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-5   Reserved. Write only default value.
  4-0   DAC Signal Processing Block
          0      = DAC miniDSP is used for signal processing
          1..25  = DAC Signal Processing Block PRB_P1 .. PRB_P25
          26..31 = Reserved. Do not use.
</TD></TR></TABLE>
<BR>
<B>TSC[0:3Dh] - ADC Instruction Set (04h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-5   Reserved. Write only default values.
  4-0   ADC Signal Processing Block
          0      = ADC miniDSP is used for signal processing
          1..3   = Reserved
          4..6   = ADC Signal Processing Block PRB_R4 .. PRB_R6
          7..9   = Reserved
          10..12 = ADC Signal Processing Block PRB_R10 .. PRB_R12
          13..15 = Reserved
          16..18 = ADC Signal Processing Block PRB_R16 .. PRB_R18
          19..31 = Reserved. Do not write these sequences to these bits.
</TD></TR></TABLE>
<BR>
<B>TSC[0:3Eh] - Programmable Instruction Mode-Control Bits (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     Reserved
  6     ADC miniDSP Engine Auxiliary Control bit A (0 or 1)
  5     ADC miniDSP Engine Auxiliary Control bit B (0 or 1)
  4     Reset ADC miniDSP instruction counter at start of new frame (0=Yes)
  3     Reserved
  2     DAC miniDSP Engine Auxiliary Control bit A (0 or 1)
  1     DAC miniDSP Engine Auxiliary Control bit B (0 or 1)
  0     Reset DAC miniDSP instruction counter at start of new frame (0=Yes)
</TD></TR></TABLE>
Above DAC/ADC bit A and B can be used for conditional instructions like JMP.<BR>
<BR>
<B>TSC[0:3Fh] - DAC Data-Path Setup (14h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     Left-channel DAC            (0=Powered down, 1=Powered up)
  6     Right-channel DAC           (0=Powered down, 1=Powered up)
  5-4   Left-channel DAC data path  (0=Off, 1=Left Data, 2=Right Data, 3=Both)
  3-2   Right-channel DAC data path (0=Off, 1=Right Data, 2=Left Data, 3=Both)
  1-0   DAC channel volume control soft-stepping (0=One step per sample,
         1=One step per 2 samples, 2=Disabled, 3=Reserved)
</TD></TR></TABLE>
Wheras, Both=((L+R)/2).<BR>
<BR>
<B>TSC[0:40h] - DAC Volume Control (0Ch)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-4   Reserved. Write only zeros to these bits.
  3     Left-channel DAC  (0=Not muted, 1=Muted)
  2     Right-channel DAC (0=Not muted, 1=Muted)
  1-0   DAC Mono/Stereo Volume
          0: Use Left/Right volume control for Left/Right channels ("stereo")
          1: Use Right volume control for Both channels            ("mono")
          2: Use Left volume control for Both channels             ("mono")
          3: Same as 0                                             ("stereo")
</TD></TR></TABLE>
<BR>
<B>TSC[0:41h] - DAC Left Volume Control (00h)</B><BR>
<B>TSC[0:42h] - DAC Right Volume Control (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-0  Digital gain in 0.5dB units (-127..+48 = -63.5dB..+24dB, Other=Reserved)
</TD></TR></TABLE>
<BR>
<B>TSC[0:43h] - Headset Detection (00h..60h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     Headset detection Enable (0=Disabled, 1=Enabled)
  6-5   Headset detection (0=None, 1=Headset, 2=Reserved, 3=Headset+Mic) (R)
  4-2   Debounce for Glitch Rejection During Headset Detection
          (0..5 = 16ms, 32ms, 64ms, 128ms, 256ms, 512ms, 6..7=Reserved)
          (when TSC[3:10h] set to 1MHz)
  1-0   Debounce for Glitch Rejection During Headset Button-Press Detection
          (0..3 = 0ms, 8ms, 16ms, 32ms) (when TSC[3:10h] set to 1MHz)
</TD></TR></TABLE>
Sampling is 8x faster than above timings (eg. time=32ms uses 4ms sampling).<BR>
<BR>
<B>TSC[0:44h] - DRC Control 1 (0Fh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     Reserved. Write only the reset value to these bits.
  6     DRC for left channel  (0=Disabled, 1=Enabled)
  5     DRC for right channel (0=Disabled, 1=Enabled)
  4-2   DRC threshold  (0..7 = -3dB,-6dB,-9dB,-12dB,-15dB,-18dB,-21dB,-24dB)
  1-0   DRC hysteresis (0..3 = +0dB,+1dB,+2dB,+3dB)
</TD></TR></TABLE>
<BR>
<B>TSC[0:45h] - DRC Control 2 (38h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     Reserved. Write only the reset value to these bits.
  6-3   DRC Hold Time
          0  = DRC Hold Disabled        ;-disable
          1  = 32 DAC Word Clocks       ;\
          2  = 64 DAC Word Clocks       ;
          3  = 128 DAC Word Clocks      ;
          4  = 256 DAC Word Clocks      ; powers of 2
          5  = 512 DAC Word Clocks      ;
          6  = 1024 DAC Word Clocks     ;
          7  = 2048 DAC Word Clocks     ;
          8  = 4096 DAC Word Clocks     ;
          9  = 8192 DAC Word Clocks     ;
          10 = 16384 DAC Word Clocks    ;/
          11 = 1*32768 DAC Word Clocks  ;\
          12 = 2*32768 DAC Word Clocks  ;
          13 = 3*32768 DAC Word Clocks  ; multiples of 32768
          14 = 4*32768 DAC Word Clocks  ;
          15 = 5*32768 DAC Word Clocks  ;/
  2-0   Reserved. Write only the reset value to these bits.
</TD></TR></TABLE>
<BR>
<B>TSC[0:46h] - DRC Control 3 (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-4   DRC attack rate, "(4 SHR N) dB per DAC Word Clock"
        (0=4dB, 1=2dB, 2=1dB, ..., 15=0.000122dB per DAC Word Clock)
  3-0   DRC decay rate, "(1 SHR (N+6)) dB per DAC Word Clock"
        (0=0.0156dB, 1=0.00781dB, ..., 15=0.000000476dB per DAC Word Clock)
</TD></TR></TABLE>
<BR>
<B>TSC[0:47h] - Beep Generator and Left Beep Volume (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     Beep Generator Enable (0=Disabled/Duration ended, 1=Enabled/Busy)
          (self-clearing based on beep duration)
  6     Auto beep generator on pen touch (0=Disabled, 1=Enabled)
          (CODEC_CLKIN should be available for this and is
          used whenever touch is detected).
  5-0   Left-channel beep volume control "(2-N)dB" (0..63 = +2dB .. -61dB)
</TD></TR></TABLE>
The beep generator is only available in PRB_P25 DAC processing mode.<BR>
<BR>
<B>TSC[0:48h] - Beep Generator and Right Beep Volume (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-6   Beep Mono/Stereo Volume
          0: Use Left/Right volume control for Left/Right channels ("stereo")
          1: Use Right volume control for Both channels            ("mono")
          2: Use Left volume control for Both channels             ("mono")
          3: Same as 0                                             ("stereo")
  5-0   Right-channel beep volume control "(2-N)dB" (0..63 = +2dB .. -61dB)
</TD></TR></TABLE>
The beep generator is only available in PRB_P25 DAC processing mode.<BR>
<BR>
<B>TSC[0:49h,4Ah,4Bh] - Beep Length MSB,MID,LSB (0000EEh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  23-0  Number of samples for which beep need to be generated (24bit)
</TD></TR></TABLE>
<BR>
<B>TSC[0:4Ch,4Dh] - Beep Frequency Sin(x) MSB,LSB (10D8h)</B><BR>
<B>TSC[0:4Eh,4Fh] - Beep Frequency Cos(x) MSB,LSB (7EE3h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-0  Beep Frequency sin/cos values (16bit, each)
</TD></TR></TABLE>
These registers should be set to sin(2pi*fin/fS) and cos(2pi*fin/fS)
accordingly; where fin is the beep frequency and fS is the DAC sample rate.<BR>
<BR>
<B>TSC[0:50h] - Reserved (xxh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-0   Reserved. Write only the reset value to these bits.
</TD></TR></TABLE>
<BR>
<B>TSC[0:51h] - ADC Digital Mic (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     ADC channel   (0=Powered Down, 1=Powered Up)
  6     Reserved
  5-4   Digital microphone input  (0=GPIO1, 1=SCLK, 2=SDIN, 3=GPIO2)
  3     Digital microphone for delta-sigma mono ADC channel (0=Off, 1=On)
  2     Reserved
  1-0   ADC channel volume control soft-stepping (0=One step per sample,
         1=One step per 2 samples, 2=Disabled, 3=Reserved)
</TD></TR></TABLE>
<BR>
<B>TSC[0:52h] - ADC Digital Volume Control Fine Adjust (80h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     ADC channel   (0=Not muted, 1=Muted)
  6-4   Delta-Sigma Mono ADC Channel Volume Control Fine Gain
        (0=0dB, 1=-0.1dB, 2=-0.2dB, 3=-0.3dB, 4=-0.4dB, 5..7=Reserved)
  3-0   Reserved. Write only zeros to these bits.
</TD></TR></TABLE>
<BR>
<B>TSC[0:53h] - ADC Digital Volume Control Coarse Adjust (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     Reserved
  6-0   Delta-Sigma Mono ADC Channel Volume Control Coarse Gain
          0..39    = Reserved
          40       = -12 dB
          39       = -11.5 dB
          ...
          103      = +19.5 dB
          104      = +20 dB
          105..127 = Reserved
</TD></TR></TABLE>
<BR>
<B>TSC[0:54h,55h] - Reserved (xxh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-0   Reserved. Write only the reset value to these bits.
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsitsc056h7fhagcandadc"></A>&nbsp;
  DSi TSC[0:56h..7Fh], AGC and ADC
</FONT></TD></TR></TABLE><BR>
<B>TSC[0:56h] - AGC Control 1 (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     AGC (0=Disabled, 1=Enabled)
  6-4   AGC target level     (0=-5.5dB, 1=-8dB, 2=-10dB, 3=-12dB,
                              4=-14dB, 5=-17dB, 6=-20dB, 7=-24dB)
  3-0   Reserved. Write only zeros to these bits.
</TD></TR></TABLE>
<BR>
<B>TSC[0:57h] - AGC Control 2 (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-6   AGC hysterysis setting (0=1dB, 1=2dB, 2=4dB, 3=Disable AGC hysterysis)
  5-1   AGC noise threshold (and silence detection)
          0   = AGC noise/silence detection is disabled.
          1   = AGC noise threshold = -30dB
          2   = AGC noise threshold = -32dB
          3   = AGC noise threshold = -34dB
          ...
          29  = AGC noise threshold = -86dB
          30  = AGC noise threshold = -88dB
          31  = AGC noise threshold = -90dB
  0     Reserved. Write only zero to this bit.
</TD></TR></TABLE>
<BR>
<B>TSC[0:58h] - AGC Maximum Gain (7Fh, uh that's 7Fh=Reserved?)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     Reserved. Write only zero to this bit.
  6-0   AGC maximum gain in 0.5dB units (0..119=0..+59.5dB, 120..127=Reserved)
</TD></TR></TABLE>
<BR>
<B>TSC[0:59h] - AGC Attack Time (00h)</B><BR>
<B>TSC[0:5Ah] - AGC Decay Time (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-3   AGC attack/decay time, (N*2+1)*32/fS (0..31 = 1*32/fS .. 63*32/fS)
  2-0   AGC attack/decay time Multiply factor, 1 SHL N (0..7 = 1..128)
</TD></TR></TABLE>
Whereas, fS is the ADC sample rate.<BR>
<BR>
<B>TSC[0:5Bh] - AGC Noise Debounce (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-5   Reserved. Write only zeros to these bits.
  4-0   AGC noise debounce
          0..5   = 0/fS, 4/fS, 8/fS, 16/fS, 32/fS, 64/fS     ;\powers of 2
          6..10  = 128/fS, 256/fS, 512/fS, 1024/fS, 2048/fS  ;/
          11..14 = 1*4096/fS, 2*4096/fS, 3*4096/fS           ;\multiples
          14..31 = 4*4096/fS, .., 20*4096/fS, 21*4096/fS     ;/of 4096
</TD></TR></TABLE>
<BR>
<B>TSC[0:5Ch] - AGC Signal Debounce (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-4   Reserved. Write only zeros to these bits.
  3-0   AGC signal debounce
          0..5   = 0/fS, 4/fS, 8/fS, 16/fS, 32/fS, 64/fS     ;\powers of 2
          6..9   = 128/fS, 256/fS, 512/fS, 1024/fS           ;/
          10..13 = 1*2048/fS, 2*2048/fS, 3*2048/fS           ;\multiples
          13..15 = 4*2048/fS, 5*2048/fS, 6*2048/fS           ;/of 2048
</TD></TR></TABLE>
<BR>
<B>TSC[0:5Dh] - AGC Gain-Applied Reading (xxh) (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-0   Gain applied by AGC in 0.5dB units (-24..+119 = -12dB..+59.5dB)   (R)
</TD></TR></TABLE>
<BR>
<B>TSC[0:5Eh...65h] - Reserved (xxh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-0   Reserved. Do not write to these registers.
</TD></TR></TABLE>
<BR>
<B>TSC[0:66h] - ADC DC Measurement 1 (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     DC measurement for mono ADC channel (0=Disabled, 1=Enabled)
  6     Reserved. Write only reset value.
  5     DC measurement is done based on
          0: 1st order sinc filter with averaging of 2^D.
          1: 1st order low-pass IIR filter whose coefficients
              are calculated based on D value.
  4-0   DC Meaurement D setting (1..20 = D=1 .. D=20) (0 or 21..31=Reserved)
</TD></TR></TABLE>
<BR>
<B>TSC[0:67h] - ADC DC Measurement 2 (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     Reserved. Write only reset value.
  6     DC measurement data update (0=Enabled, 1=Disabled/allow stable reading)
        (Disabled: user can read the last updated data without corruption)
  5     For IIR based DC measurement, the measurment value is
          0: the instantaneous output of the IIR filter
          1: update before periodic clearing of the IIR filter
  4-0   IIR based DC measurment, average time setting:
          0       Infinite average is used
          1       Averaging time is 2^1 ADC modulator clock periods
          2       Averaging time is 2^2 ADC modulator clock periods
          ...
          19      Averaging time is 2^19 ADC modulator clock periods
          20      Averaging time is 2^20 ADC modulator clock periods
          21..31  Reserved. Don't use.
</TD></TR></TABLE>
<BR>
<B>TSC[0:68h,69h,6Ah] - ADC DC Measurement Output MSB,MID,LSB (R) (000000h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  23-0  ADC DC Measurement Output (24bit)
</TD></TR></TABLE>
<BR>
<B>TSC[0:6Bh...73h] - Reserved (xxh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-0   Reserved. Do not write to these registers.
</TD></TR></TABLE>
<BR>
<B>TSC[0:74h] - VOL/MICDET-Pin SAR ADC - Volume Control (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     DAC volume control is controlled by,
          0: controlled by control register (7-bit Vol ADC is powered down)
          1: controlled by pin.
  6     Clock for the 7-bit Vol ADC for pin volume control,
          0: Internal on-chip RC oscillator
          1: External MCLK
  5-4   Hysteresis
          0: No hysteresis for volume control ADC output
          1: Hysteresis of +/-1 bit
          2: Hysteresis of +/-2 bits
          3: Reserved. Do not write this sequence to these bits.
  3     Reserved. Write only reset value.
  2-0   Throughput of the 7-bit Vol ADC for pin volume control,
        When Bit6=1 and external MCLK is 12MHz:
          (0..7=15.625Hz, 31.25Hz, 62.5Hz, 125Hz, 250Hz, 500Hz, 1000Hz, 2000Hz)
        When Bit6=0 (use Internal oscillator):
          (0..7=10.68Hz, 21.35Hz, 42.71Hz, 85Hz?, 170Hz, 340Hz, 680Hz, 1370Hz)
</TD></TR></TABLE>
<BR>
<B>TSC[0:75h] - VOL/MICDET-Pin Gain (xxh) (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     Reserved. Write only zero to this bit.
  6-0   Gain applied by pin volume control
          0   = +18 dB
          1   = +17.5 dB
          2   = +17 dB
          ...
          35  = +0.5 dB
          36  = 0 dB
          37  = -0.5 dB
          ...
          89  = -26.5 dB
          90  = -27 dB    ;below in 1dB steps instead of 0.5dB steps !
          91  = -28 dB
          ...
          125 = -62 dB
          126 = -63 dB
          127 = Reserved
</TD></TR></TABLE>
<BR>
<B>TSC[0:76h...7Fh] - Reserved (xxh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-0   Reserved. Do not write to these registers.
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsitsc1xxhdacandadcroutingpgapowercontrolsandmisclogic"></A>&nbsp;
  DSi TSC[1:xxh], DAC and ADC Routing, PGA, Power-Controls and MISC Logic
</FONT></TD></TR></TABLE><BR>
<B>TSC[1:01h..1Dh] - Reserved (xxh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-0  Reserved. Do not write to these registers.
</TD></TR></TABLE>
<BR>
<B>TSC[1:1Eh] - Headphone and Speaker Amplifier Error Control (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-2  Reserved
  1    Reset HPL/HPR power-up bits upon short-circuit detect (0=Yes, 1=No)
  0    Reset SPL/SPR power-up bits upon short-circuit detect (0=Yes, 1=No)
</TD></TR></TABLE>
The HPL/HPR auto-reset occurs only if TSC[1:1Fh].Bit1=1 (action=power down).<BR>
<BR>
<B>TSC[1:1Fh] - Headphone Drivers (04h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7    HPL output driver (0=Powered down, 1=Powered up)
  6    HPR output driver (0=Powered down, 1=Powered up)
  5    Reserved. Write only zero to this bit.
  4-3  Output common-mode voltage (0=1.35V, 1=1.5V, 2=1.65V, 3=1.8V)
  2    Reserved. Write only 1 to this bit. (!!!)
  1    Action when short-circuit protection is enabled/detected,
           0=Limit the maximum current to the load.
           1=Power down the output driver.
  0    Short-circuit detected on the headphone driver (0=No, 1=Yes) (R)
</TD></TR></TABLE>
<BR>
<B>TSC[1:20h] - Class-D Speaker Amplifier (06h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7    Left-channel class-D output driver  (0=Powered down, 1=Powered up)
  6    Right-channel class-D output driver (0=Powered down, 1=Powered up)
  5-1  Reserved. Write only the reset value (00011b) to these bits (!!!)
  0    Short-circuit is detected on the class-D driver (0=No, 1=Yes) (R)
</TD></TR></TABLE>
Bit0 is Valid only if class-D amplifier is powered up. For short-circuit flag
sticky bit, see TSC[0:2Ch].<BR>
<BR>
<B>TSC[1:21h] - HP Output Drivers POP Removal Settings (3Eh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7    If power down sequence is activated by device software power down
       using TSC[1:2Eh].Bit7 then power down DAC,
         0: simultaneously with the HP and SP amplifiers.
         1: after HP and SP amplifiers are completely powered down.
         (the latter setting is to optimize power-down POP).
  6-3  Driver power-on time (at 8.2MHz) (1=15.3us, 2=153us, 3=1.53ms,
         4=15.3ms,5=76.2ms, 6=153ms, 7=304ms, 8=610ms, 9=1.22s, 10=3.04s,
         11=6.1s, 12..15=Reserved)
  2-1  Driver ramp-up step time (8.2MHz) (0=0ms, 1=0.98ms, 2=1.95ms, 3=3.9ms)
  0    Weakly driven output common-mode voltage is generated from,
         0=resistor divider of the AVDD supply.
         1=band-gap reference.
</TD></TR></TABLE>
<BR>
<B>TSC[1:22h] - Output Driver PGA Ramp-Down Period Control (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7    Reserved. Write only the reset value to this bit.
  6-4  Speaker Power-Up Wait Time (at 8.2MHz) (0=0 ms, 1=3.04 ms, 2=7.62 ms,
         3=12.2 ms, 4=15.3 ms, 5=19.8 ms, 6=24.4 ms, 7=30.5 ms)
  3-0  Reserved. Write only the reset value to these bits.
</TD></TR></TABLE>
<BR>
<B>TSC[1:23h] - DAC_L and DAC_R Output Mixer Routing (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-6  DAC_L route      (0=Nowhere, 1=To L-Mixer, 2=Direct to HPL, 3=Reserved)
  5    MIC input routed to the left-channel mixer amplifier      (0=No, 1=Yes)
  4    AUX1 input routed to the left-channel mixer amplifier     (0=No, 1=Yes)
  3-2  DAC_R route      (0=Nowhere, 1=To R-Mixer, 2=Direct to HPR, 3=Reserved)
  1    AUX1 input routed to the right-channel mixer amplifier    (0=No, 1=Yes)
  0    HPL driver output routed to HPR driver (for differential) (0=No, 1=Yes)
</TD></TR></TABLE>
<BR>
<B>TSC[1:24h] - Analog Volume to HPL (Left Headphone) (7Fh)</B><BR>
<B>TSC[1:25h] - Analog Volume to HPR (Right Headphone) (7Fh)</B><BR>
<B>TSC[1:26h] - Analog Volume to SPL (Left Speaker) (7Fh)</B><BR>
<B>TSC[1:27h] - Analog Volume to SPR (Right Speaker) (7Fh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7    Analog volume control routed to HPx/SPx output driver (0=No, 1=Yes)
  6-0  Analog volume control gain (non-linear) (0 dB to -78 dB)
</TD></TR></TABLE>
See Table 5-37 and Table 5-38, uh?<BR>
<BR>
<B>TSC[1:28h] - HPL Driver (Left Headphone) (02h)</B><BR>
<B>TSC[1:29h] - HPR Driver (Right Headphone) (02h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7    Reserved. Write only zero to this bit.
  6-3  HPx driver PGA  (0..9 = 0dB..9dB, 10..15=Reserved)
  2    HPx driver      (0=Muted, 1=Not muted)
  1    HPx driver during power down (0=Weakly driven to a common mode,
        1=High-impedance)
  0    All programmed gains to HPx have been applied (0=Not yet, 1=Yes/all) (R)
</TD></TR></TABLE>
<BR>
<B>TSC[1:2Ah] - SPL Driver (Left Speaker) (00h)</B><BR>
<B>TSC[1:2Bh] - SPR Driver (Right Speaker) (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-5  Reserved. Write only zeros to these bits.
  4-3  SPx class-D driver output stage gain (0=6dB, 1=12dB, 2=18dB, 3=24dB)
  2    SPx class-D driver (0=Muted, 1=Not muted)
  1    Reserved. Write only zero to this bit.
  0    All programmed gains to SPx have been applied (0=Not yet, 1=Yes/all) (R)
</TD></TR></TABLE>
<BR>
<B>TSC[1:2Ch] - HP Driver Control (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-5  Debounce time for the headset short-circuit detection
         (0..7 = 0us, 8us, 16us, 32us, 64us, 128us, 256us)
         (when TSC[3:10h] set to 1MHz)
  4-3  DAC Performance (0=Normal, 1=Increased, 2=Reserved, 3=Further Increased)
       (increased: by increased current, further: by increased current gain)
  2    HPL output driver type (0=Headphone, 1=Lineout)
  1    HPR output driver type (0=Headphone, 1=Lineout)
  0    Reserved. Write only zero to this bit.
</TD></TR></TABLE>
The clock used for the debounce has a clock period = debounce duration/8.<BR>
<BR>
<B>TSC[1:2Dh] - Reserved (xxh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-0  Reserved. Do not write to these registers.
</TD></TR></TABLE>
<BR>
<B>TSC[1:2Eh] - MICBIAS (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7    Device software power-down (0=Disabled, 1=PowerDown?-Enabled)
  6-4  Reserved. Write only zeros to these bits.
  3    Programmed MICBIAS is powered up when,
         0: not if headset detection is enabled but headset isn't inserted.
         1: always, even if headset isn't inserted.
  2    Reserved. Write only zero to this bit.
  1-0  MICBIAS output (0=Off, 1=2V, 2=2.5V, 3=AVDD)
</TD></TR></TABLE>
<BR>
<B>TSC[1:2Fh] - MIC PGA (80h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7    MIC PGA            (0=Controlled by bits6-0, 1=Force 0dB)
  6-0  PGA in 0.5dB units (0..119 = 0..59.5dB, 120..127=Reserved)
</TD></TR></TABLE>
<BR>
<B>TSC[1:30h] - P-Terminal Delta-Sigma Mono ADC Channel Fine-Gain Input (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-6  MIC to MIC PGA feed-forward    (0=Off, 1=10kOhm, 2=20kOhm, 3=40kOhm)
  5-4  AUX1 to MIC PGA feed-forward   (0=Off, 1=10kOhm, 2=20kOhm, 3=40kOhm)
  3-2  AUX2 to MIC PGA feed-forward   (0=Off, 1=10kOhm, 2=20kOhm, 3=40kOhm)
  1-0  Reserved. Write only zeros to these bits.
</TD></TR></TABLE>
Program Bit7-6 of registers TSC[1:30h] and TSC[1:31h] with same value. Input
impedance selection affects the microphone PGA gain. See the Analog Front End
section for details.<BR>
<BR>
<B>TSC[1:31h] - M-Terminal ADC Input Selection (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-6  CM to MIC PGA feed-forward     (0=Off, 1=10kOhm, 2=20kOhm, 3=40kOhm)
  5-4  AUX2 to MIC PGA feed-forward   (0=Off, 1=10kOhm, 2=20kOhm, 3=40kOhm)
  3-0  Reserved. Write only zeros to these bits.
</TD></TR></TABLE>
Program Bit7-6 of registers TSC[1:30h] and TSC[1:31h] with same value. Input
impedance selection affects the microphone PGA gain. See the Analog Front End
section for details.<BR>
<BR>
<B>TSC[1:32h] - Input CM Settings (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7    MIC input  (0=Floating, 1=Connected to CM internally)
        (when not used for MIC PGA and analog bypass)
  6    AUX1 input (0=Floating, 1=Connected to CM internally)
        (when not used for MIC PGA and analog bypass)
  5    AUX2 input (0=Floating, 1=Connected to CM internally)
        (when not used for MIC PGA)
  4-1  Reserved. Write only zeros to these bits.
  0    All programmed gains to ADC have been applied (0=Not yet, 1=Yes/all) (R)
</TD></TR></TABLE>
<BR>
<B>TSC[1:33h..FFh] - Reserved (xxh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-0  Reserved. Write only the reset value to these bits.
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsitsc3xxhtouchscreensarcontrolandtscfchxxhbuffer"></A>&nbsp;
  DSi TSC[3:xxh], Touchscreen/SAR Control and TSC[FCh:xxh], Buffer
</FONT></TD></TR></TABLE><BR>
<B>TSC[3:01h] - Reserved (xxh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-0   Reserved. Write only the reset value to these bits.
</TD></TR></TABLE>
<BR>
<B>TSC[3:02h] - SAR ADC Control 1 (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     Stop  (0=Normal mode, 1=Stop conversion and power down SAR ADC)
  6-5   SAR ADC resolution   (0=12bit, 1=8bit, 2=10bit, 3=12bit)
  4-3   SAR ADC clock divider
          0 = 1 (Use for 8bit resolution mode only) (This divider is only
                 for the conversion clock generation, not for other logic.)
          1 = 2 (Use for 8bit/10bit resolution mode only)
          2 = 4 (Recommended for better performance in 8bit/10bit mode)
          3 = 8 (Recommended for better performance in 12bit mode)
          (See Figure 5-40, uh?)
  2     Filter used for on-chip data averaging (0=Mean, 1=Median) (if enabled)
  1-0   On-chip data averaging for mean/median filter
          0 = On-chip data averaging disabled
          1 = 4-data averaging (mean),  or 5-data averaging (median)
          2 = 8-data averaging (mean),  or 9-data averaging (median)
          3 = 16-data averaging (mean), or 15-data averaging (median)
</TD></TR></TABLE>
<BR>
<B>TSC[3:03h] - SAR ADC Control 2 (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     Conversions controlled,
           0: Host-controlled conversions
           1: Self-controlled conversions for touch screen based on pen touch
  6     Reserved. Write only zero to this bit.
  5-2   Conversion mode
          0 = No scan
          1 = Scan X/Y         ;\Even in host-controlled mode ;\until either
          2 = Scan X/Y/Z1/Z2   ;/                             ; pen is lifted,
          3 = Scan X           ;\                             ; or a stop bit
          4 = Scan Y           ; Only in self-controlled mode ; TSC[3:02h].Bit7
          5 = Scan Z1/Z2       ;/                             ;/is sent
          6 = VBAT measurement
          7 = AUX2 measurement
          8 = AUX1 measurement
          9 = Auto scan. Sequence used is AUX1, AUX2, VBAT.
              Each of these inputs can be enabled or disabled independently
              using TSC[3:13h], and with that sequence is modified accordingly.
              Scan continues until stop bit TSC[3:02h].Bit7 is sent,
              or Bit5-2 of this register are changed.
         10 = TEMP1 measurement
         11 = Port scan: AUX1, AUX2, VBAT
         12 = TEMP2 measurement
         13-15 = Reserved. Do not write these sequences to these bits.
  1-0   Interrupt pin (GPIO1 or GPIO2 pin)
          0 = PEN-interrupt    /PENIRQ (active low)
          1 = Data-available   /DATA_AVA (active low)
          2 = PEN-interrupt    PENIRQ and Data-available DATA_AVA (active high)
          3 = Reserved
</TD></TR></TABLE>
<BR>
<B>TSC[3:04h] - Precharge and Sense (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     Pen touch detection (0=Enabled, 1=Disabled)
  6-4   Precharge time before touch detection
        (0..7 = 0.25us, 1us, 3us, 10us, 30us, 100us, 300us, 1000us)
        (when TSC[3:11h] set to 8MHz)
  3     Reserved. Write only zero to this bit.
  2-0   Sense time during touch detection
        (0..7 = 1us, 2us, 3us, 10us, 30us, 100us, 300us, 1000us)
        (when TSC[3:11h] set to 8MHz)
</TD></TR></TABLE>
<BR>
<B>TSC[3:05h] - Panel Voltage Stabilization (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-6   SAR comparator bias current (0=Normal, 1..3=Increase by 25%, 50%, 100%)
        (use Increase to support higher conversion clock)
  5     Sample duration (0=Default, 1=Doubled; for higher impedance)
  4-3   Reserved. Write only zeroes to these bits.
  2-0   Panel voltage stabilization time before conversion
        (0..7 = 0.25us, 1us, 3us, 10us, 30us, 100us, 300us, 1000us)
        (when TSC[3:11h] set to 8MHz)
</TD></TR></TABLE>
<BR>
<B>TSC[3:06h] - Voltage Reference (20h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     Reference for Non-touch-screen Measurement  (0=External, 1=Internal)
  6     Internal reference voltage   (0=1.25V, 1=2.5V)
  5     Internal reference powered   (0=Always, 1=Only during conversion)
  4     Reserved
  3-2   Reference Stabilization Time before Conversion
        (0=0us, 1=100us, 2=500us, 3=1ms) (when TSC[3:11h] set to 8MHz)
  1     Reserved
  0     Battery measurement input (0=VBAT&lt;=VREF, 1=VBAT=BAT)
</TD></TR></TABLE>
<BR>
<B>TSC[3:07h,08h] - Reserved (xxh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-0   Reserved. Write only the reset value to these bits.
</TD></TR></TABLE>
<BR>
<B>TSC[3:09h] - Status Bits 1 (40h) (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     Pen Touch detected          (0=Not detected, 1=Detected) (R)
  6     ADC Ready                   (0=Busy, 1=Ready)            (R)
  5     New data is available       (0=None, 1=Yes)              (R)
  4     Reserved. Write only the reset value to this bit.
  3     New X data is available     (0=None, 1=Yes)              (R)
  2     New Y data is available     (0=None, 1=Yes)              (R)
  1     New Z1 data is available    (0=None, 1=Yes)              (R)
  0     New Z2 data is available    (0=None, 1=Yes)              (R)
</TD></TR></TABLE>
Bit0-3 and Bit5 are not valid for the buffer mode.<BR>
Bit0-3 are cleared after reading the corresponding data.<BR>
Bit5 is cleared after completely reading ALL data.<BR>
<BR>
<B>TSC[3:0Ah] - Status Bits 2 (00h) (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     New AUX1 data is available  (0=None, 1=Yes)              (R)
  6     New AUX2 data is available  (0=None, 1=Yes)              (R)
  5     New VBAT data is available  (0=None, 1=Yes)              (R)
  4-2   Reserved. Write only zeros to these bits.
  1     New TEMP1 data is available (0=None, 1=Yes)              (R)
  0     New TEMP2 data is available (0=None, 1=Yes)              (R)
</TD></TR></TABLE>
Bit0-1 and Bit5-7 are not valid for the buffer mode.<BR>
Bit0-1 and Bit5-7 are cleared after reading the corresponding data.<BR>
<BR>
<B>TSC[3:0Bh,0Ch] - Reserved (xxh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-0   Reserved. Write only the reset value to these bits.
</TD></TR></TABLE>
<BR>
<B>TSC[3:0Dh] - Buffer Mode (03h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     Buffer Mode Enable (0=Disabled, Enabled)
          (when disabled: RDPTR/WRPTR/TGPTR are set to their default values)
  6     Buffer Mode Type   (0=Countinuos-conversion, 1=Single-shot)
  5-3   Trigger level for conversion "(N+1)*8*number of converted data"
          0..7 = (8..64)*number of converted data
          uh, does "X*number of converted data" mean "after X conversions"?
  2     Reserved
  1     Buffer Full  (0=No, 1=Full; contains 64 unread converted data)   (R)
  0     Buffer Empty (0=No, 1=Empty; contains 0 unread converted data)   (R)
</TD></TR></TABLE>
<BR>
<B>TSC[3:0Eh] - Reserved / Undocumented (read by DSi for Pen Down Test) (0Fh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-0   Reserved. Write only the reset value to these bits.
</TD></TR></TABLE>
<BR>
<B>TSC[3:0Fh] - Scan Mode Timer (40h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     Programmable delay for Touch-screen measurement (0=Disable, 1=Enable)
  6-4   Programmable interval timer delay
          (0..7 = 8ms, 1ms, 2ms, 3ms, 4ms, 5ms, 6ms, 7ms)
          (when TSC[3:10h] set to 1MHz)
  3     Programmable delay for Non-touch-screen auto measurement   (1=Enable)
  2-0   Programmable interval timer delay (0..7 = 1.12min, 3.36min,
          5.59min, 7.83min, 10.01min, 12.30min, 14.54min, 16.78min)
          (uh, what is that? minutes? minimum? or what?)
          (when TSC[3:10h] set to 1MHz)
</TD></TR></TABLE>
These delays are from the end of one data set of conversion to the start of
another new data set of conversion.<BR>
Bit7: This interval timer mode is for all self-controlled modes. For
host-controlled mode, it is valid only for (X/Y) or (X/Y/Z1/Z2) conversions.<BR>
<BR>
<B>TSC[3:10h] - Scan Mode Timer Clock (81h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     Clock used for Programmable Delay Timer (0=Internal Osc/8, 1=Ext. MCLK)
  6-0   MCLK Divider to Generate 1-MHz Clock for the Programmable Delay Timer
        (1..127=Div1..127, or 0=Div128)
</TD></TR></TABLE>
The timings marked "(when TSC[3:10h] set to 1MHz)" are assuming the MCLK
division result to be 1MHz (1us). Other divider settings will cause those
timings to change. Using Internal Osc/8 (Bit7=0) results in 1.025MHz (0.97us),
which is almost same as the "1MHz" timings (internal osc isn't too accurate
though).<BR>
Bit7: External clock is used only to control the delay programmed between the
conversions and not used for doing the actual conversion. This is supported to
get an accurate delay, because the internal oscillator frequency varies from
device to device.<BR>
<BR>
<B>TSC[3:11h] - SAR ADC Clock (81h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     Clock used for SAR ADC and TSC FSM (0=Internal Osc/1, 1=External MCLK)
  6-0   MCLK Divider for the SAR (min 40ns)  (1..127=Div1..127, or 0=Div128)
</TD></TR></TABLE>
The timings marked "(when TSC[3:11h] set to 8MHz)" are assuming the MCLK
division result to be 8MHz (125ns). Other divider settings will cause those
timings to change. For the SAR unit, the division result should be max 25MHz
(min 40ns). Using Internal Osc/1 (Bit7=0) results in 8.2MHz (122ns), which is
almost same as the "8MHz" timings (internal osc isn't too accurate though).<BR>
<BR>
<B>TSC[3:12h] - Debounce Time for Pen-Up Detection (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     Interface used for the buffer data reading   (0=SPI, 1=I2C)
  6     SAR/buffer data update is,
          0: held automatically (to avoid simultaneous buffer read and write
               operations) based on internal detection logic.
          1: held using software control and TSC[3:12h].Bit5.
  5     SAR/buffer data update is (only if above Bit6=1),
           0: enabled all the time
           1: stopped so that user can read the last updated data
                 without any data corruption.
  4-3   Reserved. Write only zeros to these bits.
  2-0   Pen-touch removal detection with debounce
          (0..7 = 0us, 8us, 16us, 32us, 64us, 128us, 256us, 512us)
          (when TSC[3:10h] set to 1MHz)
</TD></TR></TABLE>
The clock used for the debounce has a clock period = debounce duration/8.<BR>
<BR>
<B>TSC[3:13h] - Auto AUX Measurement Selection (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7     Auto AUX1 measurement during auto non-touch screen scan (0=Off, 1=On)
  6     Auto AUX2 measurement during auto non-touch screen scan (0=Off, 1=On)
  5     Auto VBAT measurement during auto non-touch screen scan (0=Off, 1=On)
  4     Auto TEMP measurement during auto non-touch screen scan (0=Off, 1=On)
  3     TEMP Measurement (0=Use TEMP1, 1=Use TEMP2)
  2     AUX1 Usage (0=Voltage measurement, 1=Resistance measurement)
  1     AUX2 Usage (0=Voltage measurement, 1=Resistance measurement)
  0     Resistance measurement bias (0=Internal bias, 1=External bias)
</TD></TR></TABLE>
<BR>
<B>TSC[3:14h] - Touch-Screen Pen Down (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-3   Reserved
  2-0   Debounce Time for Pen-Down Detection
          (0..7 = 0us, 64us, 128us, 256us, 512us, 1024us, 2048us, 4096us)
          (when TSC[3:10h] set to 1MHz)
</TD></TR></TABLE>
The clock used for the debounce has a clock period = debounce duration/8.<BR>
<BR>
<B>TSC[3:15h] - Threshold Check Flags Register (00h) (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-6   Reserved. Write only zeros to these bits.
  5     AUX1 Maximum (0=Inrange, 1=Exceeds Limit; Equal/Above MAX)
  4     AUX1 Minimum (0=Inrange, 1=Exceeds Limit; Equal/Below MIN)
  3     AUX2 Maximum (0=Inrange, 1=Exceeds Limit; Equal/Above MAX)
  2     AUX2 Minimum (0=Inrange, 1=Exceeds Limit; Equal/Below MIN)
  1     TEMP Maximum (0=Inrange, 1=Exceeds Limit; Equal/Above MAX)
  0     TEMP Minimum (0=Inrange, 1=Exceeds Limit; Equal/Below MIN)
</TD></TR></TABLE>
Sticky flag bIts. These are read-only bits. They are automatically cleared once
they are read and are set only if the source trigger occurs again.<BR>
<BR>
<B>TSC[3:16h,17h] - AUX1 Maximum Value Check MSB,LSB (0000h)</B><BR>
<B>TSC[3:18h,19h] - AUX1 Minimum Value Check MSB,LSB (0000h)</B><BR>
<B>TSC[3:1Ah,1Bh] - AUX2 Maximum Value Check MSB,LSB (0000h)</B><BR>
<B>TSC[3:1Ch,1Dh] - AUX2 Minimum Value Check MSB,LSB (0000h)</B><BR>
<B>TSC[3:1Eh,1Fh] - Temperature(TEMP1/TEMP2) Maximum Value Check MSB,LSB (0000h)</B><BR>
<B>TSC[3:20h,21h] - Temperature(TEMP1/TEMP2) Minimum Value Check MSB,LSB (0000h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-13  Reserved
  12     Threshold check (0=Disabled, 1=Enabled)
         (valid for auto/non-auto scan measurement).
  11-0   Threshold code (12bit)
</TD></TR></TABLE>
<BR>
<B>TSC[3:22h...29h] - Reserved (xxh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-0    Reserved. Write only the reset value to these bits.
</TD></TR></TABLE>
<BR>
<B>TSC[3:2Ah,2Bh] - X-Coordinate Data MSB,LSB (0000h) (R)</B><BR>
<B>TSC[3:2Ch,2Dh] - Y-Coordinate Data MSB,LSB (0000h) (R)</B><BR>
<B>TSC[3:2Eh,2Fh] - Z1 Register MSB,LSB (0000h) (R)</B><BR>
<B>TSC[3:30h,31h] - Z2 Register MSB,LSB (0000h) (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-0   Coordinate (16bit, each)
</TD></TR></TABLE>
Touchscreen X/Y coordinates and touchscreen Z1/Z2 pressure values.<BR>
<BR>
<B>TSC[3:32h...35h] - Reserved (xxh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-0    Reserved. Write only the reset value to these bits.
</TD></TR></TABLE>
<BR>
<B>TSC[3:36h,37h] - AUX1 Data MSB,LSB (0000h) (R)</B><BR>
<B>TSC[3:38h,39h] - AUX2 Data MSB,LSB (0000h) (R)</B><BR>
<B>TSC[3:3Ah,3Bh] - VBAT Data MSB,LSB (0000h) (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-0   Data from AUX1/AUX2/VBAT inputs accordingly
</TD></TR></TABLE>
<BR>
<B>TSC[3:3Ch...41h] - Reserved (xxh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-0    Reserved. Write only the reset value to these bits.
</TD></TR></TABLE>
<BR>
<B>TSC[3:42h,43h] - TEMP1 Data Register MSB,LSB (0000h) (R)</B><BR>
<B>TSC[3:44h,45h] - TEMP2 Data Register MSB,LSB (0000h) (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-0   Data from TEMP1/TEMP2 inputs accordingly
</TD></TR></TABLE>
<BR>
<B>TSC[3:46h...7Fh] - Reserved (xxh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-0    Reserved. Write only the reset value to these bits.
</TD></TR></TABLE>
<BR>
<B>TSC[FCh:01h,02h] - Buffer Mode Data MSB,LSB (xxxxh) (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15    Ring-buffer Full  (1=All 64 entries are unread)
  14    Ring-buffer Empty (1=All 64 entries are read)
  13    Reserved          (uh?)
  12    Data ID           (0=X/Z1/BAT/AUX2, 1=Y/Z2/AUX1/TEMP)
  11-0  Converted data (12bit)
</TD></TR></TABLE>
Reads from "RDPTR" ring-buffer location.<BR>
<BR>
<B>TSC[FCh:03h..7Fh] - Reserved (xxh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-0   Reserved. Write only the reset value to these bits.
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsitsc04h05hxxhadcdigitalfiltercoefficientram"></A>&nbsp;
  DSi TSC[04h..05h:xxh], ADC Digital Filter Coefficient RAM
</FONT></TD></TR></TABLE><BR>
Default values shown for this page only become valid 100 us following a
hardware or software reset.<BR>
<BR>
<B>TSC[04h-05h:xxh] - ADC Coefficient RAM (126 x 16bit)</B><BR>
Coefficients are signed 16bit (-32,768..+32,767), each occupying 2 bytes
(MSB,LSB).<BR>
The MSB should always be written first, immediately followed by the LSB (even
if only the MSB or LSB portion of the coefficient changes, both registers
should be written in this sequence).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
                   ADC miniDSP   ADC FIR Filter Special
                   Coefficients  Coefficients   Coefficients
  TSC[4:00h]       Page Select   -              -
  TSC[4:01h]       Reserved      -              -
  TSC[4:02h..07h]  C1..C3        -              N0,N1,D1 for AGC LPF
                                                  (first-order IIR, used
                                                  as averager to detect level)
  TSC[4:08h..0Dh]  C4..C6        -              N0,N1,D1 for ADC-programmable
                                                  first-order IIR
  TSC[4:0Eh..17h]  C7..C11       FIR0..FIR4     N0,N1,N2,D1,D2 for ADC Biquad A
  TSC[4:18h..21h]  C12..C16      FIR5..FIR9     N0,N1,N2,D1,D2 for ADC Biquad B
  TSC[4:22h..2Bh]  C17..C21      FIR10..FIR14   N0,N1,N2,D1,D2 for ADC Biquad C
  TSC[4:2Ch..35h]  C22..C26      FIR15..FIR19   N0,N1,N2,D1,D2 for ADC Biquad D
  TSC[4:36h..3Fh]  C27..C31      FIR20..FIR24   N0,N1,N2,D1,D2 for ADC Biquad E
  TSC[4:40h..7Fh]  C32..C63      -              -
  TSC[5:00h]       Page Select   -              -
  TSC[5:01h]       Reserved      -              -
  TSC[5:02h..7Fh]  C65..C127     -              -
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsitsc08h0fhxxhdacdigitalfiltercoefficientram"></A>&nbsp;
  DSi TSC[08h..0Fh:xxh], DAC Digital Filter Coefficient RAM
</FONT></TD></TR></TABLE><BR>
Default values shown for this page only become valid 100 us following a
hardware or software reset.<BR>
<BR>
<B>TSC[08h:01h] - DAC Coefficient RAM Control (00h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7-4   Reserved. Write only the reset value.
  3     DAC miniDSP generated flag for toggling MSB of coefficient RAM address
        (only used in non-adaptive mode)                                (R)
  2     DAC Adaptive Filtering in DAC miniDSP (0=Disabled, 1=Enabled)   (R/W)
  1     DAC Adaptive Filter Buffer Control Flag                         (R)
          aka DAC Coefficient Buffers in adaptive filter mode
             0: miniDSP accesses Buffer A,
                  external control interface (=the user?) accesses Buffer B
             1: miniDSP accesses Buffer B,
                  external control interface (=the user?) accesses Buffer A
  0     DAC Adaptive Filter Buffer Switch Control                       (R/W)
         0: DAC coefficient buffers will not be switched at next frame boundary
         1: DAC coefficient buffers will     be switched at next frame boundary
            (only if adaptive filtering mode is enabled)
            This bit will self-clear on switching.
</TD></TR></TABLE>
<BR>
<B>TSC[08h..0Bh:xxh] - DAC Coefficient RAM, DAC Buffer A (252 x 16bit)</B><BR>
Coefficients are signed 16bit (-32,768..+32,767), each occupying 2 bytes
(MSB,LSB).<BR>
The MSB should always be written first, immediately followed by the LSB (even
if only the MSB or LSB portion of the coefficient changes, both registers
should be written in this sequence).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
                   DAC miniDSP    Special
                  (DAC Buffer A)  DAC-programmable
                   Coefficient    Coefficient
  TSC[8:00h]       Page Select    -
  TSC[8:01h]       Control        - (see above)
  TSC[8:02h..0Bh]  C1..C5         N0,N1,N2,D1,D2 for Left Biquad A  ;N0=7FFFh
  TSC[8:0Ch..15h]  C6..C10        N0,N1,N2,D1,D2 for Left Biquad B  ;N1,N2,D1,
  TSC[8:16h..1Fh]  C11..C15       N0,N1,N2,D1,D2 for Left Biquad C  ;     D2=0
  TSC[8:20h..29h]  C16..C20       N0,N1,N2,D1,D2 for Left Biquad D
  TSC[8:2Ah..33h]  C21..C25       N0,N1,N2,D1,D2 for Left Biquad E
  TSC[8:34h..3Dh]  C26..C30       N0,N1,N2,D1,D2 for Left Biquad F
  TSC[8:3Eh..3Fh]  C31            -
  TSC[8:40h..41h]  C32            for 3D PGA for PRB_P23, PRB_P24 and PRB_P25
  TSC[8:42h..4Bh]  C33..C37       N0,N1,N2,D1,D2 for Right Biquad A
  TSC[8:4Ch..55h]  C38..C42       N0,N1,N2,D1,D2 for Right Biquad B
  TSC[8:56h..5Fh]  C43..C47       N0,N1,N2,D1,D2 for Right Biquad C
  TSC[8:60h..69h]  C48..C52       N0,N1,N2,D1,D2 for Right Biquad D
  TSC[8:6Ah..73h]  C53..C57       N0,N1,N2,D1,D2 for Right Biquad E
  TSC[8:74h..7Dh]  C58..C62       N0,N1,N2,D1,D2 for Right Biquad F
  TSC[8:7Eh..7Fh]  C63            -
  TSC[9:00h]       Page Select    -
  TSC[9:01h]       Reserved       - (do not write to this register)
  TSC[9:02h..07h]  C65..C67       N0,N1,D1 for Left first-order IIR
  TSC[9:08h..0Dh]  C68..C70       N0,N1,D1 for Right first-order IIR
  TSC[9:0Eh..13h]  C71..C73       N0,N1,D1 for DRC first-order high-pass filter
  TSC[9:14h..19h]  C74..C76       N0,N1,D1 for DRC first-order low-pass filter
  TSC[9:1Ah..7Fh]  C77..C127      -
  TSC[A:00h]       Page Select    -
  TSC[A:01h]       Reserved       - (do not write to this register)
  TSC[A:02h..7Fh]  C129..C191     -
  TSC[B:00h]       Page Select    -
  TSC[B:01h]       Reserved       - (do not write to this register)
  TSC[B:02h..7Fh]  C193..C255     -
</TD></TR></TABLE>
<BR>
<B>TSC[0Ch..0Fh:xxh] - DAC Coefficient RAM, DAC Buffer B (252 x 16bit)</B><BR>
This is essentially same as above Buffer A. But it's unclear if Buffer B is
having the same special Biquad/3DPGA/IRR/DRC functions (the official datasheet
doesn't mention them, but it does specify the initial reset values same as for
Buffer A, ie. with value 7FFFh for the locations that correspond to "N0"
coefficients, which is suggesting that those special functions are present in
Buffer B, too).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
                   DAC miniDSP    Special
                  (DAC Buffer A)  DAC-programmable
                   Coefficient    Coefficient
  TSC[C:02h..0Bh]  C1..C5         Unknown  ;\
  TSC[C:0Ch..15h]  C6..C10        Unknown  ;
  TSC[C:16h..1Fh]  C11..C15       Unknown  ; maybe Left Biquad A..F
  TSC[C:20h..29h]  C16..C20       Unknown  ; as for Buffer A
  TSC[C:2Ah..33h]  C21..C25       Unknown  ;
  TSC[C:34h..3Dh]  C26..C30       Unknown  ;/
  TSC[C:3Eh..3Fh]  C31            -
  TSC[C:40h..41h]  C32            Unknown maybe 3D PGA as for Buffer A
  TSC[C:42h..4Bh]  C33..C37       Unknown  ;\
  TSC[C:4Ch..55h]  C38..C42       Unknown  ;
  TSC[C:56h..5Fh]  C43..C47       Unknown  ; maybe Right Biquad A..F
  TSC[C:60h..69h]  C48..C52       Unknown  ; as for Buffer A
  TSC[C:6Ah..73h]  C53..C57       Unknown  ;
  TSC[C:74h..7Dh]  C58..C62       Unknown  ;/
  TSC[C:7Eh..7Fh]  C63            -
  TSC[D:00h]       Page Select    -
  TSC[D:01h]       Reserved       - (do not write to this register)
  TSC[D:02h..07h]  C65..C67       Unknown  ;\
  TSC[D:08h..0Dh]  C68..C70       Unknown  ; maybe IRR and DRC
  TSC[D:0Eh..13h]  C71..C73       Unknown  ; as for Buffer A
  TSC[D:14h..19h]  C74..C76       Unknown  ;/
  TSC[D:1Ah..7Fh]  C77..C127      -
  TSC[E:00h]       Page Select    -
  TSC[E:01h]       Reserved       - (do not write to this register)
  TSC[E:02h..7Fh]  C129..C191     -
  TSC[F:00h]       Page Select    -
  TSC[F:01h]       Reserved       - (do not write to this register)
  TSC[F:02h..7Fh]  C193..C255     -
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsitsc20h2bhxxhtsc40h5fhxxhadcdacinstructionram"></A>&nbsp;
  DSi TSC[20h..2Bh:xxh], TSC[40h..5Fh:xxh] ADC/DAC Instruction RAM
</FONT></TD></TR></TABLE><BR>
<B>TSC[20h..2Bh:xxh] - ADC DSP Engine Instruction RAM (384 x 24bit)</B><BR>
ADC miniDSP Instructions are 20bit, each occupying 3 bytes (MSB,MID,LSB) (with
dummy padding in upper 4bit of MSB).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  TSC[20h..2Bh:00h]       Page Select
  TSC[20h..2Bh:01h]       Reserved
  TSC[20h:02h...61h]      ADC Instructions 0...31
  TSC[21h:02h...61h]      ADC Instructions 32...63
  TSC[22h:02h...61h]      ADC Instructions 64...95
  TSC[23h:02h...61h]      ADC Instructions 96...127
  TSC[24h:02h...61h]      ADC Instructions 128...159
  TSC[25h:02h...61h]      ADC Instructions 160...191
  TSC[26h:02h...61h]      ADC Instructions 192...223
  TSC[27h:02h...61h]      ADC Instructions 224...255
  TSC[28h:02h...61h]      ADC Instructions 256...287
  TSC[29h:02h...61h]      ADC Instructions 288...319
  TSC[2Ah:02h...61h]      ADC Instructions 320...351
  TSC[2Bh:02h...61h]      ADC Instructions 352...383
  TSC[20h..2Bh:62h..7Fh]  Reserved
</TD></TR></TABLE>
<BR>
<B>TSC[40h..5Fh:xxh] - DAC DSP Engine Instruction RAM (1024 x 24bit)</B><BR>
DAC miniDSP Instructions are 24bit (uh, unlike 20bit ADC ones?), each occupying
3 bytes (MSB,MID,LSB).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  TSC[40h..5Fh:00h]       Page Select
  TSC[40h..5Fh:01h]       Reserved
  TSC[40h:02h...61h]      DAC Instructions 0...31
  TSC[41h:02h...61h]      DAC Instructions 32...63
  TSC[42h:02h...61h]      DAC Instructions 64...95
  TSC[43h:02h...61h]      DAC Instructions 96...127
  TSC[44h:02h...61h]      DAC Instructions 128...159
  TSC[45h:02h...61h]      DAC Instructions 160...191
  TSC[46h:02h...61h]      DAC Instructions 192...223
  TSC[47h:02h...61h]      DAC Instructions 224...255
  TSC[48h:02h...61h]      DAC Instructions 256...287
  TSC[49h:02h...61h]      DAC Instructions 288...319
  TSC[4Ah:02h...61h]      DAC Instructions 320...351
  TSC[4Bh:02h...61h]      DAC Instructions 352...383
  TSC[4Ch:02h...61h]      DAC Instructions 384...415
  TSC[4Dh:02h...61h]      DAC Instructions 416...447
  TSC[4Eh:02h...61h]      DAC Instructions 448...479
  TSC[4Fh:02h...61h]      DAC Instructions 480...511
  TSC[50h:02h...61h]      DAC Instructions 512...543
  TSC[51h:02h...61h]      DAC Instructions 544...575
  TSC[52h:02h...61h]      DAC Instructions 576...607
  TSC[53h:02h...61h]      DAC Instructions 608...639
  TSC[54h:02h...61h]      DAC Instructions 640...671
  TSC[55h:02h...61h]      DAC Instructions 672...703
  TSC[56h:02h...61h]      DAC Instructions 704...735
  TSC[57h:02h...61h]      DAC Instructions 736...767
  TSC[58h:02h...61h]      DAC Instructions 768...799
  TSC[59h:02h...61h]      DAC Instructions 800...831
  TSC[5Ah:02h...61h]      DAC Instructions 832...863
  TSC[5Bh:02h...61h]      DAC Instructions 864...895
  TSC[5Ch:02h...61h]      DAC Instructions 896...927
  TSC[5Dh:02h...61h]      DAC Instructions 928...959
  TSC[5Eh:02h...61h]      DAC Instructions 960...991
  TSC[5Fh:02h...61h]      DAC Instructions 992...1023
  TSC[40h..5Fh:62h..7Fh]  Reserved
</TD></TR></TABLE>
<BR>
The miniDSP instruction set isn't officially documented anywhere. Texas
Instruments has merely released an "assembler" for the miniDSP (that is, a
graphical drag-and-drop utility referred to as PurePath Studio).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsii2cbus"></A>&nbsp;
  DSi I2C Bus
</FONT></TD></TR></TABLE><BR>
<B>I2C Bus</B><BR>
<A HREF="#dsii2cioports">DSi I2C I/O Ports</A><BR>
<A HREF="#dsii2csignals">DSi I2C Signals</A><BR>
<BR>
<B>Device 4Ah (BPTWL chip) (LED/Volume/Powerbutton/Reset)</B><BR>
<A HREF="#dsii2cdevice4ahbptwlchip">DSi I2C Device 4Ah (BPTWL chip)</A><BR>
<BR>
<B>Device 78h/7Ah (Aptina MT9V113 Cameras)</B><BR>
<A HREF="#dsiaptinacamerainitialization">DSi Aptina Camera Initialization</A><BR>
Directly addressed I2C Registers (16bit index, 16bit data):<BR>
<A HREF="#dsiaptinacameraregisterssysctl0000h0051h">DSi Aptina Camera Registers: SYSCTL (0000h-0051h)</A><BR>
<A HREF="#dsiaptinacameraregistersrxssfusexdma0100h099fh">DSi Aptina Camera Registers: RX_SS, FUSE, XDMA (0100h-099Fh)</A><BR>
<A HREF="#dsiaptinacameraregisterscore3000h31ffh38xxh">DSi Aptina Camera Registers: CORE (3000h-31FFh, 38xxh)</A><BR>
<A HREF="#dsiaptinacameraregisterssoc13210h33fdh">DSi Aptina Camera Registers: SOC1 (3210h-33FDh)</A><BR>
<A HREF="#dsiaptinacameraregisterssoc23400h3729h">DSi Aptina Camera Registers: SOC2 (3400h-3729h)</A><BR>
Indirectly addressed MCU Variables (via above "XDMA" commands):<BR>
<A HREF="#dsiaptinacameravariablesramsfrmongpiomonitormcu0000h20xxh">DSi Aptina Camera Variables: RAM/SFR/MON (GPIO/Monitor) (MCU:0000h-20xxh)</A><BR>
<A HREF="#dsiaptinacameravariablesseqsequencermcu21xxh">DSi Aptina Camera Variables: SEQ (Sequencer) (MCU:21xxh)</A><BR>
<A HREF="#dsiaptinacameravariablesaeautoexposuremcu22xxh">DSi Aptina Camera Variables: AE (Auto Exposure) (MCU:22xxh)</A><BR>
<A HREF="#dsiaptinacameravariablesawbautowhitebalancemcu23xxh">DSi Aptina Camera Variables: AWB (Auto White Balance) (MCU:23xxh)</A><BR>
<A HREF="#dsiaptinacameravariablesfdantiflickermcu24xxh">DSi Aptina Camera Variables: FD (Anti-Flicker) (MCU:24xxh)</A><BR>
<A HREF="#dsiaptinacameravariablesmodemodecontextmcu27xxh">DSi Aptina Camera Variables: MODE (Mode/Context) (MCU:27xxh)</A><BR>
<A HREF="#dsiaptinacameravariableshghistogrammcu2bxxh">DSi Aptina Camera Variables: HG (Histogram) (MCU:2Bxxh)</A><BR>
I2C Bus Caution: The Camera I2C access requires the "16.76MHz Camera External
Clock" enabled in Port 4004004h.Bit8 on ARM9 Side. For accessing registers
other than SYSCTL/CORE, one must also clear the Standby flag in SYSCTL[0018h].<BR>
<BR>
<B>Device A0h/E0h (Unknown, maybe cameras from other manufacturer)</B><BR>
<A HREF="#dsialternatecamerasfromunknownmanufacturer">DSi Alternate Cameras from Unknown Manufacturer</A><BR>
<BR>
<B>Camera Data Transfers</B><BR>
Camera configuration is done on ARM7 side via serial I2C bus. However, the
actual Camera Data transfers are done on ARM9 side through 8bit parallel bus:<BR>
<A HREF="#dsicameras">DSi Cameras</A><BR>
<BR>
<B>Device 90h (Whatever)</B><BR>
Trying to read IC2 for this device just returns FFh?<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  REGISTER  WIDTH   DESCRIPTION
  02h       1       Used for DSi IRQ6 IF flags
                      uh, IF.Bit6 would be Timer3overflow ?
                      or, IF2.Bit6 would be PowerButton ?
  04h       1       Unknown (bit0 toggled)
</TD></TR></TABLE>
Unknown purpose. If the above "IRQ6 IF" blurb applies to IF2.Bit6, then this
device might be just an alternate version of the BPTWL chip...?<BR>
<BR>
<B>Device 40h (Whatever)</B><BR>
Trying to read IC2 for this device just returns FFh?<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Unknown?
</TD></TR></TABLE>
<BR>
<B>DSi I2C Devices</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Device  Delay   Bit0    Description
  7Ah     0       No    0 Camera0(internal?)  ;Aptina MT9V113 (SelfPortrait)
  78h     0       No    1 Camera1(external?)  ;Aptina MT9V113 (External)
  A0h     0       No    2 Camera0 config (Ext) ;\maybe for other manufacturer?
  E0h     0       No    3 Camera1 config (Self);/ or camera EEPROM ?
  4Ah     180h    Yes   4 BPTWL Chip (LED/Volume/Powerbutton/Reset)
  40h     0       Yes   5  ?
  90h     0       Yes   6  ?
</TD></TR></TABLE>
Delay: required swiWaitByLoop delay<BR>
Bit0: I2C_DATA bit0 set with dev addr required for reading (uh?)<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsii2cioports"></A>&nbsp;
  DSi I2C I/O Ports
</FONT></TD></TR></TABLE><BR>
<B>4004500h - DSi7 - I2C_DATA (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-7  Data (or Device, or Register)
</TD></TR></TABLE>
When sending data, I2C_DATA should be written &lt;before&gt; setting
I2C_CNT.bit7.<BR>
When reading data, I2C_DATA should be read &lt;after&gt; I2C_CNT.bit7 goes off.<BR>
Alongsides with the 8bit data, an additional 1bit "Ack" flag is transferred as
response to the data (ie. in opposite direction of data direction), the Ack is
located in I2C_CNT.Bit4, and it's usually indicating errors (or in some cases
it appears to be also used to indicate that no further data is to be
transferred).<BR>
<BR>
<B>4004501h - DSi7 - I2C_CNT (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0    Stop  (0=No, 1=Stop/last byte)
  1    Start (0=No, 1=Start/first byte)
  2    Pause (0=Transfer Data, 1=Pause after Error, used with/after Stop)
  3    Unknown/unused (0)
  4    Ack Flag         (0=Error, 1=Okay)  (For DataRead: W, for DataWrite: R)
  5    Data Direction   (0=Write, 1=Read)
  6    Interrupt Enable (0=Disable, 1=Enable)
  7    Start/busy       (0=Ready, 1=Start/busy)
</TD></TR></TABLE>
Original Nonsense:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0   Transfer Direction          (0=Write, 1=Read)
  1   Start/device select bit?
  2   Restart/device reselect bit?
  3   ?  (0)
  4   SCL hold. When clear SCL is being held low, set when SCL is high. This
        bit must always be set (by reading CNT again) after writing I2C_CNT.
        This bit must be set when writing blocks of data(more than 1 byte) with
        bit0 clear.
  5   SCL, toggle this for each loop iteration(in the loop execute the I2C WR
        code) with max 8 iterations where the loop exits successfully when bit
        4 is set. This bit must be set when writing blocks of data(more than 1
        byte) with bit0 clear.
  6   Unknown, always set when writing to CNT?
  7   Enable/busy, wait for this bit to clear after writing to I2C_CNT.  (R)
</TD></TR></TABLE>
Bit4 is read-only? Or automatically set/cleared?<BR>
Bit7 is read-only? (reads as 0) (except in whatever busy-condition?)<BR>
Bit0,1,2 and 5,6 are R/W.<BR>
Reportedly, there's an I2C interrupt - unknown how to enable/disable it, and
unknown when it get's triggered (supposedly after transferring a byte, or so).<BR>
<BR>
<B>I2C Protocol</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Wait for the busy bit to clear.
  Write the device address to I2C_DATA.
  Write 0xc2 to I2C_CNT (busy/enable, bit 6, and start bit 1 set).
  Execute swiWaitByLoop for a device-specific duration
  Write the register address to I2C_DATA
  Write 0xc0 to I2C_CNT (busy/enable and bit 6 set)
  Wait with swiWaitByLoop device duration
  When writing: Write the data to I2C_DATA.
</TD></TR></TABLE>
When reading, write the device address to I2C_DATA and write 0xc2 to I2C_CNT.<BR>
When the delay value is zero, write 0xc1 | i&lt;&lt;5 to I2C_CNT, otherwise
write 0xc0 | i&lt;&lt;5 to I2C_CNT, wait for busy to clear, delay, then write
0xc5 to I2C_CNT. For writing i is the loop i for iteration, for reading replace
that with 1. When reading, read the data from I2C_CNT. Return a error if
I2C_CNT bit 4 SCL hold is set, otherwise return normal.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsii2csignals"></A>&nbsp;
  DSi I2C Signals
</FONT></TD></TR></TABLE><BR>
Below is some pseudo code for the I2C signal transmission. The DSi hardware is
doing most of that stuff automatically. The pseudo code may be useful for
understanding the purpose of the start/stop/ack flags in the control register.<BR>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
       START D7  D6  D5  D4  D3  D2  D1  D0 ACK  D7  D6/ .. /D1  D0 ACK STOP
      __    ___ ___ ___ ___ ___ ___ ___ ___     ___ __/    /___ ___        ___
  SDA   |__|___|___|___|___|___|___|___|___|___|___|_/ .. /|___|___|______|
      ____   _   _   _   _   _   _   _   _   _   _  /    /   _   _   _   _____
  SCL     |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |/ .. / |_| |_| |_| |_|
                                                 /    /
       &lt;--&gt;&lt;------------------------------&gt;&lt;--&gt;&lt;--------------------&gt;&lt;--&gt;&lt;--&gt;
       Start    Device/Direction Byte      Ack   Index/Data Byte(s)  Ack Stop
</TD></TR></TABLE>
<BR>
SDA should be changed at/after falling SCL edge (except for Start/Stop
conditions, which are output during SCL=High).<BR>
The Device/Direction Byte is sent by master (the byte contains a 7bit device
address in bit7-1, and a direction flag in bit0). The direction of the follwing
index/data byte(s) depends on that direction flag (0=Write, 1=Read). The ACK
bit responses are sent in opposite direction as the preceeding byte.<BR>
The SCL line is driven by master, however, when the master changes SCL from Low
to HighZ, then the slave may keep SCL held Low to signalize that it isn't yet
ready for the next bit.<BR>
<BR>
<B>i2c_write_byte(send_start,send_stop,databyte):</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  if (send_start) then i2c_start_cond()                     ;-start (if so)
  for i=7 downto 0, i2c_write_bit(databyte.bit(i)), next i  ;-write 8bit
  nack = i2c_read_bit()                                     ;-read nack
  if (send_stop) then i2c_stop_cond()                       ;-stop (if so)
  return nack        ;return 0 if ack by the slave.         ;-return nack
</TD></TR></TABLE>
<BR>
<B>i2c_read_byte(nack,send_stop):</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  for i=7 downto 0, databyte.bit(i)=i2c_read_bit(), next i  ;-read 8bit
  i2c_write_bit(nack)                                       ;-write nack
  if (send_stop) then i2c_stop_cond()                       ;-stop (if so)
  return databyte                                           ;-return databyte
</TD></TR></TABLE>
<BR>
<B>i2c_write_bit(bit):</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  if (bit) then SDA=HighZ else SDA=Low          ;-
  I2C_delay()                                   ;-
  SCL=HighZ
  wait until SCL=High (or timeout)              ;-wait (for clock stretching)
  if (bit=1 and SDA=Low) then arbitration_lost();-errif other HW pulls SDA=low
  I2C_delay()                                   ;-
  SCL=Low                                       ;-
</TD></TR></TABLE>
<BR>
<B>i2c_read_bit():</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  SDA=HighZ                                     ;-let the slave drive data
  I2C_delay()                                   ;-delay (one half clk)
  SCL=HighZ
  wait until SCL=High (or timeout)              ;-wait (for clock stretching)
  bit = SDA                     ;-
  I2C_delay()                   ;-delay (one half clk)
  SCL=Low                       ;-
  return bit                    ;-
</TD></TR></TABLE>
<BR>
<B>i2c_start_cond():</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  if (started) then            ;if started, do a restart cond
    SDA=HighZ                   ;-set SDA to 1
    I2C_delay()
    SCL=HighZ
    wait until SCL=High (or timeout)         ;-wait (for clock stretching)
    I2C_delay()         ;Repeated start setup time, minimum 4.7us
  if (SDA=Low) then arbitration_lost()
  SDA=Low                       ;-
  I2C_delay()
  SCL=Low
  started = true
</TD></TR></TABLE>
<BR>
<B>i2c_stop_cond():</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  SDA=Low                               ;-
  I2C_delay()                           ;-
  SCL=HighZ                             ;-
  wait until SCL=High (or timeout)      ;-wait (for clock stretching)
  I2C_delay()   ;Stop bit setup time, minimum 4us
  if (SDA=Low) then arbitration_lost()
  I2C_delay()
  started = false
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsii2cdevice4ahbptwlchip"></A>&nbsp;
  DSi I2C Device 4Ah (BPTWL chip)
</FONT></TD></TR></TABLE><BR>
I2C Bus Caution: The BPTWL chip requires swiWaitByLoop(180h) after each I2C
byte transfer (if the Version/Speed byte at BPTWL[00h] indicates "Fast", then
the delay can be reduced to 90h instead of 180h).<BR>
<BR>
<B>BPTWL Chip (LED/Volume/Powerbutton/Reset) (Device 4Ah)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h     R   Version/Speed (usually 33h) (00h..20h=Slow, 21h..FFh=Fast)
  01h     R   Unknown (00h)
  02h     R   Unknown (50h)
  03h-0Fh -   Reserved (5Ah-filled)
  10h     R   Power Button (bit0=WasWhat?, bit1=IsDown, bit3=WasDown?)
                (bit0/3 are cleared after reading)
  11h     R/W Reset (00h=No, 01h=Force Reset, 02h=???)
  12h     R/W Power Button Tapping (00h=Auto-Reset, 01h=IRQ)
  13h-1Fh -   Reserved (5Ah-filled)
  20h     R   Battery State (bit0..3=Battery Level, bit7=Charge)
  21h     R/W Unknown (07h)
  22h-2Fh -   Reserved (5Ah-filled)
  30h     R/W Wifi LED related (13h=Normal/Auto?, 12h=Force Wifi LED Off)
  31h     R/W Camera LED (00h=Off, 01h=On, 02h=Blink)
  32h-3Fh -   Reserved (5Ah-filled)
  40h     R/W Volume Level (00h..1Fh)             ;\nonvolatile!
  41h     R/W Backlight Level (00h..04h)          ;/
  42h-5Fh -   Reserved (5Ah-filled)
  60h     ??  Unknown (00h) FFh: Disable I2C reading, and Purple Power LED?
  61h     R   Unknown (01h)
  62h     R   Unknown (50h)
  63h     R/W Unknown (00h) FFh: Purple Power LED (red+blue on)
  64h-6Fh -   Reserved (5Ah-filled)
  70h     R/W Bootflag (00h=Coldboot, 01h=Warmboot/SkipHealthSafety)
  71h     R/W Unknown (00h)
  72h-77h R/W Unknown (00h-filled)
  78h-7Fh -   Reserved (5Ah-filled)
  80h     R/W Unknown (10h)
  81h     R/W Unknown (64h)
  82h-FFh -   Reserved (5Ah-filled)
</TD></TR></TABLE>
The R/W values can be set to 00h..FFh (except Index 40h/41h are quickly cropped
to max 1Fh/04h, and Index 70h/71h are (after some time) cropped to 01h/02h).<BR>
Above should probably also include:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Forced volume (for alerts) (ie. alternately to current "user volume")
</TD></TR></TABLE>
<BR>
<B>DSi Power Button</B><BR>
Logically, the Power Button has two functions:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Short tap --&gt; reset (warmboot, go to DSi menu, without health and safety)
  Hold 1 second --&gt; power-off
</TD></TR></TABLE>
Technically, the button can have three functions:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Auto-Reset (used for NDS games)
  IRQ (supposed to be used with Manual-Reset) (used for DSi games)
  Forced Power-off (for games which fail to handle the IRQ within 5 seconds)
</TD></TR></TABLE>
DSi games should handle the IRQ as follows: First, do some clean up (like
finishing writes to SD/MMC storage; to avoid FAT corruption). Then, issue a
Reset manually (via I2C/BPTWL registers [70h]=01h/Warmboot, [11h]=01h/Reset).<BR>
Power-Off can be implemented via SPI/Power Managment Device, however, games
only need to implement Manual-Reset or Auto-Reset, but don't need to implement
Power-Off (the firmware will do that automatically if the button is held down
for 1 second after issuing the Reset).<BR>
Ideally, emulators should also reproduce the power button (when resetting or
closing the emulator): Signalize power-button and keep the emulation running
until the game responds by Reset (or until five second timeout). That will
allow the game to finish writes to emulated SD/MMC storage.<BR>
<BR>
<B>Older blurb...</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0x10    1       Power flags. When bit0 is set, arm7 does a system reset.
                    When bit1 or bit3 are set, arm7 does a shutdown. Bits 0-2
                    are used for DSi IRQ6 IF flags (uh, rather IF2 maybe?).
  0x11    1       Power reg? Writing value 1 here does a system reset.
                    Writing value 2 powers off all DSi-only hw (uh, what??)
  0x12    1       Might be MMC bus power related, unknown. (uh, MMC power??)
  0x20    1       Battery flags. When zero the battery is at critical level,
                    arm7 does a shutdown. Bit7 is set when the battery is
                    charging. Battery levels in the low 4-bits: battery icon
                    bars full 0xF, 3 bars 0xB, 2 bars 0x7, one solid red bar
                    0x3, and one blinking red bar 0x1. When plugging in or
                    removing recharge cord, this value increases/decreases
                    between the real battery level and 0xF, thus the battery
                    level while bit7 is set is useless.
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsiaptinacamerainitialization"></A>&nbsp;
  DSi Aptina Camera Initialization
</FONT></TD></TR></TABLE><BR>
Aptina I2C registers are accessed via 16bit index, and one or more data bytes
at auto-increasing indices (usually, all transfers are done as big-endian
2-byte (16bit) values at even indices). Additional MCU Variables are accessed
indirectly via XMDA registers.<BR>
<BR>
<B>aptina_get_chip_id:</B><BR>
Reading a 16bit value from index 0000h returns the CHIP_VERSION_REG
(2580h=MT9D113), the DSi games are actually reading that register, but they
seem to ignore it's value.<BR>
If the DSi isn't fitted with Aptina cameras, then reading anything from device
78h/7Ah would most likely return FFh-bytes.<BR>
<BR>
<B>brightness / low light environments</B><BR>
Below configurations are okay for daylight (without much sunshine), but the
picture will be almost completely black at night (in rooms with small bulbs).
There are probably numerous good/bad ways to manipulate the brightness. Some
random solutions are:<BR>
Leave AE_MIN_INDEX/AE_MAX_INDEX at their power-on defaults (instead of using
below settings) (the power-on defaults will greatly improve the brightness, but
the conversion will be also much slower). Increasing COARSE_INTEGRATION_TIME to
some big value (like 0800h) does also seem to raise the brightness.<BR>
<BR>
<B>aptina_code_list_init:</B><BR>
Below is some minimal initialization (though it might still include some
unnecessary stuff). Most important sections are leaving standby mode, matching
PLL to DSi timings, selecting desired resolution(s) and YUV color format.<BR>
DSi games are usually initializing further stuff like P0..P4 Coefficients,
Gamma Tables, and Color Correction Matrices - but the cameras are also working
when leaving those settings at their power-defaults.<BR>
It's recommended to initialize both cameras in parallel (eg. issue Wakeup to
&lt;both&gt; cameras, and &lt;then&gt; wait for Wakeup completion; this is
faster than doing it separately for each camera).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  AptWr     ,0001Ah,00003h   ;RESET_AND_MISC_CONTROL (issue reset)   ;\reset
  AptWr     ,0001Ah,00000h   ;RESET_AND_MISC_CONTROL (release reset) ;/
  AptWr     ,00018h,04028h   ;STANDBY_CONTROL (wakeup)               ;\
  AptWr     ,0001Eh,00201h   ;PAD_SLEW                               ; wakeup
  AptWr     ,00016h,042DFh   ;CLOCKS_CONTROL                         ;
  AptWaitClr,00018h,04000h   ;STANDBY_CONTROL (wait for WakeupDone)  ;
  AptWaitSet,0301Ah,00004h   ;UNDOC_CORE_301A (wait for WakeupDone)  ;/
  AptWrMcu  ,002F0h,00000h   ;UNDOC! RAM?
  AptWrMcu  ,002F2h,00210h   ;UNDOC! RAM?
  AptWrMcu  ,002F4h,0001Ah   ;UNDOC! RAM?
  AptWrMcu  ,02145h,002F4h   ;UNDOC! SEQ?
  AptWrMcu  ,0A134h,  001h   ;UNDOC! SEQ?
  AptSetMcu ,0A115h,  002h   ;SEQ_CAP_MODE (set bit1=video)
  AptWrMcu  ,02755h,00002h   ;MODE_OUTPUT_FORMAT_A (bit5=0=YUV)      ;\select
  AptWrMcu  ,02757h,00002h   ;MODE_OUTPUT_FORMAT_B                   ;/YUV mode
  AptWr     ,00014h,02145h   ;PLL_CONTROL                            ;\
  AptWr     ,00010h,00111h   ;PLL_DIVIDERS                           ; match
  AptWr     ,00012h,00000h   ;PLL_P_DIVIDERS                         ; PLL
  AptWr     ,00014h,0244Bh   ;PLL_CONTROL                            ; to DSi
  AptWr     ,00014h,0304Bh   ;PLL_CONTROL                            ; timings
  AptWaitSet,00014h,08000h   ;PLL_CONTROL (wait for PLL Lock okay)   ;
  AptClr    ,00014h,00001h   ;PLL_CONTROL (disable PLL Bypass)       ;/
  AptWrMcu  ,02703h,00100h   ;MODE_OUTPUT_WIDTH_A              ;\Size A
  AptWrMcu  ,02705h,000C0h   ;MODE_OUTPUT_HEIGHT_A             ;/ 256x192
  AptWrMcu  ,02707h,00280h   ;MODE_OUTPUT_WIDTH_B              ;\Size B
  AptWrMcu  ,02709h,001E0h   ;MODE_OUTPUT_HEIGHT_B             ;/ 640x480
  AptWrMcu  ,02715h,00001h   ;MODE_SENSOR_ROW_SPEED_A          ;\
  AptWrMcu  ,02719h,0001Ah   ;MODE_SENSOR_FINE_CORRECTION_A    ;
  AptWrMcu  ,0271Bh,0006Bh   ;MODE_SENSOR_FINE_IT_MIN_A        ; Sensor A
  AptWrMcu  ,0271Dh,0006Bh   ;MODE_SENSOR_FINE_IT_MAX_MARGIN_A ;
  AptWrMcu  ,0271Fh,002C0h   ;MODE_SENSOR_FRAME_LENGTH_A       ;
  AptWrMcu  ,02721h,0034Bh   ;MODE_SENSOR_LINE_LENGTH_PCK_A    ;/
  AptWrMcu  ,0A20Bh,  000h   ;AE_MIN_INDEX                     ;\AE min/max
  AptWrMcu  ,0A20Ch,  006h   ;AE_MAX_INDEX                     ;/
  AptWrMcu  ,0272Bh,00001h   ;MODE_SENSOR_ROW_SPEED_B          ;\
  AptWrMcu  ,0272Fh,0001Ah   ;MODE_SENSOR_FINE_CORRECTION_B    ;
  AptWrMcu  ,02731h,0006Bh   ;MODE_SENSOR_FINE_IT_MIN_B        ; Sensor B
  AptWrMcu  ,02733h,0006Bh   ;MODE_SENSOR_FINE_IT_MAX_MARGIN_B ;
  AptWrMcu  ,02735h,002C0h   ;MODE_SENSOR_FRAME_LENGTH_B       ;
  AptWrMcu  ,02737h,0034Bh   ;MODE_SENSOR_LINE_LENGTH_PCK_B    ;/
  AptSet    ,03210h,00008h   ;COLOR_PIPELINE_CONTROL (PGA pixel shading..)
  AptWrMcu  ,0A208h,  000h   ;UNDOC! RESERVED_AE_08
  AptWrMcu  ,0A24Ch,  020h   ;AE_TARGETBUFFERSPEED
  AptWrMcu  ,0A24Fh,  070h   ;AE_BASETARGET
  If Device=7Ah                                                ;\
    AptWrMcu,02717h,00024h   ;MODE_SENSOR_READ_MODE_A          ; Read Mode
    AptWrMcu,0272Dh,00024h   ;MODE_SENSOR_READ_MODE_B          ; with x-flip
  Else (xflip)                                                 ; on internal
    AptWrMcu,02717h,00025h   ;MODE_SENSOR_READ_MODE_A          ; camera
    AptWrMcu,0272Dh,00025h   ;MODE_SENSOR_READ_MODE_B          ;/
  If Device=7Ah                                                ;\
    AptWrMcu,0A202h,  022h   ;AE_WINDOW_POS                    ;
    AptWrMcu,0A203h,  0BBh   ;AE_WINDOW_SIZE                   ;
  Else (?)                                                     ;
    AptWrMcu,0A202h,  000h   ;AE_WINDOW_POS                    ;
    AptWrMcu,0A203h,  0FFh   ;AE_WINDOW_SIZE                   ;/
  AptSet    ,00016h,00020h   ;CLOCKS_CONTROL (set bit5=1, reserved)
  AptWrMcu  ,0A115h,  072h   ;SEQ_CAP_MODE (was already manipulated above)
  AptWrMcu  ,0A11Fh,  001h   ;SEQ_PREVIEW_1_AWB                ;\
  If Device=7Ah                                                ;
    AptWr   ,0326Ch,00900h  ;APERTURE_PARAMETERS               ;
    AptWrMcu,0AB22h,  001h  ;HG_LL_APCORR1                     ;
  Else (?)                                                     ;
    AptWr   ,0326Ch,01000h  ;APERTURE_PARAMETERS               ;
    AptWrMcu,0AB22h,  002h  ;HG_LL_APCORR1                     ;/
  AptWrMcu     ,0A103h,  006h   ;SEQ_CMD (06h=RefreshMode)
  AptWaitMcuClr,0A103h,  00Fh   ;SEQ_CMD (wait above to become ZERO)
  AptWrMcu     ,0A103h,  005h   ;SEQ_CMD (05h=Refresh)
  AptWaitMcuClr,0A103h,  00Fh   ;SEQ_CMD (wait above to become ZERO)
</TD></TR></TABLE>
Above does set two Mode/Contexts, 256x192 and 640x480. Yet unknown how to
activate the latter one.<BR>
<BR>
<B>aptina_code_list_activate:</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  AptClr    ,00018h,00001h   ;STANDBY_CONTROL (bit0=0=wakeup)       ;\
  AptWaitClr,00018h,04000h   ;STANDBY_CONTROL (wait for WakeupDone) ; Wakeup
  AptWaitSet,0301Ah,00004h   ;UNDOC_CORE_301A (wait for WakeupDone) ;/
  AptWr     ,03012h,000xxh   ;COARSE_INTEGRATION_TIME (Y Time)
  AptSet    ,0001Ah,00200h   ;RESET_AND_MISC_CONTROL (Parallel On)  ;-Data on
</TD></TR></TABLE>
Also, don't forget to activate the Camera LED via BPTWL chip (when using the
external camera).<BR>
<BR>
<B>aptina_code_list_deactivate:</B><BR>
Before activating another camera: First disable the Parallel output of the old
camera (for avoiding collisions on the camera's parallel databus). When not
using the camera for longer time, also enter standby mode (for reducing power
consumption).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  AptClr    ,0001Ah,00200h  ;RESET_AND_MISC_CONTROL (Parallel Off)  ;-Data off
  AptSet    ,00018h,00001h  ;STANDBY_CONTROL (set bit0=1=Standby)   ;\
  AptWaitSet,00018h,04000h  ;STANDBY_CONTROL (wait for StandbyDone) ; Standby
  AptWaitClr,0301Ah,00004h  ;UNDOC_CORE_301A (wait for StandbyDone) ;/
</TD></TR></TABLE>
<BR>
<B>References</B><BR>
There aren't any MT9V113 specs released, but info for MT9D113 (a higher
resolution variant) does exist: a pdf datasheet, and an xml reference for the
I2C registers.<BR>
There are several source code files for MT9V113 cameras (different files from
different people; for use with linux/android/whatever) including samples for
adjusting stuff like contrast and sharpness. However, observe that those source
code will initialize the PLL registers to values that don't match up for the
DSi, and, transfer should be YUV via 8bit parallel databus for DSi.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsiaptinacameraregisterssysctl0000h0051h"></A>&nbsp;
  DSi Aptina Camera Registers: SYSCTL (0000h-0051h)
</FONT></TD></TR></TABLE><BR>
<B>SYSCTL (0000h-0051h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0000h   2  CHIP_VERSION_REG       Model ID (2580h=MT9D113) (R)
  0006h  ..  RESERVED_SYSCTL_06     Reserved
  0010h   2  PLL_DIVIDERS           PLL Dividers (def=0366h)
               0-7   PLL M-Divider value (uh, actually a Multiplier?!)
               8-13  PLL N-Divider value
               14-15 Unused (0)
             Because the input clock frequency is unknown, the sensor starts
             up with the PLL disabled. The PLL takes time to power up. During
             this time, the behavior of its output clock signal is not
             guaranteed. The PLL output frequency is determined by two
             constants, M and N, and the input clock frequency.
               VCO = Fin * 2 * M / (N+1)
               PLL_output_frequency = VCO / (P1+1)
             The PLL can generate a master clock signal whose frequency is up
             to 85 MHz (input clock from 6 MHz through 54 MHz).
  0012h   2  PLL_P_DIVIDERS         PLL P Dividers (def=00F5h)
               0-3   P1 (00h..0Fh)
               4-7   Unspecified
               8-11  P3 (00h..0Fh)
               12-13 Division ratio of word clock/clockn from bit_clock (0..3)
               14    Unused (0)
               15    Unspecified
  0014h   2  PLL_CONTROL            PLL Control (def=21F9h)
               0     PLL Bypass
               1     PLL Enable
               2-3   Reserved (0..3)
               4-7   Reserved (0..0Fh)
               8     Reset_cntr
               9     Reserved
               10    Reserved
               11    Reserved
               12    Reserved
               13    Reserved
               14    Unused (0)
               15    PLL Lock (R)
  0016h   2  CLOCKS_CONTROL         Clocks Control
               0     Reserved
               1     Reserved
               2     Reserved
               3     Reserved
               4     Reserved
               5     Reserved/UNDOC/USED (manipulated by DSi)
               6     Reserved
               7     Reserved
               8     Reserved
               9     clk_clkin_en
               11-12 Reserved
               13    Reserved
               15    Reserved
  0018h   2  STANDBY_CONTROL        Standby Control and Status (def=4029h)
               0     Ship (uh?) (0=Enable various regs, 1=Standby)
               1     Reserved
               2     Stop MCU
               3     en_IRQ
               4     Reserved
               5     Reserved
               6-13  Unused (0)
               14    Standby_done (0=WakeupDone, 1=StandbyDone) (R?)
                       (takes MUCH time?)
               15    Reserved (R)
  001Ah   2  RESET_AND_MISC_CONTROL Reset and Control (def=0050h) (0-0333h)
               0     Reset SOC I2C
               1     MIPI_TX_Reset
               2     Unused (0)
               3     MIPI_TX_en       (=Serial Data?)
               4     IP_PD_en         (=Parallel Data or what?)
               5     Reserved
               6     Sensor_full_res
               7     Unused (0)
               8     OE_N_Enable
               9     Parallel_enable  (=Parallel Data?)
               10    Unused (0)
               11    Reserved
               12-15 Unused (0)
  001Ch   2  MCU_BOOT_MODE          MCU Boot Mode
               0     Reset MCU
               1     Reserved
               2     Reserved
               3     Reserved
               4-7   Reserved  (0..0Fh)
               8-15  Reserved  (0..FFh) (R)
  001Eh   2  PAD_SLEW               Pad Slew Control (def=0400h)
               0-2   Parallel Data Output Slew Rate Control (0-7)
               3     Unused (0)
               4-6   GPIO Slew Rate Control (0-7)
               7     Unused (0)
               8-10  PCLK aka PXLCLK Slew Rate Control (0-7)
               11-15 Unused (0)
  0020h  ..  RESERVED_SYSCTL_20     Reserved
  0022h   2  VDD_DIS_COUNTER        VDD_DIS_COUNTER (0..FFFFh, def=0438h)
  0024h   2  GPI_STATUS             GPI_STATUS      (0..000Fh) (R)
  0026h  ..  RESERVED_SYSCTL_26     Reserved
  0028h   2  EN_VDD_DIS_SOFT        EN_VDD_DIS_SOFT (0..0001h, def=0001h)
  0050h  ..  RESERVED_SYSCTL_50     Reserved
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsiaptinacameraregistersrxssfusexdma0100h099fh"></A>&nbsp;
  DSi Aptina Camera Registers: RX_SS, FUSE, XDMA (0100h-099Fh)
</FONT></TD></TR></TABLE><BR>
<B>RX_SS (0100h-0117h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0100h  ..  RESERVED_RX_SS_100     Reserved
  0102h   2  TEST_PXL_RED           Test Pixel Red    ;\Default value is 1FFh
  0104h   2  TEST_PXL_G1            Test Pixel Green1 ; for Gray Flat Field
  0106h   2  TEST_PXL_G2            Test Pixel Green2 ; (0..03FFh, def=01FFh)
  0108h   2  TEST_PXL_BLUE          Test Pixel Blue   ;/
  010Ah  ..  RESERVED_RX_SS_10A-116 Reserved
</TD></TR></TABLE>
<BR>
<B>FUSE_ROM (0800h-081Fh)</B><BR>
Reserved, unknown purpose, all zero in DSi.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0800h  ..  RESERVED_FUSE_ROM_800-81E  Reserved
</TD></TR></TABLE>
<BR>
<B>XDMA (0982h-099Fh)</B><BR>
Access to internal LOGICAL "driver" variables.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0982h  ..  RESERVED_XDMA_982      Reserved
  098Ch   2  MCU_ADDRESS            MCU Address (0000h..FFFFh)
               0-7   driver_variable (0..FFh)
               8-12  driver_id       (0..1Fh) (eg. 3=AWB, 7=MODE, etc.)
               13-14 address space   (0=Physical/RAM/SFR, 1=Logical/Variables)
               15    access_8_bit    (0=16bit, 1=8bit; converted to 16bit)
  0990h 8x2  MCU_DATA_0-7           MCU Data 0..7 (8 x 16bit)
</TD></TR></TABLE>
For reading, it's best to use "16bit" mode, no matter if reading an 8bit BYTE,
or a 16bit MSB,LSB value. The "8bit" mode is converting bytes to 16bit values
(MSB=00h, LSB=BYTE), which is a rather contraproductive idiotism; intended for
I2C functions that implement only 16bit data transfers, but no 8bit transfers.<BR>
Unknown what exactly is mapped at MCU_DATA_0-7 (probably the 16 bytes at
MCU_ADDRESS+0..15, probably with direct mapping / ie. without latching a copy
of that memory).<BR>
MCU_ADDRESS doesn't seem to increment after reading data, however, the i2c
index does increase, so one can probably read up to 16 bytes from MCU_DATA_0-7.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsiaptinacameraregisterscore3000h31ffh38xxh"></A>&nbsp;
  DSi Aptina Camera Registers: CORE (3000h-31FFh, 38xxh)
</FONT></TD></TR></TABLE><BR>
<B>CORE (3000h-31FFh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  3000h  ..  RESERVED_CORE_3000        Reserved (same as CHIP_VERSION_REG)
  3002h   2  Y_ADDR_START              Y1      ;\Image Position/Size ;def=0004h
  3004h   2  X_ADDR_START              X1      ; (up to including    ;def=0004h
  3006h   2  Y_ADDR_END                Y2      ; X2,Y2) (0-07FFh)    ;def=04BBh
  3008h   2  X_ADDR_END                X2      ;/                    ;def=064Bh
  300Ah   2  FRAME_LENGTH_LINES        Y Total ;\Total X/Y Size with ;def=0512h
  300Ch   2  LINE_LENGTH_PCK           X Total ;/blanking (0..FFFFh) ;def=0886h
  3010h  ..  RESERVED_CORE_3010        Reserved
  3012h   2  COARSE_INTEGRATION_TIME   Y Time  ;\Integration Time in ;def=0010h
  3014h   2  FINE_INTEGRATION_TIME     X Time  ;/lines/pix (0..FFFFh);def=00F6h
  3016h   2  ROW_SPEED                 Row Speed (def=0111h)
               0-2   Pixclk_speed (0..7)
               3     Unused (0)
               4-6   Reserved
               7     Unused (0)
               8-10  Reserved
               11-15 Unused (0)
  3018h  ..  RESERVED_CORE_3018-3019   Reserved
  301Ah      UNDOC_CORE_301A           Undocumented Status Reg (mask=D7FFh)
               0-1   Unspecified
               2     Undoc/USED (1=WakeupDone) (opposite of 0018h.bit14)
               3-4   Unspecified
               5     Whatever "demo_system, version_reg_write, value=1"
               6-8   Unspecified
               9     Mask_corrupted_frames     (alias of 3022h.bit0)
               10    Unspecified
               11    Unused (0)
               12    Unspecified
               13    Unused (0)
               14    Unspecified
               15    Grouped_parameter_hold    (alias of 3022h.bit8)
  301Ch  ..  RESERVED_CORE_301C-3020   Reserved
  3022h   2  GROUPED_PARAMETER_HOLD_MASK_CORRUPTED_FRAMES
               0     Mask_corrupted_frames  (alias of Reg 301Ah.bit9)
               1-7   Unused (0)
               8     Grouped_parameter_hold (alias of Reg 301Ah.bit15)
               9-15  Unused (0)
  3024h   2  PIXEL_ORDER                Pixel Order (mask=0300h, 0..0300h) (R)
  3026h  ..  RESERVED_CORE_3026         Reserved
  3028h   2  ANALOGUE_GAIN_CODE_GLOBAL  Analog Global   ;\
  302Ah   2  ANALOGUE_GAIN_CODE_GREENR  Analog GreenR   ; Analogue Gain Codes
  302Ch   2  ANALOGUE_GAIN_CODE_RED     Analog Red      ; with 3bit fraction
  302Eh   2  ANALOGUE_GAIN_CODE_BLUE    Analog Blue     ; (0..007Fh, def=000Bh)
  3030h   2  ANALOGUE_GAIN_CODE_GREENB  Analog GreenB   ;/
  3032h   2  DIGITAL_GAIN_GREENR        Digital GreenR  ;\Digital Gain with
  3034h   2  DIGITAL_GAIN_RED           Digital Red     ; 8bit dummy-fraction
  3036h   2  DIGITAL_GAIN_BLUE          Digital Blue    ; (bit8-10=Gain, 0..7)
  3038h   2  DIGITAL_GAIN_GREENB        Digital GreenB  ;/(mask=0700h,def=100h)
  303Ah  ..  RESERVED_CORE_303A-3C      Reserved
  3040h   2  READ_MODE                  Read Mode (0-DEFFh, def=0024h)
               0    horiz_mirror
               1    vert_flip
               2-4  y_odd_inc (0..7)
               5-7  x_odd_inc (0..7)
               8    Unused (0)
               9    low_power
               10   xy_bin_en
               11   x_bin_en
               12   bin_sum (Enable summing mode for binning)
               13   read_mode_y_sumen
               14   Reserved
               15   Reserved
  3044h  ..  RESERVED_CORE_3044-3048    Reserved
  304Ah   2  OTPM_CONTROL               One-time Programmable Memory? Control
               0    auto_wr_start              ;\
               1    auto_wr_end (finished) (R) ; automatic write sequence
               2    auto_wr_success (okay) (R) ;/
               3    unspecified
               4    auto_rd_start              ;\
               5    auto_rd_end (finished) (R) ; automatic read sequence
               6    auto_rd_success (okay) (R) ;/
               7-15 Unused (0)
  3050h  ..  RESERVED_CORE_3050-3054    Reserved
  3056h   2  GREEN1_GAIN                Gain Green1             ;\
  3058h   2  BLUE_GAIN                  Gain Blue               ; Gain Values
  305Ah   2  RED_GAIN                   Gain Red                ; (0..0FFFh,
  305Ch   2  GREEN2_GAIN                Gain Green2             ; def=022Ch)
               0-6   Initial Gain (0..7Fh, with 5bit fraction)  ;
               7-8   Analog Gain  (0..3)   (bit8+1)*(bit7+1)*(initial_gain/32)
               9-11  Digital Gain (1..7)                        ;
               12-15 Unused (0)                                 ;/
  305Eh  ..  RESERVED_CORE_305E-31DF    Reserved
  31E0h   2  UNDOC_CORE_31E0            (mask=E003h, 0..8001h, def=0001h) USED!
               Used by DSi (set to 0001h) (reportedly "PIX_DEF_ID")
  31E2h  ..  RESERVED_CORE_31E2-31F9    Reserved
  31FAh   2  UNDOC_CORE_31FA            Whatever (mask=FFFFh, def=CDEFh)
               0-4   Unspecified
               5-11  Whatever "demo_system, version_reg_read, value=3"
               12-15 Unspecified
  31FCh  ..  RESERVED_CORE_305E-31FE    Reserved
</TD></TR></TABLE>
<BR>
<BR>
<B>More CORE (3800h..3803h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  3800h  ..  RESERVED_CORE_3800-3802   Reserved
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsiaptinacameraregisterssoc13210h33fdh"></A>&nbsp;
  DSi Aptina Camera Registers: SOC1 (3210h-33FDh)
</FONT></TD></TR></TABLE><BR>
<B>SOC1 Registers (3210h-33FDh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  3210h   2  COLOR_PIPELINE_CONTROL     (mask=05B8h, 0..05B0h, def=01B0h)
               3   Enable PGA pixel shading correction
                     All coefficients and other configuration settings
                     (including other fields in this register) must be set up
                     before enabling shading correction.
               4   Enable 2D aperture correction
               5   Enable color correction
               7   Enable gamma correction
               8   Decimator (1=Enable scale)
               10  Reserved
  3216h  ..  RESERVED_SOC1_3216-321A    Reserved
  321Ch   2  OFIFO_CONTROL_STATUS       Ofifo control status 1 (def=0003h)
               0-3 txfifo_bypass
                     (0=tx_fifo, 1=sensor, 2=sam observe, 3=cpipe format,
                     4=test walking ones cpipe frequency,
                     5=test walking ones sensor frequency,
                     6=RESERVED, 7=test PIXCLK, 8..F=Unspecified)
               4-6 Unused (0)
               7   sensor_bypass (0=cpipe, 1=sensor)
               8   Reserved
               9   Reserved
               10  Reserved
               11  Reserved
               12  Reserved (R)
               13  Reserved (R)
               14  Reserved (R)
               15  Reserved (R)
  321Eh   2  OFIFO_CONTROL_STATUS_2     Ofifo control status 2 (def=0010h)
               0-9   Reserved (0..3FFh)
               10    Disable PV output clock during blank (1=disable)
               11-15 Reserved (0..1Fh)
  3220h  ..  RESERVED_SOC1_3220         Reserved
  3222h   2  LOWER_X_BOUND_ZOOM_WINDOW  Lower X  ;def=?      ;\Zoom Window
  3224h   2  UPPER_X_BOUND_ZOOM_WINDOW  Upper X  ;def=063Fh  ; Boundaries
  3226h   2  LOWER_Y_BOUND_ZOOM_WINDOW  Lower Y  ;def=?      ; (0..07FFh)
  3228h   2  UPPER_Y_BOUND_ZOOM_WINDOW  Upper Y  ;def=04AFh  ;/
  322Ah   2  UNDOC_SOC1_322A            (mask=0016h, 0..0016h) USED by DSi!
  322Ch   2  WEIGHT_HORIZ_DECIMATION    Scaling Weight X ;\Scaling Weight X,Y
  322Eh   2  WEIGHT_VERTICAL_DECIMATION Scaling Weight Y ;/(0..0FFFh, def=800h)
  323Eh   2  UNDOC_SOC1_323E            (0..FFFFh, def=1A2Dh) (DSi: C22Ch)
  3240h   2  UNDOC_SOC1_3240            (0..FFFFh, def=C814h) (DSi: 6214h)
  3242h  ..  RESERVED_SOC1_3242         Reserved
  3244h   2  UNDOC_SOC1_3244            (mask=03FFh, range=0..00FFh?, def=0310)
  3254h  ..  RESERVED_SOC1_3254-326A    Reserved
  326Ch   2  APERTURE_PARAMETERS        Aperture Params (0..7FFFh, def=0A08h)
               0-7   2D aperture threshold (knee) (00h-FFh)
               8-10  2D aperture gain (0-7)
               11-13 2D aperture gain's exponent (0-7)
               14    Abs (1=force aperture gain be positive)
               15    Unused (0)
  326Eh  ..  RESERVED_SOC1_326E-3276    Reserved
  327Ah   2  BLACK_LEVEL_1ST_RED        Offset Red     ;\Offsets subtracted
  327Ch   2  BLACK_LEVEL_1ST_GREEN1     Offset Green1  ; from RGB pixels
  327Eh   2  BLACK_LEVEL_1ST_GREEN2     Offset Green2  ; (0000-01FFh/03FFh,
  3280h   2  BLACK_LEVEL_1ST_BLUE       Offset Blue    ;/def=002Ah)
  328Eh   2  THRESH_EDGE_DETECT         Demosaic Edge Threshold (def=000Ch)
  3290h   2  TEST_PATTERN               Test Pattern Enable/Width
               0-4   Unused (0)
               5     en_walk_ones_tp  Enable Test Pattern (0=disable, 1=enable)
               6     walk_ones_10     Pattern Width (0=8-bit, 1=10-bit)
               7-15  Unused (0)
  329Eh  ..  RESERVED_SOC1_329E-32A0    Reserved
  32C0h   2  COLOR_CORR_MATRIX_SCALE_14 Exponents C11..C22 (0-7FFFh, def=3923h)
  32C2h   2  COLOR_CORR_MATRIX_SCALE_11 Exponents C23..C33 (0-0FFFh, def=0724h)
  32C4h   2  COLOR_CORR_MATRIX_1_2      Elements C11=LSB, C12=MSB   (def=7DCCh)
  32C6h   2  COLOR_CORR_MATRIX_3_4      Elements C13=LSB, C21=MSB   (def=2711h)
  32C8h   2  COLOR_CORR_MATRIX_5_6      Elements C22=LSB, C23=MSB   (def=62E5h)
  32CAh   2  COLOR_CORR_MATRIX_7_8      Elements C31=LSB, C32=MSB   (def=690Dh)
  32CCh   2  COLOR_CORR_MATRIX_9        Element C33=LSB, Signs=MSB  (def=2DCDh)
  32D4h   2  DIGITAL_GAIN_1_RED         Gain for Red channel    ;\Digital Gain1
  32D6h   2  DIGITAL_GAIN_1_GREEN1      Gain for Green1 channel ; (mul 128,
  32D8h   2  DIGITAL_GAIN_1_GREEN2      Gain for Green2 channel ; 0000h..03FFh,
  32DAh   2  DIGITAL_GAIN_1_BLUE        Gain for Blue channel   ;/def=0080h)
  32F4h  ..  RESERVED_SOC1_32F4-332E    Reserved
  3330h   2  OUTPUT_FORMAT_TEST         OUTPUT_FORMAT_TEST (0..0FFFh)
               0     Disable Cr channel
               1     Disable Y channel
               2     Disable Cb channel
               3-5   Test ramp output
               6     8+2 bypass
               7     Reserved
               8     Enable Lens Correction Bypass
               9     Reserved
               10    Reserved
               11    Reserved
               12-15 Unused (0)
  3332h  ..  RESERVED_SOC1_3332-334A    Reserved
  337Ch   2  YUV_YCBCR_CONTROL          YUV_YCBCR_CONTROL (0..000Fh, def=0006h)
               0     Mult_y_uv (normalize Y in 16-235; U and V in 16-240)
               1     Coefficient control
               2     Add 128 to U and V
               3     Clip Y in 16-235; U and V in 16-240
               4-15  Unused (0)
  337Eh   2  Y_RGB_OFFSET               Y_RGB Offset
               0-7   Reserved (0..FFh)
               8-15  Y offset (0..FFh)
  33E6h  ..  RESERVED_SOC1_33E6-33EE    Reserved
  33F4h   2  KERNEL_CONFIG              Kernel Config (0..01FFh, def=0003h)
               0     Defect correction (DC) enable
               1     Reserved
               2     Reserved
               3     Noise reduction (NR) enable
               4     Reserved
               5     Reserved
               6     Reserved
               7     Reserved
               8     Reserved
  33F6h  ..  RESERVED_SOC1_33F6-33FC    Reserved
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsiaptinacameraregisterssoc23400h3729h"></A>&nbsp;
  DSi Aptina Camera Registers: SOC2 (3400h-3729h)
</FONT></TD></TR></TABLE><BR>
<B>SOC2 (3400h-3729h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  3400h   2  MIPI_CONTROL              MIPI_Control (def=782Eh)
               0     MIPI restart enable
               1     MIPI standby
               2     Continuous MIPI clock
               3     Frame boundary sync bit (R)
               4     Wait until eof to react to standby
               5     Reserved
               6-8   MIPI channel number
               9     Unused (0) or Reserved (REV3)
               10-15 Data Type (1Eh=YUV422_8bit, 20h=RGB444, 21h=RGB555,
                       22h=RGB565, 2Ah=RAW8, 2Bh=RAW10)
  3402h   2  MIPI_STATUS               MIPI_Status (def=0011h)
               0     MIPI in standby (R)
               1-3   Unused (0)
               4     MIPI aka MIPICCP idle (R)
               5     MIPI ready to receive data (R)
               6-8   Unused (0)
               9     Reserved (R)
               10    Reserved (R)
               11    Reserved
               12    Reserved
               13-15 Unused (0)
  3404h   2  CUSTOM_SHORT_PKT          MIPI_Custom_Short_Packet (0000h-3F00h)
               0-5   Unused (0)
               6     frame_cnt_reset (sent in frame start/end short packets)
               7     frame_cnt_en (Insert frame counter value in WC field)
               8-10  custom_short_packet_data_type
               11    custom_short_packet_request
               12    custom_short_packet_frame_sync
               13    custom_short_packet_reset (R)
               14-15 Unused (0)
  3408h   2  LINE_BYTE_CNT             MIPI line byte count (def=0C80h)
  340Ch   2  CUSTOM_SHORT_PKT_WC       WC field of a custom short packet
  340Eh  ..  RESERVED_SOC2_340E-341A   Reserved
  3580h   2  AE_ZONE_X                 AE Window/Zone X (def=1300h)
               0-7:  ae_zone_x_start (00h..FFh) (div8)          ;for WINDOW
               8-15: ae_zone_x_width (00h..FFh) (div8, minus 1) ;for each ZONE
  3582h   2  AE_ZONE_Y                 AE Window/Zone Y (def=0E00h)
               0-7:  ae_zone_y_start (00h..FFh) (div8)          ;for WINDOW
               8-15: ae_zone_y_width (00h..FFh) (div8, minus 1) ;for each ZONE
  3584h   2  AE_WINDOW_SIZE_LO         LSBs ;\Size of each AE zone in pixels
  3586h   2  AE_WINDOW_SIZE_HI         MSBs ;/(0..0001FFFFh, def=000x4B00h ?)
  3588h  ..  RESERVED_SOC2_3588-35AE   Reserved
  35B0h      UNDOC_SOC2_35B0           (mask=FFFFh, 0..FFFFh, def=05FAh) USED!
  35B2h  ..  RESERVED_SOC2_35B2-3602   Reserved
  3604h  20  R_GAMMA_CURVE_KNEES_0-18  Red Gamma Curve Knees 0..18   (1B00h,..)
  3618h  20  G_GAMMA_CURVE_KNEES_0-18  Green Gamma Curve Knees 0..18 (1B00h,..)
  362Ch  20  B_GAMMA_CURVE_KNEES_0-18  Blue Gamma Curve Knees 0..18  (1B00h,..)
               Above 20-byte knees consist of ten 16bit values (Knee0 in LSB)
               Due to the 16bit-big-endian format, the byte-order is:
               Knee1,Knee0,Knee3,Knee2,...,Knee17,Knee16,UNUSED,Knee18
  3640h  ..  RESERVED_SOC2_3640        Reserved
  3642h   2  POLY_ORIGIN_R             Center Row    (max 07FFh, def=025Ch)
  3644h   2  POLY_ORIGIN_C             Center Column (max 07FFh, def=0324h)
  3646h  ..  RESERVED_SOC2_3646-364C   Reserved
  364Eh 5x2  P_GR_P0Q0-4               P0Q for Green1  ;\P0 Coefficients
  3658h 5x2  P_RD_P0Q0-4               P0Q for Red     ; (5 x float16 each)
  3662h 5x2  P_BL_P0Q0-4               P0Q for Blue    ; (0010h,... each)
  366Ch 5x2  P_GB_P0Q0-4               P0Q for Green2  ;/
  3676h 5x2  P_GR_P1Q0-4               P1Q for Green1  ;\
  3680h 5x2  P_RD_P1Q0-4               P1Q for Red     ; P1 Coefficients
  368Ah 5x2  P_BL_P1Q0-4               P1Q for Blue    ; (5 x float16 each)
  3694h 5x2  P_GB_P1Q0-4               P1Q for Green2  ;/
  369Eh 5x2  P_GR_P2Q0-4               P2Q for Green1  ;\
  36A8h 5x2  P_RD_P2Q0-4               P2Q for Red     ; P2 Coefficients
  36B2h 5x2  P_BL_P2Q0-4               P2Q for Blue    ; (5 x float16 each)
  36BCh 5x2  P_GB_P2Q0-4               P2Q for Green2  ;/
  36C6h 5x2  P_GR_P3Q0-4               P3Q for Green1  ;\
  36D0h 5x2  P_RD_P3Q0-4               P3Q for Red     ; P3 Coefficients
  36DAh 5x2  P_BL_P3Q0-4               P3Q for Blue    ; (5 x float16 each)
  36E4h 5x2  P_GB_P3Q0-4               P3Q for Green2  ;/
  36EEh 5x2  P_GR_P4Q0-4               P4Q for Green1  ;\
  36F8h 5x2  P_RD_P4Q0-4               P4Q for Red     ; P4 Coefficients
  3702h 5x2  P_BL_P4Q0-4               P4Q for Blue    ; (5 x float16 each)
  370Ch 5x2  P_GB_P4Q0-4               P4Q for Green2  ;/
  3716h  ..  RESERVED_SOC2_3716-3278   Reserved
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsiaptinacameravariablesramsfrmongpiomonitormcu0000h20xxh"></A>&nbsp;
  DSi Aptina Camera Variables: RAM/SFR/MON (GPIO/Monitor) (MCU:0000h-20xxh)
</FONT></TD></TR></TABLE><BR>
<B>Internal RAM (MCU:0000h..0xxxh)</B><BR>
Internal RAM is reserved for whatever internal purposes (probably including for
storing the 'logical variables' at MCU:2xxxh at some physical memory locations
at MCU:0xxxh). However, some of those undocumented reserved RAM cells are
manipulated by DSi games:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  02F0h   2  UNDOC_RAM_02F0   (set to 0000h by DSi games)
  02F2h   2  UNDOC_RAM_02F2   (set to 0210h by DSi games)
  02F4h   2  UNDOC_RAM_02F4   (set to 001Ah by DSi games)
</TD></TR></TABLE>
Exact RAM Size is unknown (around 2Kbyte or so)? Some Aptina chips do also
contain some sort of User RAM (at 0800h or so) for unknown purpose (just
general purpose storage maybe). Unknown if the DSi chips are having any such
User RAM.<BR>
<BR>
<B>Special Function Registers SFR (MCU:1040h..10FEh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1040h  ..  RESERVED_SFR_1040-1050    Reserved
  1060h  ..  RESERVED_SFR_1060-1066    Reserved (REV3)
  1070h   2  GPIO_DATA                 GPIO Data  (0..1E00h)
               0-8   Unused (0)
               9-12  gpio_3_0_data
               13-15 Unused (0)
  1072h   2  RESERVED_SFR_1072         Reserved
  1074h   2  GPIO_OUTPUT_SET           GPIO Set   (0..0C00h/1E00h?) (W)
               0-8   Unused (0)
               9-12  gpio_3_0_output_toggle (uh, toggle or set?)
               13-15 Unused (0)
  1076h   2  GPIO_OUTPUT_CLEAR         GPIO Clear (0..0C00h/1E00h?) (W)
               0-8   Unused (0)
               9-12  gpio_3_0_output_clear
               13-15 Unused (0)
  1078h   2  GPIO_DIR                  GPIO Direction (0..1E00h, def=1E00h)
               0-8   Unused (0)
               9     gpio_0_dir (0=Output, 1=Input) ;(LSB0 of 10bit Output)
               10    gpio_1_dir (0=Output, 1=Input) ;(LSB1 of 10bit Output)
               11    gpio_2_dir (0=Output, 1=Input) ;(Flash/Shutter Pulse)
               12    gpio_3_dir (0=Output, 1=Input) ;(OE_BAR for Databus)
               13-15 Unused (0)
  107Ah  ..  RESERVED_SFR_107A-10FD    Reserved
</TD></TR></TABLE>
<BR>
<B>Monitor Variables MON (MCU:2000h..2025h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  2000h   5  RESERVED_MON_00-04        Reserved
  2005h   1  MON_CMD                   Monitor Command (0..FFh)
  2006h   2  MON_ARG1                  Monitor First Argument (0..FFFFh)
  2008h  ..  RESERVED_MON_08-22        Reserved
  2024h   2  MON_PATCH_ID_0            Monitor First Patch (0..FFFFh) (REV1)
               0-7   mon_patch_0_version (00h-0Fh)
                       The version number of the first patch (R)
               8-15  mon_patch_0_number  (00h-0Fh)
                       Identifies which patch the first patch is (R)
  2024h   1  MON_PATCH_ID_0            (mask=FFh) (R) ;\unlike above  (REV3)
  2025h   1  MON_PATCH_ID_1            (0..FF)        ;/REV1 specs    (REV3)
  2026h   1  MON_PATCH_ID_2            (0..FF)                        (REV3)
  2027h   1  RESERVED_MON_27           Reserved                       (REV3)
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsiaptinacameravariablesseqsequencermcu21xxh"></A>&nbsp;
  DSi Aptina Camera Variables: SEQ (Sequencer) (MCU:21xxh)
</FONT></TD></TR></TABLE><BR>
<B>Sequencer Variables SEQ (MCU:2100h..215Ah)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  2100h  ..  RESERVED_SEQ_00           Reserved
  2102h   1  SEQ_MODE                  SEQ Mode (enables "drivers") (def=0Fh)
               0    Enable AE   (ID=2)
               1    Enable FD   (ID=4)
               2    Enable AWB  (ID=3)
               3    Enable HG   (ID=11)
               4-7  Unspecified
  2103h   1  SEQ_CMD                   SEQ Cmd   (0..FFh, def=01h)
               0-7  Cmd   (0=Run, 1=Preview, 2=Capture, 3=Standby,
                          4=Lock, 5=Refresh, 6=Refresh Mode)
  2104h   1  SEQ_STATE                 SEQ State (0..FFh)
               0-7  State (0=Run, 1=ToPreview, 2=Enter, 3=Preview
                           4=Leave, 5=ToCapture, 6=Enter, 7=Capture,
                           8=Leave, 9=Standby)
  2105h  ..  RESERVED_SEQ_05           Reserved
  2106h   1  SEQ_FLASHTYPE             Type of flash to be used
               0-6 Flash Type (0=None, 1=LED, 2=Xenon, 3=XenonBurst)
               7   Set flash to LOCK mode (0=Normal, 1=LOCK mode)
  2107h  ..  RESERVED_SEQ_07-08        Reserved
  2109h   1  SEQ_AE_FASTBUFF           AE Fast Buff  (0..FFh, def=10h)
  210Ah   1  SEQ_AE_FASTSTEP           AE Fast Step  (0..FFh, def=02h)
  210Bh   1  SEQ_AWB_CONTBUFF          AWB Cont Buff (0..FFh, def=08h)
  210Ch   1  SEQ_AWB_CONTSTEP          AWB Cont Step (0..FFh, def=02h)
  210Dh  ..  RESERVED_SEQ_0D-10        Reserved
  2111h   1  SEQ_OPTIONS               SEQ Options (0..FFh, def=08h)
               0  Reserved
               1  Reserved
               2  Reserved
               3  seq_crop_win_ae, Use crop window for AE statistics
               4  seq_crop_win_awb, Use crop window for AWB statistics
               7  Reserved
  2112h  ..  RESERVED_SEQ_12           Reserved
  2113h   2  SEQ_FLASH_TH              SEQ Flash TH (0..FFFFh)
  2115h   1  SEQ_CAP_MODE              Capture mode (in Capture state only)
               0  Xenon Flash (Still Only)
               1  Video
               2  Turn Flash off before last frame in capture state
               4  Video AE on
               5  Video AWB on
               6  Video HG on
  2116h   1  SEQ_CAP_NUMFRAMES         Num still frames captured (0..FFh,def=3)
  2117h   1  SEQ_PREVIEW_0_AE          Preview 0 AE (PREVIEW ENTER)     ;\
               0-3  AE (0=Off, 1=Fast, 2=Manual, 3=Continuous, 4=MDR)   ;
               4-7  Unspecified (0..5) (0..0Fh for PREVIEW_2/3)         ; Pre-
  2118h   1  SEQ_PREVIEW_0_FD          Preview 0 FD (PREVIEW ENTER)     ; view
               0-7  FD (0=Off, 1=Continuous, 2=Manual)                  ; 0
  2119h   1  SEQ_PREVIEW_0_AWB         Preview 0 AWB (PREVIEW ENTER)    ;
               0-7  AWB (0=Off, 1=On)                                   ; PRE-
  211Ah   1  SEQ_PREVIEW_0_HG          Preview 0 HG (PREVIEW ENTER)     ; VIEW
               0-7  HG (0=Off, 1=Fast, 2=Manual, 3=Continuous)          ; ENTER
  211Bh   1  SEQ_PREVIEW_0_FLASH       Flash Config (0..FFh)            ;
               0-6 Flash (0=Off,1=On,2=Locked,3=AutoEvaluate,7=UserDef) ;
               7   Reserved                                             ;
  211Ch   1  SEQ_PREVIEW_0_SKIPFRAME   Skipframe State Config (def=40h) ;
               0-3 Unspecified                                          ;
               4   Unspecified (except PREVIEW_2: Reserved)             ;
               5   Skip_led_on                                          ;
               6   Skip_state (0=No skip state, 1=Skip state)           ;
               7   Turn_off_fen                                         ;/
  211Dh   1  SEQ_PREVIEW_1_AE            ;\                             def=01h
  211Eh   1  SEQ_PREVIEW_1_FD            ; Preview 1 (PREVIEW)          def=01h
  211Fh   1  SEQ_PREVIEW_1_AWB           ; (same as Preview 0, but      def=01h
  2120h   1  SEQ_PREVIEW_1_HG            ; without AE=MDR,              def=01h
  2121h   1  SEQ_PREVIEW_1_FLASH         ; without HG=Manual/Continous)
  2122h   1  SEQ_PREVIEW_1_SKIPFRAME     ;/                             def=N/A
  2123h   1  SEQ_PREVIEW_2_AE            ;\
  2124h   1  SEQ_PREVIEW_2_FD            ; Preview 2 (PREVIEW LEAVE)
  2125h   1  SEQ_PREVIEW_2_AWB           ; (same as Preview 0, but
  2126h   1  SEQ_PREVIEW_2_HG            ; without HG=Manual/Continous)
  2127h   1  SEQ_PREVIEW_2_FLASH         ;
  2128h   1  SEQ_PREVIEW_2_SKIPFRAME     ;/
  2129h   1  SEQ_PREVIEW_3_AE            ;\
  212Ah   1  SEQ_PREVIEW_3_FD            ; Preview 3 (CAPTURE ENTER)
  212Bh   1  SEQ_PREVIEW_3_AWB           ; (same as Preview 0)
  212Ch   1  SEQ_PREVIEW_3_HG            ;
  212Dh   1  SEQ_PREVIEW_3_FLASH         ;
  212Eh   1  SEQ_PREVIEW_3_SKIPFRAME     ;/
  212Fh  ..  RESERVED_SEQ_2F-33        Reserved
  2134h   1  UNDOC_SEQ_34              (0..FFh)
  2135h  ..  RESERVED_SEQ_35-44        Reserved
  2145h   2  UNDOC_SEQ_45              (0..FFFFh)
  2147h  ..  RESERVED_SEQ_47-59        Reserved
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsiaptinacameravariablesaeautoexposuremcu22xxh"></A>&nbsp;
  DSi Aptina Camera Variables: AE (Auto Exposure) (MCU:22xxh)
</FONT></TD></TR></TABLE><BR>
<B>Auto Exposure Variables AE (MCU:2200h-2261h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  2200h  ..  RESERVED_AE_00            Reserved
  2202h   1  AE_WINDOW_POS             AE Window Position Y0 and X0
               0-3  X0 (in units of 1/16th of frame width)  (0..0Fh)
               4-7  Y0 (in units of 1/16th of frame height) (0..0Fh)
  2203h   1  AE_WINDOW_SIZE            AE Window Height and Width (def=FFh)
               0-3  Width  (units of 1/16th of frame width, minus 1)  (0..0Fh)
               4-7  Height (units of 1/16th of frame height, minus 1) (0..0Fh)
  2204h  ..  RESERVED_AE_04            Reserved
  2206h   1  AE_TARGET                 AE Target Brightness (0..FFh, def=32h)
  2207h   1  AE_GATE                   AE Sensitivity       (0..FFh, def=04h)
  2208h  ..  UNDOC_AE_08               (0..FFh, def=02h)
  2209h  ..  RESERVED_AE_09-0A         Reserved
  220Bh   1  AE_MIN_INDEX              Min                      (0-FFh)
  220Ch   1  AE_MAX_INDEX              Max allowed zone number  (0-FFh,def=18h)
  220Dh   1  AE_MIN_VIRTGAIN           Min allowed virtual gain (0-FFh,def=10h)
  220Eh   1  AE_MAX_VIRTGAIN           Max allowed virtual gain (0-FFh,def=80h)
  220Fh  ..  RESERVED_AE_0F-11         Reserved
  2212h   2  AE_MAX_DGAIN_AE1          Max digital gain pre-LC  (def=8000h)
  2214h  ..  RESERVED_AE_14-16         Reserved
  2217h   1  AE_STATUS                 AE Status
               0   AE_at_limit (1=AE reached limit)
               1   R9_changed  (1=Need to skip frame)
               2   Ready       (0=AE not ready, 1=AE ready)
               3-7 Unused (0)
  2218h   1  AE_CURRENT_Y              Last measured luma   (0-FFh,def=4Bh) (R)
  2219h   2  AE_R12                    Curr shutter delay       (def=0279h) (R)
  221Bh   1  AE_INDEX                  Curr zone integration time (def=04h) (R)
  221Ch   1  AE_VIRTGAIN               Curr virtual gain    (0-FFh,def=10h) (R)
  221Dh  ..  RESERVED_AE_1D-1E         Reserved
  221Fh   2  AE_DGAIN_AE1              Current digital gain pre-LC (def=0080h)
  2221h  ..  RESERVED_AE_21            Reserved
  2222h   2  AE_R9                     Current R9:0 value (0-FFFFh, def=0010h)
  2224h  ..  RESERVED_AE_24-2C         Reserved
  222Dh   2  AE_R9_STEP                Integration time per zone   (def=009Dh)
  222Fh  ..  RESERVED_AE_2F-49         Reserved
  224Ah   1  AE_TARGETMIN              Min value for target  (0..FFh, def=32h)
  224Bh   1  AE_TARGETMAX              Max value for target  (0..FFh, def=96h)
  224Ch   1  AE_TARGETBUFFERSPEED      Target Buffer Speed   (0..FFh, def=0Ch)
  224Dh  ..  RESERVED_AE_4D            Reserved
  224Fh   1  AE_BASETARGET             Target Base           (0..FFh, def=36h)
  2250h  ..  RESERVED_AE_50-61         Reserved
  2262h  ..  RESERVED_AE_62-64         Reserved (REV3)
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsiaptinacameravariablesawbautowhitebalancemcu23xxh"></A>&nbsp;
  DSi Aptina Camera Variables: AWB (Auto White Balance) (MCU:23xxh)
</FONT></TD></TR></TABLE><BR>
<B>Auto White Balance Variables AWB (MCU:2300h..236Eh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  2300h  ..  RESERVED_AWB_00           Reserved
  2302h   1  AWB_WINDOW_POS            AWB Window Position Y0 and X0
               0-3  X0 (in units of 1/16th of frame width)  (0..0Fh)
               4-7  Y0 (in units of 1/16th of frame height) (0..0Fh)
  2303h   1  AWB_WINDOW_SIZE           AWB Window Size (def=EFh)
               0-3  Width  (units of 1/16th of frame width, minus 1)  (0..0Fh)
               4-7  Height (units of 1/16th of frame height, minus 1) (0..0Fh)
  2304h  ..  RESERVED_AWB_04           Reserved
  2306h 3x2  AWB_CCM_L_0-2             Left CCM K11,K12,K13 (0180h,FF00h,0080h)
  230Ch 3x2  AWB_CCM_L_3-5             Left CCM K21,K22,K23 (FF66h,0180h,FFEEh)
  2312h 3x2  AWB_CCM_L_6-8             Left CCM K31,K32,K33 (FFCDh,FECDh,019Ah)
  2318h   2  AWB_CCM_L_9               Left CCM Red/Green gain  (0020h)
  231Ah   2  AWB_CCM_L_10              Left CCM Blue/Green gain (0033h)
  231Ch 3x2  AWB_CCM_RL_0-2            DeltaCCM D11,D12,D13 (0100h,FF9Ah,xxxxh)
  2322h 3x2  AWB_CCM_RL_3-5            DeltaCCM D21,D22,D23 (004Dh,FFCDh,FFB8h)
  2328h 3x2  AWB_CCM_RL_6-8            DeltaCCM D31,D32,D33 (004Dh,0080h,FF66h)
  232Eh   2  AWB_CCM_RL_9              DeltaCCM Red/Green gain  (0008h)
  2330h   2  AWB_CCM_RL_10             DeltaCCM Blue/Green gain (FFF7h)
  2332h 3x2  AWB_CCM_0-2               Curr CCM C11,C12,C13 (01BAh,FF5Bh,FFF1h)
  2338h 3x2  AWB_CCM_3-5               Curr CCM C21,C22,C23 (FFC7h,01B9h,FF87h)
  233Eh 3x2  AWB_CCM_6-8               Curr CCM C31,C32,C33 (FFF9h,FF32h,01DCh)
  2344h   2  AWB_CCM_9                 Curr CCM Red/Green gain  (003Ch)
  2346h   2  AWB_CCM_10                Curr CCM Blue/Green gain (002Bh)
  2348h   1  AWB_GAIN_BUFFER_SPEED     Gain Speed (1-20h, def=08h, 20h=fastest)
  2349h   1  AWB_JUMP_DIVISOR          Jump Divisor (1-FFh, def=02h, 1=fastest)
  234Ah   1  AWB_GAIN_MIN              Min AWB Red     (def=59h) ;\Digital Gain
  234Bh   1  AWB_GAIN_MAX              Max allowed Red (def=B6h) ; Min/max
  234Ch   1  AWB_GAINMIN_B             Min AWB         (def=59h) ; (0..FFh)
  234Dh   1  AWB_GAINMAX_B             Max allowed     (def=A6h) ;/
  234Eh   1  AWB_GAIN_R                Current R digital gain    ;\Current Gain
  234Fh   1  AWB_GAIN_G                Current G digital gain    ; (0..FFh,
  2350h   1  AWB_GAIN_B                Current B digital gain    ;/def=80h)
  2351h   1  AWB_CCM_POSITION_MIN      Min/Left  (def=?)   ;\(range 0..FFh,
  2352h   1  AWB_CCM_POSITION_MAX      Max/Right (def=7Fh) ; 00h=incandescent,
  2353h   1  AWB_CCM_POSITION          Position  (def=40h) ;/7Fh=daylight)
  2354h   1  AWB_SATURATION            Saturation (0..FFh, def=80h, 80h=100%)
  2355h   1  AWB_MODE                  Misc control for AWB (0..FFh)
               0  Steady         (1=AWB is done)
               1  Limits Reached (1=AWB limit is reached)
               2  Reserved
               3  Reserved
               4  Reserved
               5  Force_unit_dgains
               6  NormCCM_off
  2356h   2  AWB_GAINR_BUF             Time-buffered R gain (0..FFFFh)
  2358h   2  AWB_GAINB_BUF             Time-buffered B gain (0..FFFFh)
  235Ah  ..  RESERVED_AWB_5A-5C        Reserved
  235Dh   1  AWB_STEADY_BGAIN_OUT_MIN  (0-FF, def=78h)
  235Eh   1  AWB_STEADY_BGAIN_OUT_MAX  (0-FF, def=86h)
  235Fh   1  AWB_STEADY_BGAIN_IN_MIN   (0-FF, def=7Eh)
  2360h   1  AWB_STEADY_BGAIN_IN_MAX   (0-FF, def=82h)
  2361h   2  UNDOC_AWB_61              (0..FFFFh, def=0040h)
  2363h   1  AWB_TG_MIN0               True Gray minimum (0..FFh, def=D2h)
  2364h   1  AWB_TG_MAX0               True Gray maximum (0..FFh, def=F6h)
  2365h   1  AWB_X0                    (0-FFh, def=10h)
  2366h   1  AWB_KR_L                  (0-FFh, def=80h)
  2367h   1  AWB_KG_L                  (0-FFh, def=80h)
  2368h   1  AWB_KB_L                  (0-FFh, def=80h)
  2369h   1  AWB_KR_R                  (0-FFh, def=80h)
  236Ah   1  AWB_KG_R                  (0-FFh, def=80h)
  236Bh   1  AWB_KB_R                  (0-FFh, def=80h)
  236Ch  ..  RESERVED_AWB_6C-6E        Reserved
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsiaptinacameravariablesfdantiflickermcu24xxh"></A>&nbsp;
  DSi Aptina Camera Variables: FD (Anti-Flicker) (MCU:24xxh)
</FONT></TD></TR></TABLE><BR>
<B>Anti-Flicker Variables FD (MCU:2400h..247Bh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  2400h  ..  RESERVED_FD_00            Reserved
  2402h   1  FD_WINDOW_POSH            Window Pos H (0..FFh, def=1Dh)
               0-3  Width (in units of 1/16th of frame width, minus 1) (0..0Fh)
               4-7  X0 (=position/origin or so?) (0..0Fh)
  2403h   1  FD_WINDOW_HEIGHT          FlickerMeasurementWindowHeight (def=04h)
               0-5  Flicker measurement window height in rows (0..3Fh)
               6-7  Unspecified
  2404h   1  FD_MODE                   Flicked Detection switches/indicators
               0-3  Reserved (0..0Fh) (R)
               4    Debug_mode (0=Disable, 1=Enable single period mode)
               5    Curr Flicker State (0=60Hz, 1=50Hz) (R)
               6    Curr Settings (0=60Hz, 1=50Hz)
               7    Manual Mode (0=Disable 1=Enable)
  2405h  ..  RESERVED_FD_05-07         Reserved
  2408h   1  FD_SEARCH_F1_50           Search F1 50Hz  (0..FFh, def=33h)
  2409h   1  FD_SEARCH_F2_50           Search F2 50Hz  (0..FFh, def=35h)
  240Ah   1  FD_SEARCH_F1_60           Search F1 60Hz  (0..FFh, def=29h)
  240Bh   1  FD_SEARCH_F2_60           Search F2 60Hz  (0..FFh, def=2Bh)
  240Ch   1  UNDOC_FD_0C               (0..FFh)
  240Dh   1  FD_STAT_MIN               Stat Min (0..FFh, def=03h)
  240Eh   1  FD_STAT_MAX               Stat Max (0..FFh, def=05h)
  240Fh  ..  RESERVED_FD_0F            Reserved
  2410h   1  FD_MIN_AMPLITUDE          Ignore Signals below Min (0..FFh, def=5)
  2411h   2  FD_R9_STEP_F60_A          60HzA (def=0D4h) ;\Minimal Shutter Width
  2413h   2  FD_R9_STEP_F50_A          50HzA (def=103h) ; Steps for 60Hz/50H AC
  2415h   2  FD_R9_STEP_F60_B          60HzB (def=09Dh) ; in Context A/B
  2417h   2  FD_R9_STEP_F50_B          50HzB (def=0B8h) ;/(0..FFFFh)
  2419h  ..  RESERVED_FD_19-7B         Reserved
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsiaptinacameravariablesmodemodecontextmcu27xxh"></A>&nbsp;
  DSi Aptina Camera Variables: MODE (Mode/Context) (MCU:27xxh)
</FONT></TD></TR></TABLE><BR>
<B>Mode Variables MODE (MCU:2700h..2768h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  2700h  ..  RESERVED_MODE_00-02              Reserved
  2703h   2  MODE_OUTPUT_WIDTH_A        (CX)  (0..FFFFh, def=0320h)  ;\Size A
  2705h   2  MODE_OUTPUT_HEIGHT_A       (CY)  (0..FFFFh, def=0258h)  ;/
  2707h   2  MODE_OUTPUT_WIDTH_B              (0..FFFFh, def=0640h)  ;\Size B
  2709h   2  MODE_OUTPUT_HEIGHT_B             (0..FFFFh, def=04B0h)  ;/
  270Bh   1  MODE_A_MIPI_VC                   (0..07h) (REV3)        ;-Mipi A
  270Ch   1  MODE_B_MIPI_VC                   (0..07h) (REV3)        ;-Mipi B
  270Dh   2  MODE_SENSOR_ROW_START_A    (Y1)  (0..FFFFh)             ;\
  270Fh   2  MODE_SENSOR_COL_START_A    (X1)  (0..FFFFh)             ;
  2711h   2  MODE_SENSOR_ROW_END_A      (Y2)  (0..FFFFh, def=040Dh)  ;
  2713h   2  MODE_SENSOR_COL_END_A      (X2)  (0..FFFFh, def=050Dh)  ; Sensor
  2715h   2  MODE_SENSOR_ROW_SPEED_A          (0..0777h, def=0112h)  ; A
               0-2:  pixclk_speed (0..7)                             ;
                       1ADC: Pclk = 2 mclks * bits[0:2]              ;
                       2ADC: bits[0:2]                               ;
               4-6:  Reserved (0..7)                                 ;
               8-10: Reserved (0..7)                                 ;
  2717h   2  MODE_SENSOR_READ_MODE_A          (0..FFFFh, def=046Ch)  ;
               0:   horiz_mirror                                     ;
               1:   vert_flip                                        ;
               2-4: y_odd_inc (0..7)                                 ;
               5-7: x_odd_inc (0..7)                                 ;
               9:   low_power                                        ;
               10:  xy_bin_en                                        ;
               11:  x_bin_en                                         ;
  2719h   2  MODE_SENSOR_FINE_CORRECTION_A    (0..FFFFh, def=007Bh)  ;
  271Bh   2  MODE_SENSOR_FINE_IT_MIN_A        (0..FFFFh, def=0408h)  ;
  271Dh   2  MODE_SENSOR_FINE_IT_MAX_MARGIN_A (0..FFFFh, def=00ABh)  ;
  271Fh   2  MODE_SENSOR_FRAME_LENGTH_A       (0..FFFFh, def=0293h)  ;
  2721h   2  MODE_SENSOR_LINE_LENGTH_PCK_A    (0..FFFFh, def=07D0h)  ;/
  2723h   2  MODE_SENSOR_ROW_START_B          (0..FFFFh, def=0004h)  ;\
  2725h   2  MODE_SENSOR_COL_START_B          (0..FFFFh, def=0004h)  ; Sensor
  2727h   2  MODE_SENSOR_ROW_END_B            (0..FFFFh, def=040Bh)  ; B
  2729h   2  MODE_SENSOR_COL_END_B            (0..FFFFh, def=050Bh)  ;
  272Bh   2  MODE_SENSOR_ROW_SPEED_B          (0..0777h, def=0111h)  ; (same
  272Dh   2  MODE_SENSOR_READ_MODE_B          (0..FFFFh, def=0024h)  ; as
  272Fh   2  MODE_SENSOR_FINE_CORRECTION_B    (0..FFFFh, def=00A4h)  ; Sensor
  2731h   2  MODE_SENSOR_FINE_IT_MIN_B        (0..FFFFh, def=0408h)  ; A, see
  2733h   2  MODE_SENSOR_FINE_IT_MAX_MARGIN_B (0..FFFFh, def=00A4h)  ; there)
  2735h   2  MODE_SENSOR_FRAME_LENGTH_B       (0..FFFFh, def=04EDh)  ;
  2737h   2  MODE_SENSOR_LINE_LENGTH_PCK_B    (0..FFFFh, def=0D06h)  ;/
  2739h   2  MODE_CROP_X0_A                   (0..FFFFh)             ;\
  273Bh   2  MODE_CROP_X1_A                   (0..FFFFh, def=031Fh)  ; Crop A
  273Dh   2  MODE_CROP_Y0_A                   (0..FFFFh)             ;
  273Fh   2  MODE_CROP_Y1_A                   (0..FFFFh, def=0257h)  ;/
  2741h  ..  RESERVED_MODE_41-45              Reserved
  2747h   2  MODE_CROP_X0_B                   (0..FFFFh)             ;\
  2749h   2  MODE_CROP_X1_B                   (0..FFFFh, def=063Fh)  ; Crop B
  274Bh   2  MODE_CROP_Y0_B                   (0..FFFFh)             ;
  274Dh   2  MODE_CROP_Y1_B                   (0..FFFFh, def=04AFh)  ;/
  274Fh  ..  RESERVED_MODE_4F-53              Reserved
  2755h   2  MODE_OUTPUT_FORMAT_A             Format A (0..FFFFh     ;\
  2757h   2  MODE_OUTPUT_FORMAT_B             Format B (0..FFFFh     ;
               0     swap_channels (swap Cb/Cr in YUV and R/B in RGB);
               1     swap_chrominance_luma                           ; Format
               2     bayer_out (Progressive Bayer)                   ; A/B
               3     monochrome (0..1)                               ;
               4     Reserved                                        ;
               5     output_mode (0=YUV, 1=RGB)                      ;
               6-7   RGB Format (0=565, 1=555, 2=444xh, 3:x444h)     ;
               8     Processed Bayer (0..1)                          ;
               9     Invert out_clk (0..1) (REV3)                    ;
               10-15 Unspecified                                     ;/
  2759h   2  MODE_SPEC_EFFECTS_A              Effects A  (def=6440h) ;\
  275Bh   2  MODE_SPEC_EFFECTS_B              Effects B  (def=6440h) ;
               0-2  Selection (1=Mono, 2=Sepia, 3=Negative,          ; Effects
                      4=Solarization, 5=Solarization w/ UV)          ; A/B
               3-5  Dither_bitwidth                                  ;
               6    Dither_luma                                      ;
               8-15 Solarization Threshold (0..7 for diff effects)   ;/
  275Dh   1  MODE_Y_RGB_OFFSET_A              Offset A (00h..FFh)    ;\Offset
  275Eh   1  MODE_Y_RGB_OFFSET_B              Offset B (00h..FFh)    ;/A/B
  275Fh   2  MODE_COMMON_MODE_SETTINGS_BRIGHT_COLOR_KILL             ;\
               Shadow register for 35A4h in SOC2                     ;
               0-2   Color kill saturation point (0..7)              ; Kill
               3-5   Bright color kill gain      (0..7)              ; Bright
               6-8   Bright color kill threshold (0..7)              ;
               9     Signal_ctrl (1=use luma as min/max value)       ;
               10    en_kl       (1=enable bright color kill)        ;
               11-15 Unspecified                                     ;/
  2761h   2  MODE_COMMON_MODE_SETTINGS_DARK_COLOR_KILL               ;\
               Shadow register for 35A2h in SOC2                     ;
               0-2   Dark color kill gain      (0..7)                ; Kill
               3-5   Dark color kill threshold (0..7)                ; Dark
               6     Signal_ctrl (1=use luma as min/max value)       ;
               7     en_dark_kl  (1=enable dark color kill)          ;
               8-15  Unspecified                                     ;/
  2763h   2  MODE_COMMON_MODE_SETTINGS_FX_SEPIA_SETTINGS             ;\
               0-7   Sepia constants for Cr (00h..FFh)               ; Sepia
               8-15  Sepia constants for Cb (00h..FFh)               ;/
  2765h   1  MODE_COMMON_MODE_SETTINGS_FILTER_MODE                   ;\
               Shadow register for 326Eh in SOC1                     ;
               0-2   UV Filter mode (0..7)                           ; Filter
               3-4   Y Filter mode  (0..3)                           ;
               5     Enable_y_filter (enable y permanently)          ;
               6     Threshold_switch, switch for adaptive Y filter threshold
               7     Off_switch, B/W filter enable switch            ;/
  2766h   1  MODE_COMMON_MODE_SETTINGS_TEST_MODE   Test (00h..FFh)
               0-?  Test Pattern (0=None?, 1=Flat, 2=Ramp, 3=ColorBars,
                    4=VertStripes, 5=Noise, 6=HoriStripes)
               Output test pattern (instead camera image)
               requires "Refresh Command" sent to Sequencer
  2767h  ..  RESERVED_MODE_67-68                   Reserved
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsiaptinacameravariableshghistogrammcu2bxxh"></A>&nbsp;
  DSi Aptina Camera Variables: HG (Histogram) (MCU:2Bxxh)
</FONT></TD></TR></TABLE><BR>
<B>Histogram Variables HG (MCU:2B00h..2B61h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  2B00h  ..  RESERVED_HG_00-03         Reserved
  2B04h   1  HG_MAX_DLEVEL             DarkLevel Limit (0..FFh, def=40h)
  2B05h  ..  RESERVED_HG_05            Reserved
  2B06h   1  HG_PERCENT                Percent?        (0..FFh, def=03h)
  2B07h  ..  RESERVED_HG_07            Reserved
  2B08h   1  HG_DLEVEL                 DarkLevel       (0..FFh, def=10h)
  2B09h  ..  RESERVED_HG_09-16         Reserved
  2B17h   1  HG_AVERAGELUMA            Average Luma      (0..FFh)
  2B18h  ..  RESERVED_HG_18-1A         Reserved
  2B1Bh   2  HG_BRIGHTNESSMETRIC       Brightness Metric (0..FFFFh)
  2B1Dh  ..  RESERVED_HG_1D            Reserved
  2B1Fh   1  HG_LLMODE                 Low Light mode controls (def=C4h)
               0-3  Brightness Metric Prescaler (01h..0Fh)
               4-5  Unused (0)
               6    HG_2d_corr_vs_clusterdc
               7    Clusterdc_vs_gains
  2B20h   1  HG_LL_SAT1                LL_SAT1            (0..FFh, def=43h)
  2B21h   1  UNDOC_HG_21               Whatever           (0..FFh, def=10h)
  2B22h   1  HG_LL_APCORR1             LL_APCORR1         (0..FFh, def=03h)
  2B23h   1  UNDOC_HG_23               Whatever           (0..FFh, def=04h)
  2B24h   1  HG_LL_SAT2                LL_SAT2            (0..FFh, def=0Ch)
  2B25h   1  HG_LL_INTERPTHRESH2       LL_INTERPTHRESH2   (0..FFh, def=23h)
  2B26h   1  HG_LL_APCORR2             LL_APCORR2         (0..FFh)
  2B27h   1  HG_LL_APTHRESH2           LL_APTHRESH2       (0..FFh, def=04h)
  2B28h   2  HG_LL_BRIGHTNESSSTART     LL_BRIGHTNESSSTART (0..FFFFh, def=0A8Ch)
  2B2Ah   2  HG_LL_BRIGHTNESSSTOP      LL_BRIGHTNESSSTOP  (0..FFFFh, def=34BCh)
  2B2Ch   1  HG_NR_START_R             NR_START_R         (0..FFh, def=06h)
  2B2Dh   1  HG_NR_START_G             NR_START_G         (0..FFh, def=0Eh)
  2B2Eh   1  HG_NR_START_B             NR_START_B         (0..FFh, def=06h)
  2B2Fh   1  HG_NR_START_OL            NR_START_OL        (0..FFh, def=06h)
  2B30h   1  HG_NR_STOP_R              NR_STOP_R          (0..FFh, def=1Eh)
  2B31h   1  HG_NR_STOP_G              NR_STOP_G          (0..FFh, def=1Eh)
  2B32h   1  HG_NR_STOP_B              NR_STOP_B          (0..FFh, def=1Eh)
  2B33h   1  HG_NR_STOP_OL             NR_STOP_OL         (0..FFh, def=1Eh)
  2B34h   1  HG_NR_GAINSTART           NR_GAINSTART       (0..FFh, def=08h)
  2B35h   1  HG_NR_GAINSTOP            NR_GAINSTOP        (0..FFh, def=80h)
  2B36h   1  HG_CLUSTERDC_TH           CLUSTERDC_TH       (0..FFh, def=1Eh)
  2B37h   1  HG_GAMMA_MORPH_CTRL       Gamma Morphing Control (0..FFh, def=3)
               0-1 Enable Gamma Morph (0=Disable, 1=Use Table A, 2=Use Table B,
                   3=AutoMorph between Table A and B based on BrightnessMetric)
               2-7 Unspecified
  2B38h   2  HG_GAMMASTARTMORPH        Gamma Start Morph (0..FFFFh, def=0A8Ch)
  2B3Ah   2  HG_GAMMASTOPMORPH         Gamma Stop Morph  (0..FFFFh, def=34BCh)
  2B3Ch  19  HG_GAMMA_TABLE_A_0-18     Gamma Table A for normal light condition
              Default=xx,1B,2E,4C,78,98,B0,E8,CF,D9,E1,E8,EE,F2,F6,F9,FB,FD,FF
  2B4Fh  19  HG_GAMMA_TABLE_B_0-18     Gamma Table B for low light condition
              Default=xx,0F,1A,2E,50,6A,80,91,A1,AF,BB,C6,D0,D9,E2,EA,F1,F9,FF
              Above 2 tables have normal byte-order (Entry0,Entry1,...,Entry18)
  2B62h   2  HG_FTB_START_BM           (0..FFFFh, def=7FBCh) (REV3)
  2B64h   2  HG_FTB_STOP_BM            (0..FFFFh, def=82DCh) (REV3)
  2B66h   2  HG_CLUSTER_DC_BM          (0..FFFFh, def=4A38h) (REV3)
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsialternatecamerasfromunknownmanufacturer"></A>&nbsp;
  DSi Alternate Cameras from Unknown Manufacturer
</FONT></TD></TR></TABLE><BR>
Device A0h/E0h appear to be cameras from an alternate manufacturer. DSi games
are supporting these devices, but as by now, there aren't any DSi consoles
known to be actually fitted with these cameras.<BR>
The camera type &amp; manufacturer are still unknown. Below initialization data
is containing some characterstic info that should allow to identify them. For
example, register 03h appears to be bank-switching the other registers.<BR>
<BR>
<B>unknown_cam_get_chip_id:</B><BR>
Reading an 8bit value from index 00h (in any bank?) seems to return some Chip
ID, at least the DSi is reading that register before initialization (despite of
reading it, the DSi does appear to ignore that value though).<BR>
Note: On a DSi with Aptina cameras, trying to read anything from IC2 devices
A0h/E0h does just return FFh-bytes.<BR>
<BR>
<B>Formatting Note</B><BR>
Below tables consist of "Index,Length,Data[Length]" entries.<BR>
<BR>
<B>unknown_cam_type_code_list_init:</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  003h, 1,001h               ;&lt;-- bank maybe?
  009h, 3,0E2h,002h,002h
  004h, 1,010h
  004h, 1,0A0h
  004h, 2,090h,04Ch
  00Dh, 1,0FFh
  016h, 1,053h
  018h, 3,002h,001h,00Fh
  020h, 1,000h
  023h, 2,000h,000h
  034h, 8,000h,003h,000h,003h,001h,002h,000h,0C2h
  03Dh, 4,050h,050h,000h,067h
  042h, 1,01Ch
  04Ah, 2,043h,0F8h
  04Eh, 7,028h,0FCh,000h,024h,014h,008h,008h
  056h,13,000h,018h,028h,034h,044h,056h,06Eh,080h,0A4h,0C2h,0D6h,0E8h,0F4h
  065h,12,00Fh,038h,008h,000h,01Fh,01Fh,01Fh,01Fh,01Fh,01Fh,01Fh,01Fh
  07Ah,17,039h,03Bh,03Ah,036h,03Ch,03Ch,03Ah,03Ch,03Ch,03Ch,03Ah,03Ch,038h
          03Ah,031h,03Ah,082h
  08Dh,22,08Ah,090h,096h,09Ch,0A4h,0AAh,0B0h,0B6h,0BCh,0C4h,0CAh,0D0h,0D6h
          0DCh,0E4h,0EAh,0F0h,0F2h,0F4h,0F6h,0F8h,0FAh
  0A9h, 1,02Bh
  0ABh, 3,02Eh,000h,050h
  0AFh, 1,070h
  0B2h, 4,03Ch,068h,049h,070h
  0B7h,21,032h,000h,00Eh,0F8h,00Ch,07Ah,040h,000h,000h,010h,044h,064h,052h
          012h,001h,0D7h,004h,002h,024h,002h,024h
  0D4h, 5,004h,004h,008h,00Ah,010h
  016h, 1,0F7h
  0DEh, 2,002h,024h
  016h, 1,053h
  0E1h, 1,034h
  0FFh, 1,00Fh
  003h, 1,002h               ;&lt;-- bank maybe?
  005h, 2,06Dh,004h
  011h, 4,004h,048h,004h,048h
  016h, 2,00Ch,0D8h
  019h, 2,00Ch,0D8h
  01Eh, 6,002h,024h,070h,000h,001h,06Eh
  026h, 7,008h,00Fh,00Fh,006h,0FFh,0FFh,003h
  02Eh,19,07Eh,088h,074h,07Eh,008h,010h,080h,008h,084h,078h,001h,003h,00Ah
          025h,060h,0B0h,006h,000h,000h
  042h, 7,080h,010h,010h,010h,040h,080h,0FFh
  04Ah,30,000h,000h,001h,0E5h,001h,0E0h,000h,070h,002h,0F0h,000h,02Eh,001h
          0F3h,000h,005h,000h,000h,001h,000h,000h,0C0h,000h,026h,000h,01Ch
          000h,0B3h,000h,086h
  069h,36,000h,000h,006h,014h,014h,01Fh,000h,000h,000h,000h,000h,01Fh,000h
          000h,010h,010h,010h,01Fh,000h,000h,004h,004h,004h,01Fh,000h,000h
          000h,000h,000h,01Fh,000h,000h,010h,010h,010h,01Fh
  095h, 1,084h
  097h,18,002h,000h,0FFh,0FFh,000h,0FFh,0FFh,000h,000h,0FFh,0FFh,000h,0FFh
          0FFh,000h,0F8h,014h,010h
  0AAh,13,044h,098h,08Ch,09Ch,048h,08Ch,08Ah,09Ch,046h,02Ah,080h,008h,026h
  0B8h, 8,02Ah,084h,000h,026h,02Ah,080h,008h,020h
  0C1h,10,038h,020h,01Fh,01Dh,034h,020h,01Fh,01Dh,045h,05Dh
  0CCh, 2,020h,020h
  0D0h, 3,080h,000h,0FFh
  003h, 1,000h               ;&lt;-- bank maybe?
  013h, 2,000h,04Ch
  01Dh, 2,000h,04Ch
  015h, 2,001h,05Fh
  055h, 2,001h,05Eh
  031h, 6,006h,068h,00Ch,005h,004h,047h
  047h, 2,000h,003h
  04Ah, 3,0A0h,000h,003h
  04Fh, 2,000h,003h
  059h, 2,000h,001h
  05Fh, 2,000h,001h
  066h, 1,09Eh
  06Eh, 2,07Fh,003h
  075h, 1,050h
  07Ah, 2,000h,001h
  07Eh, 1,020h
  082h, 1,038h
  084h,14,003h,040h,003h,040h,000h,000h,040h,003h,0FFh,002h,008h,020h,018h,006h
  093h,11,020h,040h,040h,01Fh,002h,000h,000h,000h,000h,000h,000h
  003h, 1,001h               ;&lt;-- bank maybe?
  00Fh, 1,0C9h                    ;or, for Device E0h: 00Fh, 1,0C8h
  052h, 3,004h,008h,008h          ;or, for Device E0h: N/A
  003h, 1,002h               ;&lt;-- bank maybe?
  026h, 1,008h                    ;or, for Device E0h: 026h, 1,000h
  0CCh, 2,0C0h,0C0h               ;or, for Device E0h: N/A
  0B4h, 1,000h                    ;or, for Device E0h: N/A
  0B6h, 1,026h                    ;or, for Device E0h: N/A
  0B9h, 3,000h,008h,026h          ;or, for Device E0h: N/A
  0BDh, 1,000h                    ;or, for Device E0h: N/A
  026h, 1,008h                    ;or, for Device E0h: N/A
  003h, 1,001h               ;&lt;-- bank maybe?
  02Dh, 1,0FFh
  004h, 1,020h
</TD></TR></TABLE>
<BR>
<B>unknown_cam_type_code_list_activate:</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  003h, 1,002h               ;&lt;-- bank maybe?
  0A7h, 1,014h
  003h, 1,001h               ;&lt;-- bank maybe?
  004h, 1,0A0h
  004h, 1,090h
  02Dh, 1,000h
  004h, 1,098h
</TD></TR></TABLE>
<BR>
<B>Random Note</B><BR>
This info is probably not really helpful, but the DSi firmware contains code
for setting Register C1h..C9h (within unknown bank) to one of the following
twelve settings.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  C1h, 8,038h,030h,01Fh,01Fh,02Ch,030h,01Fh,01Fh
  C1h, 8,038h,030h,01Fh,01Fh,038h,030h,01Fh,01Fh
  C1h, 8,02Ch,030h,01Fh,01Fh,02Ch,030h,01Fh,01Fh
  C1h, 8,02Ch,030h,01Fh,01Fh,02Ch,030h,01Fh,01Fh
  C1h, 8,02Ch,030h,01Fh,01Fh,02Ch,030h,01Fh,01Fh
  C1h, 8,02Ch,030h,01Fh,01Fh,02Ch,030h,01Fh,01Fh
  C1h, 8,030h,028h,018h,018h,034h,028h,008h,018h
  C1h, 8,030h,028h,018h,018h,030h,028h,008h,018h
  C1h, 8,028h,028h,018h,018h,028h,028h,008h,018h
  C1h, 8,028h,028h,018h,018h,028h,028h,008h,018h
  C1h, 8,028h,028h,018h,018h,028h,028h,008h,018h
  C1h, 8,028h,028h,018h,018h,028h,028h,008h,018h
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsicameras"></A>&nbsp;
  DSi Cameras
</FONT></TD></TR></TABLE><BR>
<B>Camera registers</B><BR>
Cameras are controlled and initialized via I2C bus (on ARM7 side).<BR>
<A HREF="#dsii2cbus">DSi I2C Bus</A><BR>
The actual camera data transfers are done with below registers (on ARM9 side).<BR>
<BR>
<B>4004200h - DSi9 - CAM_MCNT - Camera Module Control</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Unknown                                                      (R or R/W)
  1     Unknown (1=Enable?)                                          (R or R/W)
  2-4   Unknown                                                      (R or R/W)
  5     Unknown (1=Enable?) (0=CamI2C fails?)                        (R or R/W)
  6     Unknown                                                      (R or R/W)
  7     Unknown (gets set automatically?)                                  (R?)
  0-15  Unknown/Unused (00h)                                               (0?)
</TD></TR></TABLE>
Written values are 0000h and 0022h.<BR>
Camera I2C access works only when bit5=1 (otherwise camera i2c reads just
return FFh; maybe bit5=0 issues a reset to the camera devices or so?)<BR>
"Used for resetting cameras. Once cameras are reset by poking this register,
all three 0x0400420X camera registers are set to zero." Uh, is that really
true, and which "three" registers are that?<BR>
<BR>
<B>4004202h - DSi9 - CAM_CNT - Camera Control</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-3   Number of DMA scanlines minus 1 (usually 3=Four Scanlines)   (R or R/W)
  4     Data request? or Data overrun? or so?                               (R)
  5     Clear bit4, and flush CAM_DAT till next Camera Vblank?              (W)
  6-7   Unknown/Unused (0)                                                 (0?)
  8-9    ? Set to 2 during init, 0 on cameras shutdown                    (R/W)
  10     ? Set to 1 during init, 0 on cameras shutdown                    (R/W)
  11    IRQ Enable      (0=Disable, 1=Enable)                             (R/W)
  12    Unknown/Unused (0)                                                 (0?)
  13    Color Format    (0=Direct/YUV422, 1=Convert YUV-to-RGB555)   (R or R/W)
  14    Trimming Enable (0=Normal/FullPicture, 1=Crop via SOFS/EOFS) (R or R/W)
  15    Transfer Enable (0=Disable/AllowConfig, 1=Enable/Transfer)        (R/W)
</TD></TR></TABLE>
<BR>
<B>4004204h - DSi9 - CAM_DAT - Camera Data (R)</B><BR>
Transfers two camera pixels at once (from left-to-right, starting with upper
scanline).<BR>
Pixel Format (in "YUV422" mode):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-7   First Pixel Luminance (Y)   (unsigned, 00h..FFh, FFh=white)
  8-15  Both Pixels Blue (Cb aka U) (unsigned, 00h..FFh, 80h=gray)
  16-23 Second Pixel Luminance (Y)  (unsigned, 00h..FFh, FFh=white)
  24-31 Both Pixels Red (Cr aka V)  (unsigned, 00h..FFh, 80h=gray)
</TD></TR></TABLE>
Pixel Format (in YUV-to-RGB555 mode) (matches 2D Engine Bitmap format):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-4   First Pixel Red Intensity    (0..31)
  5-9   First Pixel Green Intensity  (0..31)
  10-14 First Pixel Blue Intensity   (0..31)
  15    First Pixel Alpha (always 1=NonTransparent)
  16-20 Second Pixel Red Intensity   (0..31)
  21-25 Second Pixel Green Intensity (0..31)
  26-30 Second Pixel Blue Intensity  (0..31)
  31    Second Pixel Alpha (always 1=NonTransparent)
</TD></TR></TABLE>
The Aptina camera's MODE_OUTPUT_FORMAT registers and MIPI_CONTROL register can
be configured to output stuff like YUV, RGB555, RGB444, BGR565, RAW8, etc.
However, DSi games seem to be always using YUV mode at camera side (and the
above RGB555 data is produced by activating YUV-to-RGB conversion in
CAM_CNT.bit13 at console side).<BR>
YUV mode gives better quality with 8bit resolution (whilst RGB555 mode is
having only 5bit, and, as it's converted from YUV, it's certainly having color
information being shared for each two-pixel groups, too).<BR>
CAM_DAT should be usually read via NDMA (see below). Manually reading CAM_DAT
for one block (eg. 256x4 pixels) does work, but it's unknown how to retrieve
further blocks via manual reading (except, one further block arrives after
around 40000h clock cycles, but that's much too slow, and it's only one extra
block).<BR>
<BR>
<B>Formulas for converting YUV to RGB</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  R = Y+(Cr-80h)*1.402
  G = Y-(Cr-80h)*0.714)-(Cb-80h)*0.344
  B = Y+(Cb-80h)*1.772
</TD></TR></TABLE>
Clip results to MinMax(00h,FFh), and apply final divide by 8 for RGB555.<BR>
<BR>
<B>4004210h - DSi9 - CAM_SOFS Camera Trimming Starting Position Setting (32bit)</B><BR>
<B>4004214h - DSi9 - CAM_EOFS Camera Trimming Ending Position Setting (32bit)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0      Unused (0)                                                         (0)
  1-9    X-Offset  (0..1FFh)   in words (ie. 2-pixel units)?         (R or R/W)
  10-15  Unused (0)                                                         (0)
  16-24  Y-Offset  (0..1FFh)   in scanlines?                         (R or R/W)
  25-31  Unused (0)                                                         (0)
</TD></TR></TABLE>
Crops the incoming camera picture before passing it to CAM_DAT, used only if
enabled in CAM_CNT.14.<BR>
<BR>
<B>Write-Protected Camera Bits (R or R/W)</B><BR>
The "(R or R/W)" bits are getting Read-Only when camera transmission is
enabled, ie. they can be changed only when CAM_CNT.Bit15=0.<BR>
<BR>
<B>Internal Camera Reflections from LCD Backlights</B><BR>
The LCD backlights can cause nasty reflections on the internal camera
(particulary when wearing glasses). There isn't much that could be done during
preview, but when taking photos, it might be recommended to output a black/dark
picture on the LCDs during the capture.<BR>
<BR>
<B>Internal Camera Mirroring</B><BR>
The Internal Camera is conventionally having x-flip enabled (in Aptina
MODE_SENSOR_READ_MODE registers), so the internal camera will behave as a
mirror (which may appear more familar to most users in preview mode). The
firmware's "Nintendo DSi Camera" utility is even saving jpg's in mirrored form
instead of as true images.<BR>
<BR>
<B>Camera Init</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  [4004004h]=[4004004h] OR 0004h             ;SCFG_CLK, CamInterfaceClock = ON
  [4004200h]=0000h, delay(1Eh)               ;CAM_MCNT, Camera Module Control
  [4004004h]=[4004004h] OR 0100h, delay(1Eh) ;SCFG_CLK, CamExternal Clock = ON
  [4004200h]=0022h, delay(2008h)             ;CAM_MCNT, Camera Module Control
  [4004004h]=[4004004h] AND NOT 0100h        ;SCFG_CLK, CamExternal Clock = OFF
  [4004202h]=[4004202h] AND NOT 8000h        ;CAM_CNT, allow changing params
  [4004202h]=[4004202h] OR 0020h             ;CAM_CNT, whatever?
  [4004202h]=([4004202h] AND NOT 0300h) OR 0200h
  [4004202h]=[4004202h] OR 0400h
  [4004202h]=[4004202h] OR 0800h
  [4004004h]=[4004004h] OR 0100h, delay(14h) ;SCFG_CLK, CamExternal Clock = ON
  issue "aptina_code_list_init" via I2C bus on ARM7 side
  [4004004h]=[4004004h] AND NOT 0100h        ;SCFG_CLK, CamExternal Clock = OFF
  [4004004h]=[4004004h] OR 0100h, delay(14h) ;SCFG_CLK, CamExternal Clock = ON
  issue "aptina_code_list_activate" via I2C bus on ARM7 side
  [4004202h]=[4004202h] OR 2000h
  [4004202h]=([4004202h] AND NOT 000Fh) OR 0003h
  [4004202h]=[4004202h] OR 0020h
  [4004202h]=[4004202h] OR 8000h             ;CAM_CNT, start transfer
  [4004120h]=04004204h                       ;NDMA1SAD, source CAM_DTA
  [4004124h]=0xxxxxxxh                       ;NDMA1DAD, dest RAM/VRAM
  [4004128h]=00006000h                       ;NDMA1TCNT, len for 256x192 total
  [400412Ch]=00000200h                       ;NDMA1WCNT, len for 256x4 blocks
  [4004130h]=00000002h                       ;NDMA1BCNT, timing interval or so
  [4004138h]=8B044000h                       ;NDMA1CNT, start camera DMA
</TD></TR></TABLE>
<BR>
<B>Specifications</B><BR>
The Nintendo DSi contains two cameras. The cameras can be used in the Nintendo
DSi Camera application or DSi games that are compatible.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  640*480 VGA (0.3 Megapixel)
  No zoom and no flash.
</TD></TR></TABLE>
Photos saved in JPG format (saved in DCIM/ folder on the SD/SDHC or in the
internal memory).<BR>
<BR>
<B>Camera Applications</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Nintendo DSi Camera
  System Menu
</TD></TR></TABLE>
<B>Camera Games</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Asphalt 4 : Elite Racing (DSiWare)
  Brain Challenge (DSiWare)
  Classic Word Games
  Cooking Coach
  Pop SuperStar : Road To Celebrity (DSiWare)
  Real Football 2009 (DSiWare)
  WarioWare : Snapped! (DSiWare)
  iCarly
  Pokemon Black,White (2010,JP)
  Castle of Magic (DSiWare)
  Photo Dojo (DSiWare)
  System Flaw (mis-uses camera as gyro sensor)
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcprotocolandioports"></A>&nbsp;
  DSi SD/MMC Protocol and I/O Ports
</FONT></TD></TR></TABLE><BR>
<B>I/O Ports</B><BR>
<A HREF="#dsisdmmcioportscommandparamresponsedata">DSi SD/MMC I/O Ports: Command/Param/Response/Data</A><BR>
<A HREF="#dsisdmmcioportscontrol">DSi SD/MMC I/O Ports: Control</A><BR>
<A HREF="#dsisdmmcioportsinterruptstatus">DSi SD/MMC I/O Ports: Interrupt/Status</A><BR>
<A HREF="#dsisdmmcioportsmisc">DSi SD/MMC I/O Ports: Misc</A><BR>
<BR>
<B>SD/MMC Protocol</B><BR>
<A HREF="#dsisdmmcprotocolcommandresponseregistersummary">DSi SD/MMC Protocol: Command/Response/Register Summary</A><BR>
<A HREF="#dsisdmmcprotocolgeneralcommands">DSi SD/MMC Protocol: General Commands</A><BR>
<A HREF="#dsisdmmcprotocolblockreadwritecommands">DSi SD/MMC Protocol: Block Read/Write Commands</A><BR>
<A HREF="#dsisdmmcprotocolspecialextracommands">DSi SD/MMC Protocol: Special Extra Commands</A><BR>
<A HREF="#dsisdmmcprotocolcsrregister32bitcardstatusregister">DSi SD/MMC Protocol: CSR Register (32bit Card Status Register)</A><BR>
<A HREF="#dsisdmmcprotocolssrregister512bitsdstatusregister">DSi SD/MMC Protocol: SSR Register (512bit SD Status Register)</A><BR>
<A HREF="#dsisdmmcprotocolocrregister32bitoperationconditionsregister">DSi SD/MMC Protocol: OCR Register (32bit Operation Conditions Register)</A><BR>
<A HREF="#dsisdmmcprotocolcidregister128bitcardidentification">DSi SD/MMC Protocol: CID Register (128bit Card Identification)</A><BR>
<A HREF="#dsisdmmcprotocolcsdregister128bitcardspecificdata">DSi SD/MMC Protocol: CSD Register (128bit Card-Specific Data)</A><BR>
<A HREF="#dsisdmmcprotocolextcsdregister4096bitextendedcsdregistermmc">DSi SD/MMC Protocol: EXT_CSD Register (4096bit Extended CSD Register) (MMC)</A><BR>
<A HREF="#dsisdmmcprotocolrcaregister16bitrelativecardaddress">DSi SD/MMC Protocol: RCA Register (16bit Relative Card Address)</A><BR>
<A HREF="#dsisdmmcprotocoldsrregister16bitdriverstageregisteroptional">DSi SD/MMC Protocol: DSR Register (16bit Driver Stage Register) (Optional)</A><BR>
<A HREF="#dsisdmmcprotocolscrregister64bitsdcardconfigurationregister">DSi SD/MMC Protocol: SCR Register (64bit SD Card Configuration Register)</A><BR>
<A HREF="#dsisdmmcprotocolpwdregister128bitpasswordplus8bitpasswordlen">DSi SD/MMC Protocol: PWD Register (128bit Password plus 8bit Password len)</A><BR>
<A HREF="#dsisdmmcprotocolsignals">DSi SD/MMC Protocol: Signals</A><BR>
<BR>
<B>Pinouts</B><BR>
<A HREF="#auxdsisdmmcpinouts">AUX DSi SD/MMC Pin-Outs</A><BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcioportscommandparamresponsedata"></A>&nbsp;
  DSi SD/MMC I/O Ports: Command/Param/Response/Data
</FONT></TD></TR></TABLE><BR>
<B>4004800h ?  000D Used? - SD_CMD - Command and Response/Data Type</B><BR>
<B>4004A00h 2  0000 Used? - SDIO_CMD - Command and Response/Data Type</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15    ?       Unknown/unused/undoc
  14    undoc   Security Cmd   (0=Normal, 1=Whatever/Security)
  13    undoc   Data Length    (0=Single Block, 1=Multiple Blocks)
  12    undoc   Data Direction (0=Write, 1=Read)
  11    NTDT    Data Transfer  (0=No data, 1=With data)
  10-8  REP2-0  Response Type  (0..2=Unknown/Reserved, 3=None, 4=48bit,
                                5=48bit+Busy, 6=136bit, 7=48bitOcrWithoutCRC7)
  7-6   CMD1-0  Command Type   (0=CMD, 1=ACMD, 2..3=unknown)
  5-0   CIX     Command Index  (0..3Fh, command index)
</TD></TR></TABLE>
Invalid values can cause ILA error (particulary on setting NTDT for CMD12, or
for CMD's Response=None). ILA error will also occur if an old CMD is still
busy.<BR>
DSi software is always writing just ZERO to bit11-6 though? Maybe the hardware
does automatically know which SD/MMC CMDs and ACMDs have data? Or maybe data is
always automatically transferred when receiving a data-startbit, or when
writing to data register - and bits like NTDT would be needed only for things
like proper data timeout handling?<BR>
<BR>
<B>4004804h 4  0000 Used? - SD_CMD_PARAM0-1 - Argument (32bit, 2 halfwords)</B><BR>
<B>4004A04h 4  0000 Used? - SDIO_CMD_PARAM0-1 - Argument (32bit, 2 halfwords)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-0
</TD></TR></TABLE>
<BR>
<B>400480Ch 16 0900 Used? - SD_RESPONSE0-7 - Response (128bit, 8 halfwords)</B><BR>
<B>4004A0Ch 16 0000 Used? - SDIO_RESPONSE0-7 - Response (128bit, 8 halfwords)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  127-0
</TD></TR></TABLE>
Seems to be left-shifted when receiving response bits. So, for 32bit responses,
bit0-31 would contain the current response, and bit32-127 would contain older
responses.<BR>
<BR>
DATA16 vs DATA32... and/or... SD Card vs eMMC...<BR>
<BR>
<B>40048D8h 2  1012 Used? SD_DATA_CTL           (???)</B><BR>
<B>4004AD8h 2  1010 ?     SDIO_DATA_CTL</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-13  Unknown (usually 0)
  12     Unknown (usually 1)
  11-5   Unknown (usually 0)
  4      Unknown (usually 1)
  3-2    Unknown (usually 0)
  1      Unclear? (0=DATA16/sdcard?, 1=DATA32/eMMC?)
  0      Unknown (usually 0)
</TD></TR></TABLE>
Known written values are 0000h and 0002h. However, known read values are 1010h
and 1012h.<BR>
Bit1 does probably select DATA16/DATA32 (and/or maybe it selects sdcard/eMMC?).<BR>
See also: SD_CARD_PORT_SELECT and SDIO_CARD_PORT_SELECT<BR>
<BR>
DATA16... (used for 16bit access, and/or for SD Card access)<BR>
<BR>
<B>400480Ah 2  0008 Used? - SD_DATA16_BLK_COUNT - "Transfer Sector Count"</B><BR>
<B>4004A0Ah ?  0000 Used? - SDIO_DATA16_BLK_COUNT - "Transfer Block Count"</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15?-0  Number of Data Blocks for multiple read/write commands
</TD></TR></TABLE>
<BR>
<B>4004826h 2  0200 ?     - SD_DATA16_BLK_LEN - Memory Card Transfer Data Length</B><BR>
<B>4004A26h ?  0200 ?     - SDIO_DATA16_BLK_LEN - Card Transfer Data Length</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15?-0  Data Block Length in bytes
</TD></TR></TABLE>
Should be usually 0200h (for 512-byte memory blocks). Other values may be
needed when accessing SSR/SCR/PWD registers via data transfers.<BR>
<BR>
<B>4004830h ?  0    Used? SD_DATA16_FIFO - Data Port  (SD_FIFO?)</B><BR>
<B>4004A30h ?  0    ?     SDIO_DATA16_FIFO - Data Port  (SD_FIFO?)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-0   Data (16bit) (...or could it be accessed as 32bit, too?)
</TD></TR></TABLE>
Transfer data here. FIFO size is unknown (if there's any FIFO behind it).<BR>
<BR>
DATA32... (used for 32bit access, and/or for eMMC access)<BR>
<BR>
<B>4004900h 2  0802 Used? -?- SD_DATA32_CTL       (???)</B><BR>
<B>4004B00h 2  0    ?     -?- SDIO_DATA32_CTL       (???)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-0   Unknown
</TD></TR></TABLE>
Maybe related to below "DATA32" registers. Maybe some control bits, and/or
status bits, maybe IRQ related... IRQ flags and/or IRQ mask bits for "DATA32"?<BR>
<BR>
<B>4004904h 2  0200 Used? -?- SD_DATA32_BLK_LEN   (?)</B><BR>
<B>4004B04h 2  0    ?     -?- SDIO_DATA32_BLK_LEN   (?)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15?-0  Data Block Length in bytes (maybe/guessed...?)
</TD></TR></TABLE>
<BR>
<B>4004908h 2  0001 Used? -?- SD_DATA32_BLK_COUNT (?)</B><BR>
<B>4004B08h 2  0001 ?     -?- SDIO_DATA32_BLK_COUNT (?)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15?-0  Number of Data Blocks for multiple read/write commands
</TD></TR></TABLE>
<BR>
<B>400490Ch 4  0    Used? -?- SD_DATA32_FIFO      (?)</B><BR>
<B>4004B0Ch 4  0    ?     -?- SDIO_DATA32_FIFO      (?)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-0   Data (32bit) (...or could it be accessed as 16bit, too?)
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcioportscontrol"></A>&nbsp;
  DSi SD/MMC I/O Ports: Control
</FONT></TD></TR></TABLE><BR>
<B>4004802h 2  0201 Used? SD_CARD_PORT_SELECT</B><BR>
<B>4004A02h 2  0100 ?     SDIO_CARD_PORT_SELECT</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-11 Unknown (0)
  10    Unknown (write: should be 1, read: usually 0)
  9     Unknown (write: should be 0, read: usually 1 for SD)
  8     Unknown (write: should be 0, read: usually 1 for SDIO)
  7-1   Unknown (0)
  0     Port Select (0=DATA16/sdcard?, 1=DATA32/eMMC?)
</TD></TR></TABLE>
Known written values are 0400h and 0401h (SD). However known read values are
0201h (SD) and 0100h (SDIO).<BR>
Bit0 does probably select sdcard/eMMC (and/or maybe it selects DATA16/DATA32?).<BR>
<BR>
<B>4004828h - DSi: 40E0 - SD_CARD_OPTION - Memory Card Option Setup</B><BR>
<B>4004A28h - DSi: 40EE - SDIO_CARD_OPTION - Card Option Setup</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15        Bus Width (0=4bit, 1=1bit)
  14-0 ?    Unknown (...among others, 4bit timeout)
</TD></TR></TABLE>
Settings spotted on DSi are 40E0h,40EEh.<BR>
Among others, this register should contain a 4bit timeout setting, "RTO[3:0]
for SD (aka TO[3:0] SDIO) timeout period for data start/busy bits, in the form
of a multiple number of the SDCLK period."<BR>
Maybe also selects transfer CLK rate, or whatever.<BR>
<BR>
<B>4004834h - DSi: 0000 - SD_TRANSACTION_CTL - Transaction Control</B><BR>
<B>4004A34h - DSi: 0000 - SDIO_TRANSACTION_CTL - Transaction Control</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-0 ?    Unknown (zero on DSi)
</TD></TR></TABLE>
Maybe also selects transfer CLK rate, or whatever.<BR>
<BR>
<B>40048E0h - DSi: 0007 - SD_SOFT_RESET - Software Reset</B><BR>
<B>4004AE0h - DSi: 0006 - SDIO_SOFT_RESET - Software Reset</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-3 ?    Unknown (zero on DSi)
  2-1  ?    Unknown (can be nonzero on DSi)
  0    SRST Soft Reset (0=Reset, 1=Release)
</TD></TR></TABLE>
Software should apply reset after sensing card insertion/removal, and
(thereafter) release reset in case of card insertion. Software reset does
acknowledge all IRQs (except that from SDIO /IRQ pin?), and does probably also
reinitialize some other registers.<BR>
<BR>
<B>4004808h - DSi: 0100 - SDCTL_STOP_INTERNAL_ACTION</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-0   Unknown (0100h on DSi)
</TD></TR></TABLE>
Stop whatever internal action for whatever purpose in whatever situation?<BR>
<BR>
<B>4004824h - DSi: 0000 - DSi: Used? - SDCTL_CARD_CLK_CTL Card Clock Control</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15     Disable HCLK divider (0=SDCLK selected via bit7-0, 1=SDCLK=HCLK)
  14-10  Unknown (zero on DSi)
  9      Unknown (set in some cases on DSi)
  8      Unknown (1=Start Clock, or Apply Clock Change, or so?)
  7-0    HCLK Div (0,1,2,4,8,10h,20h,40h,80h = Div2,4,8,16,32,64,128,256,512)
</TD></TR></TABLE>
Clock supply to SD Card<BR>
The SDCLK signal is used for a provision of SD Memory Card or SDIO Card. Please
refer to the following setting for enabling the SDCLK output.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 (1) Set Stop Clock Control Register (Config Offset:40h) to 1Fh.
 (2) Set D0 of SD Software Reset Register (Offset:0E0h) to 1b.
 (3) Set D7-0 of SD Card Clock Control Register (Offset:024h). These bits
     are used for setting the frequency of SDCLK.
       80h : SDCLK=HCLK/512
       40h : SDCLK=HCLK/256
       20h : SDCLK=HCLK/128
       10h : SDCLK=HCLK/64
       08h : SDCLK=HCLK/32
       04h : SDCLK=HCLK/16
       02h : SDCLK=HCLK/8
       01h : SDCLK=HCLK/4
       00h : SDCLK=HCLK/2
     In addition, TC6387XB holds a function that SDCLK can have same
     frequency as HCLK. In this case, D7-0 settings of SD Card Clock Control
     Register (Offset:024h) becomes invalid setting.
     * Set D0 of Clock Mode Register (Config Offset:42h) to 1b.
     * Set D15 of SD Card Clock Control Register (Offset:024h) to 1b.
     Please attend that the specification of SDCLK is max.25MHz at the case
     of SD Card and is max.20MHz at the case of MultiMedia Card.
 (4) D8 of SD Card Clock Control Register (Offset:024h) to 1b.
 (5) D8 of Clock &amp; Wait Control Register (Offset:138h) to 1b.
</TD></TR></TABLE>
On the DSi, HCLK seems to be 33.513982 MHz.<BR>
<BR>
<B>4004x38h - DSi: 0000 - SDCTL_CLK_AND_WAIT_CTL</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-0   Unknown (zero on DSi)
</TD></TR></TABLE>
Maybe transfer CLK rate, or some master clock control for the clock input.<BR>
<BR>
<B>4004x3Ah - DSi: 0000 - SDCTL_SDIO_HOST_INFORMATION</B><BR>
<B>4004x3Ch - DSi: 0000 - SDCTL_ERROR_CONTROL</B><BR>
<B>4004x3Eh - DSi: 0000 - SDCTL_SDLED_CONTROL - LED Control (TC6387XB only)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-0   Unknown (zero on DSi)
</TD></TR></TABLE>
<BR>
<B>40048E2h - DSi: 0009 - SDCTL_RESERVED2 (TC6371AF:CORE_REV)</B><BR>
<B>40048E6h - DSi: 0000 - SDCTL_RESERVED3 (TC6371AF:BUF_ADR)</B><BR>
<B>40048E8h - DSi: 0000 - UNDOC/UNUSED (TC6371AF:Resp_Header)</B><BR>
<B>40048F6h - DSi: 0000 - SDCTL_RESERVED4 --- used by DSi !!!</B><BR>
<B>40048F8h - DSi: 0004 - SDCTL_RESERVED5</B><BR>
<B>40048FAh - DSi: 0007 - SDCTL_RESERVED6</B><BR>
<B>40048FCh - DSi: 00FC - SDCTL_RESERVED7</B><BR>
<B>40048FEh - DSi: 00FF - SDCTL_RESERVED8 (TC6371AF:Revision)</B><BR>
<B>4004xE2h - DSi: 0000 - SDCTL_RESERVED9</B><BR>
<B>4004xF0h - DSi: 0000 - SDCTL_RESERVED10</B><BR>
<B>4004836h - DSi: 0002 - UNDOC!</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-0   Unknown
</TD></TR></TABLE>
<BR>
<B>4004838h/4004A38h - DSi: C007 - UNDOC!</B><BR>
<B>4004840h/4004A40h - DSi: 003F - UNDOC?</B><BR>
<B>4004842h/4004A42h - DSi: 002A - UNDOC?</B><BR>
<B>40048B2h/4004AB2h - DSi: FFFF - UNDOC?</B><BR>
<B>40048BAh/4004ABAh - DSi: 0200 - UNDOC?</B><BR>
<B>40048F4h/4004AF4h - DSi: 0700 - UNDOC!</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-0   Unknown
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcioportsinterruptstatus"></A>&nbsp;
  DSi SD/MMC I/O Ports: Interrupt/Status
</FONT></TD></TR></TABLE><BR>
<B>400481Ch 4  0601 Used? SD_IRQ_STATUS0-1 - Interrupt Status</B><BR>
<B>4004A1Ch 4  0603 ?     SDIO_IRQ_STATUS0-1 - Interrupt Status</B><BR>
<B>4004820h 4  0305 Used? SD_IRQ_MASK0-1 - Interrupt Mask</B><BR>
<B>4004A20h 4  031D ?     SDIO_IRQ_MASK0-1 - Interrupt Mask</B><BR>
IRQ Status (0=ack, 1=request)<BR>
IRQ Mask (0=enable, 1=disable)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit Stat  Mask   Function
  0   SREP  MREP   CMDRESPEND    (response end) (or R1b: busy end)
  1   ?     -      Unknown/unused/undoc
  2   SRWA  MRWA   DATAEND       (after data read/write end bit)
  3   SCOT  MCOT   CARD_REMOVE       ;\SD only (not SDIO)
  4   SCIN  MCIN   CARD_INSERT       ;/
  5   undoc -      SIGSTATE          card/type/signal/signature detect?
  6   ?     -      Unknown/unused/undoc     maybe card-detect switch?
  7   undoc -      WRPROTECT      probably write-protect switch
  8   undoc undoc  CARD_REMOVE_A    ;\
  9   undoc undoc  CARD_INSERT_A    ; uh, somewhat dupes of bit3-5?
  10  undoc -      SIGSTATE_A       ;/
  11  ?     -      Unknown/unused/undoc
  12  ?     -      Unknown/unused/undoc
  13  ?     -      Unknown/unused/undoc
  14  ?     -      Unknown/unused/undoc
  15  ?     -      Unknown/unused/undoc
  16  SCIX  MCIX   CMD_IDX_ERR   Bad CMD-index in response      (RCMDE,SCMDE)
  17  SCRC  MCRC   CRCFAIL       CRC response error (WCRCE,RCRCE,SCRCE,CCRCE)
  18  SEND  MEND   STOPBIT_ERR   End bit error      (WEBER,REBER,SEBER,CEBER)
  19  SDTO  MDTO   DATATIMEOUT   Data Timeout                (NRCS,NWCS,KBSY)
  20  SFOF  MFOF   RXOVERFLOW    HOST tried write full
  21  SFUF  MFUF   TXUNDERRUN    HOST tried read empty
  22  SCTO  MCTO   CMDTIMEOUT    Response start-bit timeout         (NRS,NSR)
  23  ?     -      Unknown/unused/undoc
  24  SBRE  MBRE   RXRDY         (fifo not empty)
  25  SBWE  MBWE   TXRQ          (datafifoempty?)
  26  ?     -      Unknown/unused/undoc
  27  undoc undoc  Unknown/used?! (the bit is mask-able in IRQ_MASK)
  28  ?     -      Unknown/unused/undoc
  29  ILFSL IFSMSK ILL_FUNC      Illegal SDIO Function  ;SDIO only (not SD)
  30  undoc -      CMD_BUSY
  31  ILA   IMSK   Illegal Command Access (old CMD still busy, or wrong NTDT)
</TD></TR></TABLE>
Acknowledge by STAT=0, or by MASK=1, or by soft reset (SRST=0) or hard reset.<BR>
The Insert/Remove bits (bit3,4, and maybe also bit8,9) exist in the "SD"
registers only, not in the "SDIO" registers (the bits should be treated as
general insert/remove flags though, no matter if the card is an SD or SDIO
card).<BR>
Bit29 is SDIO related, and exist in SDIO registers only, not in SD registers.<BR>
<BR>
<B>400482Ch 4  2000 ?     SD_ERROR_DETAIL_STATUS0-1 - Error Detail Status</B><BR>
<B>4004A2Ch 4  0    ?     SDIO_ERROR_DETAIL_STATUS0-1 - Error Detail Status</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-23 ?      Unknown/unused/undoc
  22    KBSY   Timeout for CRC status busy timeout                  ;\STAT.19
  21    NWCS   Timeout for CRC status timeout                       ; (SDTO)
  20    NRCS   Timeout for Data start-bit, or for Post Data Busy    ;/
  19-18 ?      Unknown/unused/undoc
  17    NRS    Response timeout for auto-issued CMD12               ;\STAT.22
  16    NCR    Response timeout for non-auto-issued CMD's           ;/(SCTO)
  15-14 ?      Unknown/unused/undoc
  13    ??     Unknown/undoc (bit13 can be nonzero on DSi!)
  12    ?      Unknown/unused/undoc
  11    WCRCE  CRC error for Write CRC status for a write command   ;\
  10    RCRCE  CRC error for read data                              ; STAT.17
  9     SCRCE  CRC error for a response for auto-issued CMD12       ; (SCRC)
  8     CCRCE  CRC error for a response for non-auto-issued CMD's   ;/
  5     WEBER  End bit error for Write CRC status                   ;\
  4     REBER  End bit error for read data                          ; STAT.18
  3     SEBER  End bit error for response for auto-issued CMD12     ; (SEND)
  2     CEBER  End bit error for response for non-auto-issued CMD's ;/
  1?    SCMDE  Bad CMD-index in response of auto-issued CMD12       ;\STAT.16
  0     RCMDE  Bad CMD-index in response of non-auto-issued CMD's   ;/(SCIX)
</TD></TR></TABLE>
Note: CMD12 is STOP_TRANSMISSION (maybe sent after BLK_COUNT?).<BR>
The four "auto-issued CMD12" bits exist for SD registers only (not SDIO).<BR>
SCMDE is probably in bit1 (though, official specs say bit0, which would be same
as RCMDE).<BR>
<BR>
<B>4004A36h - DSi: 0000 - SDCTL_CARD_INTERRUPT_CONTROL</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-13  ?      Unknown (zero on DSi)
  12     CINT0  SDIO Interrupt Flag (0=none, 1=irq)       (/IRQ aka Data1 pin)
  11-9   ?      Unknown (zero on DSi)
  8      CIMSK0 SDIO Interrupt Mask (0=enable, 1=disable) (/IRQ aka Data1 pin)
  7-0    ?      Unknown (zero on DSi)
</TD></TR></TABLE>
Acknowledge by writing CINT0=0, or CIMSK0=1, or hard reset (unlike as for other
SD/MMC interrupts, soft reset does not acknowlege this interrupt type?).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcioportsmisc"></A>&nbsp;
  DSi SD/MMC I/O Ports: Misc
</FONT></TD></TR></TABLE><BR>
<B>Ports</B><BR>
There appear to be separate command/response/data/control registers for Memory
Card access and SDIO access - although both are using the same bus. The
controller is probably somehow automatically interleaving Memory and SDIO
transmissions (so memory cards and SDIO extensions could use separate software
drivers, without needing to share the same set of I/O ports).<BR>
<BR>
<B>Values for "SD_IRQ_MASK"</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Toshiba Disable All IRQs: 837F031Dh  ;&lt;-- Toshiba: without bit27
  DSi 4004820h spotted:     8B7F0305h  ;&lt;-- #1: no cart remove/insert
  DSi 4004A20h spotted:     8B7F031Dh  ;&lt;-- #2: with cart remove/insert
</TD></TR></TABLE>
The above DSi values have been spotted somewhere during DSi booting, unknown if
value 8B7F031Dh does disable ALL irqs, and unknown if the two cleared bits in
port 4004820h do mean that the Remove/Insert IRQs are &lt;enabled&gt; or
&lt;unsupported&gt; on that port).<BR>
<BR>
<B>Toshiba Chips</B><BR>
The DSi SDIO/MMC port addresses and status bits appear to be identical to those
on Toshiba SD/MMC/SDIO controller chips.<BR>
One small difference is that the DSi can set SD_IRQ_MASK.Bit27 (which wasn't
used on (older) Toshiba chips). The Toshiba chips seem to include additional
"CNF" configuration registers (which seem to be missing on DSi).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Chip             Year   Pages Features
  Toshiba TC6371AF 2000-2002 58 SD/MMC/Smart/PCI (old/basic specs, no SDIO)
  Toshiba TC6380AF 2001-2002 90 SD/MMC/SDIO/SmartMedia
  Toshiba TC6387XB 2001-2002 62 SD/MMC/SDIO/SDLED
  Toshiba TC6391XB 2002     202 SD/MMC/SDIO/SmartMedia/USB/LCD/etc.
  Toshiba TC6393XB ?  ;\unknown features, no datasheet exists (the chips
  Toshiba T7L66XB  ?  ;/are mentioned in tmio_mmc.h and tmio_mmc.c source)
</TD></TR></TABLE>
The TC6380AF/TC6387XB/TC6391XB datasheets are more or less identical on the
SD/MMC/SDIO section, TC6387XB is probably the best reference because it doesn't
contain offtopic extras like SmartMedia, USB, LCD, etc. The datasheets contain
I/O Maps with port addresses, but no description tables for the bits in those
ports (though some bits are mentioned here and there in the text, but the bits
are scattered across many different pages, and other bits are left completely
undocumented).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcprotocolcommandresponseregistersummary"></A>&nbsp;
  DSi SD/MMC Protocol: Command/Response/Register Summary
</FONT></TD></TR></TABLE><BR>
All future reserved commands shall have a codeword length of 48 bits, as well
as their responses (if there are any).<BR>
<BR>
<B>Basic Commands (class 0)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  CMD0     sd/mmc spi GO_IDLE_STATE (type=bc)
  CMD1     sd/mmc spi SEND_OP_COND (On SD Cards: SPI only)
  CMD2     sd/mmc     ALL_SEND_CID (type=bcr)
  CMD3     sd         SEND_RELATIVE_ADDR (type=bcr)
  CMD3     mmc        SET_RELATIVE_ADDR (type=ac)
  CMD4     sd         SET_DSR (type=bc)
  CMD5     sd     spi Reserved for I/O cards (see "SDIO Card Specification")
  CMD7     sd/mmc     SELECT/DESELECT_CARD (type=ac) ;actually: (type=bcr)
  CMD8     sd     spi SEND_IF_COND (type=bcr)
  CMD8     mmc    spi SEND_EXT_CSD (type=adtc)
  CMD9     sd/mmc spi SEND_CSD (type=ac) (SPI: type=adtc)
  CMD10    sd/mmc spi SEND_CID (type=ac) (SPI: type=adtc)
  CMD11    sd         VOLTAGE_SWITCH (type=ac)
  CMD12    sd/mmc spi STOP_TRANSMISSION (type=ac)
  CMD13    sd/mmc spi SEND_STATUS (type=ac) (sends 16bit status in SPI Mode)
  CMD14    mmc        BUSTEST_R (type=adtc) (MMC only, Reserved on SD)
  CMD19    mmc        BUSTEST_W (type=adtc) (MMC only, SEND_TUNING_BLOCK on SD)
  CMD15    sd/mmc     GO_INACTIVE_STATE (type=ac)
</TD></TR></TABLE>
<BR>
<B>Block-Oriented Read Commands (class 2)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  CMD16    sd/mmc spi SET_BLOCKLEN (type=ac)
  CMD17    sd/mmc spi READ_SINGLE_BLOCK (type=adtc)
  CMD18    sd/mmc spi READ_MULTIPLE_BLOCK (type=adtc)
  CMD19    sd         SEND_TUNING_BLOCK (type=adtc)
  CMD20    sd         SPEED_CLASS_CONTROL (type=ac)
  CMD22    sd         Reserved
  CMD23    sd/mmc-spi SET_BLOCK_COUNT (type=ac) (SPI supported ONLY on MMC?)
</TD></TR></TABLE>
<BR>
<B>Block-Oriented Write Commands (class 4)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  CMD16    sd/mmc spi SET_BLOCKLEN (type=ac)
  CMD20    sd         SPEED_CLASS_CONTROL (type=ac)
  CMD23    sd/mmc-spi SET_BLOCK_COUNT (type=ac) (SPI supported ONLY on MMC?)
  CMD24    sd/mmc spi WRITE_BLOCK (type=adtc)
  CMD25    sd/mmc spi WRITE_MULTIPLE_BLOCK (type=adtc)
  CMD26    sd         Reserved For Manufacturer
  CMD27    sd/mmc spi PROGRAM_CSD (type=adtc)
</TD></TR></TABLE>
<BR>
<B>Block-Oriented Write-Protection Commands (class 6)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  CMD28    sd/mmc spi SET_WRITE_PROT (type=ac)
  CMD29    sd/mmc spi CLR_WRITE_PROT (type=ac)
  CMD30    sd/mmc spi SEND_WRITE_PROT (type=adtc)
  CMD31    -          Reserved
</TD></TR></TABLE>
<BR>
<B>Erase Commands (class 5)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  CMD32    sd     spi ERASE_WR_BLK_START (type=ac)
  CMD33    sd     spi ERASE_WR_BLK_END (type=ac)
  CMD32-34 mmc    spi Reserved for compatibility with older MMC cards (uh?)
  CMD35    mmc    spi ERASE_GROUP_START (type=ac)
  CMD36    mmc    spi ERASE_GROUP_END (type=ac)
  CMD37    mmc    spi Reserved for compatibility with older MMC cards (uh?)
  CMD38    sd/mmc spi ERASE (type=ac)
  CMD39    -          Reserved
  CMD41    -          Reserved
</TD></TR></TABLE>
<BR>
<B>Lock Card (class 7)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  CMD16    sd/mmc spi SET_BLOCKLEN (type=ac)
  CMD40    sd         Defined by DPS Spec (type=adtc)
  CMD42    sd/mmc spi LOCK_UNLOCK (type=adtc)
  CMD43-47 -          Reserved
  CMD51    -          Reserved
</TD></TR></TABLE>
<BR>
<B>Application-Specific Commands (class 8)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  CMD39-40 mmc        MMCA Optional Command, currently not supported
  CMD55-56 mmc        MMCA Optional Command, currently not supported
  CMD55    sd     spi APP_CMD (type=ac)    ;\also defined for MMC,
  CMD56    sd     spi GEN_CMD (type=adtc)  ;/but ONLY in SPI mode !!??
  CMD60-63 sd/mmc spi Reserved for manufacturer
</TD></TR></TABLE>
<BR>
<B>I/O Mode Commands (class 9)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  CMD52-54 sd     spi Commands for SDIO (Refer to "SDIO Card Specification")
</TD></TR></TABLE>
<BR>
<B>Switch Function Commands (class 10) (version 1.10+)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  CMD6     mmc    spi SWITCH      (type=ac)   ;related to EXT_CSD register
  CMD6     sd     spi SWITCH_FUNC (type=adtc)
  CMD34-37 sd+spi     Reserved for Command Systems from CMD6  ;\SPI
  CMD50,57 sd+spi     Reserved for Command Systems from CMD6  ;/
  CMD34-35 sd         Reserved                                ;\
  CMD36-37 sd         Undoc (description field is held blank) ; Non-SPI
  CMD50,57 sd         Undoc (description field is held blank) ;/
</TD></TR></TABLE>
<BR>
<B>Function Extension Commands (class 11)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  CMD21    sd         Reserved for DPS Specification
  CMD48    sd         READ_EXTR_SINGLE (type=adtc)
  CMD49    sd         WRITE_EXTR_SINGLE (type=adtc)
  CMD58    sd         READ_EXTR_MULTI (type=adtc)   ;SPI: READ_OCR
  CMD59    sd         WRITE_EXTR_MULTI (type=adtc)  ;SPI: CRC_ON_OFF
</TD></TR></TABLE>
<BR>
<B>Below CMD58-59 SPI-only (in Non-SPI mode: MMC=Reserved, SD=EXTR_MULTI)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  CMD58    sd/mmc+spi READ_OCR     ;SD Mode: READ_EXTR_MULTI
  CMD59    sd/mmc+spi CRC_ON_OFF   ;SD Mode: WRITE_EXTR_MULTI
</TD></TR></TABLE>
<BR>
<B>Application Specific Commands (prefixed by CMD55 aka APP_CMD)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ACMD6     sd        SET_BUS_WIDTH (type=ac)
  ACMD13    sd    spi SD_STATUS (type=adtc) (get 512bit SSR)
  ACMD22    sd    spi SEND_NUM_WR_BLOCKS (type=adtc)
  ACMD23    sd    spi SET_WR_BLK_ERASE_COUNT (type=ac)
  ACMD41    sd    spi SD_SEND_OP_COND (type=bcr)  ;SPI: reduced functionality
  ACMD42    sd    spi SET_CLR_CARD_DETECT (type=ac)
  ACMD51    sd    spi SEND_SCR (type=adtc)
  ACMD1-5   -         Reserved
  ACMD7-12  -         Reserved
  ACMD14-16 sd        Reserved for DPS Specification
  ACMD17    -         Reserved
  ACMD18    sd    spi Reserved for SD security applications
  ACMD19-21 -         Reserved
  ACMD24    -         Reserved
  ACMD25    sd    spi Reserved for SD security applications
  ACMD26    sd    spi Reserved for SD security applications
  ACMD27    -         Shall not use this command
  ACMD28    sd        Reserved for DPS Specification
  ACMD29    -         Reserved
  ACMD30-35 sd        Reserved for Security Specification
  ACMD36-37 -         Reserved
  ACMD38    sd    spi Reserved for SD security applications
  ACMD39-40 -         Reserved
  ACMD43-49 sd    spi Reserved for SD security applications
  ACMD52-54 sd        Reserved for Security Specification
  ACMD55    -         Not exist (equivalent to CMD55)
  ACMD56-59 sd        Reserved for Security Specification
  ACMD0     -         Unknown/Unused/Undocumented
  ACMD50    -         Unknown/Unused/Undocumented
  ACMD60-63 -         Unknown/Unused/Undocumented
</TD></TR></TABLE>
<BR>
<B>Card Registers</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  CSR       32bit  sd/mmc spi Card Status: command error &amp; state information
  OCR       32bit  sd/mmc spi Operation Conditions Register
  CID      128bit  sd/mmc spi Card Identification
  CSD      128bit  sd/mmc spi Card-Specific Data (CSD Version 1.0 and 2.0)
  RCA       16bit  sd/mmc     Relative Card Address (not used in SPI mode)
  DSR       16bit  sd/mmc spi Driver Stage Register (optional)
  SSR      512bit  sd     spi SD Card Status Register: Extended status field
  SCR       64bit  sd     spi SD Card Configuration Register
  EXT_CSD 4096bit  mmc    spi MMC Extended CSD Register (status &amp; config)
  PWD      128bit  sd/mmc spi Password (Card Lock) (max 16 bytes)
  PWD_LEN    8bit  sd/mmc spi Password Length (0..16 max) (0=no password)
</TD></TR></TABLE>
<BR>
<B>SD Mode Response Types</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  N/A    0bit  CMD0, CMD4, CMD15   No response
  R1    48bit  Normal CMDs/ACMDs   32bit CSR Card Status
  R1b   48bit  Busy CMDs/ACMDs     32bit CSR Card Status (and DATA=busy)
  R2   136bit  CMD9                120bit CSD Card-Specific Data
  R2   136bit  CMD2, CMD10         120bit CID Card Identification
  R3    48bit  ACMD41              32bit OCR Register (without crc7)
  R4        -  -                   Reserved for SDIO
  R5        -  -                   Reserved for SDIO
  R6    48bit  CMD3                16bit RCA and cut-down 16bit CSR
  R7    48bit  CMD8                32bit Card interface condition
</TD></TR></TABLE>
<BR>
<B>SPI Mode Response Types</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  R1     8bit  Normal CMDs/ACMDs   8bit CSR Card Status
  R1b    8bit  Busy CMDs/ACMDs     8bit CSR Card Status (and DATA=busy)
  R2    16bit  CMD13, ACMD13       16bit CSR Card Status
  R3    40bit  CMD58               8bit CSR and 32bit OCR
  R4        -  -                   Reserved for SDIO
  R5        -  -                   Reserved for SDIO
  R6        -  -                   Reserved
  R7    40bit  CMD8                8bit CSR and 32bit Card interface condition
  ERROR  8bit  Only first 8bit sent upon Illegal Command or Command CRC Error
</TD></TR></TABLE>
<BR>
<B>Commands with Data Transfers (additionally to command/response) (type=adtc)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  CMD17,18 R/W sd/mmc spi READ_SINGLE_BLOCK, READ_MULTIPLE_BLOCK
  CMD24,25 R/W sd/mmc spi WRITE_BLOCK, WRITE_MULTIPLE_BLOCK
  CMD8     R   mmc    spi SEND_EXT_CSD (4096bit)
  CMD9     R   sd/mmc spi SEND_CSD (128bit)  ;\in SPI Mode only (Non-SPI mode
  CMD10    R   sd/mmc spi SEND_CID (128bit)  ;/sends that info as CMD response)
  ACMD13   R   sd     spi SD_STATUS (512bit SSR register)
  ACMD22   R?  sd     spi SEND_NUM_WR_BLOCKS (32bit counter)
  ACMD51   R   sd     spi SEND_SCR (64bit SCR register)
  CMD14,19 R/W mmc        BUSTEST_R, BUSTEST_W
  CMD19    W?  sd         SEND_TUNING_BLOCK (512bit tuning pattern)
  CMD27    W   sd/mmc spi PROGRAM_CSD (128bit CSD register)
  CMD30    R   sd/mmc spi SEND_WRITE_PROT (32bit write-protect flags)
  CMD42    W   sd/mmc spi LOCK_UNLOCK (password header/data)
  CMD6     ??  sd     spi SWITCH_FUNC
  CMD40    ?   sd         Defined by DPS Spec
  CMD48,49 R/W sd         READ_EXTR_SINGLE, WRITE_EXTR_SINGLE
  CMD58,59 R/W sd         READ_EXTR_MULTI, WRITE_EXTR_MULTI
  CMD56    R/W sd     spi GEN_CMD
 xR1b      R   sd/mmc spi Busy signal for commands with "R1b" response
</TD></TR></TABLE>
<BR>
<B>Misnamed Commands</B><BR>
Official command names include various SEND_xxx commands, which are misleading
because they don't indicate if they "send" information &lt;to&gt; or
&lt;from&gt; the card (or both). Better naming would be GET_xxx, SET_xxx, or
GET_SET_xxx.<BR>
Other misnamed commands include SET_BLOCKLEN occassionally spelled
SET_BLOCK_LEN in SD specs.<BR>
<BR>
<B>Difference of SD Commands Definition in UHS-II</B><BR>
SD-TRAN driver of host should manage the difference of SD commands functions.
Not supported commands should not issue to UHS-II card. CMD13 shall not be
issued during data transfer. Normally, data transfer should be stopped by
setting TLEN instead of using CMD12.<BR>
CMD23 and CMD55 functions are included in UHS-II packet functions.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 CMD0   Terminate SD transaction and reset SD-TRAN state.
 CMD3   Returns Device ID in the response instead of RCA
 CMD4   Illegal
 CMD6   Function Group 1 and 3 are not used.
 CMD7   Device ID is set to the argument instead of RCA
 CMD13  Device operation is up to implementation during data transfer (eg. CTS)
 CMD11  Illegal
 CMD12  Normally, TLEN (data length) in UHS-II packet is used to stop data
        transfer.
 CMD12  Should be used to abort an operation when illegal situation occurs.
 CMD15  Illegal
 CMD19  Illegal
 CMD23  Not Affected. TLEN in UHS-II packet is used to specify data length.
 CMD55  Not Affected. ACMD is set by APP field in UHS-II packet.
 ACMD6  Illegal
 ACMD42 Illegal
</TD></TR></TABLE>
Not Affected means that the command is not executed in any card state, and
response is returned (response type is up to implementation).<BR>
Illegal means that card returns response with NACK=1.<BR>
As SDHC/SDXC Cards do not support CMD28, 29 and 30, these commands are also
illegal in UHS-II mode.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcprotocolgeneralcommands"></A>&nbsp;
  DSi SD/MMC Protocol: General Commands
</FONT></TD></TR></TABLE><BR>
<B>CMD0 - SD/MMC - SPI - GO_IDLE_STATE (type=bc)</B><BR>
Parameter bits:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-0  stuff bits
</TD></TR></TABLE>
SD Mode Response: N/A<BR>
SPI Mode Response: R1<BR>
Resets all cards to idle state. The command does also seem to reset further
registers (for example, TRAN_SPEED is said to be reset to 25MHz).<BR>
The command is also used to enter SPI mode (in SPI mode, the /CS pin held low,
while in 1bit/4bit mode that pin would be DAT3=floating/high), SPI commands can
be sent without CRCs, however, at time when entering SPI mode, memory cards may
still insist on checksums, CMD0 should be thus always sent with CRC7.<BR>
<BR>
<B>CMD8 - SD (SD v2.00 and up) - SPI - SEND_IF_COND (type=bcr)</B><BR>
Parameter bits:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-12 reserved bits
  11-8  supply voltage (VHS)
  7-0   check pattern
</TD></TR></TABLE>
SD Mode Response: R7:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  47      Start Bit (0)                                 ;\
  46      Transmission To Host (0)                      ; 1st byte
  45-40   Command (the 6bit CMD being responded to)     ;/
  39-20   Reserved (zero filled)           (20bit)      ;\2nd..4th byte
  19-16   Voltage accepted (see below)     (4bit)       ;/
  23-8    Echo-back of check pattern       (8bit)       ;-5th byte
  7-1     CRC7                                          ;\6th byte
  0       End Bit (1)                                   ;/
</TD></TR></TABLE>
SPI Mode Response: R7:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  39-32  R1 (8bit Card Status, same as in normal SPI command responses)
  31-28  Command version (???)         (4bit)
  27-12  Reserved (0)                  (16bit)
  11-8   Voltage Accepted (see below)  (4bit)
  7-0    Echo-back of check pattern    (8bit)
</TD></TR></TABLE>
Sends SD Memory Card interface condition, which includes host supply voltage
information and asks the card whether card supports voltage.<BR>
Voltage Accepted values:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0001b  = 2.7-3.6V
  0010b  = Reserved for Low Voltage Range
  0100b  = Reserved
  1000b  = Reserved
  Others = Not Defined
</TD></TR></TABLE>
The card supported voltage information of 3.3V range power pin is sent by the
response of CMD8. Bits 19-16 indicate the voltage range that the card supports.
The card that accepted the supplied voltage returns R7 response. In the
response, the card echoes back both the voltage range and check pattern set in
the argument.<BR>
<BR>
<B>CMD11 - SD - VOLTAGE_SWITCH (type=ac)</B><BR>
Parameter bits:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-0  reserved bits (0)
</TD></TR></TABLE>
Response: R1<BR>
Switch to 1.8V bus signaling level.<BR>
<BR>
<B>CMD12 - SD/MMC - SPI - STOP_TRANSMISSION (type=ac)</B><BR>
Parameter bits:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-0  stuff bits
</TD></TR></TABLE>
Response: R1b<BR>
Additional Data Transfer (from card): Busy signal for "R1b" response<BR>
Forces the card to stop transmission (SPI: in Multiple Block Read Operation).<BR>
Note: Toshiba SD/MMC controllers are sending STOP_TRANSMISSION automatically.<BR>
<BR>
<B>CMD15 - SD/MMC - GO_INACTIVE_STATE (type=ac)</B><BR>
Parameter bits:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-16 RCA
  15-0  reserved bits (0)
</TD></TR></TABLE>
Response: N/A<BR>
Sends an addressed card into the Inactive State. This command is used when the
host explicitly wants to deactivate a card.<BR>
<BR>
<B>CMD59 - SD/MMC - SPI-ONLY (not Non-SPI Mode) - CRC_ON_OFF</B><BR>
Supported in SPI Mode only (in Non-SPI mode, CMD59 would be: MMC=Reserved,
SD=WRITE_EXTR_MULTI)!<BR>
Parameter bits:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-1  stuff bits
  0     CRC option (0=off, 1=on)
</TD></TR></TABLE>
SPI Mode Response: R1<BR>
Default on power up is unknown. Also unknown if this does completely prevent
transmission of both CRC7 and CRC-CCITT values (especially in case of CID/CSD
registers that have the CRC7 "inside" of the "128bit" register). Also unknown
if CID/CSD are having "double" checksums (CRC7 plus CRC-CCITT) when
transferring them as DATA packet (instead of as normal command/response).<BR>
<BR>
<B>ACMD6 - SD - SET_BUS_WIDTH (type=ac)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-2  stuff bits
  1-0   Bus width for Data transfers (0=1bit, 2=4bit, 1/3=reserved).
</TD></TR></TABLE>
Response: R1<BR>
The supported widths can be found in SCR register. The current width is stored
in SSR register. Default width is 1bit on power up.<BR>
Note: MMC uses a different mechanism to change the bus-width (via EXT_CSD).<BR>
<BR>
<B>ACMD42 - SD - SPI - SET_CLR_CARD_DETECT (type=ac)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-1  stuff bits
  0     set_cd (0=Disconnect, 1=Connect)
</TD></TR></TABLE>
Response: R1<BR>
Connect/Disconnect the 50 KOhm pull-up resistor on CD/DAT3 pin of the card.<BR>
The pull-up might be intended for card detection (other than by using the
slot's card detect switch), and/or for sensing SPI mode (which would drag that
pin to LOW level when asserting /CS chip select).<BR>
During operation, disabling the pull-up might improve data transfers (unless
for card controllers which do rely on the card pull-up to be present). The
TC6387XB datasheet recommends external 100K pull-ups on DAT0-2, and only 47K on
DAT3 (not quite sure why, unless Toshiba believed the parallel 50K+47K pull-ups
to sum up to approximately 100K).<BR>
<BR>
<B>CMD55 - SD/MMC (MMC: only in SPI-mode?) - SPI - APP_CMD (type=ac)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-16  RCA (SPI Mode: stuff bits)
  15-0   stuff bits
</TD></TR></TABLE>
Response: R1<BR>
Used as prefix for application specific commands, ie. the next command will be
treated as "ACMDnn" rather than as normal "CMDnn".<BR>
As the name says, this was originally intended for "application specific"
extensions, however, in the SD Card protocol, it's also used for some ACMD's
that are part of the SD protocol.<BR>
<BR>
<B>CMD56 - SD/MMC (MMC: only in SPI-mode?) - SPI - GEN_CMD (type=adtc)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-1  stuff bits
  0     RD/WR Direction (0=Write to Card, 1=Read from Card)
</TD></TR></TABLE>
Response: R1<BR>
Additional Data Transfer (to/from card, depending on above R/W bit):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  General purpose data
  For SDSC, block length is set via SET_BLOCKLEN command.
  For SDHC/SDXC, block length is fixed to 512 bytes.
</TD></TR></TABLE>
Used to transfer a data block to/from the card for general purpose/application
specific commands.<BR>
<BR>
<B>CMD14 - MMC - BUSTEST_R (type=adtc) (MMC only, Reserved on SD)</B><BR>
<B>CMD19 - MMC - BUSTEST_W (type=adtc) (MMC only, SEND_TUNING_BLOCK on SD)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-0  stuff bits
</TD></TR></TABLE>
Response: R1<BR>
Additional Data Transfer (to/from card):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  test pattern (2bit per DATA line? eg. 8bit pattern in 4bit-mode?)
</TD></TR></TABLE>
MMC only. And, that, in Non-SPI mode only.<BR>
BUSTEST_W: Host sends the "bus TEST Data pattern" to card.<BR>
BUSTEST_R: Host reads the "REVERSED bus TESTING data pattern" from card.<BR>
The reversing is said to change a 2bit value of "01" into "10", unknown if that
means that the bit-order is reversed, or that the bits are inverted.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcprotocolblockreadwritecommands"></A>&nbsp;
  DSi SD/MMC Protocol: Block Read/Write Commands
</FONT></TD></TR></TABLE><BR>
<B>CMD16 - SD/MMC - SPI - SET_BLOCKLEN (type=ac)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-0  Block length (for Block Read, Block Write, Lock, and GEN_CMD)
</TD></TR></TABLE>
Response: R1<BR>
In the case of SDSC Card, this command sets the block length (in bytes) for all
following block commands (read, write, lock). Default block length is fixed to
512 Bytes. Set length is valid for memory access commands only if partial block
read operation are allowed in CSD.<BR>
In the case of SDHC/SDXC Cards, block length set by CMD16 command does not
affect memory read and write commands. Always 512 Bytes fixed block length is
used. This command is effective for LOCK_UNLOCK command.<BR>
In both cases, if block length is set larger than 512 Bytes, the card sets the
BLOCK_LEN_ERROR bit.<BR>
In DDR50 mode, block length must be even (because data is sampled on both clock
edges).<BR>
<BR>
<B>CMD20 - SD (optional, see SCR.Bit32) - SPEED_CLASS_CONTROL (type=ac)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-28  Speed Class Control (for Block Read, and Block Write commands)
  27-0   Reserved (0)
</TD></TR></TABLE>
Response: R1b<BR>
Additional Data Transfer (from card): Busy signal for "R1b" response<BR>
Speed Class control command. Refer to Section 4.13.2.8.<BR>
<BR>
<B>CMD23 - SD/MMC - SPI (but only on MMC) - SET_BLOCK_COUNT (type=ac)</B><BR>
Supported by SD and MMC Cards. However, in SPI-mode it's supported only for
MMC? And, for SD it's optional (see SCR.Bit33).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-0  Block Count (MMC: only lower 16bit used, upper 16bit=reserved)
</TD></TR></TABLE>
Response: R1<BR>
Specify block count for CMD18 and CMD25.<BR>
<BR>
================ Block-Oriented READ Commands ================<BR>
<BR>
<B>CMD17 - SD/MMC - SPI - READ_SINGLE_BLOCK (type=adtc)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-0  data address (SDSC: in 1-byte units, SDHC/SDXC: in 512-byte units)
</TD></TR></TABLE>
Response: R1<BR>
Additional Data Transfer (from card):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  data
</TD></TR></TABLE>
In the case of SDSC Card, this command reads a block of the size selected by
the SET_BLOCKLEN command. The data transferred shall not cross a physical block
boundary unless READ_BLK_MISALIGN is set in the CSD.<BR>
In case of SDHC and SDXC Cards, block length is fixed 512 Bytes regardless of
the SET_BLOCKLEN command.<BR>
<BR>
<B>CMD18 - SD/MMC - SPI - READ_MULTIPLE_BLOCK (type=adtc)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-0  data address (SDSC: in 1-byte units, SDHC/SDXC: in 512-byte units)
</TD></TR></TABLE>
Response: R1<BR>
Additional Data Transfer (from card):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  data
</TD></TR></TABLE>
Continuously transfers data blocks from card to host until interrupted by a
STOP_TRANSMISSION command.<BR>
Block length is specified the same as READ_SINGLE_BLOCK command.<BR>
<BR>
<B>CMD19 - SD - SEND_TUNING_BLOCK (type=adtc)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-0  reserved bits (0)
</TD></TR></TABLE>
Response: R1<BR>
Additional Data Transfer (to card):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  64 bytes (512bit) tuning pattern is sent for SDR50 and SDR104.
</TD></TR></TABLE>
<BR>
================ Block-Oriented WRITE Commands ================<BR>
<BR>
<B>CMD24 - SD/MMC - SPI - WRITE_BLOCK (type=adtc)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-0  data address (SDSC: in 1-byte units, SDHC/SDXC: in 512-byte units)
</TD></TR></TABLE>
Response: R1<BR>
Additional Data Transfer (to card):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  data
</TD></TR></TABLE>
In case of SDSC Card, block length is set by the SET_BLOCKLEN command. The data
transferred shall not cross a physical block boundary unless WRITE_BLK_MISALIGN
is set in the CSD. In the case that write partial blocks is not supported, then
the block length=default block length (given in CSD).<BR>
In case of SDHC and SDXC Cards, block length is fixed 512 Bytes regardless of
the SET_BLOCKLEN command.<BR>
<BR>
<B>CMD25 - SD/MMC - SPI - WRITE_MULTIPLE_BLOCK (type=adtc)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-0  data address (SDSC: in 1-byte units, SDHC/SDXC: in 512-byte units)
</TD></TR></TABLE>
Response: R1<BR>
Additional Data Transfer (to card):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  data
</TD></TR></TABLE>
Continuously writes blocks of data until a STOP_TRANSMISSION follows.<BR>
Block length is specified the same as WRITE_BLOCK command.<BR>
<BR>
<B>ACMD22 - SD - SPI - SEND_NUM_WR_BLOCKS (type=adtc)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-0  stuff bits
</TD></TR></TABLE>
Response: R1<BR>
Additional Data Transfer (from card):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-0  Number of the written (without errors) write blocks (32bit)
</TD></TR></TABLE>
Responds with 32bit+CRC data block.<BR>
If WRITE_BL_PARTIAL='0', the unit of ACMD22 is always 512 byte.<BR>
If WRITE_BL_PARTIAL='1', the unit of ACMD22 is a block length which was used
when the write command was executed.<BR>
<BR>
<B>ACMD23 - SD - SPI - SET_WR_BLK_ERASE_COUNT (type=ac)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-23  stuff bits
  22-0   Number of blocks
</TD></TR></TABLE>
Response: R1<BR>
Set the number of write blocks to be pre-erased before writing (to be used for
faster Multiple Block WR command). "1"=default (one wr block).<BR>
Command STOP_TRAN (CMD12) shall be used to stop the transmission in Write
Multiple Block whether or not the pre-erase (ACMD23) feature is used.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcprotocolspecialextracommands"></A>&nbsp;
  DSi SD/MMC Protocol: Special Extra Commands
</FONT></TD></TR></TABLE><BR>
================ Write PROTECTION Commands ================<BR>
<BR>
<B>CMD28 - SDSC/MMC (not SDHC/SDXC) - SPI - SET_WRITE_PROT (type=ac)</B><BR>
<B>CMD29 - SDSC/MMC (not SDHC/SDXC) - SPI - CLR_WRITE_PROT (type=ac)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-0  data address (SDSC: in 1-byte units, SDHC/SDXC: Unsupported)
</TD></TR></TABLE>
Response: R1b<BR>
Additional Data Transfer (from card): Busy signal for "R1b" response<BR>
Write protection support is indicated in CSD(WP_GRP_ENABLE), and additionally
"class 6" should be flagged in CSD(CCC). The group size is indicated in
CSD(WP_GRP_SIZE), observe that that field is 5bit/7bit wide for SD/MMC
accordingly.<BR>
<BR>
<B>CMD30 - SDSC/MMC (not SDHC/SDXC) - SPI - SEND_WRITE_PROT (type=adtc)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-0  data address (SDSC: in 1-byte units, SDHC/SDXC: Unsupported)
</TD></TR></TABLE>
Response: R1<BR>
Additional Data Transfer (from card):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-0  Flags (1=write-protected) (bit0=addressed group, bit1..31=next groups)
</TD></TR></TABLE>
If the card provides write protection features, this command asks the card to
send the status of the write protection bits: 32 write protection bits
(representing 32 write protect groups starting at the specified address)
followed by 16 CRC bits are transferred in a payload format via the DATA line.
The last (least significant) bit of the protection bits corresponds to the
first addressed group. If the addresses of the last groups are outside the
valid range, then the corresponding write protection bits shall be set to 0.<BR>
<BR>
<B>Further Write-Protection Mechanisms</B><BR>
The whole card can be write-protected via PERM_WRITE_PROTECT and
TMP_WRITE_PROTECT bits in CSD register (supported for MMC and SDSC/SDHC/SDXC).<BR>
SD Cards (and SD Card adaptors for miniSD and microSD cards) are additionally
having a mechanical "LOCK" write protection tab (MMC cards don't have that
feature).<BR>
The PWD feature provides Read/Write-protection (when not knowing the password).<BR>
<BR>
================ Erase Commands ================<BR>
<BR>
<B>CMD32 - SD - SPI - ERASE_WR_BLK_START (type=ac)</B><BR>
<B>CMD33 - SD - SPI - ERASE_WR_BLK_END (type=ac)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-0  data address (SDSC: in 1-byte units, SDHC/SDXC: in 512-byte units)
</TD></TR></TABLE>
Response: R1<BR>
Sets the address of the first/last write block of the continuous range to be
erased.<BR>
<BR>
<B>CMD35 - MMC - SPI - ERASE_GROUP_START (type=ac)</B><BR>
<B>CMD36 - MMC - SPI - ERASE_GROUP_END (type=ac)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-0  data address (MMC: in WHAT units?)
</TD></TR></TABLE>
Response: R1<BR>
MMC only. Unknown, maybe similar to above SD commands?<BR>
<BR>
<B>CMD32-34,37 - SPI - MMC - Reserved for compatibility with older MMC cards</B><BR>
MMC only. Unknown, maybe also Erase related?<BR>
<BR>
<B>CMD38 - SD/MMC - SPI - ERASE (type=ac)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-0  stuff bits
</TD></TR></TABLE>
Response: R1b<BR>
Additional Data Transfer (from card): Busy signal for "R1b" response<BR>
Erases all previously selected write blocks.<BR>
<BR>
<B>Further Erase Commands</B><BR>
Sectors are automatically erased on-the-fly when writing data blocks, so
manually using above erase commands isn't really necessary; it may be useful
for shreddering private data though, and it might also speed up subsequent
writes since the writes can omit the on-the-fly erasing step.<BR>
The SET_WR_BLK_ERASE_COUNT (ACMD23) can be used to notify the card that it may
pre-erase multiple sectors upon write commands (eg. to speed-up cluster writes
that are spanning across multiple sectors).<BR>
The password lock feature includes a Forced Erase function, which will reset
the password, and ERASE THE WHOLE CARD, this may be useful if the user has
forgot the password, but will destroy data (possibly including the
pre-formatted filesystem headers; which would be bad, because that headers
should contain cluster sizes somewhat matched to the physical sector sizes).<BR>
<BR>
================ I/O Commands ================<BR>
<BR>
<B>CMD5 - SD - SPI - Reserved for I/O cards</B><BR>
<B>CMD52-54 - SD - SPI - Commands for SDIO</B><BR>
Refer to the "SDIO Card Specification". SDIO is an extension to the SD protocol
that allows to access non-memory-card hardware (such like cameras or network
adaptors).<BR>
<BR>
================ Switch Function Commands ================<BR>
<BR>
<B>CMD6 - SD (SD v1.10 and up) - SPI - SWITCH_FUNC (type=adtc)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31     Mode (0=Check function, 1=Switch function)
  30-24  reserved (All '0')
  23-20  function group 6: Reserved (0h or Fh)
  19-16  function group 5: Reserved (0h or Fh)
  15-12  function group 4: Power Limit     ;SPI Mode: Reserved (0h or Fh)
  11-8   function group 3: Drive Strength  ;SPI Mode: Reserved (0h or Fh)
  7-4    function group 2: Command System
  3-0    function group 1: Access Mode
</TD></TR></TABLE>
Response: R1<BR>
Additional Data Transfer (to/from whatever):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  unknown
</TD></TR></TABLE>
Checks switch-able function (mode 0) and switch card function (mode 1). See
Chapter 4.3.10.<BR>
<BR>
<B>CMD34-35 - SD - Reserved</B><BR>
Reserved for each command system set by switch function command (CMD6).<BR>
Detailed definition is referred to each command system specification.<BR>
Maybe related to above "function group 5..6"?<BR>
<BR>
<B>CMD36,37 - SD - Undoc (description field is held blank)</B><BR>
<B>CMD50,57 - SD - Undoc (description field is held blank)</B><BR>
Undoc. Maybe related to above "function group 1..4"?<BR>
<BR>
<B>SPI: CMD34-37 - SD - SPI - Reserved for Command Systems from CMD6</B><BR>
<B>SPI: CMD50,57 - SD - SPI - Reserved for Command Systems from CMD6</B><BR>
Described as so for SPI Mode. Maybe related to above "function group 1..6"?<BR>
<BR>
================ Function Extension Commands ================<BR>
<BR>
<B>CMD21 - SD - Reserved for DPS Specification</B><BR>
Reserved.<BR>
<BR>
<B>CMD48 - SD (optional, see SCR.Bit34) - READ_EXTR_SINGLE (type=adtc)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31     MIO (0=Memory, 1=I/O)
  30-27  FNO
  26     Reserved (0)
  25-9   ADDR
  8-0    LEN
</TD></TR></TABLE>
Response: R1<BR>
Additional Data Transfer (from card):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  whatever
</TD></TR></TABLE>
Single block read type. Refer to Section 5.7.2.1.<BR>
<BR>
<B>CMD49 - SD (optional, see SCR.Bit34) - WRITE_EXTR_SINGLE (type=adtc)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31     MIO (0=Memory, 1=I/O)
  30-27  FNO
  26     MW
  25-9   ADDR
  8-0    LEN/MASK
</TD></TR></TABLE>
Response: R1<BR>
Additional Data Transfer (to card):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  whatever
</TD></TR></TABLE>
Single block write type. Refer to Section 5.7.2.2.<BR>
<BR>
<B>CMD58 - SD (optional, see SCR.Bit35) - READ_EXTR_MULTI (type=adtc)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31     MIO (0=Memory, 1=I/O)
  30-27  FNO
  26     BUS (0=512B, 1=32KB)
  25-9   ADDR
  8-0    BUC
</TD></TR></TABLE>
Response: R1<BR>
Additional Data Transfer (from card):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  whatever
</TD></TR></TABLE>
Multi-block read type. Refer to Section 5.7.2.4.<BR>
<BR>
<B>CMD59 - SD (optional, see SCR.Bit35) - WRITE_EXTR_MULTI (type=adtc)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31     MIO (0=Memory, 1=I/O)
  30-27  FNO
  26     BUS (0=512B, 1=32KB)
  25-9   ADDR
  8-0    BUC
</TD></TR></TABLE>
Response: R1<BR>
Additional Data Transfer (to card):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  whatever
</TD></TR></TABLE>
Multi-block write type. Refer to Section 5.7.2.5.<BR>
<BR>
Note: CCC bit 11 is set to 1 when any command of class 11 is supported.
Supporting of these commands is indicated in SCR register.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcprotocolcsrregister32bitcardstatusregister"></A>&nbsp;
  DSi SD/MMC Protocol: CSR Register (32bit Card Status Register)
</FONT></TD></TR></TABLE><BR>
<B>CMD13 - SD/MMC - SPI - SEND_STATUS (type=ac)</B><BR>
Parameter bits:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-16 RCA (SPI Mode: stuff bits)
  15-0  stuff bits
</TD></TR></TABLE>
SD Mode Response: R1 (32bit Card Status):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  47      Start Bit (0)                                 ;\
  46      Transmission To Host (0)                      ; 1st byte
  45-40   Command (the 6bit CMD being responded to)     ;/
  39-8    CSR Card Status Register (32bit) (see below)  ;-2nd..5th byte
  7-1     CRC7                                          ;\6th byte
  0       End Bit (1)                                   ;/
</TD></TR></TABLE>
SPI Mode Response: R2 (16bit Card Status):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-0    CSR Card Status Register (16bit) (see below)  ;-1st..2nd byte
</TD></TR></TABLE>
Addressed card sends its status register.<BR>
<BR>
<B>CMDxx/ACMDxx - Other Commands</B><BR>
Most other commands are also returning the Card Status in their responses:<BR>
SD Mode Response: R1 (32bit Card Status)<BR>
SPI Mode Response: R1 (8bit Card Status; most SPI commands return only 8bit)<BR>
SPI Mode Response: R2 (16bit Card Status; SPI commands CMD13/ACMD return 16bit)<BR>
<BR>
<B>CMDxx/ACMDxx - Other Commands with R1b Response</B><BR>
R1b is identical to R1, with an optional busy signal transmitted on the DATA
line (R1b occurs for CMD7, CMD12, CMD20, CMD28, CMD29, CMD38). The card may
become busy after receiving these commands based on its state prior to the
command reception. The Host shall check for busy at the response.<BR>
In SD Mode, the busy signal is sent on DAT0 line (DAT1-3 aren't used, even if
the card is in 4bit mode). The busy signal does consist of BITs? (not bytes?),
and has a "start bit"?, followed by what-value-when-busy? and
what-final-value-when-ready?<BR>
In SPI Mode, the busy signal is sent as BYTEs (00h=Busy, xxh=Nonzero=Ready).<BR>
<BR>
<B>CSR Card Status Register (full 32bit, as returned in SD Mode Response: R1)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit  Typ Clr Identifier         Meaning
  31   ERX  C  OUT_OF_RANGE       (1=Command's argument was out of range)
  30   ERX  C  ADDRESS_ERROR      (1=Misaligned address/block len mismatch)
  29   ERX  C  BLOCK_LEN_ERROR    (1=Wrong block length, bytelen mismatch)
  28   ER   C  ERASE_SEQ_ERROR    (1=Error in erase command sequence)
  27   ERX  C  ERASE_PARAM        (1=Wrong erease selection of write-blocks)
  26   ERX  C  WP_VIOLATION       (1=Write failed due to write-protection)
  25   SX   A  CARD_IS_LOCKED     (1=Card is locked by the host)
  24   ERX  C  LOCK_UNLOCK_FAILED (1=Lock/unlock sequence or password error)
  23   ER   B  COM_CRC_ERROR      (1=CRC check of previous command failed)
  22   ER   B  ILLEGAL_COMMAND    (1=Command not legal for the card state)
  21   ERX  C  CARD_ECC_FAILED    (1=Internal error correction failed)
  20   ERX  C  CC_ERROR           (1=Internal card controller error)
  19   ERX  C  ERROR              (1=General error, or Unknown error)
  18   -    -  Reserved
  17   -    -  Reserved for DEFERRED_RESPONSE (refer to eSD Addendum)
  16   ERX  C  CSD_OVERWRITE      (1=read-only CSD section doesn't match card
                                  content, or attempted to reverse the
                                  Copy/WP bits)
  15   ERX  C  WP_ERASE_SKIP      (1=partial erase error due to write-protect)
  14   SX   A  CARD_ECC_DISABLED  (1=Internal error correction wasn't used)
  13   SR   C  ERASE_RESET        (1=Erase sequence was aborted)
  12-9 SX   B  CURRENT_STATE      (00h..0Fh=state, see below)
  8    SX   A  READY_FOR_DATA     (1=Ready/buffer is empry)
  7    EX   C  SWITCH_ERROR       (1=SWITCH command refused, MMC only)
  6    -    -  Reserved/Unspecified (description is left blank)
  5    SR   C  APP_CMD            (1=Card will expect ACMD)
  4    -    -  Reserved for SD I/O Card
  3    ER   C  AKE_SEQ_ERROR      (1=Authentication Sequence Error)
  2    -    -  Reserved for application specific commands
  1-0  -    -  Reserved for manufacturer test mode
</TD></TR></TABLE>
Values for CURRENT_STATE (bit12-9) (state of card when receiving the command):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h     = idle
  01h     = ready
  02h     = ident
  03h     = stby
  04h     = tran
  05h     = data
  06h     = rcv
  07h     = prg
  08h     = dis
  09h     = btst (MMC only)
  0Ah-0Eh = reserved
  0Fh     = reserved for I/O mode
</TD></TR></TABLE>
Type aka Typ column (in above table):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  E: Error bit.
  S: Status bit.
  R: Flag may get set within response of current command.
  X: Flag may get set within response of NEXT command (with R1 response)
</TD></TR></TABLE>
Clear Condition aka Clr column (in above table):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  A: According to the card current state.
  B: Always related to the previous command. Reception of a valid command
     will clear it (with a delay of one command).
  C: Clear by read.
</TD></TR></TABLE>
<BR>
<B>SPI Responses (8bit "R1" Responses, and 16bit "R2" Responses)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 FIRST BYTE of all SPI Responses:
  7  always 0                          ;\
  6  parameter error                   ; These 8bit are returned in ALL normal
  5  address error                     ; SPI commands (with 8bit "R1" response)
  4  erase sequence error              ; and,
  3  com crc error                     ; the same 8bits are also returned
  2  illegal command                   ; as FIRST BYTE in SPI commands with
  1  erase reset                       ; longer responses
  0  in idle state                     ;/
 SECOND BYTE of SPI "R2" Response:
  7  out of range, or csd overwrite           ;\
  6  erase param                              ;
  5  wp violation                             ; These extra 8bits are returned
  4  card ecc failed                          ; as SECOND BYTE in SPI commands
  3  CC error                                 ; with 16bit "R2" status response
  2  error                                    ; (ie. in CMD13 and ACMD13)
  1  wp erase skip, or lock/unlock cmd failed ;
  0  Card is locked                           ;/
</TD></TR></TABLE>
<BR>
<B>Card Status Field/Command - Cross Reference</B><BR>
For each command responded by R1 response, following table defines the affected
bits in the status field. An 'x' means the error/status bit may be set in the
response to the respective command.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bits     31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12-9 8 5
  CMD3                             x  x        x                    x
  CMD6     x                 x     x  x  x  x  x                    x
  CMD7                 x  x  x  x  x  x  x  x  x        x  x  x  x  x    x
  CMD11                      x     x  x        x                    x
  CMD12    x  x           x  x     x  x  x  x  x              x     x
  CMD13    x  x        x  x  x  x  x  x  x  x  x        x  x  x     x    x
  CMD16          x     x  x  x  x  x  x  x  x  x        x  x  x  x  x
  CMD17    x  x        x  x  x  x  x  x  x  x  x        x  x  x  x  x
  CMD18    x  x        x  x  x  x  x  x  x  x  x        x  x  x  x  x
  CMD19    x  x        x  x  x  x  x  x  x  x  x        x  x  x  x  x
  CMD20    x  x  x     x  x  x  x  x  x  x  x  x        x  x  x  x  x    x
  CMD23    x  x  x     x  x  x  x  x  x  x  x  x        x  x  x  x  x
  CMD24    x  x  x     x  x  x  x  x  x  x  x  x        x  x  x  x  x    x
  CMD25    x  x  x     x  x  x  x  x  x  x  x  x        x  x  x  x  x    x
  CMD26                x  x  x  x  x  x  x  x  x        x  x  x  x  x
  CMD27                x  x  x  x  x  x  x  x  x        x  x  x  x  x
  CMD28    x           x  x  x  x  x  x  x  x  x        x  x  x  x  x
  CMD29    x           x  x  x  x  x  x  x  x  x        x  x  x  x  x
  CMD30    x           x  x  x  x  x  x  x  x  x        x  x  x  x  x
  CMD32    x        x  x  x  x  x  x  x  x  x  x        x  x  x  x  x
  CMD33    x        x  x  x  x  x  x  x  x  x  x        x  x  x  x  x
  CMD38             x  x  x  x  x  x  x  x  x  x        x  x  x  x  x
  CMD42                x  x  x  x  x  x  x  x  x        x  x  x  x  x
  CMD48    x  x  x     x  x  x  x  x  x  x  x  x        x  x  x  x  x    x
  CMD49    x  x  x     x  x  x  x  x  x  x  x  x        x  x  x  x  x    x
  CMD55                x  x  x  x  x  x  x  x  x        x  x  x  x  x       x
  CMD56                x  x  x  x  x  x  x  x  x        x  x  x  x  x    x  x
  CMD58    x  x  x     x  x  x  x  x  x  x  x  x        x  x  x  x  x    x
  CMD59    x  x  x     x  x  x  x  x  x  x  x  x        x  x  x  x  x    x
  ACMD6    x           x  x  x  x  x  x  x  x  x        x  x  x  x  x       x
  ACMD13               x  x  x  x  x  x  x  x  x        x  x  x  x  x       x
  ACMD22               x  x  x  x  x  x  x  x  x        x  x  x  x  x       x
  ACMD23               x  x  x  x  x  x  x  x  x        x  x  x  x  x       x
  ACMD42               x  x  x  x  x  x  x  x  x        x  x  x  x  x       x
  ACMD51               x  x  x  x  x  x  x  x  x        x  x  x  x  x       x
</TD></TR></TABLE>
Note: The response to CMD3 is R6 that includes only bits 23, 22, 19 and 12:9
out of the Card Status.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcprotocolssrregister512bitsdstatusregister"></A>&nbsp;
  DSi SD/MMC Protocol: SSR Register (512bit SD Status Register)
</FONT></TD></TR></TABLE><BR>
<B>ACMD13 - SD - SPI - SD_STATUS (type=adtc)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-0   stuff bits
</TD></TR></TABLE>
SD Mode Response: R1 (32bit Card Status)<BR>
SPI Mode Response: R2 (16bit Card Status) (same as for CMD13, see there)<BR>
Additional Data Transfer (from card):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  511-0  SSR Register (512bit)
</TD></TR></TABLE>
Send the SD Status. The status fields are given in Table 4-43.<BR>
<BR>
<B>SD Status (transferred on DATA line after ACMD13)</B><BR>
The size of the SD Status is one data block of 512 bit. The content of this
register is transmitted to the Host over the DAT bus along with a 16-bit CRC.<BR>
ACMD13 can be sent to a card only in 'tran_state' (card is selected).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bits   Type Clr Identifier
  511-510  SR A   DAT_BUS_WIDTH (0..3, see below)
  509      SR A   SECURED_MODE  (0=Normal, 1=Secured) (Part 3 Security Specs)
  508-502  -  -   Reserved for Security Functions     (Part 3 Security Specs)
  501-496  -  -   Reserved
  495-480  SR A   SD_CARD_TYPE  (0..FFFFh, see below)
  479-448  SR A   SIZE_OF_PROTECTED_AREA   Size of protected area (see below)
  447-440  SR A   SPEED_CLASS      Speed Class of the card (see below)
  439-432  SR A   PERFORMANCE_MOVE Performance of move indicated by 1 MB/s step
  431-428  SR A   AU_SIZE          Size of AU (see below)
  427-424  -  -   Reserved
  423-408  SR A   ERASE_SIZE       Number of AUs to be erased at a time
  407-402  SR A   ERASE_TIMEOUT    Timeout value for erasing areas
                                   specified by UNIT_OF_ERASE_AU (see below)
  401-400  SR A   ERASE_OFFSET     Fixed offset value added to erase time
  399-396  SR A   UHS_SPEED_GRADE  Speed Grade for UHS mode  (see below)
  395-392  SR A   UHS_AU_SIZE      Size of AU  for UHS mode  (see below)
  391-312  -  -   Reserved
  311-0    -  -   Reserved for manufacturer
</TD></TR></TABLE>
<BR>
<B>Values for DAT_BUS_WIDTH (as set via SET_BUS_WIDTH command):</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h = 1 bit width (default)
  01h = reserved
  02h = 4 bit width
  03h = reserved
</TD></TR></TABLE>
<BR>
<B>Values for SD_CARD_TYPE</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0000h = Regular SD RD/WR Card
  0001h = SD ROM Card
  0002h = OTP
  0004h,0008h,0010h,0020h,0040h,0080h = Reserved for future variations
  01xxh..FFxxh = Reserved for Cards that don't comply to Physical Layer Specs
</TD></TR></TABLE>
<BR>
<B>Values for SIZE_OF_PROTECTED_AREA</B><BR>
Setting this field differs between SDSC and SDHC/SDXC.<BR>
In case of SDSC Card, the capacity of protected area is calculated as follows:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Protected Area = SIZE_OF_PROTECTED_AREA_* MULT * BLOCK_LEN.
  SIZE_OF_PROTECTED_AREA is specified by the unit in MULT*BLOCK_LEN.
</TD></TR></TABLE>
In case of SDHC and SDXC Cards, the capacity of protected area is calculated as
follows:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Protected Area = SIZE_OF_PROTECTED_AREA
  SIZE_OF_PROTECTED_AREA is specified by the unit in byte.
</TD></TR></TABLE>
<BR>
<B>Values for SPEED_CLASS</B><BR>
This 8-bit field indicates the Speed Class. Classes lower than indicated by
this field are also effective.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h      Speed Class 0
  01h      Speed Class 2
  02h      Speed Class 4
  03h      Speed Class 6
  04h      Speed Class 10
  05h-FFh  Reserved for future/faster classes
</TD></TR></TABLE>
Application Note:<BR>
If a Class value indicated in SD Status (including reserved value) is larger
than that of host supported, the host should read as any Class can be used with
the card.<BR>
For example, Class 10 is indicated, host should consider Class 2 to 6 is also
effective.<BR>
<BR>
<B>Values for PERFORMANCE_MOVE</B><BR>
This 8-bit field indicates Pm and the value can be set by 1 [MB/sec] step.<BR>
If the card does not move used RUs, Pm should be considered as infinity.<BR>
Setting to FFh means infinity.<BR>
Pm is defined for Class 2 to 6 in Default Speed Mode. When host uses Class 10,
Pm indicated in SD Status shall be ignored and treated as 0.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h    Sequential Write
  01h    1 [MB/sec]
  02h    2 [MB/sec]
  ...    ...
  FEh    254 [MB/sec]
  FFh    Infinity
</TD></TR></TABLE>
<BR>
<B>Values for AU_SIZE</B><BR>
This 4-bit field indicates AU Size and the value can be selected from 16 KB.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h    Not Defined
  01h    16 KB
  02h    32 KB
  03h    64 KB
  04h    128 KB
  05h    256 KB
  06h    512 KB
  07h    1 MB
  08h    2 MB
  09h    4 MB
  0Ah    8 MB
  0Bh    12 MB (!)
  0Ch    16 MB
  0Dh    24 MB (!)
  0Eh    32 MB
  0Fh    64 MB
</TD></TR></TABLE>
Maximum AU size (depending on card capacity):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Card Capacity     up to 64MB  up to 256MB  up to 512MB  up to 32GB  up to 2TB
  Maximum AU Size   512 KB      1 MB         2 MB         4 MB1       64MB
</TD></TR></TABLE>
The card can set any AU size (up to above maximum AU size values).<BR>
The card should set smaller AU size as much as possible.<BR>
Application Notes:<BR>
The host should determine host buffer size based on total busy time of 4MB and
the card supported class. The host can treat multiple AUs combined as one unit.<BR>
<BR>
<B>Values for ERASE_SIZE</B><BR>
This 16-bit field indicates NERASE. When NERASE numbers of AUs are erased, the
timeout value is specified by ERASE_TIMEOUT (Refer to ERASE_TIMEOUT).<BR>
The host should determine proper number of AUs to be erased in one operation so
that the host can indicate progress of erase operation.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0000h    Erase Time-out Calculation is not supported.
  0001h    1 AU
  0002h    2 AU
  0003h    3 AU
  ...      ...
  FFFFh    65535 AU
</TD></TR></TABLE>
<BR>
<B>Values for ERASE_TIMEOUT</B><BR>
This 6-bit field indicates the TERASE and the value indicates erase timeout
from offset when multiple AUs are erased as specified by ERASE_SIZE. The range
of ERASE_TIMEOUT can be defined as up to 63 seconds and the card manufacturer
can choose any combination of ERASE_SIZE and ERASE_TIMEOUT depending on the
implementation. Once ERASE_TIMEOUT is determined, it determines the ERASE_SIZE.
The host can determine timeout for any number of AU erase by the Equation (6).
Refer to 4.14 for the concept of calculating erase timeout. If ERASE_SIZE field
is set to 0, this field shall be set to 0.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h      Erase Time-out Calculation is not supported.
  01h      1 [sec]
  02h      2 [sec]
  03h      3 [sec]
  ...      ...
  3Fh      63 [sec]
</TD></TR></TABLE>
<BR>
<B>Values for ERASE_OFFSET</B><BR>
This 2-bit field indicates the TOFFSET and one of four values can be selected.
The erase offset adjusts the line by moving in parallel on the upper side.
Refer to Figure 4-57 and Equation (6) in 4.14. This field is meaningless if
ERASE_SIZE and ERASE_TIMEOUT fields are set to 0.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h      0 [sec]
  01h      1 [sec]
  02h      2 [sec]
  03h      3 [sec]
</TD></TR></TABLE>
<BR>
<B>Values for UHS_SPEED_GRADE</B><BR>
This 4-bit field indicates the UHS mode Speed Grade. Reserved values are for
future speed grades larger than the highest defined value. Host shall treat
reserved values (undefined) as highest grade defined.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h      Less than 10MB/sec
  01h      10MB/sec and above
  02h-0Fh  Reserved
</TD></TR></TABLE>
<BR>
<B>Values for UHS_AU_SIZE</B><BR>
This 4-bit field indicates AU Size for UHS-I and UHS-II cards. Card should set
smaller value as much as possible. Host shall refer to UHS_AU_SIZE instead of
AU_SIZE when the card is operating in UHS-I or UHS-II bus speed modes.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h      Not Defined
  01h-06h  Not Used
  07h      1 MB
  08h      2 MB
  09h      4 MB
  0Ah      8 MB
  0Bh      12 MB (!)
  0Ch      16 MB
  0Dh      24 MB (!)
  0Eh      32 MB
  0Fh      64 MB
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcprotocolocrregister32bitoperationconditionsregister"></A>&nbsp;
  DSi SD/MMC Protocol: OCR Register (32bit Operation Conditions Register)
</FONT></TD></TR></TABLE><BR>
<B>CMD1 - SD/MMC (For SD Cards: SPI-only) - SPI - SEND_OP_COND</B><BR>
Parameter For SD Cards (supported in SPI mode only, not in Non-SPI mode):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31    Reserved (0)
  30    HCS (Host Capacity Support information)
  29-0  Reserved (0)
</TD></TR></TABLE>
Parameter For MMC Cards (supported in SPI and Non-SPI mode):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-0  "OCR without busy"? (ie. without the power-up busy flag in bit31?)
</TD></TR></TABLE>
Response: R1<BR>
Sends host capacity support information and activates the card's initialization
process. HCS is effective when card receives SEND_IF_COND command.<BR>
<BR>
<B>CMD58 - SD/MMC - SPI-ONLY (not Non-SPI Mode) - READ_OCR</B><BR>
Supported on SD Cards in SPI Mode only (CMD58 would be READ_EXTR_MULTI on SD
Card in SD Mode. Not supported by MMC cards)!<BR>
Parameter bits:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-0  stuff bits
</TD></TR></TABLE>
SPI Mode Response: R3:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  39-32  R1 (8bit Card Status, same as in normal SPI command responses)
  31-0   OCR (32bit)
</TD></TR></TABLE>
<BR>
<B>ACMD41 - SD - SPI - SD_SEND_OP_COND (type=bcr)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31     reserved bit
  30     HCS(OCR[30])
  29     reserved for eSD                ;\
  28     XPC                             ; SPI Mode: Reserved
  27-25  reserved bits                   ; (ie. only bit30 is used for SPI)
  24     S18R                            ; (ie. ACMD41 is SAME as SPI CMD1 ?)
  23-0   VDD Voltage Window(OCR[23-0])   ;/
</TD></TR></TABLE>
SD Mode Response: R3:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  47     Start Bit (0)                                 ;\
  46     Transmission To Host (0)                      ; 1st byte
  45-40  Reserved (111111) (instead of Command value)  ;/
  39-8   OCR (32bit)                                   ;-2nd..5th byte
  7-1    Reserved (111111) (instead of CRC7)           ;\6th byte
  0      End Bit (1)                                   ;/
</TD></TR></TABLE>
SPI Mode Response: R1 (without extra Data transfer? use READ_OCR instead?)<BR>
Sends host capacity support information (HCS) and asks the accessed card to
send its operating condition register (OCR) content in the response on the CMD
line. HCS is effective when card receives SEND_IF_COND command.<BR>
Sends request to switch to 1.8V signaling (S18R).<BR>
Reserved bit shall be set to '0'. CCS bit is assigned to OCR[30].<BR>
XPC controls the maximum power in the default speed mode of SDXC card.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  XPC=0: 0.36W (100mA at 3.6V on VDD1) (max) but speed class is not supported.
  XPC=1: 0.54W (150mA at 3.6V on VDD1) (max) and speed class is supported.
</TD></TR></TABLE>
<BR>
<B>OCR register</B><BR>
The 32-bit operation conditions register stores the VDD voltage profile of the
non UHS-II card and VDD1 voltage profile of the UHS-II card. Additionally, this
register includes status information bits. One status bit is set if the card
power up procedure has been finished. This register includes another status bit
indicating the card capacity status after set power up status bit. The OCR
register shall be implemented by the cards.<BR>
The 32-bit operation conditions register stores the VDD voltage profile of the
card.<BR>
Bit 7 of OCR is newly defined for Dual Voltage Card and set to 0 in default. If
a Dual Voltage Card does not receive CMD8, OCR bit 7 in the response indicates
0, and the Dual Voltage Card which received CMD8, sets this bit to 1.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31     Card power up status bit (0=Busy, 1=Ready)
  30     Card Capacity Status (CCS) (valid only if above Bit31 indicates Ready)
          CCS=0   SDSC Card      (addressed in 1-byte units)   ;MMC max 2GB
          CCS=1   SDHC/SDXC card (addressed in 512-byte units) ;MMC &gt; 2GB
  29     UHS-II Card Status
  28-25  Reserved
  24     Switching to 1.8V Accepted (S18A) (Only UHS-I card supports this bit)
  23     3.5-3.6                        ;\
  22     3.4-3.5                        ;
  21     3.3-3.4                        ;
  20     3.2-3.3                        ;
  19     3.1-3.2                        ; VDD Voltage Window
  18     3.0-3.1                        ;
  17     2.9-3.0                        ;
  16     2.8-2.9                        ;
  15     2.7-2.8                        ;
  14-8   Reserved (MMC: 2.0V .. 2.6V)   ;  ;&lt;-- uh, probably in opposite order?
  7      Reserved for Low Voltage Range ;
  6-4    Reserved                       ;
  3-0    Reserved                       ;/
</TD></TR></TABLE>
The supported voltage range is coded as shown in Table 5-1. A voltage range is
not supported if the corresponding bit value is set to LOW. As long as the card
is busy, the corresponding bit (31) is set to LOW.<BR>
VDD Voltage Window of OCR indicates VDD1 voltage range in case of UHS-II Card.<BR>
UHS-II Card Status bit is added in Bit 29 to indicate whether the card supports
UHS-II Interface. Non UHS-II Card sets Bit 29 to 0 and UHS-II Card sets Bit 29
to 1. This bit is not affected by whether VDD2 is supplied or not.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcprotocolcidregister128bitcardidentification"></A>&nbsp;
  DSi SD/MMC Protocol: CID Register (128bit Card Identification)
</FONT></TD></TR></TABLE><BR>
<B>CMD2 - SD/MMC - ALL_SEND_CID (type=bcr)</B><BR>
Parameter bits:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-0  stuff bits
</TD></TR></TABLE>
SD Mode Response: R2 (same 136bit response as for CMD10, see there)<BR>
Asks any card to send the CID numbers on the CMD line (any card that is
connected to the host will respond).<BR>
<BR>
<B>CMD10 - SD/MMC - SPI - SEND_CID (type=ac)</B><BR>
Parameter bits:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-16 RCA (SPI Mode: stuff bits)
  15-0  stuff bits
</TD></TR></TABLE>
SD Mode Response: R2:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  135     Start Bit (0)                                 ;\
  134     Transmission To Host (0)                      ; 1st byte
  133-128 Reserved (111111) (instead of Command value)  ;/
  127-8   CID (120bit) (15 bytes)     ;\aka 128bit      ;-2nd..16th byte
  7-1     CRC7                        ; when including  ;\17th byte
  0       End Bit (1)                 ;/CRC7+EndBit     ;/
</TD></TR></TABLE>
SPI Mode Response: R1, plus DATA line,<BR>
SPI Mode Additional Data Transfer (from card):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  127-0   CID (128bit) ... or 120bit ?
</TD></TR></TABLE>
Addressed card sends its card identification (CID).<BR>
<BR>
<B>CID register</B><BR>
The Card IDentification (CID) register is 128 bits wide. It contains the card
identification information used during the card identification phase. Every
individual Read/Write (RW) card shall have a unique identification number.<BR>
For SD Cards (short product name, but bigger date field, 2000..2255?):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit     Siz  Field  Name
  127-120   8  MID    Manufacturer ID    (binary) ;\assigned by SD-3C, LLC
  119-104  16  OID    OEM/Application ID (ASCII)  ;/
  103-64   40  PNM    Product name       (ASCII)
  63-56     8  PRV    Product revision   (BCD, 00h-99h) (eg 62h = rev 6.2)
  55-24    32  PSN    Product serial number (32bit)
  23-20     4  -      Reserved (zero)
  19-8     12  MDT    Manufacturing date (yymh) (m=1..12, yy=0..255?; +2000)
  7-1       7  CRC    CRC7 checksum
  0         1  1      Stop bit (always 1)
</TD></TR></TABLE>
For MMC Cards (smaller date field, range 1997..2012 only):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit     Siz  Field  Name
  127-120   8  MID    Manufacturer ID    (binary)   ;\assigned by MMCA
  119-104  16  OID    OEM/Application ID (binary)   ;/  ... or ...
  127-120   8  MID    Manufacturer ID    (binary)   ;\assigned by MMCA/JEDEC
  119-114   6  -      Reserved (0)                  ;
  113-112   2  CBX    Device (0=Card, 1=BGA, 2=POP) ;
  119-104   8  OID    OEM/Application ID (binary)   ;/
  103-56   48  PNM    Product name       (ASCII)
  55-48     8  PRV    Product revision   (BCD, 00h-99h) (eg 62h = rev 6.2)
  47-16    32  PSN    Product serial number (32bit)
  15-8      8  MDT    Manufacturing date (myh) (m=1..12, y=0..15; +1997)
  7-1       7  CRC    CRC7 checksum
  0         1  1      Stop bit (always 1)
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcprotocolcsdregister128bitcardspecificdata"></A>&nbsp;
  DSi SD/MMC Protocol: CSD Register (128bit Card-Specific Data)
</FONT></TD></TR></TABLE><BR>
<B>CMD9 - SD/MMC - SPI - SEND_CSD (type=ac)</B><BR>
Parameter bits:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-16 RCA (SPI Mode: stuff bits)
  15-0  stuff bits
</TD></TR></TABLE>
SD Mode Response: R2:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  135     Start Bit (0)                                 ;\
  134     Transmission To Host (0)                      ; 1st byte
  133-128 Reserved (111111) (instead of Command value)  ;/
  127-8   CSD (120bit) (15 bytes)     ;\aka 128bit      ;-2nd..16th byte
  7-1     CRC7                        ; when including  ;\17th byte
  0       End Bit (1)                 ;/CRC7+EndBit     ;/
</TD></TR></TABLE>
SPI Mode Response: R1, plus DATA line,<BR>
SPI Mode Additional Data Transfer (from card):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  127-0   CID (128bit) ... or 120bit ?
</TD></TR></TABLE>
Addressed card sends its card-specific data (CSD).<BR>
<BR>
<B>CMD27 - SD/MMC - SPI - PROGRAM_CSD (type=adtc)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-0  stuff bits
</TD></TR></TABLE>
Response: R1<BR>
Additional Data Transfer (to card):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  128-0  CSD register (whole 128bit) (read-only bits must be unchanged)
</TD></TR></TABLE>
Programming of the programmable bits of the CSD, ie. the "R/W" bits, the "R"
bits must be kept unchanged (read via CMD9, and write-back same values via
CMD27).<BR>
The writable once "R/W(1)" bits can be changed only from 0-to-1, or vice-versa,
they can be really written only ONCE, by the manufacturer?<BR>
Most of the "R/W(1)" bits are probably set by the manufacturer at time when
pre-formatting the card, so they aren't actually user-writeable.<BR>
<BR>
<B>CSD Register</B><BR>
The types of the entries in the table below are coded as follows: R=readable,
W(1)=writable once, W=multiple writable.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit    Siz Type   Name                             Field             Value
  127-126 2  R      CSD structure version            CSD_STRUCTURE     00b
  125-122 4  R      MMC: System spec version         SPEC_VERS         ..
  125-122 4  R      SD: reserved                     -                 0000b
  121-120 2  R      reserved                         -                 00b
  119-112 8  R      data read access-time-1          TAAC              xxh
  111-104 8  R      data read access-time-2          NSAC              xxh
  103-96  8  R      max data transfer rate           TRAN_SPEED   32h or 5Ah
  95-84  12  R      card command classes             CCC          01x110110101b
  83-80   4  R      max read data block len          READ_BL_LEN          xh
  79      1  R      partial blocks for read allowed  READ_BL_PARTIAL      1b
  78      1  R      write block misalignment         WRITE_BLK_MISALIGN   xb
  77      1  R      read block misalignment          READ_BLK_MISALIGN    xb
  76      1  R      DSR implemented                  DSR_IMP              xb
  75-74   2  R      reserved                              -               00b
  73-70   4  R      SDHC/SDXC: reserved                   -               0000b
  69-48  22  R      SDHC/SDXC: device size                C_SIZE          ...
  47      1  R      SDHC/SDXC: reserved                   -               0
  73-62  12  R      MMC/SDSC: device size                 C_SIZE          xxxh
  61-59   3  R      MMC/SDSC: max read current @VDD min   VDD_R_CURR_MIN  xxxb
  58-56   3  R      MMC/SDSC: max read current @VDD max   VDD_R_CURR_MAX  xxxb
  55-53   3  R      MMC/SDSC: max write current @VDD min  VDD_W_CURR_MIN  xxxb
  52-50   3  R      MMC/SDSC: max write current @VDD max  VDD_W_CURR_MAX  xxxb
  49-47   3  R      MMC/SDSC: device size multiplier      C_SIZE_MULT     xxxb
  46-42   5  R      MMC: Erase Group Size             ERASE_GRP_SIZE   ..
  41-37   5  R      MMC: Erase Group Multiplier       ERASE_GRP_MULT   ..
  36-32   5  R      MMC: Write Protect Grp Size       WP_GRP_SIZE      ..
  46      1  R      SD: erase single block enable     ERASE_BLK_EN     xb
  45-39   7  R      SD: erase sector size             SECTOR_SIZE      xxxxxxxb
  38-32   7  R      SD: write protect group size      WP_GRP_SIZE      xxxxxxxb
  31      1  R      write protect group enable        WP_GRP_ENABLE    xb
  30-29   2  R      MMC: Manufacturer default ECC     DEFAULT_ECC      ..
  30-29   2  R      SD: reserved (do not use)         -                00b
  28-26   3  R      write speed factor                R2W_FACTOR       xxxb
  25-22   4  R      max write data block len          WRITE_BL_LEN     xxxxb
  21      1  R      partial blocks for write allowed  WRITE_BL_PARTIAL xb
  20-17   4  R      reserved                          -                0000b
  16      1  R      SD: reserved                      -                0
  16      1  R      MMC: Content Protection Applicat. CONTENT_PROP_APP ..
  15      1  R/W(1) File format group                 FILE_FORMAT_GRP  xb
  15      1  R      SDHC/SDXC: reserved               (FILE_FORMAT_GRP)0
  14      1  R/W(1) copy flag                         COPY             xb
  13      1  R/W(1) permanent write protection     PERM_WRITE_PROTECT  xb
  12      1  R/W    temporary write protection     TMP_WRITE_PROTECT   xb
  11-10   2  R/W(1) File format                    FILE_FORMAT         xxb
  11-10   2  R      SDHC/SDXC: reserved            (FILE_FORMAT)       00b
  9-8     2  R/W    MMC: ECC Code                  ECC                 ..
  9-8     2  R/W    SDSC: reserved, R/W            -                   00b
  9-8     2  R      SDHC/SDXC: reserved, R         -                   00b
  7-1     7  R/W    CRC                            CRC                 xxxxxxxb
  0       1  -      not used, always'1'            -                   1b
</TD></TR></TABLE>
<BR>
<B>CSD_STRUCTURE (upper 2bit of CSD register)</B><BR>
Field structures of the CSD register are different depend on the Physical Layer
Specification Version and Card Capacity.<BR>
The CSD_STRUCTURE field in the CSD register indicates its structure version.<BR>
For MMC:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h      CSD version No. 1.0    MMC Version 1.0 - 1.2
  01h      CSD version No. 1.1    MMC Version 1.4 - 2.2
  02h      CSD version No. 1.2    MMC Version 3.1 - 3.2 - 3.31 - 4.0 - 4.1- 4.2
  03h      Version is coded in the CSD_STRUCTURE byte in the EXT_CSD register
</TD></TR></TABLE>
For SD:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h      CSD Version 1.0   SDSC (Standard Capacity)
  01h      CSD Version 2.0   SDHC/SDXC (High Capacity and Extended Capacity)
  02h-03h  Reserved
</TD></TR></TABLE>
SDHC/SDXC applies major changes to CSD register (C_SIZE is expanded, and many
other fields are removed or set to dummy values), for details see:<BR>
<A HREF="#dsisdmmcprotocolcsdregister128bitcardspecificdataversion20">DSi SD/MMC Protocol: CSD Register (128bit Card-Specific Data) Version 2.0</A><BR>
<BR>
<B>SPEC_VERS (MMC only)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h       MMC System Specification Version 1.0 - 1.2
  01h       MMC System Specification Version 1.4
  02h       MMC System Specification Version 2.0 - 2.2
  03h       MMC System Specification Version 3.1 - 3.2 - 3.31
  04h       MMC System Specification Version 4.0 - 4.1 - 4.2
  05h-0Fh   Reserved
</TD></TR></TABLE>
<BR>
<B>TAAC</B><BR>
Defines the asynchronous part of the data access time.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7    Reserved
  6-3  Time value
         0=reserved, 1=1.0, 2=1.2, 3=1.3, 4=1.5, 5=2.0, 6=2.5, 7=3.0,
         8=3.5, 9=4.0, A=4.5, B=5.0, C=5.5, D=6.0, E=7.0, F=8.0
  2-0  Time unit
         0=1ns, 1=10ns, 2=100ns, 3=1us, 4=10us, 5=100us, 6=1ms, 7=10ms
</TD></TR></TABLE>
<BR>
<B>NSAC</B><BR>
Defines the worst case for the clock-dependent factor of the data access time.
The unit for NSAC is 100 clock cycles. Therefore, the maximal value for the
clock-dependent part of the data access time is 25.5 k clock cycles.<BR>
The total access time NAC is the sum of TAAC and NSAC. It should be computed by
the host for the actual clock rate. The read access time should be interpreted
as a typical delay for the first data bit of a data block or stream.<BR>
<BR>
<B>TRAN_SPEED</B><BR>
The following table defines the maximum data transfer rate PER ONE data line:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7    Reserved
  6-3  Time value
         0=reserved, 1=1.0, 2=1.2, 3=1.3, 4=1.5, 5=2.0, 6=2.5, 7=3.0,
         8=3.5, 9=4.0, A=4.5, B=5.0, C=5.5, D=6.0, E=7.0, F=8.0
  2-0  Transfer rate unit
         0=100kbit/s, 1=1Mbit/s, 2=10Mbit/s, 3=100Mbit/s, 4..7=reserved
         MMC: same as above, but specified in &lt;Hz&gt; instead of &lt;bits/s&gt;
</TD></TR></TABLE>
Note that for current SD Memory Cards, this field shall be always 32h which is
equal to 25 MHz - the mandatory maximum operating frequency of SD Memory Card.<BR>
In High-Speed mode, this field shall be always 5Ah which is equal to 50 MHz,
and when the timing mode returns to the default by CMD6 or CMD0 command, its
value will be 32h.<BR>
<BR>
<B>CCC (Card Command Class)</B><BR>
The SD Memory Card command set is divided into subsets (command classes). A
value of 1 in a CCC bit means that the corresponding command class is
supported. For command class definitions, refer to Table 4-21.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  11   Supports Command Class 11 - Function Extension Commands (SD)
  10   Supports Command Class 10 - Switch Function Commands (SD)
  9    Supports Command Class 9 - I/O Mode Commands (SDIO)
  8    Supports Command Class 8 - Application-Specific Commands
  7    Supports Command Class 7 - Password Lock Commands
  6    Supports Command Class 6 - Block-Oriented Write Protection Commands
  5    Supports Command Class 5 - Erase Commands
  4    Supports Command Class 4 - Block-Oriented Write Commands
  3    Supports Command Class 3 - N/A
  2    Supports Command Class 2 - Block-Oriented Read Commands
  1    Supports Command Class 1 - N/A
  0    Supports Command Class 0 - Basic Commands
</TD></TR></TABLE>
Same for MMC (though on MMC the classes may have different meaning?)<BR>
<BR>
<B>READ_BL_LEN</B><BR>
The maximum read data block length is computed as 2^READ_BL_LEN. The maximum
block length might therefore be in the range 512...2048 bytes (Refer to 4.3.3
for details). Note that in an SD Memory Card the WRITE_BL_LEN is always equal
to READ_BL_LEN.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  3-0  Setting
</TD></TR></TABLE>
Values:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h..08h  Reserved
  09h       Block length 512 Bytes (2^9)
  0Ah       Block length 1024 Bytes (2^10)
  0Bh       Block length 2048 Bytes (2^11)
  0Ch..0Fh  Reserved
</TD></TR></TABLE>
MMC allows any values from 2^0 to 2^14, and uses 0Fh for Extension (see TBD
field in EXT_CSD) (uh, but "TBD" isn't yet defined in KMCEN0000M datasheet,
maybe TBD means to-be-defined?).<BR>
<BR>
<B>READ_BL_PARTIAL (always = 1 in SDSC Memory Card)</B><BR>
Partial Block Read is always allowed in an SDSC Memory Card. It means that
smaller blocks can be used as well. The minimum block size will be one byte.<BR>
<BR>
<B>WRITE_BLK_MISALIGN</B><BR>
Defines if the data block to be written by one command can be spread over more
than one physical block of the memory device. The size of the memory block is
defined in WRITE_BL_LEN.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  WRITE_BLK_MISALIGN=0   crossing physical block boundaries is invalid
  WRITE_BLK_MISALIGN=1   crossing physical block boundaries is allowed
</TD></TR></TABLE>
<BR>
<B>READ_BLK_MISALIGN</B><BR>
Defines if the data block to be read by one command can be spread over more
than one physical block of the memory device. The size of the memory block is
defined in READ_BL_LEN.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  READ_BLK_MISALIGN=0    crossing physical block boundaries is invalid
  READ_BLK_MISALIGN=1    crossing physical block boundaries is allowed
</TD></TR></TABLE>
<BR>
<B>DSR_IMP</B><BR>
Defines if the configurable driver stage is integrated on the card. If set, a
driver stage register (DSR) shall be implemented (also see Chapter 5.5).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  DSR_IMP=0    no DSR implemented
  DSR_IMP=1    DSR implemented
</TD></TR></TABLE>
<BR>
<B>C_SIZE (for max 2GB)</B><BR>
This parameter is used to compute the user's data card capacity (not include
the security protected area). The memory capacity of the card is computed from
the entries C_SIZE, C_SIZE_MULT and READ_BL_LEN as follows:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  memory capacity = BLOCKNR * BLOCK_LEN
</TD></TR></TABLE>
Whereas,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  BLOCKNR = (C_SIZE+1) * MULT
  MULT = 2^(C_SIZE_MULT+2)    ;(C_SIZE_MULT &lt; 8)
  BLOCK_LEN = 2^READ_BL_LEN   ;(READ_BL_LEN &lt; 12)
</TD></TR></TABLE>
To indicate 2 GByte card, BLOCK_LEN shall be 1024 bytes.<BR>
Therefore, the maximal capacity that can be coded is 4096*512*1024 = 2 G bytes.<BR>
Example: A 32 Mbyte card with BLOCK_LEN = 512 can be coded by C_SIZE_MULT = 3
and C_SIZE = 2000.<BR>
The Maximum Data Area size of SDSC Standard Capacity Card is 4,153,344 sectors
(2028MB).<BR>
<BR>
<B>C_SIZE (for MMC above 2GB)</B><BR>
The 12bit C_SIZE field should be set 0FFFh. Use "SEC_COUNT" in EXT_CSD to
specify actual size.<BR>
<BR>
<B>VDD_R_CURR_MIN, VDD_W_CURR_MIN</B><BR>
Maximum values for read and write currents at the MINIMAL power supply VDD:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  2-0   0=0.5mA, 1=1mA, 2=5mA, 3=10mA, 4=25mA, 5=35mA, 6=60mA, 7=100mA
</TD></TR></TABLE>
<BR>
<B>VDD_R_CURR_MAX, VDD_W_CURR_MAX</B><BR>
Maximum values for read and write currents at the MAXIMAL power supply VDD:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  2-0   0=1mA, 1=5mA, 2=10mA, 3=25mA, 4=35mA, 5=45mA, 6=80mA, 7=200mA
</TD></TR></TABLE>
<BR>
<B>C_SIZE_MULT</B><BR>
This parameter is used for coding a factor MULT for computing the total device
size (see 'C_SIZE'). Defined as "MULT = 2^(C_SIZE_MULT+2)".<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  2-0   Device Size Factor (0..7 = Factor 4,8,16,32,64,128,256,512)
</TD></TR></TABLE>
<BR>
<B>SD: ERASE_BLK_EN</B><BR>
The ERASE_BLK_EN defines the granularity of the unit size of the data to be
erased. The erase operation can erase either one or multiple units of 512 bytes
or one or multiple units (or sectors) of SECTOR_SIZE (see definition below).<BR>
If ERASE_BLK_EN=0, the host can erase one or multiple units of SECTOR_SIZE. The
erase will start from the beginning of the sector that contains the start
address to the end of the sector that contains the end address. For example, if
SECTOR_SIZE=31 and the host sets the Erase Start Address to 5 and the Erase End
Address to 40, the physical blocks from 0 to 63 will be erased as shown in
Figure 5-1.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Figure 5-1: ERASE_BLK_EN = 0 Example
  Physical Block (per CSD)
  0          1          2          3          4          5          6
  0123456789 0123456789 0123456789 0123456789 0123456789 0123456789 0123456789
       &lt;----- Host Erase Address Range -------&gt;
  &lt;---------- Erase Area ----------------------------------------------&gt;
  &lt;---------- Erase Unit Size ------&gt;&lt;------- Erase Unit Size ---------&gt;
</TD></TR></TABLE>
If ERASE_BLK_EN=1 the host can erase one or multiple units of 512 bytes. All
blocks that contain data from start address to end address are erased. For
example, if the host sets the Erase Start Address to 5 and the Erase End
Address to 40, the physical blocks from 5 to 40 will be erased as shown in
Figure 5-2.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Figure 5-2: ERASE_BLK_EN = 1 Example
  Physical Block (per CSD)
  0          1          2          3          4          5          6
  0123456789 0123456789 0123456789 0123456789 0123456789 0123456789 0123456789
       &lt;----- Host Erase Address Range -------&gt;
       &lt;----- Erase Area ---------------------&gt;
</TD></TR></TABLE>
<BR>
<B>SD: SECTOR_SIZE</B><BR>
The size of an erasable sector. The content of this register is a 7-bit binary
coded value, defining the number of write blocks (see WRITE_BL_LEN). The actual
size is computed by increasing this number by one. A value of zero means one
write block, 127 means 128 write blocks.<BR>
<BR>
<B>MMC: ERASE_GRP_SIZE</B><BR>
The contents of this register is a 5 bit binary coded value, used to calculate
the size of the erasable unit of the moviNAND. The size of the erase unit (also
referred to as erase group) is determined by the ERASE_GRP_SIZE and the
ERASE_GRP_MULT entries of the CSD, using the following equation:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  size of erasable unit = (ERASE_GRP_SIZE + 1) * (ERASE_GRP_MULT + 1)
</TD></TR></TABLE>
This size is given as minimum number of write blocks that can be erased in a
single erase command.<BR>
<BR>
<B>MMC: ERASE_GRP_MULT</B><BR>
A 5 bit binary coded value used for calculating the size of the erasable unit
of the moviNAND. See ERASE_GRP_SIZE section for detailed description.<BR>
<BR>
<B>MMC: DEFAULT_ECC</B><BR>
Set by the moviNAND manufacturer. It defines the ECC code which is recommended
for use. The field definition is the same as for the ECC field described later.<BR>
<BR>
<B>MMC: CONTENT_PROT_APP</B><BR>
This field in the CSD indicates whether the content protection application is
supported. MultiMediaCards which implement the content protection application
will have this bit set to '1'.<BR>
<BR>
<B>MMC: ECC</B><BR>
Defines the ECC code that was used for storing data on the moviNAND. This field
is used by the host (or application) to decode the user data. The following
table defines the field format:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ECC      ECC type         Maximum number of correctable bits per block
  00h      None (default)   Mone
  01h      BCH (542,512)    3
  02h-03h  Reserved         -
</TD></TR></TABLE>
<BR>
<B>MMC: WP_GRP_SIZE (5bit)</B><BR>
The size of a write protected group. The contents of this register is a 5 bit
binary coded value, defining the number of erase groups which can be write
protected.<BR>
The actual size is computed by increasing this number by one. A value of zero
means 1 erase group, 31 means 32 erase groups. (Refer to the chapter 4.11.1 on
page 48)<BR>
<BR>
<B>SD: WP_GRP_SIZE (7bit)</B><BR>
The size of a write protected group. The content of this register is a 7-bit
binary coded value, defining the number of erase sectors (see SECTOR_SIZE). The
actual size is computed by increasing this number by one. A value of zero means
one erase sector, 127 means 128 erase sectors.<BR>
<BR>
<B>WP_GRP_ENABLE</B><BR>
A value of 0 means no group write protection possible.<BR>
<BR>
<B>R2W_FACTOR</B><BR>
Defines the typical block program time as a multiple of the read access time.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  2-0   Multiples of read access time (0..5=Mul 1,2,4,8,16,32, 6..7=Reserved)
</TD></TR></TABLE>
For example, value 5 means that writing is 32 times slower than reading.<BR>
<BR>
<B>WRITE_BL_LEN</B><BR>
The maximum write data block length is computed as 2^WRITE_BL_LEN. The maximum
block length might therefore be in the range from 512 to 2048 bytes. Write
Block Length of 512 bytes is always supported.<BR>
Note that in the SD Memory Card, the WRITE_BL_LEN is always equal to
READ_BL_LEN.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  3-0    Block Length
</TD></TR></TABLE>
Values:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h..08h  Reserved
  09h       512 bytes (2^9)
  0Ah       1024 Bytes (2^10)
  0Bh       2048 Bytes (2^11)
  0Ch..0Fh  Reserved
</TD></TR></TABLE>
MMC: See READ_BL_LEN<BR>
<BR>
<B>WRITE_BL_PARTIAL</B><BR>
Defines whether partial block sizes can be used in block write commands.<BR>
WRITE_BL_PARTIAL=0 means that only the WRITE_BL_LEN block size and its partial
derivatives, in resolution of units of 512 bytes, can be used for block
oriented data write.<BR>
WRITE_BL_PARTIAL=1 means that smaller blocks can be used as well. The minimum
block size is one byte.<BR>
<BR>
<B>COPY</B><BR>
Defines whether the contents is original (=0) or has been copied (=1). Setting
this bit to 1 indicates that the card content is a copy. The COPY bit is a one
time programmable bit except ROM card.<BR>
<BR>
<B>PERM_WRITE_PROTECT</B><BR>
<B>TMP_WRITE_PROTECT</B><BR>
Permanently/temporarily write-protects the entire card (by disabling all write
and erase commands). The default values are 0, ie. not write protected.<BR>
<BR>
<B>FILE_FORMAT</B><BR>
<B>FILE_FORMAT_GRP</B><BR>
Indicates the file format on the card. These fields are read-only for ROM. The
following formats are defined:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  FILE_FORMAT_GRP  FILE_FORMAT  Type
  0                0            Hard disk-like file system with partition table
  0                1            DOS FAT (floppy-like) with boot sector only
                                  (no partition table)
  0                2            Universal File Format
  0                3            Others/Unknown
  1                0, 1, 2, 3   Reserved
</TD></TR></TABLE>
A more detailed description is given in the Filesystem Specification.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcprotocolcsdregister128bitcardspecificdataversion20"></A>&nbsp;
  DSi SD/MMC Protocol: CSD Register (128bit Card-Specific Data) Version 2.0
</FONT></TD></TR></TABLE><BR>
<B>CSD Register (CSD Version 2.0) (SDHC/SDXC)</B><BR>
The field name in parenthesis is set to fixed value and indicates that the host
is not necessary to refer these fields. The fixed values enables host, which
refers to these fields, to keep compatibility to CSD Version 1.0.<BR>
The Cell Type field is coded as follows: R=readable, W(1)=writable once,
W=multiple writable.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Siz Type   Name                        Field          Value
  127-126 2 R      CSD structure               CSD_STRUCTURE  01b
  125-120 6 R      reserved                    -              000000b
  119-112 8 R      data read access-time-1     (TAAC)         0Eh
  111-104 8 R      data read access-time-2     (NSAC)         00h
  103-96  8 R      max data transfer rate      (TRAN_SPEED)   32h,5Ah,0Bh,2Bh
  95-84  12 R      card command classes        CCC            x1x110110101b
  83-80   4 R      max read data block length       (READ_BL_LEN)        9
  79      1 R      partial blocks for read allowed  (READ_BL_PARTIAL)    0
  78      1 R      write block misalignment         (WRITE_BLK_MISALIGN) 0
  77      1 R      read block misalignment          (READ_BLK_MISALIGN)  0
  76      1 R      DSR implemented                  DSR_IMP              x
  75-70   6 R      reserved                         -                   000000b
  69-48  22 R      device size                      C_SIZE              xxxxxxh
  47      1 R      reserved                         -                    0
  46      1 R      erase single block enable        (ERASE_BLK_EN)       1
  45-39   7 R      erase sector size                (SECTOR_SIZE)        7Fh
  38-32   7 R      write protect group size         (WP_GRP_SIZE)        00h
  31      1 R      write protect group enable       (WP_GRP_ENABLE)      0
  30-29   2 R      reserved                         -                    00b
  28-26   3 R      write speed factor               (R2W_FACTOR)         010b
  25-22   4 R      max write data block length      (WRITE_BL_LEN)       9
  21      1 R      partial blocks for write allowed (WRITE_BL_PARTIAL)   0
  20-16   5 R      reserved                         -                    00000b
  15      1 R      File format group                (FILE_FORMAT_GRP)    0
  14      1 R/W(1) copy flag                        COPY                 x
  13      1 R/W(1) permanent write protection       PERM_WRITE_PROTECT   x
  12      1 R/W    temporary write protection       TMP_WRITE_PROTECT    x
  11-10   2 R      File format                      (FILE_FORMAT)        00b
  9-8     2 R      reserved                         -                    00b
  7-1     7 R/W    CRC                              CRC                  xxh
  0       1 -      not used, always '1'             -                    1
</TD></TR></TABLE>
<BR>
<B>C_SIZE</B><BR>
This field is expanded to 22 bits and can indicate up to 2 TBytes (that is the
same as the maximum memory space specified by a 32-bit block address.)<BR>
This parameter is used to calculate the user data area capacity in the SD
memory card (not include the protected area). The user data area capacity is
calculated from C_SIZE as follows:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  memory capacity = (C_SIZE+1) * 512KByte
</TD></TR></TABLE>
The Minimum user area size of SDHC Card is 4,211,712 sectors (2GB + 8.5MB).<BR>
The Minimum value of C_SIZE for SDHC in CSD Version 2.0 is 001010h (4112).<BR>
The Maximum user area size of SDHC Card is (32GB - 80MB).<BR>
The Maximum value of C_SIZE for SDHC in CSD Version 2.0 is 00FF5Fh (65375).<BR>
The Minimum user area size of SDXC Card is 67,108,864 sectors (32GB).<BR>
The Minimum value of C_SIZE for SDXC in CSD Version 2.0 is 00FFFFh (65535).<BR>
<BR>
<B>TRAN_SPEED</B><BR>
TRAN_SPEED is variable depends on bus speed mode of SD Interface.<BR>
When CMD0 is received, this field is reset to 32h.<BR>
On SDSC (but not SDHC/SDXC), CMD6 does the same reset stuff?<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  32h   SDSC/SDHC/SDXC in Default Speed mode (25MHz)
  5Ah   SDSC/SDHC/SDXC in High Speed mode    (50MHz)
  0Bh   SDHC/SDXC in SDR50 or DDR50 mode     (100Mbit/sec)
  2Bh   SDHC/SDXC in SDR104 mode             (200Mbit/sec)
</TD></TR></TABLE>
UHS-II mode is not related to this field.<BR>
<BR>
<B>CCC, DSR_IMP, COPY, PERM_WRITE_PROTECT, TMP_WRITE_PROTECT</B><BR>
Definition of these fields is same as in CSD Version 1.0.<BR>
<BR>
<B>TAAC, NSAC, R2W_FACTOR</B><BR>
In SDHC/SDXC, these fields should be fixed to TAAC=0Eh (1 ms), NSAC=00h, and
R2W_FACTOR=02h (mul4).<BR>
The host should not use TAAC, NSAC, and R2W_FACTOR to calculate timeout and
should uses fixed timeout values for read and write operations (See 4.6.2).<BR>
<BR>
<B>READ_BL_LEN, WRITE_BL_LEN</B><BR>
These two fields are fixed to 9h (which indicates 512 Bytes).<BR>
<BR>
<B>READ_BL_PARTIAL, WRITE_BL_PARTIAL, READ_BLK_MISALIGN, WRITE_BLK_MISALIGN</B><BR>
These four fields are fixed to 0 (partial block read and physical page crossing
prohibited for block read/write).<BR>
<BR>
<B>SECTOR_SIZE</B><BR>
This field is fixed to 7Fh, which indicates 64 KBytes. This value is not
related to erase operation. SDHC and SDXC Cards indicate memory boundary by AU
size and this field should not be used.<BR>
<BR>
<B>ERASE_BLK_EN</B><BR>
This field is fixed to 1, which means the host can erase one or multiple units
of 512 bytes.<BR>
<BR>
<B>WP_GRP_SIZE, WP_GRP_ENABLE</B><BR>
These field are fixed to WP_GRP_SIZE=00h, and WP_GRP_ENABLE=0.<BR>
SDHC and SDXC Cards do not support write protected groups.<BR>
<BR>
<B>FILE_FORMAT_GRP</B><BR>
<B>FILE_FORMAT</B><BR>
These fields are set to 0. Host should not use these fields.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcprotocolextcsdregister4096bitextendedcsdregistermmc"></A>&nbsp;
  DSi SD/MMC Protocol: EXT_CSD Register (4096bit Extended CSD Register) (MMC)
</FONT></TD></TR></TABLE><BR>
<B>CMD8 - MMC - SPI - SEND_EXT_CSD (type=adtc)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-0  stuff bits
</TD></TR></TABLE>
Response: R1<BR>
Additional Data Transfer (from card):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4095-0  EXT_CSD Register (4096bit)
</TD></TR></TABLE>
MMC only.<BR>
<BR>
<B>CMD6 - MMC - SPI - SWITCH (type=ac)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-26  6bit  Reserved (0)
  25-24  2bit  Access
                 00h  Change Command Set (EXT_CSD[191] = parameter bit2-0)
                 01h  Set bits (EXT_CSD[index] = EXT_CSD[index] OR value)
                 02h  Clr bits (EXT_CSD[index] = EXT_CSD[index] AND NOT value)
                 03h  Write    (EXT_CSD[index] = value)
  23-16  8bit  Index (0..191)   ;\used only if "Access=1..3"
  15-8   8bit  Value (0..255)   ;/
  7-3    5bit  Reserved (0)
  2-0    3bit  Cmd Set (0..7)   ;-used only if "Access=0"
</TD></TR></TABLE>
Response: R1b<BR>
Additional Data Transfer (from card): Busy signal for "R1b" response<BR>
MMC only.<BR>
<BR>
<B>Extended CSD Register (MMC only)</B><BR>
The Extended CSD register defines the card properties and selected modes. It is
512 bytes (4096 bits) long.<BR>
The most significant 320 bytes are the Properties segment, which defines the
card capabilities and cannot be modified by the host. The lower 192 bytes are
the Modes segment, which defines the configuration the card is working in.
These modes can be changed by the host by means of the SWITCH command.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
<B>  Properties Segment</B>
  Byte    Siz  Type  Name                          Field
  511-505   7  -     Reserved(1)                   -
  504       1  R     Supported Command Sets        S_CMD_SET
  503-216 288  -     Reserved(1)                   -
  215-212   4  R     moviNAND only: Sector Count   SEC_COUNT
  211       1  -     Reserved                      -
                     Minimum Write Performance for
  210       1  R       8bit @52MHz                 MIN_PERF_W_8_52
                     Minimum Read Performance for
  209       1  R       8bit @52MHz                 MIN_PERF_R_8_52
                     Minimum Write Performance for
  208       1  R       8bit @26MHz / 4bit @52MHz   MIN_PERF_W_8_26_4_52
                     Minimum Read Performance for
  207       1  R       8bit @26MHz / 4bit @52MHz   MIN_PERF_R_8_26_4_52
                     Minimum Write Performance for
  206       1  R       4bit @26MHz                 MIN_PERF_W_4_26
                     Minimum Read Performance for
  205       1  R       4bit @26MHz                 MIN_PERF_R_4_26
  204       1  -     Reserved(1)                   -
  203       1  R     Power Class for 26MHz @ 3.6V  PWR_CL_26_360
  202       1  R     Power Class for 52MHz @ 3.6V  PWR_CL_52_360
  201       1  R     Power Class for 26MHz @ 1.95V PWR_CL_26_195
  200       1  R     Power Class for 52MHz @ 1.95V PWR_CL_52_195
  199-197   3  -     Reserved(1)                   -
  196       1  R     Card Type                     CARD_TYPE
  195       1  -     Reserved(1)                   -
  194       1  R     CSD Structure Version         CSD_STRUCTURE
  193       1  -     Reserved(1)                   -
  192       1  R     Extended CSD Revision         EXT_CSD_REV
<B>  Modes Segment</B>
  191       1  R/W   Command Set                   CMD_SET
  190       1  -     Reserved(1)                   -
  189       1  RO    Command Set Revision          CMD_SET_REV
  188       1  -     Reserved(1)                   -
  187       1  R/W   Power Class                   POWER_CLASS
  186       1  -     Reserved(1)                   -
  185       1  R/W   High Speed Interface Timing   HS_TIMING
  184       1  -     Reserved(1)                   -
  183       1  WO    Bus Width Mode                BUS_WIDTH
  181       1  -     Reserved                      -
  180       1  RO    moviNAND only: Erased Memory Content   ERASED_MEM_CONT
  180-0   181  -     Reserved(a)                   -
</TD></TR></TABLE>
(a) Reserved(a) bits should read as '0'.<BR>
(1) Reserved(1) bits should be probably ZERO, too.<BR>
The above table is transferred "most significant first", which does probably
mean that it starts with BYTE 0, not with byte 511. ALTHOUGH, the 4-byte
SEC_COUNT appears to be LITTLE-ENDIAN?<BR>
Note: JEDEC Standard No. 84-A44 contains MANY additional fields in EXT_CSD.<BR>
<BR>
<B>S_CMD_SET</B><BR>
This field defines which command sets are supported by the card.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Command Set
  7-5   Reserved
  4     moviNAND only: ATA on MMC
  3     moviNAND only: SecureMCC 2.0
  2     Content Protection SecureMMC
  1     SecureMMC
  0     Standard MMC
</TD></TR></TABLE>
<BR>
<B>SEC_COUNT (moviNAND and newer JEDEC specs only)</B><BR>
The device density is calculated from the register by multiplying the value of
the register (sector count) by 512B/sector. The maximum density possible to be
indicated is thus 2 Tera bytes (minus 512 bytes) (4,294,967,295 x 512B). The
least significant byte (LSB) of the sector count value is the byte [212].<BR>
<BR>
<B>MIN_PERF_a_b_ff</B><BR>
These fields defines the overall minimum performance value for the read and
write access with different bus width and max clock frequency modes. The value
in the register is coded as follows. Other than defined values are illegal.<BR>
Table 5-28 : R/W Access Performance Value<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Value Performance
  0x00  For Cards not reaching the 2.4MB/s minimum value
  0x08  Class A: 2.4MB/s and is the lowest allowed value for MMCplus and
         MMCmobile(16x150kB/s)
  0x0A  Class B: 3.0MB/s and is the next allowed value (20x150kB/s)
  0x0F  Class C: 4.5MB/s and is the next allowed value (30x150kB/s)
  0x14  Class D: 6.0MB/s and is the next allowed value (40x150kB/s)
  0x1E  Class E: 9.0MB/s and is the next allowed value (60x150kB/s)
         This is also the highest class which any MMCplus or MMCmobile card
         is needed to support in low bus category operation mode (26MHz with
         4bit data bus).
         A MMCplus or MMCmobile card supporting any higher class than this
         have to support this class also (in low category bus operation mode).
  0x28  Class F: Equals 12.0MB/s and is the next allowed value (80x150kB/s)
  0x32  Class G: Equals 15.0MB/s and is the next allowed value (100x150kB/s)
  0x3C  Class H: Equals 18.0MB/s and is the next allowed value (120x150kB/s)
  0x46  Class J: Equals 21.0MB/s and is the next allowed value (140x150kB/s)
         This is also the highest class which any MMCplus or MMCmobile card
         is needed to support in mid bus category operation mode (26MHz with
         8bit data bus or 52MHz with 4bit data bus).
         A MMCplus or MMCmobile card supporting any higher class than this
         have to support this Class (in mid category bus operation mode) and
         Class E also (in low category bus operation mode).
  0x50  Class K: Equals 24.0MB/s and is the next allowed value (160x150kB/s)
  0x64  Class M: Equals 30.0MB/s and is the next allowed value (200x150kB/s)
  0x78  Class O: Equals 36.0MB/s and is the next allowed value (240x150kB/s)
  0x8C  Class R: Equals 42.0MB/s and is the next allowed value (280x150kB/s)
  0xA0  Class T: Equals 48.0MB/s and is the last defined value (320x150kB/s)
</TD></TR></TABLE>
<BR>
<B>PWR_CL_ff_vvv</B><BR>
These fields define the supported power classes by the card. By default, the
card has to operate at maximum frequency using 1 bit bus configuration, within
the default max current consumption, as stated in the table below. If 4 bit/8
bits bus configurations, require increased current consumption, it has to be
stated in these registers.<BR>
By reading these registers the host can determine the power consumption of the
card in different bus modes. Bits [7:4] code the current consumption for the 8
bit bus configuration. Bits [3:0] code the current consumption for the 4 bit
bus configuration.<BR>
The PWR_52_vvv registers are not defined for 26MHz MultiMediaCards.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Voltage Value Max RMS Current   Max Peak Current   Remarks
  3.6V    0     100 mA            200 mA             Default current
          1     120 mA            220 mA             consumption for
          2     150 mA            250 mA             high voltage cards
          3     180 mA            280 mA
          4     200 mA            300 mA
          5     220 mA            320 mA
          6     250 mA            350 mA
          7     300 mA            400 mA
          8     350 mA            450 mA
          9     400 mA            500 mA
          10    450 mA            550 mA
          11-15 Reserved for future use
  1.95V   0     65 mA             130 mA             Default current
          1     70 mA             140 mA             consumption for
          2     80 mA             160 mA             Dual voltage cards
          3     90 mA             180 mA             (if any, not moviNAND)
          4     100 mA            200 mA
          5     120 mA            220 mA
          6     140 mA            240 mA
          7     160 mA            260 mA
          8     180 mA            280 mA
          9     200 mA            300 mA
          10    250 mA            350 mA
          6-15  Reserved for future use
</TD></TR></TABLE>
The measurement for max RMS current is done as average RMS current consumption
over a period of 100ms.<BR>
Max peak current is defined as absolute max value not to be exceeded at all.<BR>
The conditions under which the power classes are defined are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  - Maximum bus frequency
  - Maximum operating voltage
  - Worst case functional operation
  - Worst case environmental parameters (temperature,...)
</TD></TR></TABLE>
These registers define the maximum power consumption for any protocol operation
in data transfer mode, Ready state and Identification state.<BR>
<BR>
<B>CARD_TYPE</B><BR>
This field defines the type of the card. The only currently valid values for
this field are 0x01 and 0x03.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit Card Type
  7-2 Reserved
  1   High Speed MultiMediaCard @ 52MHz
  0   High Speed MultiMediaCard @ 26MHz
</TD></TR></TABLE>
<BR>
<B>CSD_STRUCTURE</B><BR>
This field is a continuation of the CSD_STRUCTURE field in the CSD register.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  CSD_STRUCTURE CSD structure version   Valid for System Specification Version
  0             CSD version No. 1.0     Version 1.0 - 1.2
  1             CSD version No. 1.1     Version 1.4 - 2.2
  2             CSD version No. 1.2     Version 3.1-3.2-3.31-4.0-4.1-4.2
  3             Reserved for future use
  4-255         Reserved for future use
</TD></TR></TABLE>
<BR>
<B>EXT_CSD_REV</B><BR>
Defines the fixed parameters. related to the EXT_CSD, according to its
revision.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  EXT_CSD_REV   Extended CSD Revision
  0             Revision 1.0
  1             Revision 1.1
  2             Revision 1.2 (moviNAND)
  3-255         Reserved
</TD></TR></TABLE>
<BR>
<B>CMD_SET</B><BR>
Contains the binary code of the command set that is currently active in the
card. It is set to '0' (Standard MMC) after power up and can be changed by a
SWITCH command.<BR>
<BR>
<B>CMD_SET_REV</B><BR>
Contains a binary number reflecting the revision of the currently active
command set. For Standard MMC command set it is:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Code    MMC Revisions
  0       v4.0
  1-255   Reserved
</TD></TR></TABLE>
This field, though in the Modes segment of the EXT_CSD, is read only.<BR>
<BR>
<B>POWER_CLASS</B><BR>
This field contains the 4 bit value of the selected power class for the card.
The power classes are defined in Table. The host should be responsible of
properly writing this field with the maximum power class it allows the card to
use. The card uses this information to, internally, manage the power budget and
deliver an optimized performance.<BR>
This field is 0 after power-on or software reset.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bits    Description
  7-4     Reserved
  3-0     Card power class code (See Table 5-29)
</TD></TR></TABLE>
<BR>
<B>HS_TIMING</B><BR>
This field is 0 after power-on, or software reset, thus selecting the backwards
compatibility interface timing for the card. If the host writes 1 to this
field, the card changes its timing to high speed interface timing (refer to
Chapter 5.4.8).<BR>
<BR>
<B>BUS_WIDTH</B><BR>
It is set to '0' (1 bit data bus) after power up and can be changed by a SWITCH
command.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Value   Bus Mode
  0       1 bit data bus
  1       4 bit data bus
  2       8 bit data bus
  3-255   Reserved
</TD></TR></TABLE>
<BR>
<B>ERASED_MEM_CONT (moviNAND) (but, RESERVED in newer JEDEC specs!)</B><BR>
This Field defines the content of an explicitly erased memory range.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Value   Erased Memory content
  00h     Erased memory range shall be '0'
  01h     Erased memory range shall be '1'
  02h-FFh Reserved
</TD></TR></TABLE>
Looks like a mis-definition, since value 00h should have been kept reserved for
cards that do not specify whether they set erased bits to 0 or 1.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcprotocolrcaregister16bitrelativecardaddress"></A>&nbsp;
  DSi SD/MMC Protocol: RCA Register (16bit Relative Card Address)
</FONT></TD></TR></TABLE><BR>
The RCA was intended for connecting multiple cards to the same host, possibly
even sharing the same signal wires for multiple cards. The multi-card feature
isn't used to often though.<BR>
Most hosts are having only a single card slot. And, hosts that &lt;do&gt;
support multiple cards may use separate busses and even separate controllers
for each card (eg. Nintendo DSi is doing so for onboard NAND and external SD
slot).<BR>
However, even single-card systems will need to obtain a "dummy" RCA, and use
that RCA value for selecting the card.<BR>
The only exception is SPI mode: SPI isn't using RCA, and doesn't support RCA
commands at all - instead, in SPI mode, the cards are selected via /CS signal
(which may include multiple /CS signals for multiple cards).<BR>
<BR>
<B>CMD3 - SD - SEND_RELATIVE_ADDR (type=bcr)</B><BR>
Parameter bits:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-0  stuff bits
</TD></TR></TABLE>
Response: R6:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  47      Start Bit (0)                                 ;\
  46      Transmission To Host (0)                      ; 1st byte
  45-40   Command (the 6bit CMD being responded to)     ;/
  39-24   New published RCA of the card   ;-16bit       ;-2nd..3th byte
  23-22   CSR Card Status, bit 23-22      ;\            ;\
  21      CSR Card Status, bit 19         ; 16bit       ; 4nd..5th byte
  20-8    CSR Card Status, bit 12-0       ;/            ;/
  7-1     CRC7                                          ;\6th byte
  0       End Bit (1)                                   ;/
</TD></TR></TABLE>
Ask the card to publish a new relative address (RCA).<BR>
Dunno how this is intended to work with multiple cards. The goal should be to
assign &lt;different&gt; RCAs to each card. The command should be probably
repeatedly used until all cards respond with different RCAs. This would require
the cards to contain some sort of analog random generator - or maybe to use the
CID register as random seed (the CID seems to contain unique serial numbers per
card)?<BR>
<BR>
<B>CMD3 - MMC - SET_RELATIVE_ADDR (type=ac)</B><BR>
Parameter bits:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-16 RCA
  15-0  stuff bits
</TD></TR></TABLE>
Response: R1<BR>
Assigns an RCA value TO the card (ie. the opposite of CMD3 on SD Cards).<BR>
Dunno how this is intended to work with multiple cards. The goal should be to
assign &lt;different&gt; RCAs to each card. But actually, the command appears
to assign the &lt;same&gt; RCA to all cards?<BR>
<BR>
<B>CMD7 - SD/MMC - SELECT/DESELECT_CARD (type=ac) ;actually: (type=bcr)</B><BR>
Parameter bits:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-16 RCA
  15-0  stuff bits
</TD></TR></TABLE>
Response: R1b (only from the selected card)<BR>
Additional Data Transfer (from card): Busy signal for "R1b" response<BR>
Command toggles a card between the stand-by and transfer states or between the
programming and disconnect states. In both cases, the card is selected by its
own relative address and gets deselected by any other address; address 0
deselects all.<BR>
In the case that the RCA equals 0, then the host may do one of the following:<BR>
- Use other RCA number to perform card de-selection.<BR>
- Re-send CMD3 to change its RCA number to other than 0 and then use CMD7 with
RCA=0 for card deselection.<BR>
<BR>
<B>RCA register</B><BR>
The writable 16-bit relative card address register carries the card address
that is published by the card during the card identification. This address is
used for the addressed host-card communication after the card identification
procedure. The default value of the RCA register is 0000h. The value 0000h is
reserved to set all cards into the Stand-by State with CMD7.<BR>
In UHS-II mode, Node ID is used as RCA. Refer to SD-TRAN Section of UHS-II
Addendum for more details.<BR>
<BR>
<B>Note</B><BR>
Commands SEND_CSD, SEND_CID, APP_CMD, GO_INACTIVE_STATE, and SEND_STATUS
allow/require to specify RCA in parameter field.<BR>
Other commands are either processed by all cards (broadcast commands), or
processed only be cards that have been previously selected via CMD7 (most
normal commands).<BR>
<BR>
<B>Broadcast Commands</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  CMD0     sd/mmc spi GO_IDLE_STATE (type=bc)
  CMD2     sd/mmc     ALL_SEND_CID (type=bcr)
  CMD3     sd         SEND_RELATIVE_ADDR (type=bcr)
  CMD4     sd         SET_DSR (type=bc)
  CMD7     sd/mmc     SELECT/DESELECT_CARD (type=ac) ;actually: (type=bcr)
  CMD8     sd     spi SEND_IF_COND (type=bcr)
  ACMD41   sd     spi SD_SEND_OP_COND (type=bcr)  ;SPI: reduced functionality
</TD></TR></TABLE>
Some broadcast commands are sending responses.<BR>
SD specs are suggesting to use separate CMD lines for each card (so the host
would broadcast the same command on all CMD lines, and would receive separate
responses in parallel from each CMD line).<BR>
MMC cards are said to support open-collector CMD lines (so responses from
separate cards would be logically ORed, though, dunno what that would be good
for).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcprotocoldsrregister16bitdriverstageregisteroptional"></A>&nbsp;
  DSi SD/MMC Protocol: DSR Register (16bit Driver Stage Register) (Optional)
</FONT></TD></TR></TABLE><BR>
<B>CMD4 - MMC - SET_DSR (type=bc)</B><BR>
Parameter bits:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-16 DSR
  15-0  stuff bits
</TD></TR></TABLE>
Response: N/A<BR>
Programs the DSR of all cards.<BR>
<BR>
<B>DSR register (Optional)</B><BR>
The 16-bit driver stage register is described in detail in Chapter 0 (uh,
where?). It can be optionally used to improve the bus performance for extended
operating conditions (depending on parameters like bus length, transfer rate or
number of cards). The CSD register carries the information about the DSR
register usage. The default value of the DSR register is 0404h.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcprotocolscrregister64bitsdcardconfigurationregister"></A>&nbsp;
  DSi SD/MMC Protocol: SCR Register (64bit SD Card Configuration Register)
</FONT></TD></TR></TABLE><BR>
<B>ACMD51 - SD - SPI - SEND_SCR (type=adtc)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-0  stuff bits
</TD></TR></TABLE>
Response: R1<BR>
Additional Data Transfer (from card):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  63-0  SCR Register (8bytes, aka 64bit)
</TD></TR></TABLE>
<BR>
<B>SD Configuration Register (SCR)</B><BR>
In addition to the CSD register, there is another configuration register named
SD CARD Configuration Register (SCR). SCR provides information on the SD Memory
Card's special features that were configured into the given card. The size of
SCR register is 64 bits. This register shall be set in the factory by the SD
Memory Card manufacturer.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit  Siz  Typ Description                      Field
  63-60  4  R   SCR Structure                    SCR_STRUCTURE
  59-56  4  R   SD Memory Card - Spec. Version   SD_SPEC
  55     1  R   data_status_after erases         DATA_STAT_AFTER_ERASE
  54-52  3  R   CPRM Security Support            SD_SECURITY
  51-48  4  R   DAT Bus widths supported         SD_BUS_WIDTHS
  47     1  R   Spec. Version 3.00 or higher     SD_SPEC3
  46-43  4  R   Extended Security Support        EX_SECURITY
  42     1  R   Spec. Version 4.00 or higher     SD_SPEC4
  41-36  6  R   Reserved                         -
  35-32  4  R   Command Support bits             CMD_SUPPORT
  31-0  32  R   reserved for manufacturer usage  -
</TD></TR></TABLE>
<BR>
<B>SCR Register Structure Version</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  SCR_STRUCTURE  SCR Structure Version  SD Physical Layer Specification Version
  00h            SCR version 1.0        Version 1.01-4.00
  01h..0Fh       reserved
</TD></TR></TABLE>
Note: SD_SPEC is used to indicate SCR Structure Version instead of this field.<BR>
<BR>
<B>SD_SPEC, SD_SPEC3, SD_SPEC4</B><BR>
The Physical Layer Specification Version is indicated in combination with
SD_SPEC, SD_SPEC3 and SD_SPEC4 as described Table 5-19.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  SD_SPEC  SD_SPEC3  SD_SPEC4   Physical Layer Specification Version Number
  0        0         0          Version 1.0 and 1.01
  1        0         0          Version 1.10
  2        0         0          Version 2.00
  2        1         0          Version 3.0X
  2        1         1          Version 4.XX
         Others                 Reserved
</TD></TR></TABLE>
(1) Version 2.00 hosts do not recognize SD_SPEC3 and SD_SPEC4.<BR>
(2) Version 3.00 hosts do not recognize SD_SPEC4.<BR>
Hosts recognize Physical Layer Specification Version shall also recognize
including future version. Next version will be defined in SD_SPEC field.<BR>
<BR>
The card manufacturer determines SD_SPEC value by conditions indicated below.
All conditions shall be satisfied for each version. The other combination of
conditions is not allowed.<BR>
<BR>
Essential conditions to indicate Version 1.01 Card (SD_SPEC=0, SD_SPEC3=0 and
SD_SPEC4=0):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  (1) The card does not support CMD6
  (2) The card does not support CMD8
  (3) User area capacity shall be up to 2GB
</TD></TR></TABLE>
Essential conditions to indicate Version 1.10 Card (SD_SPEC=1, SD_SPEC3=0 and
SD_SPEC4=0):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  (1) The card shall support CMD6
  (2) The card does not support CMD8
  (3) User area capacity shall be up to 2GB
</TD></TR></TABLE>
Essential conditions to indicate Version 2.00 Card (SD_SPEC=2, SD_SPEC3=0 and
SD_SPEC4=0):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  (1) The card shall support CMD6
  (2) The card shall support CMD8
  (3) The card shall support CMD42
  (4) User area capacity shall be up to 2GB (SDSC) or 32GB (SDHC)
  (5) Speed Class shall be supported (SDHC)
</TD></TR></TABLE>
Essential conditions to indicate Version 3.00 Card (SD_SPEC=2, SD_SPEC3=1 and
SD_SPEC4=0):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  (1) The card shall support CMD6
  (2) The card shall support CMD8
  (3) The card shall support CMD42
  (4) User area capacity shall be up to 2GB (SDSC) or 32GB (SDHC)
    User area capacity shall be more than or equal to 32GB and up to 2TB (SDXC)
  (5) Speed Class shall be supported (SDHC or SDXC)
</TD></TR></TABLE>
Optional conditions to indicate Version 3.00 Card:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  A card supports any of following functions shall satisfy essential
  conditions of Version 3.00 Card
  (1) Speed Class supported under the conditions defined in Version 3.00
  (2) UHS-I supported card
  (3) CMD23 supported card
</TD></TR></TABLE>
Essential conditions to indicate Version 4.XX Card (SD_SPEC=2, SD_SPEC3=1 and
SD_SPEC4=1):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  (1) Same as the essential conditions of Version 3.00 device
  (2) Support any of additional functions defined by Version 4.XX:
      Followings functions (a) to (c) are defined by Version 4.00.
        (a) Support of CMD48 and CMD49
        (b) Support of UHS-II mode
        (c) Support of DPS
      Followings functions (d) to (f) are defined by Version 4.10.
        (d) Support of CMD58 and CMD59
        (e) Support of Power Management Functions
        (f) Support of Speed Grade 1 for UHS-II mode
</TD></TR></TABLE>
The requirements of supporting commands mentioned above are for the optional
commands, the support of which depends on versions (SD_SPEC, SD_SPEC3 and
SD_SPEC4). Refer to Table 4-21 (and Notes below the table) about the mandatory
and optional commands in the card.<BR>
<BR>
<B>DATA_STAT_AFTER_ERASE</B><BR>
Defines the data status after erase, whether it is 0 or 1 (the status is card
vendor dependent).<BR>
<BR>
<B>SD_SECURITY</B><BR>
This field indicates CPRM Security Specification Version for each capacity
card. The definition of Protected Area is different in each capacity card.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h           No Security
  01h           Not Used
  02h           SDSC Card (CPRM Security Version 1.01)
  03h           SDHC Card (CPRM Security Version 2.00)
  04h           SDXC Card (CPRM Security Version 3.xx)
  05h-07h       Reserved
</TD></TR></TABLE>
The basic rule of setting this field:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  SDSC Card sets this field to 2 (Version 1.01).
  SDHC Card sets this field to 3 (Version 2.00).
  SDXC Card sets this field to 4 (Version 3.xx).
</TD></TR></TABLE>
Note that it is mandatory for a regular writable SD Memory Card to support
Security Protocol. For ROM (Read Only) and OTP (One Time Programmable) types of
the SD Memory Card, the security feature is optional.<BR>
<BR>
<B>SD_BUS_WIDTHS</B><BR>
Describes all the DAT bus widths that are supported by this card.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit 3          Reserved
  Bit 2          4 bit (DAT0-3)
  Bit 1          Reserved
  Bit 0          1 bit (DAT0)
</TD></TR></TABLE>
Since the SD Memory Card shall support at least the two bus modes 1-bit or
4-bit width, then any SD Card shall set at least bits 0 and 2
(SD_BUS_WIDTH="0101").<BR>
<BR>
<B>EX_SECURITY</B><BR>
This field indicates Extended Security which is defined by the Part A4 Data
Protection System Specification Version 1.00 or will be defined by a later
version of the Part 3 Security Specification Version 3.00.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h          Extended Security is not supported.
  01h..0Fh     Extended Security is supported. SCR[44-43] is defined by the
                 Part A4 Data Protection System Specification. SCR[46-45] is
                 reserved for future extension.
</TD></TR></TABLE>
<BR>
<B>CMD_SUPPORT</B><BR>
Support bit of new commands are defined to Bit 33-32 (uh, 35-32?) of SCR.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit Supported Command               Command  CCC  Remark
  35  Extension Register Multi-Block  CMD58/59 11   Optional.
  34  Extension Register Single Block CMD48/49 11   Optional.
  33  Set Block Count                 CMD23    2,4  Mandatory for UHS104 card
  32  Speed Class Control             CMD20    2,4  Mandatory for SDXC card
</TD></TR></TABLE>
If CMD58/59 is supported, then CMD48/49 shall be also supported.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcprotocolpwdregister128bitpasswordplus8bitpasswordlen"></A>&nbsp;
  DSi SD/MMC Protocol: PWD Register (128bit Password plus 8bit Password len)
</FONT></TD></TR></TABLE><BR>
<B>CMD40 - SD - Defined by DPS Spec (type=adtc)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Defined by DPS Spec.
</TD></TR></TABLE>
Response: R1<BR>
Additional Data Transfer (to/from whatever):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  unknown
</TD></TR></TABLE>
Single block read type. Intended to read whatever "public" data, which is
available even if the card is locked.<BR>
<BR>
<B>CMD42 - SD/MMC (SD v2.00 and up) - SPI - LOCK_UNLOCK (type=adtc)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  31-0  Reserved bits (0)
</TD></TR></TABLE>
Response: R1 (MMC: R1b?)<BR>
MMC?: Additional Data Transfer (from card): Busy signal for "R1b" response<BR>
Additional Data Transfer (to card):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Note: Before using this command, the size of the following data block (ie.
        "1st..Nth/Extra" byte) must be set via SET_BLOCKLEN command (CMD16).
  1st byte: Flags
    Bit7-4 Reserved (0)
    Bit3   ERASE       Force Erase (1=Erase WHOLE CARD and clear password)
    Bit1   LOCK_UNLOCK Lock card (0=Unlock, 1=Lock) (default on power up: Lock)
    Bit1   CLR_PWD     Clears password  (0=no, 1=yes)
    Bit0   SET_PWD     Set new password (0=no, 1=yes)
  2nd byte: PWDS_LEN   Length of the Password(s) in bytes ("3rd..Nth" byte)
  3rd..Nth byte: Password (old password, if SET_PWD: followed by new password)
  Extra byte: Alignment padding (only in DDR50 mode, if above is odd num bytes)
</TD></TR></TABLE>
Used to set/clear the password (=to change the password), or to lock/unlock the
card (=to log out/log in). If the password exists, then the default state on
power-up is Locked (user is logged out).<BR>
In locked state, the card will accept only "Basic Commands" (class 0), plus
CMD16,40,42, plus ACMD41,42. Observe that this will prevent some initialization
commands (for example, switching to 4bit bus via SET_BUS_WIDTH (ACMD6) isn't
possible on locked cards).<BR>
The password is stored in a 128bit PWD register, so password can be max 16
bytes long. The PWDS_LEN value can be max 32 bytes (when sending old+new
password). The length of the current/old password is stored in an 8bit PWD_LEN
register (though due to the above limit, that "8bit" value can be in range
0..16 only; PWD_LEN=0 means that there is no password, which is somewhat
equivalent to what happens when setting the CLR_PWD bit?).<BR>
PWD Notes:<BR>
Related CSR status bits are: CARD_IS_LOCKED and LOCK_UNLOCK_FAILED. Presence of
the locking feature is indicated by the CCC "class 7" bit in CSD register.<BR>
Many SD cards are internally containing separate controller and memory chips,
so it might be quite easy to bypass the locking by desoldering one of those
chips.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcprotocolsignals"></A>&nbsp;
  DSi SD/MMC Protocol: Signals
</FONT></TD></TR></TABLE><BR>
XXX...<BR>
<BR>
<B>SD Mode 1-bit data transfer mode</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
          __ start bit                             __ checksum bits (CRC-CCITT)
         |                                        |
         |  &lt;------------data bits-------------&gt;  |   __ stop bit
         |                                        |  |
  DAT0   0  1st 2nd 3rd 4th 5th 6th 7th ... last crc 1
</TD></TR></TABLE>
<BR>
<B>SD Mode 4-bit data transfer mode</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
          __ start bit         __ checksum bits (CRC-CCITT)
         |                    |
         |  &lt;--data bits--&gt;   |   __ stop bit
         |                    |  |
  DAT3   0  1st 5th ... ...  crc 1
  DAT2   0  2nd 6th ... ...  crc 1
  DAT1   0  3rd 7th ... ...  crc 1
  DAT0   0  4th 8th ... last crc 1
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcfilesystem"></A>&nbsp;
  DSi SD/MMC Filesystem
</FONT></TD></TR></TABLE><BR>
<B>DSi Partition Table and FAT Filesystems</B><BR>
<A HREF="#dsisdmmcpartitiontableakamasterbootrecordakambr">DSi SD/MMC Partition Table (aka Master Boot Record aka MBR)</A><BR>
<A HREF="#dsisdmmcfilesystemfat">DSi SD/MMC Filesystem (FAT)</A><BR>
System Tools and DSiware games are having regular "ROM Cartridge" headers, with
NitroROM filesystem defined in that headers (ie. the ".app" files are
internally containing a 2nd filesystem inside of the FAT filesystem; eventually
there can be also NARC files as 3rd filesystem inside of the NitroROM
filesystem).<BR>
<A HREF="#dsicartridgeheader">DSi Cartridge Header</A><BR>
<A HREF="#dscartridgenitroromandnitroarcfilesystems">DS Cartridge NitroROM and NitroARC File Systems</A><BR>
Savedata for DSiWare games is usually stored in "public.sav" or "private.sav"
files, the games are probably receiving a list of sector/cluster numbers from
the firmware (so they can access the .sav sectors directly without needing to
deal with the FAT16 filesystem). However, that .sav files are usually
containing a FAT12 with its own VBR, FAT, and Directories (so they use some
virtual FAT12 inside of the real FAT16).<BR>
<BR>
<B>DSi Filesystem Overview</B><BR>
<A HREF="#dsisdmmcinternalnandlayout">DSi SD/MMC Internal NAND Layout</A><BR>
<A HREF="#dsisdmmcbootloader">DSi SD/MMC Bootloader</A><BR>
<A HREF="#dsisdmmccompletelistofsdmmcfilesfolders">DSi SD/MMC Complete List of SD/MMC Files/Folders</A><BR>
<A HREF="#dsisdmmcsummaryofsdmmcfilesfolders">DSi SD/MMC Summary of SD/MMC Files/Folders</A><BR>
<A HREF="#dsisdmmcimages">DSi SD/MMC Images</A><BR>
<BR>
<B>DSi Files</B><BR>
<A HREF="#dsisdmmctadfilesonsdcards">DSi SD/MMC Tad Files on SD Cards</A><BR>
<A HREF="#dsisdmmcfirmwaredevkpandcertsyscertificatefiles">DSi SD/MMC Firmware dev.kp and cert.sys Certificate Files</A><BR>
<A HREF="#dsisdmmcfirmwarefontfile">DSi SD/MMC Firmware Font File</A><BR>
<A HREF="#dsisdmmcfirmwarelogfiles">DSi SD/MMC Firmware Log Files</A><BR>
<A HREF="#dsisdmmcfirmwaremiscfiles">DSi SD/MMC Firmware Misc Files</A><BR>
<A HREF="#dsisdmmcfirmwarewififirmware">DSi SD/MMC Firmware Wifi Firmware</A><BR>
<A HREF="#dsisdmmcfirmwaresystemsettingsdatafiles">DSi SD/MMC Firmware System Settings Data Files</A><BR>
<A HREF="#dsisdmmcfirmwaretitlemetadatatmdfiles">DSi SD/MMC Firmware Title metadata (.tmd) Files</A><BR>
<A HREF="#dsisdmmcfirmwareversiondatafile">DSi SD/MMC Firmware Version Data File</A><BR>
<A HREF="#dsisdmmcfirmwarenintendodscartwhitelistfile">DSi SD/MMC Firmware Nintendo DS Cart Whitelist File</A><BR>
<A HREF="#dsisdmmccamerafilesoverview">DSi SD/MMC Camera Files - Overview</A><BR>
<A HREF="#dsisdmmccamerafilesjpegs">DSi SD/MMC Camera Files - JPEG's</A><BR>
<A HREF="#dsisdmmccamerafilespitbin">DSi SD/MMC Camera Files - pit.bin</A><BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcpartitiontableakamasterbootrecordakambr"></A>&nbsp;
  DSi SD/MMC Partition Table (aka Master Boot Record aka MBR)
</FONT></TD></TR></TABLE><BR>
<B>DSi eMMC Partition table</B><BR>
The decrypted DSi MBR contains:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0000  00 00 00 00 00 00 00 00 .. .. .. .. 00 00        ;bootcode (zero)
  01BE  00 03 18 04 06 0F E0 3B 77 08 00 00 89 6F 06 00  ;1st partition (main)
  01CE  00 02 CE 3C 06 0F E0 BE 4D 78 06 00 B3 05 01 00  ;2nd partition (photo)
  01DE  00 02 DE BF 01 0F E0 BF 5D 7E 07 00 A3 01 00 00  ;3rd partition (extra)
  01EE  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ;4th partition (none)
  01FE  55 AA                                            ;mbr id (55h,AAh)
</TD></TR></TABLE>
Above values are following the classical standard MBR format:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h      446  bootcode (zerofilled on DSi)                   ;-bootcode
  1BEh+n*10h  1  status (00h)                                   ;\
  1BFh+n*10h  3  chsFirst                                       ; four
  1C2h+n*10h  1  type (00h=unused, 01h=FAT12, 06h=FAT16B)       ; partitions
  1C3h+n*10h  3  chsLast                                        ; (n=0..3)
  1C6h+n*10h  4  lbaFirst  ;\logical block addresses/sizes      ;
  1CAh+n*10h  4  lbaSize   ;/counted in 200h-byte sectors       ;/
  1FEh        2  mbrsig (55h,AAh)                               ;-MBR ID
</TD></TR></TABLE>
The CHS and LBA values are essentially containing the same information (CHS
being an older standard, and LBA being invented in 1996). The 24bit CHS values
are encoded as:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-7    Head Bit0-7     (00h..FEh) (or less common, 00h..FFh)
  8-13   Sector Bit0-5   (01h..3Fh)
  14-15  Cylinder Bit8-9
  16-23  Cylinder Bit0-7 (000h..3FFh, with above bit8-7)
</TD></TR></TABLE>
To convert CHS to LBA, one must know the number of (logical) heads and sectors
per cylinder (that info isn't stored in the MBR). The DSi's eMMC uses 32
sectors, 16 heads, 1024 cylinders:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  LBA = (Cylinder*32*16) + (Head*32) + (Sector-1)
</TD></TR></TABLE>
Anyways, it's better/easier to use the LBA values directly, and ignore the CHS
values.<BR>
<BR>
<B>3DS eMMC Partition table</B><BR>
Contents are unknown. The 3DS is said to have more than four partitions, so it
must be using some extended MBR variant. Reportedly there's some extra "NCSD"
header in the MBR sector.<BR>
<BR>
<B>SD/MMC Card Partition table</B><BR>
SD/MMC Cards are shipped with pre-formatted filesystem, so they should stick to
some standarized MBR variant, with only a single partition used, possibly with
additional date/id fields(?).<BR>
Note that SD/MMC Cards may or may not use partition tables (see CSD Register,
FILE_FORMAT entry).<BR>
<BR>
<B>Formatting and Reformatting</B><BR>
SD/MMC cards are usually pre-formatted with empty filesystems. Reformatting
should be avoided, or should be done only with tools that are aware of some
memory card specific requirements:<BR>
The cluster size should not be less than the physical sector size (otherwise,
when writing smaller clusters, sectors may get erased multiple times, which
would result in slower writing and reduced lifetime).<BR>
Many devices do support only the standard FAT filesystems (for example, cameras
or mp3-players may be unable to access memory cards with NTFS filesystem).<BR>
<BR>
<B>More info</B><BR>
For more info on MBR variants (and on the Partition Type value at 1C2h+n*10h),
see:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  http://en.wikipedia.org/wiki/Master_Boot_Record
  http://en.wikipedia.org/wiki/Partition_type &lt;-- rather meaningless
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcfilesystemfat"></A>&nbsp;
  DSi SD/MMC Filesystem (FAT)
</FONT></TD></TR></TABLE><BR>
<B>Volume Boot Record (VBR) (FAT12/FAT16) (DOS 4.0 EBPB)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 3   80x86 jump opcode       (DSi: E9h,00h,00h)
  003h 8   ascii disk name         (DSi: "TWL     ")
  00Bh 2   bytes / sector          (DSi: 0200h)
  00Dh 1   sectors / cluster       (DSi: 20h)
  00Eh 2   sectors / boot-record   (DSi: 0001h)
  010h 1   number of FAT-copys     (DSi: 02h)
  011h 2   entrys / root-directory (DSi: 0200h)
  013h 2   sectors / disk          (DSi: 0000h)
  015h 1   ID                      (DSi: F8h=HDD)
  016h 2   sectors / FAT           (DSi: A:0034h, B:0009h)
  018h 2   sectors / track         (DSi: 0020h)
  01Ah 2   heads / disk            (DSi: 0010h)
  01Ch 2   number of reserved sectors    (DSi: None such entry!)
  01Ch 4   LBA First "hidden"      (DSi: A:00000877h, B:0006784Dh)
  020h 4   LBA Size                (DSi: A:00066F89h, B:000105B3h)
  024h 1   Drive Number            (DSi: A:00h, B:01h)
  025h 1   Flags                   (DSi: 00h)
  026h 1   EBPB Version            (DSi: 29h) (that is, DOS 4.0 EBPB)
  027h 4   Volume Serial Number    (DSi: 12345678h)
  02Bh 11  Volume Label            (DSi: "           ")
  036h 8   Filesystem Type         (DSi: 00h-filled)
  03Eh 448 Bootcode                (DSi: 00h-filled)
  1FEh 2   Signature               (DSi: 55h,AAh)
</TD></TR></TABLE>
http://en.wikipedia.org/wiki/BIOS_Parameter_Block<BR>
<BR>
<B>File Allocation Table - FAT and FAT copy(s)</B><BR>
The following sectors are occupied by the File Allocation Table (FAT), which
contains 12- or 16-bit entries for each cluster:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  (0)000      unused, free
  (0)001      ???
  (0)002...   pointer to next cluster in chain (0)002..(F)FEF
  (F)FF0-6    reserved (no part of chain, not free)
  (F)FF7      defect cluster, don't use
  (F)FF8-F    last cluster of chain
</TD></TR></TABLE>
Number and size of FATs can be calculated by the information in the boot
sector.<BR>
<BR>
<B>Root directory</B><BR>
The following sectors are the Root directory, again, size depends on the info
in bootsector. Each entry consists of 32 bytes:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00-07  8    Filename (first byte: 00=free entry,2E=dir, E5=deleted entry)
  08-0A  3    Filename extension
  0B     1    Fileattribute
                bit0 read only
                bit1 hidden
                bit2 system
                bit3 volume label
                bit4 subdirectory
                bit5 archive-flag
                bit6 reserved
                bit7 reserved
  0C-0D  2    Reserved, or stuff
  0E-0F  2    Reserved, or Creation Timestamp
  10-11  2    Reserved, or Creation Datestamp
  12-13  2    Reserved, or Last Access Datestamp
  14-15  2    Reserved, or MSBs of Cluster (for FAT32)
  16-17  2    Last Modify Timestamp: HHHHHMMM, MMMSSSSS
  18-19  2    Last Modify Datestamp: YYYYYYYM, MMMDDDDD
  1A-1B  2    Pointer to first Cluster of file
  1C-1F  4    Filesize in bytes
</TD></TR></TABLE>
The 'cluster' entry points to the first used cluster of the file. The FAT entry
for that cluster points to the next used cluster (if any), the FAT entry for
that cluster points to the next cluster, and so on.<BR>
<BR>
<B>Long File Names (LFNs)</B><BR>
Long File Names (LFNs) are occupying multiple continous directory entries,
consisting of a normal short filename entry, preceeded by one or more LFN
prefix entries (with Attribute=0Fh). Each LFN prefix can hold 13 characters,
the total length should not exceed 255 characters. The name should be
terminated by 0000h, and any remaing unused characters should be padded by
FFFFh. The LFN prefix entries are using the following format:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h  1  Sequence Number (bit 6: last logical, first physical LFN entry,
          bit 5: 0; bits 4-0: number 01h..14h (1Fh),
          deleted entry: E5h)
  01h  10 Long Filename characters (five UCS-2 characters)
  0Bh  1  Attributes (always 0Fh)
  0Ch  1  Type (always 00h)
  0Dh  1  Short Filename Checksum
          sum=00h, for i=0 to 10, sum = (sum ROR 1) + shortname_char[i], next i
  0Eh  12 Long Filename characters (six UCS-2 characters)
  1Ah  2  First cluster (always 0000h)
  1Ch  4  Long Filename characters (two UCS-2 characters)
</TD></TR></TABLE>
For example a filename like "File with very long filename.ext" would be
formatted like this:Sequence number Entry data<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  LFN Prefix (43h) "me.ext", 0000h, FFFFh-padding
  LFN Prefix (02h) "y long filena"
  LFN Prefix (01h) "File with ver"
  Normal 8.3 short filename entry "FILEWI~1.EXT"
</TD></TR></TABLE>
http://en.wikipedia.org/wiki/Design_of_the_FAT_file_system#VFAT_long_file_names<BR>
<BR>
<B>Reserved Sectors (if any)</B><BR>
Usually the number of reserved sectors is zero. If it is non-zero, then the
following sector(s) are reserved (and could be used by the boot procedure for
whatever purposes).<BR>
<BR>
<B>Data Clusters 0002..nnnn</B><BR>
Finally all following sectors are data clusters. The first cluster is called
cluster number (0)002, followed by number (0)003, (0)004, and so on.<BR>
<BR>
http://en.wikipedia.org/wiki/Design_of_the_FAT_file_system<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcinternalnandlayout"></A>&nbsp;
  DSi SD/MMC Internal NAND Layout
</FONT></TD></TR></TABLE><BR>
The DSi uses a 256MB Samsung eMMC moviNAND(?) flash chip, which is a NAND flash
chip with a built-in controller that implements a MMC (SDIO?) interface. In
many ways, it's like an SD card (or actually: MMC card) in BGA packaging, and
some people have successfully read it with modified(why/how?) SD(/MMC?) card
readers (is there any standard software that can be used for doing that?). The
last 16MB is used for wear-leveling purposes (such as replacing bad blocks),
while the first 240MB is used for storing actual data.<BR>
<BR>
Addressing is done in terms of 512-bytes sectors. All wear-levelling and
bad-block-mapping is handled transparently inside the chip by the controller.
Most sectors are encrypted with a per-console key.<BR>
<BR>
<B>Overall eMMC Layout</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Offset     Size     Description
  00000000h  200h     PC-style MBR, encrypted with a per-console key
  00000200h  200h     Stage 2 Info Block 1 (used)
  00000400h  200h     Stage 2 Info Block 2 (unused, same as above)
  00000600h  200h     Stage 2 Info Block 3 (unused, with nonsense NAND offsets)
  00000800h  26600h   Stage 2 ARM9 Bootcode (encrypted with universal key)
  00026E00h  27600h   Stage 2 ARM7 Bootcode (encrypted with universal key)
  0004E400h  400h     Stage 2 Footer -- unknown format, but first 10 bytes
                        are (unencrypted) build number of Stage 2 bootloader
  0004E800h  B1200h   Unused (all 00h)
  000FFA00h  400h     Diagnostic area. (often contains build date of
                        device in plaintext) Blank in never-before-booted
                        DSi. Might be written to during firmware updates.
  000FFE00h  200h     Unused (all FFh)
  00100000h  EE00h    Unused (all 00h)
  0010EE00h  CDF1200h 1st partition (205.9Mbyte) (main, encrypted, FAT16)
  0CF00000h  9A00h    Unused (all 00h)
  0CF09A00h  20B6600h 2nd partition (32.7Mbyte)  (photo, encrypted, FAT12)
  0EFC0000h  BA00h    Unused (all 00h)
  0EFCBA00h  34600h   3rd partition (0.2Mbyte)   (extra, unformatted)
  0F000000h           End of 240MByte Address Space
</TD></TR></TABLE>
<BR>
<B>Stage 2 Info Blocks 1, 2, 3 (unencrypted; aside from the RSA block)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 20h Zerofilled
  020h 4   ARM9 Bootcode NAND Offset     (800h)          (Info Block 3: 80400h)
  024h 4   ARM9 Bootcode Size actual     (26410h)
  028h 4   ARM9 Bootcode RAM Address?    (37B8000h)
  02Ch 4   ARM9 Bootcode Size rounded-up (26600h)
  030h 4   ARM7 Bootcode NAND Offset     (26E00h)        (Info Block 3: A6A00h)
  034h 4   ARM7 Bootcode Size actual     (27588h)
  038h 4   ARM7 Bootcode RAM Address?    (37B8000h)
  03Ch 4   ARM7 Bootcode Size rounded-up (27600h)
  040h BFh Zerofilled
  0FFh 1   Unknown (0Ch)
  100h 80h RSA Block            (B3,FF,EC,E5,..) (Info Block 3: 5B,E1,7A,9F,..)
  180h 14h Global MBK1..MBK5 Slot Settings
  194h 0Ch Local ARM9 MBK6..MBK8 Settings
  1A0h 0Ch Local ARM7 MBK6..MBK8 Settings
  1ACh 4   Global MBK9 Slot Master Setting (FF000000h)
  1B0h 50h Zerofilled
</TD></TR></TABLE>
The above RSA Block contains 74h bytes of information (plus 0Bh bytes padding):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Pre  0Bh  Leading RSA Padding (01,FF,FF,FF,FF,FF,FF,FF,FF,FF,00)
  00h  10h  AES_Engine Key Y for ARM9/ARM7 Bootcode (EC,07,00,00,...)
  10h  14h  SHA1 (AF,B5,A2,74,59,4D,DE,C8,59,3F,56,2D,06,8E,E2,B1,D8,76,DC,7C)
            Going by 3DS TWL_FIRM this seems to calculated over the
            first 0x28-bytes of NAND, then the first 0x100-bytes of the header,
            then the last 0x80-bytes of the header(following the signature).
            This works with the bootloader contained in TWL_FIRM, however it's
            unknown how the first part is handled on DSi.
  24h  14h  SHA1 on decrypted ARM9 Bootcode, with the actual binary size.
  38h  14h  SHA1 on decrypted ARM7 Bootcode, with the actual binary size.
  4Ch  14h  Zerofilled
  60h  14h  SHA1? (63,D2,FC,6E,A9,E7,99,00,00,79,5C,FE,F1,E8,26,C4,C0,C9,CF,A5)
</TD></TR></TABLE>
<BR>
<B>eMMC Encryption for Boot Sectors (AES-CTR, with fixed key; from RSA block)</B><BR>
The ARM9/ARM7 bootcode is encrypted via AES-CTR:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  RSA_KEY  = F1,F5,1A,FF,...         ;-from 3DS TWL_FIRM (for RSA Block)
  IV[0..3] = +size                   ;\
  IV[4..7] = -size                   ; size rounded up to 200h boundary, ie.
  IV[8..B] = -size-1                 ; from Info Block entries [02Ch,03Ch]
  IV[C..F] = 00000000h               ;/
  KEY_X[0..F] = "Nintendo DS",...    ;-same as Key X for "Tad Files"
  KEY_Y[0..F] = EC,07,00,00,...      ;-from RSA Block (see above)
</TD></TR></TABLE>
The RSA_KEY key is stored in some non-dumpable area of the DSi BIOS, making it
impossible to obtain that key without chip decapping. However, Nintendo has
included the same RSA_KEY in the "TWL_FIRM" firmware update for 3DS.<BR>
<BR>
<B>eMMC Encryption for MBR/Partitions (AES-CTR, with console-specific key)</B><BR>
The MBR and both partitions are encrypted via AES-CTR:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  IV[0..F]:    SHA1(CID)+Address/10h                    ;-eMMC Chip ID
  KEY_X[0..3]: [4004D00h]                               ;\
  KEY_X[4..7]: [4004D00h] XOR 24EE6906h                 ; CPU/Console ID
  KEY_X[8..B]: [4004D04h] XOR E65B601Dh                 ;
  KEY_X[C..F]: [4004D04h]                               ;/
  KEY_Y[0..F]: 0AB9DC76h,BD4DC4D3h,202DDD1Dh,E1A00005h  ;-Constant
</TD></TR></TABLE>
The CID value (eMMC Chip ID) should be in same format as stored in RAM at<BR>
2FFD7BCh: little-endian 120bit (without crc7), padded to 128bit (with MSB=00h),
ie. it should look like this (dd/ss being date/serial numbers):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  CID = [2FFD7BCh] = dd,ss,ss,ss,ss,03,4D,30,30,46,50,41,00,00,15,00
  SHA1(CID) = SWI_27h(SHA1value,2FFD7BCh,10h)
</TD></TR></TABLE>
The resulting SHA1value is 14h-bytes, the first 10h-bytes are used as IV value,
whereas the DSi doesn't adjust the endianness (it does just use the SWI's
"big-endian" SHA1value as "little-endian" AES/IV value).<BR>
The CTR gets incremented after each 10h bytes (ie. to access a random address:
"IV=SHA1value+(address/10h)".<BR>
For more info on obtaining the CID and Port [4004D00h] values, see:<BR>
<A HREF="#dsiconsoleids">DSi Console IDs</A><BR>
See also:<BR>
<A HREF="#dsisdmmcimages">DSi SD/MMC Images</A><BR>
<BR>
<B>Related Decryption Tools</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  "NUS Downloader" allows to download and decrypt system updates.
  "DSi SRL Extract" allows to decrypt DSiware files (when copied to SD card).
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcbootloader"></A>&nbsp;
  DSi SD/MMC Bootloader
</FONT></TD></TR></TABLE><BR>
<B>Stages</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Stage 1: Load Stage 2 from NAND Boot Sectors (via code in BIOS ROM)
  Stage 2: Load Stage 3 from NAND Filesystem
  Stage 3: Contains GUI and allows to boot Cartridges or NAND files
</TD></TR></TABLE>
<BR>
<B>Stage 1</B><BR>
The first stage of the DSi's bootloader lives in ROM, presumably on the CPU
die. It loads further encrypted (and probably signed) stages from NAND flash,
starting with a (partially unencrypted) offset table in the sector at 0x200.<BR>
Not much is known about this bootloader yet, but it presumably knows how to:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Initialize the encryption hardware
  Read the contents of NVRAM
  Initialize both LCDs
  Read blocks (but not files) from the NAND flash
  Perform some variety of integrity check on all data it reads(signature,CRC,?)
  Display basic hexadecimal error codes
  Possibly factory-programming the NAND flash?
  Might also do basic power-on self test of peripherals
</TD></TR></TABLE>
When the Stage 1 bootloader (in ROM) fails, it displays a 32-bit hexadecimal
number on the top screen, known Stage 1 error codes are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Error Code Description
  0000FE00   Error communicating NAND chip (It's missing, CLK shorted, etc.)
  0000FEFC   Integrity error in first block of Stage 2 (address at 220h)
  0000FEFD   Integrity error in second block of Stage 2 (address at 230h)
  0000FEFE   Boot sector integrity error (Sector 200h not valid), or error
               in NVRAM contents.
</TD></TR></TABLE>
<BR>
<B>Stage 2</B><BR>
Unlike the stage1 bootloader, which must be small enough to fit in ROM
(probably several kilobytes), the stage2 bootloader has about a megabyte of
NAND flash reserved for it. The stage2 bootloader understands partitions and
filesystems, and it is capable of loading the DSi menu. It also must understand
the encryption used on filesystem blocks in the NAND, and it must understand
how to load and validate title metadata.<BR>
The Stage 2 loader was not modified by the System Menu 1.4 update. This is
still earlier in the boot process than the "Health and Safety" warning.<BR>
The first stage bootloader reads sector 0x200 in order to find a table of
offsets to the Stage 2 bootloader:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00000220  00 08 00 00 10 64 02 00  00 80 7b 03 00 66 02 00 |.....d....{..f..|
  00000230  00 6e 02 00 88 75 02 00  00 80 7b 03 00 76 02 00 |.n...u....{..v..|
  00000240  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00 |................|
</TD></TR></TABLE>
This appears to be describing two chunks of the stage2 loader, one 0x26410
bytes in length at address 0x800, and one 0x27588 bytes at address 0x26e00.<BR>
Note that this sector (and two similar ones at 0x400 and 0x600) appear to be
the only unencrypted blocks on the NAND flash.<BR>
It is unclear why there are two pieces which are nearly but not quite the same
size. Passive traces of the boot sequence confirm that the 0x26e00 chunk is
slightly larger, and it's loaded first. The 0x800 chunk is read immediately
after the 0x26e00 chunk.<BR>
Whereas the filesystem data in NAND is encrypted using a unique key for every
DSi, the stage2 bootloader is identical on every DSi tested so far. This
probably means that it is encrypted using a fixed key included in stage1.<BR>
<BR>
<B>After Stage 2 is loaded:</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1. The NAND flash is partially re-initialized
  2. Sector 0 is read from the NAND. Appears to be (encrypted) DOS-style MBR.
  3. The MBR signature and the type of the first partition are verified.
  4. Filesystem metadata is read from sectors starting around 0x100000. The
       metadata appears to be in FAT format with long filenames.
  5. Multiple files are loaded from the filesystem. The exact read addresses
       will vary depending on your DSi's firmware version and the state of
       its filesystem when you performed the last firmware update. On a brand
       new DSi, it appears that the DSi Menu itself is loaded from 0xb20000
       after two small metadata files are read from 0xb1c000 and 0x7a0000.
</TD></TR></TABLE>
<BR>
All Stage 2 errors show before the health and safety screen. It appears that
Stage 2 errors from a cold power-on always cause the DSi to hang at a black
screen, whereas Stage 2 errors after reset (pressing but not holding the power
button) will give an error message screen. Known Stage 2 errors:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Text                    Description
  "Error: 1-2435-8325"    Invalid signature or partition type in MBR,
                            invalid starting LBA.
  "Error: 3-2435-8325"    DSi Menu integrity checks failed
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmccompletelistofsdmmcfilesfolders"></A>&nbsp;
  DSi SD/MMC Complete List of SD/MMC Files/Folders
</FONT></TD></TR></TABLE><BR>
<B>DSi eMMC Partition 1 (FAT16)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  SYS          &lt;DIR&gt;    sys
  LOG          &lt;DIR&gt;     log
  PRODUCT  LOG 0000023D   product.log
  SYSMENU  LOG 00004000   sysmenu.log
  SHOP     LOG 00000020   shop.log
  HWINFO_S DAT 00004000  HWINFO_S.dat
  HWINFO_N DAT 00004000  HWINFO_N.dat
  CERT     SYS 00000F40  cert.sys
  HWID     SGN 00000100  HWID.sgn
  TWLFON~1 DAT 000D2C40  TWLFontTable.dat
  DEV      KP  000001BE  dev.kp
  TITLE        &lt;DIR&gt;    title
  00030017     &lt;DIR&gt;     00030017 (aka System Menu)
  484E4150     &lt;DIR&gt;      484e4150 (aka Launcher)
  DATA         &lt;DIR&gt;       data
  PRIVATE  SAV 00004000     private.sav
  CONTENT      &lt;DIR&gt;       content
  TITLE    TMD 00000208     title.tmd
  00000002 APP 0019E400     00000002.app
  00030015     &lt;DIR&gt;     00030015 (aka System Base Tools)
  484E4250     &lt;DIR&gt;      484e4250 (aka System Settings)
  DATA         &lt;DIR&gt;       data
  CONTENT      &lt;DIR&gt;       content
  TITLE    TMD 00000208     title.tmd
  00000002 APP 00285C00     00000002.app
  484E4650     &lt;DIR&gt;      484e4650 (aka Nintendo DSi Shop)
  DATA         &lt;DIR&gt;       data
  PRIVATE  SAV 00004000     private.sav
  EC       CFG 00000134     ec.cfg
  CONTENT      &lt;DIR&gt;       content
  00000004 APP 00526400     00000004.app
  TITLE    TMD 00000208     title.tmd
  0003000F     &lt;DIR&gt;     0003000f (aka System Data)
  484E4341     &lt;DIR&gt;      484e4341 (aka Wifi Firmware)
  DATA         &lt;DIR&gt;       data
  CONTENT      &lt;DIR&gt;       content
  TITLE    TMD 00000208     title.tmd
  00000002 APP 00017E60     00000002.app
  484E4841     &lt;DIR&gt;      484e4841 (aka Nintendo DS Cart Whitelist)
  DATA         &lt;DIR&gt;       data
  CONTENT      &lt;DIR&gt;       content
  TITLE    TMD 00000208     title.tmd
  00000001 APP 0004B1D0     00000001.app
  484E4C50     &lt;DIR&gt;      484e4c50 (aka Version Data)
  DATA         &lt;DIR&gt;       data
  CONTENT      &lt;DIR&gt;       content
  00000004 APP 00001B50     00000004.app
  TITLE    TMD 00000208     title.tmd
  00030005     &lt;DIR&gt;     00030005 (aka System Fun Tools)
  484E4441     &lt;DIR&gt;      484e4441 (aka DS Download Play)
  DATA         &lt;DIR&gt;       data
  CONTENT      &lt;DIR&gt;       content
  TITLE    TMD 00000208     title.tmd
  00000001 APP 00069BC0     00000001.app
  484E4541     &lt;DIR&gt;      484e4541 (aka Pictochat)
  DATA         &lt;DIR&gt;       data
  CONTENT      &lt;DIR&gt;       content
  00000000 APP 00074FC0     00000000.app
  TITLE    TMD 00000208     title.tmd
  484E4950     &lt;DIR&gt;      484e4950 (aka Nintendo DSi Camera)
  DATA         &lt;DIR&gt;       data
  PRIVATE  SAV 00080000     private.sav
  CONTENT      &lt;DIR&gt;       content
  TITLE    TMD 00000208     title.tmd
  00000002 APP 00443C00     00000002.app
  484E4A50     &lt;DIR&gt;      484e4a50 (aka Nintendo Zone)
  DATA         &lt;DIR&gt;       data
  PRIVATE  SAV 00100000     private.sav
  CONTENT      &lt;DIR&gt;       content
  00000003 APP 0014D000     00000003.app
  TITLE    TMD 00000208     title.tmd
  484E4B50     &lt;DIR&gt;      484e4b50 (aka Nintendo DSi Sound)
  DATA         &lt;DIR&gt;       data
  PRIVATE  SAV 00080000     private.sav
  CONTENT      &lt;DIR&gt;       content
  00000002 APP 00451000     00000002.app
  TITLE    TMD 00000208     title.tmd
  00030004     &lt;DIR&gt;     00030004 (aka DSiware)
  484E4750     &lt;DIR&gt;      484e4750 (aka Nintendo DSi Browser)
  DATA         &lt;DIR&gt;       data
  PRIVATE  SAV 00200000     private.sav
  CONTENT      &lt;DIR&gt;       content
  00000001 APP 008F1C00     00000001.app
  TITLE    TMD 00000208     title.tmd
  4B475556     &lt;DIR&gt;      4b475556 (aka Flipnote Studio)
  DATA         &lt;DIR&gt;       data
  PUBLIC   SAV 007F0000     public.sav
  CONTENT      &lt;DIR&gt;       content
  00000000 APP 00348400     00000000.app
  TITLE    TMD 00000208     title.tmd
  TICKET       &lt;DIR&gt;    ticket
  00030017     &lt;DIR&gt;     00030017 (aka System Menu)
  484E4150 TIK 000002C4   484e4150.tik (aka Launcher)
  00030015     &lt;DIR&gt;     00030015 (aka System Base Tools)
  484E4250 TIK 000002C4   484e4250.tik (aka System Settings)
  484E4650 TIK 000002C4   484e4650.tik (aka Nintendo DSi Shop)
  0003000F     &lt;DIR&gt;     0003000f (aka System Data)
  484E4341 TIK 000002C4   484e4341.tik (aka Wifi Firmware)
  484E4841 TIK 000002C4   484e4841.tik (aka Nintendo DS Cart Whitelist)
  484E4C50 TIK 000002C4   484e4c50.tik (aka Version Data)
  00030005     &lt;DIR&gt;     00030005 (aka System Fun Tools)
  484E4441 TIK 000002C4   484e4441.tik (aka DS Download Play)
  484E4541 TIK 000002C4   484e4541.tik (aka Pictochat)
  484E4950 TIK 000002C4   484e4950.tik (aka Nintendo DSi Camera)
  484E4A50 TIK 000002C4   484e4a50.tik (aka Nintendo Zone)
  484E4B50 TIK 000002C4   484e4b50.tik (aka Nintendo DSi Sound)
  00030004     &lt;DIR&gt;     00030004 (aka DSiware)
  484E4750 TIK 000002C4   484e4750.tik (aka Nintendo DSi Browser)
  4B414D56 TIK 000002C4   4b414d56.tik (aka Paper Plane)
  4B443956 TIK 000002C4   4b443956.tik (aka Dr. Mario)
  4B475556 TIK 000002C4   4b475556.tik (aka Flipnote Studio)
  4B4D3958 TIK 000002C4   4b4d3958.tik (aka Magic Made Fun: Deep Psyche)
  SHARED1      &lt;DIR&gt;    shared1
  TWLCFG0  DAT 00004000  TWLCFG0.dat
  TWLCFG1  DAT 00004000  TWLCFG1.dat
  SHARED2      &lt;DIR&gt;    shared2
  LAUNCHER     &lt;DIR&gt;     launcher
  WRAP     BIN 00004000   wrap.bin
  0000         00200000  0000
  IMPORT       &lt;DIR&gt;    import
  TMP          &lt;DIR&gt;    tmp
  ES           &lt;DIR&gt;     es
  WRITE        &lt;DIR&gt;      write
  PROGRESS     &lt;DIR&gt;    progress
</TD></TR></TABLE>
Unclear where the Paper Plane, Dr. Mario, and Deep Psyche tickets came from (I
bough my DSi second hand, maybe the previous owner downloaded/deleted the
corresponding games, or maybe those tickets were preinstalled by Nintendo).<BR>
<BR>
<B>DSi eMMC Partition 2 (FAT12)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  PHOTO        &lt;DIR&gt;    photo
  PRIVATE      &lt;DIR&gt;     private
  DS           &lt;DIR&gt;      ds
  APP          &lt;DIR&gt;       app
  484E494A     &lt;DIR&gt;        484E494A (aka Nintendo DSi Camera Stuff)
  PIT      BIN 00001F60      pit.bin
  DCIM         &lt;DIR&gt;     DCIM
  100NIN02     &lt;DIR&gt;      100NIN02
  HNI_0008 JPG 0000AB51    HNI_0008.JPG
  HNI_0009 JPG 00009A96    HNI_0009.JPG
  HNI_0010 JPG 0000932B    HNI_0010.JPG
  HNI_0011 JPG 00009CB8    HNI_0011.JPG
  HNI_0012 JPG 00009CA9    HNI_0012.JPG
  HNI_0013 JPG 00009A3B    HNI_0013.JPG
</TD></TR></TABLE>
<BR>
<B>DSi eMMC Partition 3 (unformatted)</B><BR>
There's a small 3rd partition in MBR, but it's left unformatted (the VBR and
FAT and everything is left zero-filled). Unknown if there are any cases where
this partition is used, and if so: if it's meant to be encrypted or
unencrypted. In case it's meant to be encrypted: Observe that the unformatted
partition contains UNENCRYPTED zeroes (so trying to "decrypt" those zeroes
would produce random garbage data).<BR>
<BR>
<B>SD Card</B><BR>
DSiware (including Browser and Flipnote) can be exported to SD Card (via System
Menu, Data Managment).<BR>
Camera Photos and Frames can be exported (via Nintendo DSi Camera, Options,
Copy) (Frames are some sort of gaudi-masks that can be used (and created) via
on of the Camera special effect features; the mask uses YELLOW as transparent
color). As on eMMC storage, all photos from internal camera are mirrored
horizontally.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  PRIVATE      &lt;DIR&gt;    private
  DS           &lt;DIR&gt;     ds
  TITLE        &lt;DIR&gt;      title                                     ;\
  484E4750 BIN 9.180K      484E4750.bin (aka Nintendo DSi Browser)  ; dsiware
  4B475556 BIN 11.510K     4B475556.bin (aka Flipnote Studio)       ; games
  HNB_     LST 2K          HNB_.lst     (content: "VUGKPGNH")       ;/
  APP          &lt;DIR&gt;      app
  484E494A     &lt;DIR&gt;       484E494A (aka Nintendo DSi Camera Stuff) ;\
  PIT      BIN 47K          pit.bin                                 ; camera
  DCIM         &lt;DIR&gt;        DCIM                                    ; frames
  100NIN02     &lt;DIR&gt;         100NIN02                               ;
  HNI_0001 JPG 45K            HNI_0001.JPG  ;-frame/mask            ;/
  4B475556     &lt;DIR&gt;       4B475556 (aka Flipnote Studio Stuff)     ;\
  RECENT10 PLS 4K           recent10.pls                            ;
  MARK0    PLS 8K           mark0.pls                               ; flipnote
  MARK1    PLS 8K           mark1.pls                               ; stuff
  MARK2    PLS 8K           mark2.pls                               ;
  MARK3    PLS 8K           mark3.pls                               ;
  001          &lt;DIR&gt;        001                                     ;
  DIRMEMO2 LST 157K         dirmemo2.lst                            ;
  F08243~1 PPM 467K         F08243_0E5E2296197E5_000.ppm            ;/
  DCIM         &lt;DIR&gt;    DCIM
  101NIN02     &lt;DIR&gt;     101NIN02           ;&lt;-- 101 here (not 100)
  HNI_0001 JPG 43K        HNI_0001.JPG      ;\dsi camera photos
  HNI_0002 JPG 17K        HNI_0002.JPG      ; (names are numbered differently
  HNI_0003 JPG 39K        HNI_0003.JPG      ;/as on eMMC where they came from)
</TD></TR></TABLE>
Reportedly, the "Nintendo DSi Sound" application can also access audio files in
AAC format, saved in any folders on SD Card.<BR>
Dunno, the "\DCIM\101NIN02" may be called so because a folder with "100" did
already exist (my SD card contained a "\DCIM\100CANON" folder)?<BR>
Aside from DSi-related files, the SD Card can also contain whatever files from
other computers.<BR>
<BR>
<B>Blocks</B><BR>
The System Menu, Data Manament feature is referring to filesizes in "Blocks":<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Flipnote Studio         90 Blocks  =  11.510K      1 block = 128K ?
  Nintendo DSi Browser    88 Blocks  =  9.180K       odd, with/without .sav?
  SD Card Blocks Free  4,168 Blocks  =  ca. 500MB    1 block = 128K ?
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcsummaryofsdmmcfilesfolders"></A>&nbsp;
  DSi SD/MMC Summary of SD/MMC Files/Folders
</FONT></TD></TR></TABLE><BR>
<B>File/folder names</B><BR>
The DSi is using weird numeric strings as file/folder names:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000000vv Title Version (hex? decimal?) as carthdr[1Eh]
  4ggggggg Title ID Gamecode (hex) as carthdr[230h..233h]
  000300tt Title ID Filetype (hex) as carthdr[234h..237h]
  HNI_nnnn Camera photo/frame files (nnnn = 0001..0100 decimal)
  nnnNIN02 Camera photo/frame folders (nnn = 100..999 decimal)
</TD></TR></TABLE>
The "000300tt" can be:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00030000 ROM Cartridges (as so for ROMs, doesn't appear in SD/MMC)
  00030004 DSiware (browser and games) (if any installed)
  00030005 System Fun Tools (camera, sound, pictochat, etc.)
  0003000f System Data (non-executable, without carthdr)
  00030015 System Base Tools (system settings and dsi shop)
  00030017 System Menu (launcher)
</TD></TR></TABLE>
The "4ggggggg" can be (last two digits are region(s), or "41" for all regions):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  484e41gg System Menu (Launcher)
  484e42gg System Settings
  484e4341 Wifi Firmware (non-executable datafile) (all regions)
  484e4441 DS Download Play (all regions)
  484e4541 Pictochat (all regions) (no update available)
  484e46gg Nintendo DSi Shop
  484e47gg Nintendo DSi Browser
  484e4841 Nintendo DS Cart Whitelist (non-executable datafile) (all regions)
  484e49gg Nintendo DSi Camera
  484e4agg Nintendo Zone
  484e4bgg Nintendo DSi Sound
  484e4cgg Version Data (non-executable datafile)
  484e4fgg Nintendo 3DS Transfer Tool (non-freeware)
  484E494A Nintendo DSi Camera Data (uppercase) ("japan") (aka all regions)
  4b44474a Dokodemo Wii no Ma (japan only)
  4b4755gg Flipnote Studio
  4bgggggg DSiware games... (whatever games you have purchased, if any)
</TD></TR></TABLE>
These files can be stored in Internal eMMC, or on external SD card, and can be
downloaded from Nintendo's server (when buying games, or updating system
files).<BR>
<BR>
<B>DSi Internal eMMC</B><BR>
Internal eMMC can contain System files and any purchased DSiware games:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  FAT16:\ticket\000300tt\4ggggggg.tik (encrypted)      ;ticket (708 bytes)
  FAT16:\title\000300tt\4ggggggg\content\title.tmd     ;tmd (520 bytes)
  FAT16:\title\000300tt\4ggggggg\content\000000vv.app  ;executable (decrypted)
  FAT16:\title\000300tt\4ggggggg\data\public.sav       ;size as carthdr[238h]
  FAT16:\title\000300tt\4ggggggg\data\private.sav      ;size as carthdr[23Ch]
  FAT16:\title\000300tt\4ggggggg\data\ec.cfg           ;dsi shop only
</TD></TR></TABLE>
Reportedly, there can be also this (maybe custom icon/title?):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  FAT16:\title\000300tt\4ggggggg\data\banner.sav       ;if carthdr[1BFh].bit2=1
</TD></TR></TABLE>
Note that some of the above files are containing their own virtual filesystem
inside of the eMMC's FAT16 filesystem (NitroROM filesystems in "000000vv.app"
files, and FAT12 filesystems in "public.sav" and "private.sav" files).<BR>
The System tools (menu, settings, and shop) are also storing further data on
FAT16 (outside of the ticket and title folders):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  FAT16:\shared1\TWLCFG0.dat            ;16K
  FAT16:\shared1\TWLCFG1.dat            ;16K
  FAT16:\shared2\launcher\wrap.bin      ;16K
  FAT16:\shared2\0000                   ;2048K
  FAT16:\sys\log\product.log            ;573 bytes
  FAT16:\sys\log\sysmenu.log            ;16K
  FAT16:\sys\log\shop.log               ;32 bytes
  FAT16:\sys\HWINFO_S.dat               ;16K
  FAT16:\sys\HWINFO_N.dat               ;16K
  FAT16:\sys\cert.sys                   ;3904 bytes
  FAT16:\sys\HWID.sgn                   ;256 bytes (unknown purpose/content)
  FAT16:\sys\TWLFontTable.dat           ;843.1K (D2C40h bytes) (compressed)
  FAT16:\sys\dev.kp                     ;446 bytes (encrypted)
  FAT16:\import\                        ;empty folder
  FAT16:\progress\                      ;empty folder
  FAT16:\tmp\es\write\                  ;empty folder
</TD></TR></TABLE>
The Camera is storing further data on the eMMC FAT12 partition:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  FAT12:\photo\DCIM\100NIN02\HNI_nnnn.JPG                        ;camera photos
  FAT12:\photo\private\ds\app\484E494A\pit.bin                   ;camera info
</TD></TR></TABLE>
And, probably (assuming similar path as on SD) (not verified for eMMC):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  FAT12:\photo\private\ds\app\484E494A\DCIM\100NIN02\HNI_nnnn.JPG;camera frames
</TD></TR></TABLE>
And, there's a small 3rd eMMC partition in MBR, but it's left unformatted (the
VBR and FAT and everything is left zero-filled).<BR>
<BR>
<B>DSi External SD Card</B><BR>
DSiware games (and browser and flipnote) can be copied to SD card (via System
Menu, Data Managment) (however, the DSi doesn't seem to allow to execute files
on SD card, so they can be used only if they are copied back to the DSi):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  SD:\private\ds\title\4GGGGGGG.bin    ;executable/data in one file (encrypted)
  SD:\private\ds\title\HNB_.lst        ;list of gamecodes
</TD></TR></TABLE>
Camera data can be copied to SD card (via Nintendo DSi Camera, Options, Copy):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  SD:\DCIM\101NIN02\HNI_nnnn.JPG    ;&lt;-- 101 here (not 100) ;camera photos
  SD:\private\ds\app\484E494A\pit.bin                       ;camera info
  SD:\private\ds\app\484E494A\DCIM\100NIN02\HNI_nnnn.JPG    ;camera frames
</TD></TR></TABLE>
Flipnote "movies" can be also saved on SD card:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  SD:\private\ds\app\4B475556\recent10.pls
  SD:\private\ds\app\4B475556\mark0.pls
  SD:\private\ds\app\4B475556\mark1.pls
  SD:\private\ds\app\4B475556\mark2.pls
  SD:\private\ds\app\4B475556\mark3.pls
  SD:\private\ds\app\4B475556\001\dirmemo2.lst
  SD:\private\ds\app\4B475556\001\F08243_0E5E2296197E5_000.ppm
</TD></TR></TABLE>
The Nintendo DSi Sound utility can read AAC files from SD card (though it
doesn't seem to allow to save your own recordings to SD card?). There appears
to be no special folder location, ie. the AAC files can be anywhere:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  SD:\...\*.AAC
</TD></TR></TABLE>
<BR>
<B>DSi Shop and System Update Download URLs</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  http://nus.cdn.t.shop.nintendowifi.net/ccs/download/000300tt4ggggggg/tmd
  http://nus.cdn.t.shop.nintendowifi.net/ccs/download/000300tt4ggggggg/cetk
  http://nus.cdn.t.shop.nintendowifi.net/ccs/download/000300tt4ggggggg/000000vv
</TD></TR></TABLE>
The "cetk" file contains the encrypted ticket? The "cetk" file is available
only for freeware downloads (eg. system updates). Commercial DSi Shop titles
can be downloaded the same way, except that the ticket must be somehow
purchased/downloaded separetely.<BR>
Nintendo does keep hosting older "00000vv" versions (except, the original
version, "00000000" isn't available in all cases; namely if the title was
pre-installed on all DSi's then it would be pointless to provide it as update).<BR>
<BR>
<B>NUS Downloader Notation</B><BR>
The homebrew NUS Downloader utility for PCs comes up with its own renaming
scheme:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  d:\...\TITLES\000300tt4ggggggg\ddd\000000vv      ;executable (encrypted)
  d:\...\TITLES\000300tt4ggggggg\ddd\000000vv.APP  ;executable (decrypted)
  d:\...\TITLES\000300tt4ggggggg\ddd\CETK          ;cetk (2468 bytes)
  d:\...\TITLES\000300tt4ggggggg\ddd\TMD           ;tmd (520 bytes)
</TD></TR></TABLE>
Whereas, "ddd" is same as "000000vv" multiplied by 256 decimal (which is
nonsense and redundant). The decrypted ".APP" file is generated only if the
"common key" is found in 16-byte file "dsikey.bin".<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcimages"></A>&nbsp;
  DSi SD/MMC Images
</FONT></TD></TR></TABLE><BR>
<B>Filesystem Viewer</B><BR>
no$gba debug version is allowing to view the filesystem tree from encrypted
eMMC images (via menubar: Window, Filesystem), the filesystem viewer is also
able to export single files from the eMMC image (by double-clicking separate
files).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  XXX    currently, the double-clicked file will be saved as "TEMP.TMP",
  XXX    in no$gba folder (there is no "Save as" dialog yet)
</TD></TR></TABLE>
<BR>
<B>Emulation</B><BR>
Future no$gba versions should be also able to emulate access to eMMC images
(which will require understanding &amp; emulating the SD/MCC I/O ports; not to
mention working emulation of games that do access those I/O ports).<BR>
Another idea for future would be using files &amp; folders on the PC filesystem
instead of a single image file (that might be easier to deal with in some
cases, but for the reverse-engineering stage it's better to stick with original
authentic images).<BR>
<BR>
<B>Encrypted eMMC Images</B><BR>
no$gba can emulate up to 12 consoles simultaneously, and expects the eMMC
images having following filename(s), in no$gba folder:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  DSi-#.mmc             ;eMMC for machine 1..12 (# = 1..C hex)
</TD></TR></TABLE>
the eMMC images are encrypted with per-console keys, so decryption won't work
without knowing the console ID values. no$gba expects that info to be stored in
a 40h-byte Footer at the end of the file:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0000000h ..  Encrypted eMMC image (usually 240Mbyte for DSi)
  F000000h 16  Footer ID      ("DSi eMMC CID/CPU")
  F000010h 16  eMMC CID       (dd ss ss ss ss 03 4D 30 30 46 50 41 00 00 15 00)
  F000020h 8   CPU/Console ID (nn n1 nn nn nn 0n A2 08)
  F000028h 24  Reserved       (zerofilled)
</TD></TR></TABLE>
<BR>
<B>Dumping eMMC Images</B><BR>
DSiware exploits like sudokuhax are allowing to access SD/MMC hardware (so one
could simply copy all eMMC sectors to a file on SD Card).<BR>
Unfortunately, most/other exploits don't have SD/MMC access, so dumping would
work only when the eMMC chip to a SD/MMC card reader. For details, see:<BR>
<A HREF="#auxdsisdmmcpinouts">AUX DSi SD/MMC Pin-Outs</A><BR>
For obtaining the Console IDs, see:<BR>
<A HREF="#dsiconsoleids">DSi Console IDs</A><BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmctadfilesonsdcards"></A>&nbsp;
  DSi SD/MMC Tad Files on SD Cards
</FONT></TD></TR></TABLE><BR>
The DSi can export applications from NAND to SD (via System Settings --&gt;
Data Managment). The ".bin" files created on SD are using the "Tad file
structure", and alongsides, there's a "HNB_.lst" file containing a list of game
codes.<BR>
<BR>
<B>SD:\private\ds\title\HNB_.lst (list of gamecodes)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 1200  List of 300 gamecodes, spelled backwards (or zero = unused entry)
  4B0h 1     Language (0=Jap, 1=Eng, 2=Fre, 3=Ger, 4=Ita, 5=Spa, 6=Chi, 7=Kor?)
  4B1h 3     Zero
  4B4h 2     CRC16 on entries [000h..4B3h] (with initial value FFFFh)
  4B6h 2     Zero
</TD></TR></TABLE>
For example, "VUGK" in HNB_.lst would indicate gamecode KGUV aka "Flipnote
Studio" for EUR/AUS regions. And the corresponding SD Card file would be
"SD:\private\ds\title\4B475556.bin" (with the 4-letter gamecode encoded as
8-digit uppercase HEX number). The full 16-digit on eMMC storage would be
"00030004\4b475556" (in lowercase, and with the "00030004" implied for the
DSiWare folder; files from system folders cannot be exported to SD Card).<BR>
The Language byte reflects the System Settings's language selection at time
when the HNB_.lst was created or modified (unknown why that info is stored in
the file).<BR>
<BR>
<B>SD:\private\ds\title\4GGGGGGG.bin (encrypted executable/data in one file)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Offset   Size       Key  Description
  000000h  4000h+20h  FIX  Icon/Title
  004020h  B4h+20h    FIX  Header
  0040F4h  440h+20h   FIX  Footer (certificates/hashes)
  004554h  208h+20h   VAR  title.tmd (usually 208h bytes; but could be bigger)
  00477Ch  size+N*20h VAR  000000vv.app
  ...      0          ?    seven N/A parts (unknown if/when they are used)
  ...      size+N*20h FIX  public.sav  (if any)
  ...      0          ?    banner.sav? (if any?)
</TD></TR></TABLE>
ES Block Encryption is used to encrypt the header block, footer block, and the
11 content parts. Each are their own seperate ES blocks.<BR>
<A HREF="#dsiesblockencryption">DSi ES Block Encryption</A><BR>
Some of the above blocks use fixed keys (FIX):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  KEY_X[00h..0Fh] = Constant ("Nintendo DS",...)
  KEY_Y[00h..0Fh] = Constant (66 82 32 04 ...)  ;from ARM7BIOS
  since above X/Y are constant, that gives a fixed normal key:
  KEY[00h..0Fh]   = Constant (3D A3 EA 33 ...)  ;as used in "dsi srl extract"
</TD></TR></TABLE>
Other blocks use variable per-console keys (VAR):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  KEY_X[00h..03h] = 4E00004Ah
  KEY_X[04h..07h] = 4A00004Eh
  KEY_X[08h..0Bh] = Port[4004D00h+4] xor C80C4B72h
  KEY_X[0Ch..0Fh] = Port[4004D00h+0]
  KEY_Y[00h..0Fh] = Constant (CC FC A7 03 ...)  ;from ARM7BIOS
</TD></TR></TABLE>
Without knowing the console-specifc Port[4004D00h] value, the data could be
decrypted only by the DSi console that has originally exported the file to SD
card.<BR>
However, Nintendo has somehow (maybe accidently) managed to store the
Port[4004D00h] value as 16-digit ASCII string in the "TW cert"; which can be
decrypted right from the SD card file (as done by the homebrew "dsi srl
extract" utility).<BR>
<BR>
<B>Decrypted Icon/Title (at 0000h, size 4000h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0000h 23C0h  Icon/Title (usually 23C0h bytes) ;see carthdr[068h,208h]
  23C0h 1C40h  Zerofilled (padding to get 4000h byte size)
</TD></TR></TABLE>
<BR>
<B>Decrypted Header block (at 4020h, size B4h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h  4      Fixed ID "4ANT" (aka TNA4, spelled backwards)
  004h  2      Maker Code, spelled backwards ("10"=Nintendo) ;carthdr[010h]
  006h  1      Zero
  007h  1      Title version (vv)                            ;carthdr[01Eh]
  008h  6      DSi MAC Address, spelled backwards            ;wifi_flash[036h]
  00Eh  2      Zero
  010h  16     Some console ID from HWINFO_N.dat             ;datfile[8Ch..9Bh]
  020h  8      Title ID (gg gg gg gg 04 00 03 00)            ;carthdr[230h]
  028h  4      Size of title.tmd    (usually 208h+20h)
  02Ch  4      Size of 000000vv.app (size+N*20h)             ;carthdr[210h]
  030h  4*7    Size of seven N/A parts (0)
  04Ch  4      Size of public.sav   (size+8000h?)            ;carthdr[238h]
  050h  4      Size of banner.sav?  (usually 0)       ;carthdr[1BFh].bit2=1
  054h  8 * 4  List of eight Content IDs in same order as title.tmd
  074h  0x3e   Reserved section per tmds, uh? (mostly zero, plus garbage?)
  0B2h  2      Unknown (zero)
</TD></TR></TABLE>
<BR>
<B>Decrypted Footer block (at 40F4h, size 460h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h  20     SHA1 of Icon/Title
  014h  20     SHA1 of TNA4
  028h  20     SHA1 of title.tmd
  03Ch  20     SHA1 of 000000vv.app
  040h  20*7   SHA1 of seven N/A parts (unused, can be whatever garbage)
  0DCh  20     SHA1 of public.sav
  0F0h  20     SHA1 of banner.sav?
  104h  3Ch    ECC signature of [000h..103h] with AP cert
  140h  180h   AP cert, signed by TW cert
  2C0h  180h   TW cert, specific to a console (see dev.kp)
</TD></TR></TABLE>
<BR>
Much like the Wii, the DSi carries with it a private ECC key that it can use to
sign things, and a certificate signed by Nintendo that attests to the fact that
the public ECC key belongs to a genuine DSi.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcfirmwaredevkpandcertsyscertificatefiles"></A>&nbsp;
  DSi SD/MMC Firmware dev.kp and cert.sys Certificate Files
</FONT></TD></TR></TABLE><BR>
<B>FAT16:\sys\cert.sys                   ;3904 bytes</B><BR>
Data in this file is same on all DSi consoles (even for different regions like
US and EUR).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4    (00 01 00 01)                               ;\
  004h 100h Hex numbers                                 ;
  104h 3Ch  Zerofilled                                  ;
  140h 40h  "Root-CA00000001" (padded with zeroes)      ;
  180h 4    (00 00 00 01)                               ;
  184h 3Ch  "XS00000006"      (padded with zeroes)      ;
  1C0h 4    (00 00 00 00)                               ;
  1C4h 104h Hex numbers                                 ;
  2C8h 4    (00 01 00 01)                               ;
  2CCh 34h  Zerofilled                                  ;/
  300h 4    (00 01 00 00)                               ;\
  304h 200h Hex numbers     ;&lt;-- huge                   ;
  504h 3Ch  Zerofilled                                  ;
  540h 40h  "Root"            (padded with zeroes)      ;
  580h 4    (00 00 00 01)                               ;
  584h 3Ch  "CA00000001"      (padded with zeroes)      ;
  5C0h 4    (00 00 00 00)                               ;
  5C4h 104h Hex numbers                                 ;
  6C8h 4    (00 01 00 01)                               ;
  6CCh 34h  Zerofilled                                  ;/
  700h 4    (00 01 00 00)                               ;\
  704h 100h Hex numbers                                 ;
  804h 3Ch  Zerofilled                                  ;
  840h 40h  "Root-CA00000001" (padded with zeroes)      ;
  880h 4    (00 00 00 01)                               ;
  884h 3Ch  "CP00000007"      (padded with zeroes)      ;
  8C0h 4    (00 00 00 00)                               ;
  8C4h 104h Hex numbers                                 ;
  9C8h 4    (00 01 00 01)                               ;
  9CCh 34h  Zerofilled                                  ;/
  A00h 4    (00 01 00 01)                               ;\
  A04h 100h Hex numbers                                 ;
  B04h 3Ch  Zerofilled                                  ;
  B40h 40h  "Root-CA00000001" (padded with zeroes)      ;
  B80h 4    (00 00 00 02)                               ;
  B84h 3Ch  "MS00000008"      (padded with zeroes)      ;
  BC0h 4    (00 00 00 00)                               ;
  BC4h 40h  Hex numbers     ;&lt;-- short                  ;
  N/A  -    (no extra id here)                          ;
  C04h 3Ch  Zerofilled                                  ;/
  C40h 4    (00 01 00 01)                               ;\
  C44h 100h Hex numbers                                 ;
  D44h 3Ch  Zerofilled                                  ;
  D80h 40h  "Root-CA00000001" (padded with zeroes)      ;
  DC0h 4    (00 00 00 01)                               ;
  DC4h 3Ch  "XS00000003"      (padded with zeroes)      ;
  E00h 4    (00 00 00 00)                               ;
  E04h 104h Hex numbers                                 ;
  F08h 4    (00 01 00 01)                               ;
  F0Ch 34h  Zerofilled                                  ;/
</TD></TR></TABLE>
Cert chain for the DSi. Contains certificates signed by Root-CA00000001 for:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Root-CA00000001-XS00000006: used for signing (common) tickets ("access"?)
  Root-CA00000001-CP00000007: used for signing TMDs ("Content Protection"?)
  Root-CA00000001-MS00000008: used for signing per-console ECC keys ("Master"?)
  Root-CA00000001-XS00000003: used for signing tickets from the DSiWare Shop
</TD></TR></TABLE>
Also contains a certificate for Root-CA00000001, signed by Root. The public key
for Root is presumably contained elsewhere and unmodifiable.<BR>
A similar file with the same name exists on the Wii.<BR>
<BR>
<B>FAT16:\sys\dev.kp                     ;446 bytes (encrypted)</B><BR>
The dev.kp file is encrypted with ES Block Encryption. The key (or probably a
key X/Y pair) needed for decryption is unknown; the encrypted data is totally
different on different consoles, so it does apparently require a per-console
key.<BR>
<A HREF="#dsiesblockencryption">DSi ES Block Encryption</A><BR>
The contents of an example dev.kp file after decryption is shown below.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4    (00 01 00 02)                                       ;\
  004h 3Ch  Hex numbers                                         ;
  040h 40h  Zerofilled                                          ;
  080h 40h  "Root-CA00000001-MS00000008"  (padded with zeroes)  ;
  0C0h 4    (00 00 00 02)                                       ;
  0C4h 3Ch  "TWxxxxxxxx-08nnnnnnnnnnn1nn" (padded with zeroes)  ;
  100h 4    (00 00 00 00)                                       ;
  104h 40h  Hex numbers                                         ;
  144h 3Ch  Zerofilled                                          ;
  180h 1Eh  Hex numbers                                         ;/
</TD></TR></TABLE>
The "TWxxxxxxxx-08nnnnnnnnnnn1nn" string may vary:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  "TW" might be for DSi only (ie. it might be different on DSi XL or 3DS?)
  "xxxxxxxx" is some 8-digit lower-case hex number (unknown where/what from)
  "08nnnnnnnnnnn1nn" is 16-digit lower-case hex number (from Port 4004D00h)
</TD></TR></TABLE>
Example:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Signature across rest of block -- type = 0x00010002, ECC
  0000000: 00 01 00 02 00 db da 21 3b e1 f1 bf bb 4d dc 1d
  0000010: 60 29 da 19 42 1e 66 4f a8 e5 27 a1 d4 ea 46 7d
  0000020: 9b b4 00 95 c5 0d e8 fa ef a7 8d e9 bc 54 da c1
  0000030: 24 94 0b 7c ad a8 61 d5 05 97 c2 64 38 ad 18 f9
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Key used to sign this cert (Root-CA00000001-MS00000008)
  0000080: 52 6f 6f 74 2d 43 41 30 30 30 30 30 30 30 31 2d  Root-CA00000001-
  0000090: 4d 53 30 30 30 30 30 30 30 38 00 00 00 00 00 00  MS00000008
  00000a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  00000b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Console ID string
  00000c0: 00 00 00 02 54 57 63 37 39 64 63 65 63 39 2d 30  ....TWc79dcec9-0
  00000d0: 38 61 32 30 32 38 37 30 31 30 38 34 31 31 38 00  8a2028701084118.
  00000e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  00000f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Public ECC key (30 bytes, starting at 0x108)
  0000100: 00 00 00 00 6f dd de 42 01 e0 34 a3 19 bc a9 af
  0000110: 50 fe 8a ac 75 08 07 a9 3a 2c 21 51 93 ae 4a 90
  0000120: 6e 62 41 f1 a2 fe 00 00 3d 0a 13 97 da 53 17 98
  0000130: 69 38 65 67 ca f4 9c 87 ec 44 b7 eb d0 ec b8 3d
  0000140: 23 cf 7a 35 00 00 00 00 00 00 00 00 00 00 00 00
  0000150: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0000160: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0000170: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Private per-console ECC key, used for signing files on SD
  0000180: 01 12 9d e0 77 82 44 d3 ee 99 ad ce e5 fa fa ed
  0000190: c9 ab 8e a1 f9 b5 c8 14 3c 74 74 f8 19 3a
</TD></TR></TABLE>
Note that the console id itself is burned in an OTP area of the TWL CPU, and
changing the contents of this file will not actually change the console id.<BR>
This file contains the unique per-console ECC private-public key pair, along
with a certificate issued by Nintendo.<BR>
This file is created by the DSi Shop, with data from a SOAP reply. The SOAP
request data includes the hw console id, and the 0x100-byte RSA signature
stored in NAND file "HWID.sgn". Trying to send that request would require a
NAND dump, but when you have a NAND dump already sending that request is
pointless since you can grab dev.kp from NAND.<BR>
Sending that request is pointless anyway since the dev.kp data from the server
is random. The returned dev.kp data from the server for the EC private/public
keys are random, the ticket consoleID immediately following TW before - in the
twcert keyid is random as well. DSi Shop and System Settings don't contain any
code for deleting dev.kp. If you try to delete/rename dev.kp manually from NAND
a new dev.kp will be generated by the shop, but then the server will return an
error since the server account public dev.kp cert won't match.<BR>
<BR>
Data management can't be accessed when dev.kp doesn't exist since you'd have no
twcert to sign/verify tads with, like when you never connected the DSi Shop
server.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcfirmwarefontfile"></A>&nbsp;
  DSi SD/MMC Firmware Font File
</FONT></TD></TR></TABLE><BR>
<B>FAT16:\sys\TWLFontTable.dat           ;843.1K (D2C40h bytes) (compressed)</B><BR>
This is the only real long filename that exceeds the 8.3 limit on the DSi
(alternate short name is TWLFON~1.DAT).<BR>
This file contains fonts in the NFTR (Nitro font) format, and supports the
following character sets:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ASCII
  ISO 8859-1
  ISO 8859-7
  CP 932
  CP 1252
  CP 1253
  JIS X0201
  JIS X0208
</TD></TR></TABLE>
Uh? Unknown if/how it does really support above character sets (it might be
possible via diferrent "Character Map" chunks; but on the other hand, the
"encoding" is said to be defined in the "Font Info" chunk, and there appears to
be one such chunk per font)?<BR>
Nintendo only allows developers to use these fonts for NAND applications. Card
applications may not use these fonts.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0000h       80h  RSA SHA1 on entries [0080h..009Fh]
  0080h       4    Unknown (00h,31h,07h,08h) (maybe date, or whatever?)
  0084h       1    Number of NFTR resources (3)
  0085h       7    Zerofilled
  008Ch       14h  SHA1 on below resource headers at [00A0h+0..(3*40h-1)]
  00A0h+N*40h 20h  Resource Name in ASCII, padded with 00h
  00C0h+N*40h 4    Compressed Resource Size in .dat file   ;\compressed
  00C4h+N*40h 4    Compressed Resource Start in .dat file  ;/
  00C8h+N*40h 4    Decompressed Resource Size              ;-decompressed
  00CCh+N*40h 14h  SHA1 on Compressed Resource at [Start+0..Size-1]
</TD></TR></TABLE>
That, followed by the actual font resources in (in compressed form, and with
16-byte alignment padding between each resource). The three resources are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  "TBF1_l.NFTR"     (large font)
  "TBF1_m.NFTR"     (medium font)
  "TBF1_s.NFTR"     (small font)
</TD></TR></TABLE>
In the DSi font file, below data is somehow compressed. The compression format
is unknown (probably some LZ variant). And it's unknown where the compression
starts (the "RTFN" ID looks uncompressed, without preceeding compression flags,
so compression may start in the next some bytes; which might contain
compression type/flags).<BR>
<BR>
000160h:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  52 54 46 4E FF FE 02 01 78 32 0A 00 10 00 18 00  ;RTFN............
  46 4E 49 46 20 18 27 20 13 10 01 D5 12 EC 0D 00  ;FNIF............
  4C 53 C7 09 00 15 11 11 00 50 00 4C 47 43 B4 70  ;.........P.LGC..
  09 00 10 00 15 54 00 11 11 02 09 90 0F F0 C0 0F
  F0 0F F0 51 F0 F5 F1 39 9B 05 50 01 10 3D 12 FF
  E1 11 D1 11 15 88 41 F4 21 F0 51 A1 00 01 10 DF
  B2 01 00 71 A9 00 61 09 B5 0F F0 0F F0 EA 40 F0
  41 C1 02 C2 80 00 02 83 05 40 00 2B AB A0 D9 05
</TD></TR></TABLE>
That is, maybe...<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ...
  "FNIF"
  20
  18
  27 20 13
  10              width?
  01 D5
  12 EC 0D 00
  4C
  53 C7 09 00     offset to char map?
  15              height
  11 11           width, bearing?
  00              unknown
  "P"
  00h   (compression flags: next 8 bytes uncompressed)
  "LGC"
  000970B4h (size)
  10h   (width)
  00h   (compression flags: next 8 bytes uncompressed)
  15h   (height)
  0054h (size) (height*4)
  1111h (unknown)
  02h   (depth)
  09h   (rotation?)
  90h   (first data byte)
  0Fh   (compression flags: ?)
  F0 33 F0 7D F7 14 91 F8 6E 5D 19 F0 41 00 00 00 00
</TD></TR></TABLE>
<BR>
063680h:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  52 54 46 4E FF FE 02 01 C4 26 06 00 10 00 18 00  ;RTFN............
  46 4E 49 46 20 EE 33 F4 01 0C 01 30 38 00 CA 06  ;FNIF............
  0D 00 98 BB 05 00 0C 10 0D 0D 00 50 4C 47 43 00  ;...........PLGC.
  00 65 05 00 0C 10 30 00 00 0D 0D 02 0B B0 0F F0
  33 F0 7D F7 14 91 F8 6E 5D 19 F0 41 00 00 00 00
  C3 00 23 00 82 00 00 3D F0 3D F2 04 00 07 1C 1C
  00 0B 2C 00 7F FE 00 00 0C 30 00 0C 70 1E 19 79
  D4 20 7E 10 61 D4 F1 0C 00 D3 0E E0 00 E3 1D 24
  00 E3 00 00 7F EA 00 09 00 C0 2C 00 83 1C 00 D7
  CD 22 4A F1 C0 3D 00 A0 E7 02 C0 D3 47 00 00 D3
  4C 00 7E 34 00 14 00 73 D0 00 CE 70 03 4D 34 00
</TD></TR></TABLE>
<BR>
0A3A80h:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  52 54 46 4E FF FE 02 01 EC 20 04 00 10 00 18 00  ;RTFN............
  46 4E 49 46 20 02 00 B5 20 0A 0A 01 18 38 AE 16  ;FNIF............
  0D 00 C0 B5 03 00 0C 06 0B 0A 00 50 4C 47 43 28  ;...........PLGC.
  00 5F 03 00 0A 0C 1E 00 0A 00 0B 02 05 50 3D F0
  AD F4 68 59 A1 B1 88 7C 14 2F 93 F0 8E 4F D0 B2
  0B 7F F4 02 17 4C 00 35 C0 0F FE BB 0F 03 40 30
  D9 80 3E 40 0E DC E1 05 07 42 D0 78 04 04 CD 00
  DD D0 FB 01 82 0C 8D 76 05 0C 71 C0 CB 34 02 07
  C9 00 01 9F 00 73 1C 00 0C 32 C3 41 22 87 2E 00
</TD></TR></TABLE>
<BR>
The decompressed data should be reportedly looking somehow as so:<BR>
<BR>
<B>Nitro Font Resource Header Chunk</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h 4    Chunk ID "RTFN" (Nitro Font Resource)
  04h 2    Byte Order    (FEFFh) (indicates that above is to be read backwards)
  06h 2    Version       (0102h or 0100h)
</TD></TR></TABLE>
Everything below is compressed?<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  08h 4    Decompressed Resource Size (000A3278h) (including the NFTR header)
  0Ch 2    Chunk Size (of the "RTFN" chunk) (0010h)
  0Eh 2    Total number of Chunks (0018h?)
</TD></TR></TABLE>
<BR>
<B>Font Info Chunk</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h      4    Chunk ID "FNIF" (Font Info)
  04h      4    Chunk Size (1Ch or 20h)
  08h      1    Unknown
  09h      1    Height
  0Ah      3    Unknown
  0Dh      1    Width
  0Eh      1    Width_bis
  0Fh      1    Encoding (0/UTF8, 1/UNICODE, 2/SJIS, 3/CP1252)   ?
  10h      4    Offset to Character Glyph chunk        plus 8
  14h      4    Offset to Character Width chunk        plus 8
  18h      4    Offset to first Character Map chunk    plus 8
  1Ch      (1)  Height_Font   ;\
  1Dh      (1)  Width_Font    ; present only when above
  1Eh      (1)  Bearing Y     ; Chunk Size = 20h
  1Fh      (1)  Unknown       ;/
</TD></TR></TABLE>
<BR>
<B>Character Glyph (Tile Bitmaps)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h      4    Chunk ID "PLGC" (Character Glyph)
  04h      4    Chunk Size
  08h      1    Tile Width
  09h      1    Tile Height
  0Ah      2    Tile Size (in bytes) (siz)
  0Ch      2    Unknown
  0Eh      1    Depth    (uh, bits per pixel or so?)
  0Fh      1    Tile Rotation (0=0', 1=90', 2=270', 3=180')
                Other info:   (0=0', 2=90', 4=180', 6=270')
              tiles = new Byte[(block_size - 0x10) / tile_length][];
              for (int i = 0; i &lt; tiles.Length; i++)
  10h+N*siz     tiles[i] = BytesToBits(br.ReadBytes(siz));
</TD></TR></TABLE>
<BR>
<B>Character Width</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h      4    Chunk ID "HDWC" (Character Width)
  04h      4    Chunk Size
  08h      2    fist_code     start
  0Ah      2    last_code     end
  0Ch      4    Unknown
              for (int i = 0; i &lt; font.plgc.tiles.Length; i++)
  10h+N*3  1    info.pixel_start
  11h+N*3  1    info.pixel_width
  12h+N*3  1    info.pixel_length
</TD></TR></TABLE>
<BR>
<B>Character Map(s) - Translation Tables for ASCII/JIS/etc to Tile Numbers?</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h      4    Chunk ID "PAMC" (Character Map)
  04h      4    Chunk Size
  08h      2    first_char
  0Ah      2    last_char
  0Ch      4    type_section
  10h      4    Offset to next Character Map,     plus 8   (0=None, no further)
</TD></TR></TABLE>
For type_section=0:    Type0 type0<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  14h      2    TileNo for first char (and increasing for further chars)
</TD></TR></TABLE>
For type_section=1:    Type1 type1<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  14h+N*2  2    TileNo for first..last char? (FFFFh=special, maybe none?)
</TD></TR></TABLE>
For type_section=2:    Type2 type2<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  14h      2    Number of following groups...
  16h+N*4  2    Maybe First TileNo of group?
  18h+N*4  2    Maybe number of Tiles in group, or so?
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcfirmwarelogfiles"></A>&nbsp;
  DSi SD/MMC Firmware Log Files
</FONT></TD></TR></TABLE><BR>
<B>FAT16:\sys\log\shop.log (32 bytes)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0000h 20h   Zerofilled
</TD></TR></TABLE>
Unknown if this file can contain anything else.<BR>
<BR>
<B>FAT16:\sys\log\product.log (573 bytes)</B><BR>
Contains some ASCII text with version, date (YY/MM/DD), and time (HH:SS) info
(using 0Ah as CRLF):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0,BOARD,START,1.5,09/01/14,14:52,000055, ,
  0,BOARD,OK,1.5,09/01/14,14:53,000055, ,
  0,TP_CAL,OK,2.0, , , ,(647 811)-(3478 3245),
  0,AGING,OK,1.0, , , ,Time=60:20(m:s)
  Count=32,
  0,FINAL,START,1.5,09/01/15,09:52,000084,TWL Ver.2.0,
  0,FINAL,OK,1.5,09/01/15,09:52,000084,TWL Ver.2.0,
  0,MIC,OK,2.1, , , ,All Test Passed,
  0,CAMERA,OK,2.1, , , , ,
  0,WRFU,START,0.60,09/01/15,10:03,000143,P000063 G000143 717cfde74f5ef6763473,
  0,WRFU,OK,0.60,09/01/15,10:04,000143,PCVer:1.7f
  R-53 -55 E0.00 0.00,
  0,IMPORT,START,1.0, , , , ,
  0,IMPORT,OK,1.0, , , ,Region=EUR,
  0,NCHECK,OK,1.0, , , , ,
</TD></TR></TABLE>
<BR>
<B>FAT16:\sys\log\sysmenu.log (16Kbytes)</B><BR>
Contains several groups of three text lines. Each "#FFT" group begins with two
0Ah characters, and is followed by space padding for 256-byte alignment of the
next group).<BR>
Below is some example (with blank space removed, original 40-digit hash strings
abbreviated to "xxxx..xx", and some lines are replaced by "...").<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  #FFT 13-08-18[SUN] 12:37:10
  title: HNAP
  DHT_PAHSE1_FAILED (sub info): hash1     - 8dfc..59
  #FFT 13-08-18[SUN] 12:37:10
  title: HNAP
  DHT_PAHSE1_FAILED (sub info): calc_hash - 7eca..f5
  #FFT 13-08-18[SUN] 12:37:11
  title: HNAP
  menuRedIplManager.cpp [l.514] RED FATAL 0000000010000000 (0000000041575445)
  #FFT 13-08-18[SUN] 12:37:11
  title: HNAP
  menuResetCallback.cpp [l.50] type 0
  #FFT 13-08-18[SUN] 13:44:16
  title: HNAP
  DHT_PAHSE1_FAILED (sub info): hash1Addr-02799e38
  #FFT 13-08-18[SUN] 13:44:16
  title: HNAP
  DHT_PAHSE1_FAILED (sub info): hash1     - 8dfc..59
  ...
  ...
  #FFT 13-09-10[TUE] 22:07:39
  title: HNAP
  menuResetCallback.cpp [l.50] type 0
  #FFT 13-09-14[SAT] 14:59:16
  title: HNAP
  SYSMi_LoadTitleThreadFunc: some error has occurred.
  #FFT 13-09-14[SAT] 14:59:16
  title: HNAP
  SYSMi_AuthenticateTitleThreadFunc: loaded 1 times.
  #FFT 13-09-14[SAT] 14:59:17
  title: HNAP
  menuRedIplManager.cpp [l.514] RED FATAL 0000800000002100 (0003000049524544)
  #FFT 13-09-14[SAT] 14:59:17
  title: HNAP
  menuResetCallback.cpp [l.50] type 0
  #FFT 00-01-03[MON] 20:50:18
  title: HNAP
  WHITELIST_NOTFOUND (sub info): no entry for phase 1/2.
  #FFT 00-01-03[MON] 20:50:18
  title: HNAP
  WHITELIST_NOTFOUND (sub info): no entry for phase 3.
  #FFT 00-01-03[MON] 20:50:18
  title: HNAP
  SYSMi_LoadTitleThreadFunc: some error has occurred.
  #FFT 00-01-03[MON] 20:50:18
  title: HNAP
  SYSMi_AuthenticateTitleThreadFunc: loaded 1 times.
  #FFT 00-01-03[MON] 20:50:19
  title: HNAP
  menuRedIplManager.cpp [l.514] RED FATAL 0000800008000100 (000000004143454b)
  #FFT 00-01-03[MON] 20:50:19
  title: HNAP
  menuResetCallback.cpp [l.50] type 0
  #FFT 00-01-05[WED] 01:03:16
  title: HNAP
  WHITELIST_NOTFOUND (sub info): no entry for phase 1/2.
  ...
  ...
  #FFT 00-01-01[SAT] 00:02:37
  title: HNAP
  SYSMi_AuthenticateTitleThreadFunc: loaded 1 times.
  #FFT 00-01-01[SAT] 00:02:38
  title: HNAP
  menuRedIplManager.cpp [l.514] RED FATAL 0002004000000100 (00000000414e5045)
  #FFT 00-01-01[SAT] 00:02:38
  title: HNAP
  menuResetCallback.cpp [l.50] type 0
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcfirmwaremiscfiles"></A>&nbsp;
  DSi SD/MMC Firmware Misc Files
</FONT></TD></TR></TABLE><BR>
<B>FAT16:\sys\HWINFO_S.dat (aka Serial/Barcode) (16Kbytes)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0000h 80h   Maybe RSA stuff...
  0080h 4     Header, Version or so (00000001h)
  0084h 4     Header, Size of entries at [0088h..00A3h] (0000001Ch)
  0088h 9     Unknown (3E,00,00,00,00,00,00,00,02)   ;"&gt;"
  0091h 12    Serial/Barcode (ASCII, 11-12 characters; see console sticker)
  009Dh 3     Unknown (00,00,3C)                     ;"&lt;"
  00A0h 4     String "PANH" (aka HNAP=Launcher spelled backwards?)
  00A4h 3F5Ch Unused (FFh-filled)
</TD></TR></TABLE>
Entries [0088h..009Fh] are copied to [2FFFD68h..2FFFD7Fh].<BR>
<BR>
<B>FAT16:\sys\HWINFO_N.dat (16Kbytes)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0000h 14h   SHA1 on entries [088h..09Bh]
  0014h 6Ch   Zerofilled
  0080h 4     Header, Version or so (00000001h)
  0084h 4     Header, Size of entries at [0088h..009Bh] (00000014h)
  0088h 4     Some per-console ID (used what for?)
  008Ch 10h   Some per-console ID (used in "Tad Files")
  009Ch 3F64h Unused (FFh-filled)
</TD></TR></TABLE>
<BR>
<B>FAT16:\shared2\launcher\wrap.bin (16Kbytes)</B><BR>
Contains a list of Title IDs (maybe the sort-order how they are arranged in
System Menu; users can drag the icons to rearrange their ordering - or actually
THAT info is probably stored in the System Menu's "private.sav" file).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0000h 14h   SHA1 on entries [014h..03Fh]
  0014h 14h   SHA1 on entries [028h..177h]
  0028h 4     Header, ID   ("APWR")
  002Ch 4     Header, Size of entries at [040h..177h] (00000138h)
  0030h 10h   Header, Zero (00h-filled)
  0040h 138h  Space for 39 Title IDs (as at cart[230h]) (8x00h=unused entry)
  0178h 3E88h Unknown (looks like random/garbage, or encrypted junk)
</TD></TR></TABLE>
<BR>
<B>FAT16:\sys\HWID.sgn (256 bytes)</B><BR>
Unknown. Some 256-byte signature, or two 128-byte signatures, whatever.<BR>
<BR>
<B>FAT16:\shared2\0000 (2048K)</B><BR>
Unknown. Huge 2Mbyte file with several used areas (and many zerofilled areas).<BR>
<BR>
<B>FAT16:\import\</B><BR>
<B>FAT16:\progress\</B><BR>
<B>FAT16:\tmp\es\write\</B><BR>
Empty folders.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcfirmwarewififirmware"></A>&nbsp;
  DSi SD/MMC Firmware Wifi Firmware
</FONT></TD></TR></TABLE><BR>
<B>FAT16:\title\0003000f\484e4341\content\00000002.app (aka Wifi Firmware)</B><BR>
Unknown. 17E60h bytes. (non-executable datafile) (all regions) (compressed)<BR>
What is this? Firmware for some extra CPU inside of the wifi unit?<BR>
Or just compressed ARM9 and ARM7 code?<BR>
Or two versions, one for Atheros/Mitsumi, one for Sony?<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00000h 80h    RSA SHA1    (on [00080h..0009Fh]) (via RSA key from BIOS) ;\
  00080h 14h    Header SHA1 (on [000A0h..000FFh])                         ; SHA
  00094h 4      Header Size (00000060h, for entries 000A0h..000FFh)       ;
  00098h 8      Zerofilled                                                ;/
  000A0h 4      Whatever (00020002h)                              ;\
  000A4h 4      Part 1 Start (00000100h)                ;\        ;
  000A8h 4      Part 1 Size  (00013AC0h)                ; Part 1  ;
  000ACh 4      Part 1 ID    (00000001h)                ;         ; Header
  000B0h 14h    Part 1 SHA1  (on [00100h..13BBFh])      ;/        ;
  000C4h 4      Part 2 Start (00013BC0h)                ;\        ;
  000C8h 4      Part 2 Size  (000042A0h)                ; Part 2  ;
  000CCh 4      Part 2 ID    (00000002h)                ;         ;
  000D0h 14h    Part 2 SHA1  (on [13BC0h..17E5Fh])      ;/        ;
  000E4h 1Ch    Zerofilled                                        ;/
  00100h 4      Part 1 stuff    (00440204h)                                   ;\
  00104h 10h    Part 1.a subheader (00000080h,00013458h,80000001h,00502400h)  ;
  00114h 10h    Part 1.b subheader (000134E0h,000002BCh,00000002h,0052D944h)  ;
  00124h 10h    Part 1.c subheader (000137A0h,000002DEh,00000004h,00515000h)  ;
  00134h 10h    Part 1.d subheader (00013A80h,00000030h,00000005h,00502400h)  ;
  00144h 10h    ?                  (02010001h,20000188h,02000001h,20000188h)  ;
  00154h 10h    ?                  (2100007Bh,00500400h,00500000h,0002E000h)  ;
  00164h 1Ch    Zerofilled                                                    ;
  00180h 13460h Part 1.a data (13458h compressed bytes, +8 bytes zeropadding) ;
  135E0h 2C0h   Part 1.b data (2BCh bytes, +04h bytes zeropadding)            ;
  138A0h 2E0h   Part 1.c data (2DEh bytes, +02h bytes zeropadding)            ;
  13B80h 40h    Part 1.d data (30h bytes, +10h bytes zeropadding)             ;/
  13BC0h 4      Part 1 stuff    (00440204h)                                   ;\
  13BC4h 10h    Part 2.a subheader (00000080h,00002EECh,80000001h,00524C00h)  ;
  13BD4h 10h    Part 2.b subheader (00002F80h,00000FC0h,00000002h,0053F040h)  ;
  13BE4h 10h    Part 2.c subheader (00003F40h,00000312h,00000004h,00527000h)  ;
  13BF4h 10h    Part 2.d subheader (00004260h,00000038h,00000005h,00524C00h)  ;
  13C04h 10h    ?                  (0D000000h,23000024h,0D000001h,23000024h)  ;
  13C14h 10h    ?                  (2300006Ch,00520000h,00520000h,00020000h)  ;
  13C24h 1Ch    Zerofilled                                                    ;
  13C40h 2F00h  Part 2.a data (2EECh compressed bytes, +14h bytes zeropadding);
  16B40h FC0h   Part 2.b data (FC0h bytes)                                    ;
  17B00h 320h   Part 2.c data (312h bytes, +0Eh bytes zeropadding)            ;
  17E20h 40h    Part 2.d data (38h bytes, +08h bytes zeropadding)             ;/
</TD></TR></TABLE>
The subheader's consist of Offset (relative to Start of Part 1/2 accordingly),
Length, and two unknown words (maybe ID/Flag/DestAddr).<BR>
part 1.a data and part 2.a data are compressed with some kind of "tag,len,disp"
compression. The data looks as so:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Part 1.a data: 9F,FF,FF,FF,FF,FF,FF,00,00,00,00,9F,04,04,..
  Part 2.a data: 5E,00,00,00,00,5E,04,04,5E,08,08,41,5F,49,..
</TD></TR></TABLE>
The first byte identifies the "tag" value (this should be the value used least
often in the uncompressed data). The following bytes are plain uncompressed
data, mixed with "tag,len,disp" values (which will copy "len" bytes from
"dest-disp" to "dest"). A special case is "tag,00h", which will store the "tag"
value at dest. The len and disp values can consist of one or more byte(s) each
(the LSB is indicated by bit7=0; for example, "84h,86h,0Fh" would mean
01030Fh). For some odd reason, the values are always "len&lt;=disp" (even for
zerofilled regions where "len&gt;disp" would be useful).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcfirmwaresystemsettingsdatafiles"></A>&nbsp;
  DSi SD/MMC Firmware System Settings Data Files
</FONT></TD></TR></TABLE><BR>
The DSi stores System Settings on eMMC in two identical files (TWLCFG0.dat and
TWLCFG1.dat). If both files are intact then the newer file is taken (as
indicated by the update counter).<BR>
For NDS compatibility, some of the data is additionally stored on Wifi FLASH:<BR>
<A HREF="#dsfirmwareusersettings">DS Firmware User Settings</A><BR>
The TWL data and the NDS-style data are also copied to RAM:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  2000400h 128h   TWLCFGn.dat bytes [088h..1AFh]
  2FFFC80h 70h    Wifi FLASH User Settings (fmw[newest_user_settings])
  2FFFDFCh 4      Pointer to 2000400h
</TD></TR></TABLE>
For some reason, most DSi games are containing some initialization code for
repairing or initializing the above pointer, as so:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  if [2FFFDFCh]=0 then [2FFFDFCh]=2000400h
</TD></TR></TABLE>
The RAM data at 2000400h isn't actually used by too many games though (one
program that is using it is Flipnote).<BR>
<BR>
<B>FAT16:\shared1\TWLCFG0.dat (16Kbytes) (System Settings Data)</B><BR>
<B>FAT16:\shared1\TWLCFG1.dat (16Kbytes) (System Settings Data)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  File RAM  Siz   Description
  000h -    14h   SHA1 on entries [088h..1AFh]
  014h -    6Ch   Zerofilled
  080h -    1     Version or so (01h)
  081h -    1     Update Counter (wraps after 7bit? 8bit?)   ;fmw_user[070h]
  082h -    2     Zero (0000h)
  084h -    4     Size of below RAM area (00000128h)
  088h 000h 1     Unknown (0Fh) (bit3 set when wireless comms are enabled)
  089h 001h 2     Zerofilled
  08Bh 003h 1     Unknown (01h)
  08Ch 004h 1     Zero
  08Dh 005h 1     Country code, same as Wii country codes (4Eh)
  08Eh 006h 1     Unknown, related to country code? (01=USA/EUR, 02=Canada?)
                     or maybe language 1=English, 2=French?
  08Fh 007h 2     Unknown, related to above? (00,00)
  091h 009h 1     Zero
  092h 00Ah 2     u16 unknown (0000h)
  094h 00Ch 4     Zerofilled
  098h 010h 1     Flags (01h) (bit0 set when EULA was accepted)
  099h 011h 10h   Zerofilled
  0A9h 021h 4     Unknown (09 1E 00 03)  (2nd.byte.LSB E=English, F=French ??)
  0ADh 025h 3     Zerofilled
  0B0h 028h 8     Title ID (most recent System Menu index?) (as at cart[230h])
  0B8h 030h 2x2   TSC calib (adc.x1,y1) 12bit ADC-position   ;fmw_user[058h]
  0BCh 034h 2x1   TSC calib (scr.x1,y1) 8bit pixel-position  ;fmw_user[05Ch]
  0BEh 036h 2x2   TSC calib (adc.x2,y2) 12bit ADC-position   ;fmw_user[05Eh]
  0C2h 03Ah 2x1   TSC calib (scr.x2,y2) 8bit pixel-position  ;fmw_user[062h]
  0C4h 03Ch 4     Unknown (9C 20 01 02)
  0C8h 040h 4     Zerofilled
  0CCh 044h 1     Favorite color (0Ch)             ;fmw_user[002h]
  0CDh 045h 1     Zero
  0CEh 046h 2     Birthday, month and day          ;fmw_user[003h..004h]
  0D0h 048h 14h   Nickname (UCS-2), max 10 chars   ;fmw_user[006h..019h]
  0E4h 05Ch 2     Zero (END of above)
  0E6h 05Eh 34h   Message (UCS-2), max 26 chars    ;fmw_user[01Ch..04Fh]
  11Ah 092h 2     Zero (END of above)
  11Ch 094h 1     Parental Control flags?
  11Dh 095h 6
  123h 09Bh 1     Unknown
  124h 09Ch 1     Parental Control Years of age rating?
  125h 09Dh 1
  126h 09Eh 1     Unknown
  127h 09Fh 2
  129h 0A1h 4     Parental Controls PIN (ASCII)   digits only?
  12Dh 0A5h 1
  12Eh 0A6h 40h   Parental Controls Secret Answer (UCS-2), max 32 chars?
  16Eh 0E6h ..    RAM:Unknown File:Zerofilled
  1B0h -    3E50h Unused (FFh-filled)
</TD></TR></TABLE>
Unknown entries:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Alarm hour,minute   2  fmw_user[052h]
  Alarm enable?       1  fmw_user[056h]
  Language and Flags  2  fmw_user[064h]
  Year?               1  fmw_user[066h]
  RTC Offset?         4  fmw_user[068h]
  More Parental Control stuff
</TD></TR></TABLE>
Parental controls fields are all zero when not in use.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcfirmwaretitlemetadatatmdfiles"></A>&nbsp;
  DSi SD/MMC Firmware Title metadata (.tmd) Files
</FONT></TD></TR></TABLE><BR>
<B>Title metadata (.tmd)</B><BR>
Title metadata, or TMD for short, is a format used to store information about a
title (DSiWare, etc.) and all its installed contents, including which contents
they consist of and their SHA1 hashes. The format between Wii and DSi Title
metadata appears to be identical.<BR>
Many operations are done in terms of 64-byte blocks, which means you will often
see padding out to the nearest 64-byte boundary at the end of a field.<BR>
Example of a Nintendo DSi TMD:
http://nus.cdn.t.shop.nintendowifi.net/ccs/download/0003000f484e4c4a/tmd
("HNLJ", or Japanese Version Data.)<BR>
Structure<BR>
Header<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h        4    Signature type (00h,01h,00h,01h)
  004h        256  Signature
  104h        60   Zerofilled (padding/align 40h)
  140h        64   Issuer ("Root-CA00000001-CP00000007") (padded with 00h)
  180h        1    Version               (00h)
  181h        1    ca_crl_version        (00h)
  182h        1    signer_crl_version    (00h)
  183h        1    Zero       (padding/align 4h)
  184h        8    System Version (0)
  18Ch        8    Title ID       (00,03,00,17,"HNAP")
  194h        4    Title type     (0)
  198h        2    Group ID       ("01"=Nintendo)
  19Ah        62   Reserved? (contains some nonzero stuff)
  1D8h        4    Access rights (0)
  1DCh        2    Title version (02h,00h)
  1DEh        2    Number of contents (at 1E4h and up) (usually 00h,01h)
  1E0h        2    boot index    (0)
  1E2h        2    Zerofilled (padding/align 4h)
  1E4h+N*24h  4    Content ID    (00,00,00,02)
  1E8h+N*24h  2    Content Index (00,00)
  1EAh+N*24h  2    Content Type  (00,01)
  1ECh+N*24h  8    Content Size  (00,00,00,00,00,19,E4,00)
  1F4h+N*24h  14h  Content SHA1
</TD></TR></TABLE>
<BR>
<B>Cetk (as saved by NUS Downloader)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h        4    Signature type (00h,01h,00h,01h)
  004h        256  Signature
  104h        60   Zerofilled (padding/align 40h)
  140h        64   Text ("Root-CA00000001-XS00000006") (padded with 00h)
  180h        64   Zerofilled
  1C0h        24   Hexvalues
  1D8h        4    Zero
  1DCh        8    Title ID       (00,03,00,17,"HNAP")
  1E4h        2    Zero
  1E6h        1    07h (version maybe?)
  1E7h        ..   Zerofilled
  220h        2    00h,01h
  222h        32   FFh-filled
  242h        ..   00h-filled
  2A4h        4    Signature type (00h,01h,00h,01h)
  2A8h        256  Signature
  3A8h        ..   Zerofilled
  3E4h        64   Text ("Root-CA00000001") (padded with 00h)
  424h        4    00,00,00,01
  428h        64   Text ("XS00000006") (padded with 00h)
  468h        104h Hexvalues
  56Ch        4    Type (00h,01h,00h,01h)
  570h        ..   Zerofilled
  5A4h        4    00,01,00,00
  5A8h        200h Hexvalues
  7A8h        ..   Zerofilled
  7E4h        ..   "Root" (padded with 00h)
  828h        40h  Text ("CA00000001") (padded with 00h)
  868h        104h Hexvalues
  86Ch        4    00,01,00,01
  970h        34h  Zerofilled
</TD></TR></TABLE>
<BR>
<B>Certificates, uh?</B><BR>
Below is REPORTEDLY appended to above only when DOWNLOADING "tmd" from nintendo<BR>
(but is NOT stored in ".tmd" files on eMCC ?!?)<BR>
(and is also NOT appended when downloading via NUS Downloader utility ?!?)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Start Length  Description
  000h  4       Signature type
  004h  256     Signature
  104h  32      Issuer
  124h  4       Tag
  128h  64      Name
  168h  ?       Key
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcfirmwareversiondatafile"></A>&nbsp;
  DSi SD/MMC Firmware Version Data File
</FONT></TD></TR></TABLE><BR>
verdata (00030005-HNLx) is a bundle of data which corresponds to a release of
the "System Menu" -- every time Nintendo announces a new version of the system
menu, they will update one or more other titles and then update this title.<BR>
<BR>
<B>FAT16:\title\0003000f\484e4cgg\content\000000vv.app (aka Version Data)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0000h 80h  RSA SHA1 on entries [0080h..end of file]
  0080h ...  NARC (Nitro Archive) ...
</TD></TR></TABLE>
The NARC is a nintendo-specific virtual filesystem. For details, see:<BR>
<A HREF="#dscartridgenitroromandnitroarcfilesystems">DS Cartridge NitroROM and NitroARC File Systems</A><BR>
The NARC archive contains the following files:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 twl-nup-cert.der    - server cert for software update server
 twl-nup-prvkey.der  - client-side private key for software update server
 twl-shop-cert.der   - server cert for Shopping Channel server
 twl-shop-prvkey.der - client-side private key for Shopping Channel server
 NintendoCA-G2.der   - Certificate Authority cert, used to sign the other certs
 eula_url.bin        - URL to the EULA text for this system update,
                       generally https://cfh.t.app.nintendowifi.net/eula/
 nup_host.bin        - server to query for the next system update,
                       generally nus.t.shop.nintendowifi.net:443
 time_stamp.bin      - build date for this version, eg. 00281108 (28 Nov 2008)
 user_area_size.bin  - eg. 00000008
 version.bin         - machine and human-readable version numbers for this
                       version of the System Menu, eg.
   0000: 01000300 31002e00 33004500 00000000  ....1...3.E.....
   0010: 00000000 00000000 00000000 00000000  ................
   bytes 0 and 1 are the major version number, bytes 2 and 3 are the minor
   version number, and the rest of the file is the human-readable
   UCS-2 version number displayed in the Settings menu as the "System Menu
   Version".
</TD></TR></TABLE>
Other titles access this data by reading from eg. "verdata:/version.bin".<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmcfirmwarenintendodscartwhitelistfile"></A>&nbsp;
  DSi SD/MMC Firmware Nintendo DS Cart Whitelist File
</FONT></TD></TR></TABLE><BR>
<B>FAT16:\title\0003000f\484e4841\content\00000001.app (aka NDS Cart Whitelist)</B><BR>
"If i remember correctly, HNHA.bin is a file stored in the DSi (NAND fs ?),
that contains a list of white listed DS games. Basic HNHA.bin File Structure."
Uh?<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Start  Length     Description
  00000h 4          ID "NDHT"                                             ;\
  00004h 80h        Unknown, RSA maybe                                    ;
  00084h 4          Number of titles in file (00000D76h) (=3446)          ;
  00088h D76h*30h   Titles (30h bytes each, with two SHA1s)               ;/
  287A8h 4          ID "NDHX"                                             ;\
  287ACh 80h        Unknown, RSA maybe                                    ;
  2872Ch 4          Number of Xxx (000013BCh) (=5052)                     ;
  28730h 13BCh*1Ch  Titles (1Ch bytes each, only one SHA1)                ;/
  4AFC0h 4          ID "NDHI"                                             ;\
  4AFC4h 80h        Unknown, RSA maybe                                    ;
  4B044h 4          Number of (00000004h)                                 ;
  4B048h 4*5Ch      Specials for A3TE,A6WE,YF7E,YOUF ?                    ;/
  4B1B8h 13         String "2832",0Dh,0Ah,"10619",0Dh,0Ah                 ;\
  4B1C5h 11         C4 8E AC EC 69 35 C9 2B C2 58 E1                      ;/
</TD></TR></TABLE>
Title Structure (48 bytes each):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Start Length  Description
  000h  4   Title ID (Gamecode)
  004h  4   Title version
  008h  20  First SHA-1 sum    ;\unknown WHAT they are calculated on,
  01Ch  20  Second SHA-1 sum   ;/and if they are SHA1 or maybe SHA1-HMAC?
</TD></TR></TABLE>
Example values for Metroid Demo ("AMFE"):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  41 4D 46 45 00 00 00 00
  95 9A B3 09 B7 4E AF 29 2E 97 61 B9 DC E9 5F FE 86 5C 91 4E
  D3 94 43 02 64 3A AF C5 D1 E1 3B C0 47 4A A2 98 AB 5D 71 8F
  41 4D 46 45 00 00 00 00
  51 24 FE EF D4 3C 22 42 CC 17 13 0A 72 F8 FA 3B 4D 83 2A B1
</TD></TR></TABLE>
Specials related to games:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  NTR-A3TE-USA = Tak: The Great Juju Challenge
  NTR-A6WE-USA = FIFA World Cup 2006
  NTR-YF7E-USA = Fish Tycoon
  NTR-YOUF-FRA = Samantha Oups!
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmccamerafilesoverview"></A>&nbsp;
  DSi SD/MMC Camera Files - Overview
</FONT></TD></TR></TABLE><BR>
<B>Photos/Frames</B><BR>
Photos can be taken via Nintendo DSi Camera utitilty (or alternately, directly
via hotkeys in System Menu; which will be automatically flagging the photos
with "Star" stickers, which will cause them to be shown as System Menu
background image).<BR>
Frames are masks (with transparent pixels) that can be put onto photos. The
Frames can be created via Nintendo DSi Camera utility (Camera, select Frame
(upper-right Lens option), accept that Lens, then click Create Frame; the
procedure then is to take a photo, and to rub-out pixels on touchscreen to make
them transparent).<BR>
<BR>
<B>Internal/External Storage</B><BR>
The Camera is storing further data on the eMMC FAT12 partition:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  FAT12:\photo\DCIM\100NIN02\HNI_nnnn.JPG                        ;camera photos
  FAT12:\photo\private\ds\app\484E494A\pit.bin                   ;camera info
</TD></TR></TABLE>
And, probably (assuming similar path as on SD) (not verified for eMMC):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  FAT12:\photo\private\ds\app\484E494A\DCIM\100NIN02\HNI_nnnn.JPG;camera frames
</TD></TR></TABLE>
Camera data can be copied to SD card (via Nintendo DSi Camera, Options, Copy):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  SD:\DCIM\101NIN02\HNI_nnnn.JPG    ;&lt;-- 101 here (not 100) ;camera photos
  SD:\private\ds\app\484E494A\pit.bin                       ;camera info
  SD:\private\ds\app\484E494A\DCIM\100NIN02\HNI_nnnn.JPG    ;camera frames
</TD></TR></TABLE>
And, in internal eMMC only (not on SD), the DSi is somewhere storing Calendar
entries (some sort of bitmaps with optional handwritten comments drawn via
touchscreen).<BR>
<BR>
<B>File/Folder Numbers</B><BR>
The "nnnNIN02" folders are numbered "100NIN02" through "999NIN02". The first
folder is usually 100NIN02, unless another "100xxxxx" folder did already exist
(eg. if the SD card contains a "100CANON" folder, then DSi would start at
101NIN02 or higher).<BR>
The trailing "02" of the "nnnNIN02" folders appears to be fixed for DSi photos
(folder name "nnnNIN01" is reserved for Wii screenshots).<BR>
The "HNI_nnnn.JPG" filenames are numbered "HNI_0001.JPG" through
"HNI_0100.JPG", thereafter, the DSi will switch to next higher folder number,
and wrap to using "HNI_0001.JPG" as first filename in that folder.<BR>
The weird "484E494A" folder name is based on the japanese Nintendo DSi Camera's
gamecode (HNIJ) converted to an 8-digit uppercase HEX string (this appears to
be always the japanese gamecode, even on europen DSi consoles).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmccamerafilesjpegs"></A>&nbsp;
  DSi SD/MMC Camera Files - JPEG's
</FONT></TD></TR></TABLE><BR>
<B>Overall JPEG Format (big-endian)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Offs   ID    Len   Data
  0000h  FFD8h                                      ;(start of image)    ;SOI
  0002h  FFE1h,10C4h,"Exif",00h,00h,&lt;Exif Body&gt;     ;(extra "Exif" data) ;APP1
  10C8h  FFC0h,0011h,08h,01E0h,0280h,03h,012100h,021101h,031101h         ;SOF0
  10DBh  FFDBh,0084h, 00 06 04 05 06 05 04 06 06 05 06 07 07 .. 28 28 28 ;DQT
  1161h  FFC4h,01A2h, 00 00 01 05 01 01 01 .. .. F8 F9 FA                ;DHT
  1305h  FFDAh,000Ch,03h,010002h,110311h,003F00h    ;(start of scan)     ;SOS
  1313h  E6 76 F4 DD 4F 0A 3B 60 0F 4C D7 9E 9A 93 3D 4B EE 98 B8 .. ..
  AB4Fh  FFD9h                                      ;(end of image)      ;EOI
</TD></TR></TABLE>
<BR>
<B>Exif Body for Nintendo DSi Photos</B><BR>
The Exif data consists of several headers/footers and data blocks, mixed with
several "IFD" tables.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Offs  Siz  ExID  Type  Length    Offset    ;&lt;-- Format for "IFD" Tables
  0000h 4    "MM",002Ah                      ;Big-Endian (aka Motorola)
  0004h 4    00000008h                       ;first IFD offset (IFD0)
</TD></TR></TABLE>
IFD0 (Main Image):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0008h 2    0009h                           ;number of IFD0 entries
  000Ah 12   010Fh,0002h,00000009h,0000007Ah ;Maker ("Nintendo",0)
  0016h 12   0110h,0002h,0000000Bh,00000084h ;Model ("NintendoDS",0)
  0022h 12   011Ah,0005h,00000001h,00000090h ;Resolution X (72 dpi)
  002Eh 12   011Bh,0005h,00000001h,00000098h ;Resolution Y (72 dpi)
  003Ah 12   0128h,0003h,00000001h,00020000h ;Resolution Unit (2=Inches)
  0046h 12   0131h,0002h,00000005h,000000A0h ;Firmware (Gamecode backwards)
  0052h 12   0132h,0002h,00000014h,000000A6h ;Date/Time Modified
  005Eh 12   0213h,0003h,00000001h,00020000h ;Subsampling (2=datum point)
  006Ah 12   8769h,0004h,00000001h,000000BAh ;Exif SubIFD offset
  0076h 4    000001DEh                       ;next IFD offset (IFD1)
  007Ah 9+1  "Nintendo",00h,00h              ;Maker ("Nintendo",0,0)
  0084h 11+1 "NintendoDS",00h,00h            ;Model ("NintendoDS",0,0)
  0090h      00000048h,00000001h             ;Resolution X (72 dpi)
  0098h      00000048h,00000001h             ;Resolution Y (72 dpi)
  00A0h 5+1  "PINH",00h,00h   ;aka HNIP      ;Firmware (Gamecode backwards)
  00A6h 20   "YYYY:MM:DD HH:MM:SS",00h       ;Date/Time Modified
</TD></TR></TABLE>
Sub IFD:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00BAh 2    000Ah                           ;number of Sub IFD entries
  00BCh 12   9000h,0007h,00000004h,30323230h ;Exif Version ("0220")
  00C8h 12   9003h,0002h,00000014h,00000138h ;Date/Time Original
  00D4h 12   9004h,0002h,00000014h,0000014Ch ;Date/Time Digitized
  00E0h 12   9101h,0007h,00000004h,01020300h ;Components (Y,Cb,Cr)
  00ECh 12   927Ch,0007h,00000042h,00000160h ;Maker dependent internal data
  00F8h 12   A000h,0007h,00000004h,30313030h ;Flashpix Version ("0100")
  0104h 12   A001h,0003h,00000001h,00010000h ;Color Space (1=Normal=sRGB)
  0110h 12   A002h,0004h,00000001h,00000280h ;Pixel Dimension X (640)
  011Ch 12   A003h,0004h,00000001h,000001E0h ;Pixel Dimension Y (480)
  0128h 12   A005h,0004h,00000001h,000001A2h ;Interoperability IFD (R98)
  0134h 4    00000000h                       ;next IFD offset (none)
  0138h 20   "YYYY:MM:DD HH:MM:SS",00h       ;Date/Time Original
  014Ch 20   "YYYY:MM:DD HH:MM:SS",00h       ;Date/Time Digitized
</TD></TR></TABLE>
Maker dependent IFD (DSi specific):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0160h 2    0002h                           ;number of IFD entries
  0162h 12   1000h,0007h,0000001Ch,0000017Eh ;DSi Signature or so ?
  016Eh 12   1001h,0007h,00000008h,0000019Ah ;DSi Whatever Zero (Frame info?)
  017Ah 12   00000000h                       ;next IFD offset (none)
  017Eh 28   2E AB A5 D1 FD A8 .. ..         ;DSi Signature or so ?
  019Ah 8    0000000000000000h               ;&lt;-- different for Frames
</TD></TR></TABLE>
Interoperability IFD (R98) (some common/useless stuff for JPEGs):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  01A2h 2    0003h                           ;number of IFD entries
  01A4h 12   0001h,0002h,00000004h,52393800h ;Stipulated File ("R98",0)
  01B0h 12   0002h,0007h,00000004h,30313030h ;Whatever ("0100")
  01BCh 12   1000h,0002h,00000012h,000001CCh ;Whatever (JPEG Exif Ver 2.2",0)
  01C8h 4    00000000h                       ;next IFD offset (none)
  01CCh 18   "JPEG Exif Ver 2.2",00h         ;Whatever (JPEG Exif Ver 2.2",0)
</TD></TR></TABLE>
IFD1 (Thumbnail Image):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  01DEh 2    0006h                           ;number of IFD1 entries
  01E0h 12   0103h,0003h,00000001h,00060000h ;Compression (1=JPEG)
  01ECh 12   011Ah,0005h,00000001h,0000022Ch ;Resolution X (72 dpi)
  01F8h 12   011Bh,0005h,00000001h,00000234h ;Resolution Y (72 dpi)
  0204h 12   0128h,0003h,00000001h,00020000h ;Resolution Unit (2=Inches)
  0210h 12   0201h,0004h,00000001h,0000023Ch ;Jpeg Offset
  021Ch 12   0202h,0004h,00000001h,00000xxxh ;Jpeg Size (eg. E80h)
  0228h 4    00000000h                       ;next IFD offset (none)
  022Ch 8    00000048h,00000001h             ;Resolution X (72 dpi)
  0234h 8    00000048h,00000001h             ;Resolution Y (72 dpi)
</TD></TR></TABLE>
Thumbnail Data (160x120pix, in JPEG Format):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  023Ch 2    FFD8h                           ;(start of thumbnail/image) ;SOI
  023Eh 13h  FFC0h,0011h,08h,0078h,00A0h,03h,012100h,021101h,031101h     ;SOF0
  0251h 86h  FFDBh,0084h, 00 0A 07 07 08 07 .. ..                        ;DQT
  02D7h 1A4h FFC4h,01A2h, 00 00 01 05 01 .. .. F8 F9 FA                  ;DHT
  047Bh 0Eh  FFDAh,000Ch,03h,010002h,110311h,003F00h   ;(start of scan)  ;SOS
  0489h ...  CC 55 14 F0 3D 2B 8B 4B 9D C2 E3 BD 18 A5 B0 09 B6 .. ..
  10xxh 2    FFD9h                           ;(end of thumbnail/image)   ;EOI
</TD></TR></TABLE>
The above european gamecode entry differs for other regions. Above offsets are
usually as so for DSi jpeg's, but they might change if Nintendo adds/removes
some entries, or changes size of some entries (for example, the Model string is
said to be different for 3DS, and "Frames" are including a bigger entry, as
described below).<BR>
<BR>
Unknown how to calculate the above signature. Some random ideas: The 1Ch-byte
size might be SHA224 related (not too likely). Locating "ldr rx,=927Ch" opcodes
at various locations in Nintendo DSi Camera is easy; but the stuff is handled
via numerous sub-functions, including IPC stuff, so both ARM7 and ARM9 might be
envolved; which isn't too easy to disassemble. The 1Ch-bytes appear to be split
into 0Ch-byte-whatever, plus 10h-bytes-compared (which might hint on AES-CCM
with 12-byte Nonce, and 16-byte MAC).<BR>
The 1Ch-bytes appear to be zerofilled during calculation, so the signature is
probably simply calculated across the whole file (with the zero'ed signature).
Unknown if the System Menu (launcher) is checking the signature, too.<BR>
<BR>
<B>Exif Body for Nintendo DSi Frames</B><BR>
Frames are using same format above, but with the 8-byte zero entry at [019Ah]
replaced by a bigger 8FCh-byte entry (accordingly, the size in IFD entry
[016Eh] is also adjusted, and offsets for entries [01A2h..10xxh] are moved up).<BR>
The actual change is that 0000000000000000h is changed from 8 byte size to
8FCh-byte size, containing 0000000000000001h, followed by 8F4h extra bytes
(with unknown content; maybe the frame mask for transparent pixels; the data
doesn't really look like a mask though, unless it's compressed, but then the
fixed size would be strange).<BR>
<BR>
<B>IFD Type Values (and Length/Offset)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0001h = 8bit Unsigned
  0002h = 7bit ASCII
  0003h = 16bit Unsigned
  0004h = 32bit Unsigned
  0005h = 64bit Unsigned Rational (32bit numberator, plus 32bit denominator)
  0006h = Reserved
  0007h = 8bit General Purpose
  0009h = 32bit Signed
  000Ah = 64bit Signed Rational (32bit numberator, plus 32bit denominator)
  000Bh..FFFFh = Reserved
</TD></TR></TABLE>
The "Length" value indicates the number of type units, eg. type=16bit, length=3
would mean 6 bytes. If the information fits into 4 bytes then it's stored
directly in the 4-byte "Offset" field, otherwise "Offset" is a pointer to the
actual information.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsisdmmccamerafilespitbin"></A>&nbsp;
  DSi SD/MMC Camera Files - pit.bin
</FONT></TD></TR></TABLE><BR>
<B>FAT12:\photo\private\ds\app\484E494A\pit.bin (8K) (camera info)</B><BR>
<B>SD:\private\ds\app\484E494A\pit.bin (47K) (camera info)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0000h       8  ID ("0TIP00_1") (maybe meant to read as PIT01_00 or so)
  0008h       2  Number of pit.bin entries (3000 for SD Card) (500 for eMMC)
  000Ah       2  Unknown (0001h)
  000Ch       2  Next Photo Folder-Number minus 100  (xxxNIN02)
  000Eh       2  Next Photo File-Number minus 1      (HNB_0xxx.JPG)
  0010h       2  Next Frame Folder-Number minus 100  (xxxNIN02)
  0012h       2  Next Frame File-Number minus 1      (HNB_0xxx.JPG)
  0014h       2  CRC16 of whole file (with initial value 0000h, and with
                 entry [0014h] being treated as 0000h for calculation)
  0016h       2  Size of Header (0018h)
  0018h+N*10h 4  Entry N, Time/Date (seconds since 01 Jan 2000)
  001Ch+N*10h 8  Entry N, Unknown (zerofilled)
  0024h+N*10h 4  Entry N, Flags (see below)
                  0     Used Entry Flag (0=Unused/Deleted, 1=Used)
                  1-10  Folder-Number minus 100 (xxxNIN02)
                  11-17 File-Number minus 1     (0..99 = HNB_0001..0100.JPG)
                  18-19 Sticker (0=None, 1=Star, 2=Clover, 3=Heart)
                  20-21 Type (0,3=Photo, 1=Frame, 2=?)
                  22-23 Unknown (0,2=Normal?, 1=?, 3=Error)
                  24-31 Unused (zero)
  xxx8h       8  Padding for 16-byte filesize alignment (zerofilled)
</TD></TR></TABLE>
The "Next Photo/Frame" entries contain File/Folder Numbers where the next
images will be saved; that file numbers increase after saving, and do
eventually wrap to next higher folder number.<BR>
The Nintendo DSi Camera utility shows only photos listed in "pit.bin", when
manually copying jpg's to SD Card one could:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 - Delete "pit.bin" (it'll be recreated with ALL jpgs, sticker flags are lost)
 - Replace an existing 'listed' file by a new file with same filename
 - Manually edit "pit.bin" and adjust its CRC16 checksum
</TD></TR></TABLE>
Photos are region free, can be viewed from any other DSi's (as long as they are
listed in pit.bin). However, they do require some signature in Exif header, so
in general, the DSi accepts only images that come from DSi consoles; not images
from other sources.<BR>
<BR>
<B>Stickers</B><BR>
Photos with "Star" sticker are shown as background picture in System Menu; this
works only for images stored in internal eMMC memory (images on SD Card can
have stickers, too, but they are ignored by System Menu).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsigpioregisters"></A>&nbsp;
  DSi GPIO Registers
</FONT></TD></TR></TABLE><BR>
<B>4004C00h DSi7 - GPIO Data In (R) (even in DS mode)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     GPIO18[0]   ;\maybe 1.8V signals? (1=normal)
  1     GPIO18[1]   ; (maybe this are the three "NC" pins on CPU,
  2     GPIO18[2]   ;/near to the other GPIO pins)
  3     Unused (0)
  4     GPIO33[0] Probably "GPIO330" test point on mainboard
  5     GPIO33[1] Headphone connect (HP#SP) (0=None, 1=Connected)
  6     GPIO33[2] Powerbutton interrupt (0=Short Keydown Pulse, 1=Normal)
  7     GPIO33[3] Maybe via near GPIO330 test point
</TD></TR></TABLE>
One of the above is probably the "IRQ_O" signal on mainboard (possibly the
"power button" bit; if so, then that bit might be some general interrupt from
the "BPTWL" chip, rather than being solely related to the power button).<BR>
Bit0-2 might be unused "NC" pins. Bit4 might be GPIO330, which might be just a
test point without other connection. Bit7 might be connected to one of unknown
vias, and which might connect to somewhere (the cooking coach cart sets
interrupt edge select bit7; which hints that the pin could be used for
something; the interrupt isn't actually enabled though).<BR>
Some bits seem to be floating high-z (when switching from output/low to input
they won't &lt;instantly&gt; get high).<BR>
<BR>
<B>4004C00h DSi7 - GPIO Data Out (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-2   GPIO18[0-2] Data Output (0=Low, 1=High)
  3     Unused (0)
  4-7   GPIO33[0-3] Data Output (0=Low, 1=High)
</TD></TR></TABLE>
Used only when below is set to direction=out.<BR>
<BR>
<B>4004C01h DSi7 - GPIO Data Direction (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-2   GPIO18[0-2] Data Direction (0=Normal/Input, 1=Output)
  3     Unused (0)
  4-7   GPIO33[0-3] Data Direction (0=Normal/Input, 1=Output)
</TD></TR></TABLE>
Should be usually set to 00h=Input. When using output direction, the "Data In"
register will return the "Data Out" value ANDed with external inputs.<BR>
<BR>
Observe that HP#SP could be used as Output (output/low will probably cause the
DSi to believe that there is no headphone connected, thus forcing the internal
speakers to be enabled; possible with/without disabling the headphones?).<BR>
<BR>
<B>4004C02h DSi7 - GPIO Interrupt Edge Select (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-2   GPIO18[0-2] Interrupt Edge Select (0=Falling, 1=Rising)
  3     Unused (0)
  4-7   GPIO33[0-3] Interrupt Edge Select (0=Falling, 1=Rising)
</TD></TR></TABLE>
<BR>
<B>4004C03h DSi7 - GPIO Interrupt Enable      (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-2   GPIO18[0-2] Interrupt Enable (0=Disable, 1=Enable)
  3     Unused (0)
  4-7   GPIO33[0-3] Interrupt Enable (0=Disable, 1=Enable)
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsiconsoleids"></A>&nbsp;
  DSi Console IDs
</FONT></TD></TR></TABLE><BR>
The DSi contains several unique per-console numbers:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  CPU/Console ID     - Found in Port 4004D00h, in AES Keys, and in Files
  eMMC CID Register  - Found in Main RAM, and in eMMC CID register
  Serial/Barcode     - Found in Main RAM, and on stickers, and in HWINFO_S.dat
  Wifi MAC Address   - Found in Main RAM, and in Wifi FLASH
  Nintendo WFC ID    - Found in Wifi FLASH
</TD></TR></TABLE>
<BR>
<B>4004D00h - DSi7 - CPU/Console ID Code (64bit)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-63  CPU/Console ID Code
</TD></TR></TABLE>
This appears to be a PROM inside of the CPU TWL chip. The value is used to
initialize KEY_X values for eMMC encryption/decryption. Common 64bit settings
are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  08A20nnnnnnnn1nnh  for DSi
  08201nnnnnnnn1nnh  for DSi XL
  ????????????????h  for 3DS
</TD></TR></TABLE>
The "n" digits appear to be always in BCD range (0..9), the other digits appear
to be fixed (on all known consoles; ie. on three DSi's and two DSi XL's and
null 3DS's). For 3DS it's unknown if 4004D00h exists in DSi mode (though
there's probably a similar register in 3DS mode). The 64bit value is also
stored as 16-byte ASCII string in "dev.kp". And, the ASCII string is also
stored in footer of "Tad Files on SD Cards".<BR>
Port 4004D00h should be read only if the flag in 4004D08h is zero. Moreover,
Port 4004D00h can be read only firmware, and get's disabled for all known
games, so exploits will only see zeroes in 4004D00h..4004D08h.<BR>
Easiest way to obtain the 64bit value would be extracting it from SD Card
(using modified "DSi SRL Extract" source code).<BR>
<A HREF="#dsisdmmctadfilesonsdcards">DSi SD/MMC Tad Files on SD Cards</A><BR>
Obtaining the 64bit value by DSi software is working only indirectly:<BR>
With sudokuhax it can be simply "read" from 40044E0h (LSW) and 40044ECh (MSW).
Whereas, that ports are write-only, so it needs some small efforts to "read"
them.<BR>
With other exploits it's a bit more difficult: The values at 40044D4h..40044FBh
are destroyed, but 40044D0h..40044D3h is left intact, which can be used to
compute the original MSW value at 40044ECh, using a bunch of constants and
maths operations (caution: the result may depend on carry-in from unknown LSBs,
eg. the MSW may appear as 08A2nnnnh or 08E2nnnnh). Next, one can simply
brute-force the LSW (there should be only 10 million combinations (assuming it
to be a BCD number with one fixed digit), which could be scanned within less
than 6 minutes using the DSi AES hardware).<BR>
<BR>
<B>4004D08h - DSi7 - CPU/Console ID Flag (1bit)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     CPU/Console ID Flag (0=Okay, 1=Bad)
  1-15  Unknown/Unused (0)
</TD></TR></TABLE>
Some flag that indicates whether one can read the CPU/Console ID from Port
4004D00h. The flag should be usually zero (unknown when it could be nonzero,
maybe when the internal PROM wasn't programmed yet; which should never happen
in retail units).<BR>
<BR>
<B>eMMC CID Register</B><BR>
The CID can be read via SD/MMC commands, and it's also stored at 2FFD7BCh in
RAM; the RAM value is little-endian 120bit (ie. without the CRC7 byte),
zeropadded to 16-bytes (with 00h in MSB); the value looks as so;<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  MY ss ss ss ss 03 4D 30 30 46 50 41 00 00 15 00    ;CID for DSi and DSi XL
  MY ss ss ss ss 03 47 31 30 43 4D 4D 00 01 11 00    ;CID for 3DS
</TD></TR></TABLE>
The value is used to initialize AES_IV register for eMMC encryption/decryption.<BR>
The "MY" byte contains month/year; with Y=0Bh..0Dh for 2008..2010 (Y=0Eh..0Fh
would be 2011..2012, but there aren't any known DSi/3DS consoles using that
values) (unknown how 2013 and up would be assigned; JEDEC didn't seem to mind
to define them yet). The "ss" digits are a 32bit serial number (or actually it
looks more like a 32bit random number, not like a incrementing serial value).<BR>
Without a working exploit (for reading RAM at 2FFD7BCh), the CID could be
obtained by connecting wires to the eMMC chip. However, this might require
whatever custom hardware/software setup (unknown if any standard tools like PC
card readers are able to read the CID value).<BR>
<BR>
<B>Serial/Barcode</B><BR>
The barcode is found on a sticker on the bottom of console (and on an identical
sticker underneath of the battery). It's also stored as ASCII string in
HWINFO_S.dat file, and at 2FFFD71h in RAM. The barcode contains 2-3 letters,
followed by 9 decimal digits. Known barcodes are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  TEFnnnnnnnnn   DSi    (europe)
  TEHnnnnnnnnn   DSi    (europe)
  TWnnnnnnnnn    DSi    (us)
  WEFnnnnnnnnn   DSi XL (europe)
  WWnnnnnnnnn    DSi XL (us)
</TD></TR></TABLE>
3DS are CWnnnnnnnnn according to Nintendo (or maybe with 3 letters in europe).<BR>
Unknown if the barcode is internally used for any purposes (such like
encryption, or network identification).<BR>
The last digit is probably a checksum (at least, that would be common for
general barcodes).<BR>
<BR>
<B>Wifi MAC Address   - Found in Main RAM, and in Wifi FLASH</B><BR>
The MAC is a unique 48bit number needed for Wifi communications. The MAC is
stored in Wifi FLASH, and it's also stored at 2FFFCF4h in RAM. The MAC can be
also viewed in Firmware (see System Settings, Internet, Options, System
Information). Common values for DSi are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00 22 4C xx xx xx    ;seen in DSi XL
  00 23 CC xx xx xx    ;seen in DSi
  00 24 1E xx xx xx    ;seen in DSi
  00 27 09 xx xx xx    ;seen in DSi
</TD></TR></TABLE>
The value isn't used for eMMC encryption (the eMMC is still accessible when
swapping the Wifi daughterboard). However, games stored on SD card are
reportedly containing the MAC value (unknown if that is any causing issues when
running the games on a console with swapped Wifi daughterboard).<BR>
<BR>
<B>Nintendo WFC ID</B><BR>
This is some unknown purpose value stored in Wifi FLASH. The value can viewed
in Firmware (see System Settings, Internet, Options, System Information). The
firmware does only show the lower 43bit of the value, in decimal format,
multiplied by 1000, whilst the actual WFC in FLASH seems to be about 14 bytes
(112bit). The firmware does also allow to "delete" and "transfer" the "WFC
Configuration" (whatever that means).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsiunknownregisters"></A>&nbsp;
  DSi Unknown Registers
</FONT></TD></TR></TABLE><BR>
<B>40021A0h ... second NDS cart slot, DSi prototype relict (?)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ARM9: Can be set to 00000000h or 0000E043h
  ARM7: Can be set to 00000000h or 0000E043h
</TD></TR></TABLE>
<BR>
<B>40021A4h ... second NDS cart slot, DSi prototype relict (?)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ARM9: Can be set to 20000000h or FF7F7FFFh
  ARM7: Can be set to 00000000h or FF7F7FFFh
</TD></TR></TABLE>
Can be all-zero on arm7, uh, or is that due to port being disabled somehow?<BR>
<BR>
<B>4004600h - DSi7 - MIC_CNT - Microphone Control (can be 0000E10Fh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-1   Bits per sample? Or "stereo"? (0..2, 3=None)    (R/W)
  2-3   Sampling Rate  (0..3=F/1, F/2, F/3, F/4)        (R/W)
  4-7   Unknown/Unused (0)                              (0?)
  8     Status...    (1=Empty?)                         (R)
  9     Status...    (1=Not empty?)                     (R)
  10    Status...    (1=More data?)                     (R)
  11    Status...    (1=Overrun?)                       (R)
  12    Reset? (maybe clear MIC_DATA fifo?)             (W?)
  13    IRQ Enable      ?  ;\maybe one is not-empty and (R/W)
  14    IRQ Enable, too ?  ;/half-full or overrun ?     (R/W)
  15    Enable                                          (R/W)
</TD></TR></TABLE>
The Sampling Rate depends on the I2S frequency in SNDEXCNT.Bit13,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  I2S=32.73kHz --&gt; F/1=32.73kHz, F/2=16.36kHz, F/3=10.91kHz, F/4=8.18kHz
  I2S=47.61kHz --&gt; F/1=47.61kHz, F/2=23.81kHz, F/3=15.87kHz, F/4=11.90kHz
</TD></TR></TABLE>
The Sampling Rate becomes zero (no data arriving) when SNDEXCNT.Bit15=0, or
when MIC_CNT.bit0-1=3... and probably also when MIC_CNT.bit15=0 ?<BR>
<BR>
<B>4004604h - DSi7 - MIC_DATA - Microphone Data (R?)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-31  Data
</TD></TR></TABLE>
Currently, this is always returning 00000000h or FFFFFFFFh. Theoretically, it
should contain two 16bit samples (or four 8bit samples in case 8bit is also
supported). Appears to be required to enable the external A/D converter,
probably via Touchscreen SPI commands (there might be a MIC enable flag, there
should be a Gain setting with at least 120 possible selections, and there might
be also some other stuff like BIAS for signed/unsigned data selection).<BR>
<BR>
<B>4004C04h - DSi7 - GPIO? Unknown</B><BR>
<B>4004C05h - DSi7 - GPIO? Unknown</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Unknown
  1-7   Zero
</TD></TR></TABLE>
Maybe GPIO related, or something else.<BR>
<BR>
<B>Dead Registers</B><BR>
Cooking coach has disabled several DSi7 registers:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4004000h-40FFh ARM7 System Control (though ARM9-side isn't disabled)
  4004800h-49FFh ARM7 SD/MMC (though 4A00h-4BFFh are somewhat present)
</TD></TR></TABLE>
Accordingly, there isn't much known about them since they cannot be used/tested
with the cooking coach exploit.<BR>
Note: Other cartridges (eg. System Flaw) do access SD/MMC ports, so there might
be way to access those ports (if somebody finds an exploit for those games).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsinotes"></A>&nbsp;
  DSi Notes
</FONT></TD></TR></TABLE><BR>
<B>DSi Detection</B><BR>
Cartridges are using the same executable for NDS and DSi mode, the executable
must thus detect whether it is running on a NDS console or DSi console. At ARM9
this is usually done as follows:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  if ([4004000h] AND 03h)=01h then DSi_mode else NDS_mode
</TD></TR></TABLE>
On ARM7 side, the executables are attempting to do the same thing, but they are
(maybe accidently) skipping the detection depending on a 2nd I/O port:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ;Caution: Below detection won't work with DSi exploits (because they are
  ;  usually having the ARM7 SCFG registers disabled - it would be thus better
  ;  to do the dection only on ARM9 side as described above, and then forward
  ;  the result to ARM7 side).
  if ([4004008h] AND 80000000h)=0 then skip_detection_and_assume_NDS_mode
  else if ([4004000h] AND 03h)=01h then DSi_mode else NDS_mode
</TD></TR></TABLE>
In DSi_mode, the game can use additional hardware features, and it must be also
aware of some changed BIOS SWI functions.<BR>
In NDS_mode, the game can use only old hardware features, in case of
DSi-exclusive games: The cartridge must contain a small NDS function that
displays a message saying that the game will work only on DSi consoles.<BR>
<BR>
<B>DSi Executables</B><BR>
The boot executables &amp; entrypoints are always defined in the ARM9/ARM7
entries in cartridge header, regardless of whether the game is running on a NDS
console or DSi console. The ARM9/ARM7 executables are thus restricted to max
2MByte size (for not violating the NDS memory limit). The ARM9i/ARM7i entries
are allowing to load additional code or data, presumably to addresses (almost)
anywhere within the DSi's 16MByte memory space. Of course, if you want to use
separate executables for NDS and DSi mode, then you can put some small
bootstrap loader into the ARM9/ARM7 area, which will then load the actual main
executables.<BR>
<BR>
<B>DSi Official Games</B><BR>
There are only a few DSi-Exclusive games, and quite a lot of DSi-Enhanced
games. The package of that games doesn't seem bear any DSi-logos, so it's hard
to tell if a game contains DSi features (except via inofficial databases).<BR>
<BR>
<B>DSi Homebrew Games</B><BR>
These are extremly rare, hard to find, and practically non-existant yet. Most
webpages are mis-offering NDS games as "homebrew DSi games" (which, well, they
may work on DSi, but only in NDS mode).<BR>
There are a few "real" DSi homebrew games/emus/demos: Atari 5200 EMU, Atari
7800 EMU, CQuake, DSx86, GBA Emulator, Project Legends DS, Sandbox Engine,
StellaDS, Zoomx3 - most or all of them seem to require weird DSi exploits
(probably CycloDS iEvolution flashcarts), the games appear to be completely
lacking DSi cartridge headers, without even setting the DSi flag in
cartheader[012h].bit1 (and instead they do contain pre-historic NDS-passme
headers for booting from GBA slot, which is definetely incompatible with real
DSi consoles).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsiexploits"></A>&nbsp;
  DSi Exploits
</FONT></TD></TR></TABLE><BR>
DSi executables require RSA signatures (signed with Nintendo's private key),
which is making it impossible to run any unlicensed/homebrew code, except via
exploits. As by now there aren't any known BIOS, Firmware, or Browser exploits.
But, there are savegame exploits for several games which are quite fine for
running custom code. One downside is that many games are (permanently)
disabling unused hardware before hitting the exploit, so exploits aren't giving
access to all DSi features (eg. no SD/MMC access with some exploits).<BR>
<BR>
<B>Firmware Updates</B><BR>
Nintendo tends to block exploits in newer firmware updates. So many exploits
will work only with old DSi consoles, and only if the firmware wasn't updated.<BR>
However, there are loads of DSi enhanced games, so it should be possible to
find more exploits which aren't blocked by current firmwares.<BR>
Also unknown if Nintendo has really completely blocked the existing exploits
(which would require patching the games; if they have just 'repaired' the
savegame states before starting the games, then one could still overcome it by
mapping the correct savegame content at time when starting the game).<BR>
Note: The current firmware version is shown in the DSi's System Settings menu.
Firmware updates can be downloaded via internet (via System Update option in
System Settings menu). Nintendo doesn't allow to access the DSi shop without
doing a prior firmware update (otherwise, when not using the shop, then there
is no good reason to update the firmware).<BR>
<BR>
<B>Cooking Coach exploit</B><BR>
Cooking Coach is the best thing ever. This game allows you to make heathy food
with dead animals - and, with wintermute's exploit, it's allowing to run
homebrew code on the DSi (it's most comfortable when using it with dslink for
booting your executables via Wifi). The exploit is auto-starting right after
the game's UBI soft intro screen. And, the cartridge is dirt-cheap (should be
available for $5 including shipping).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  TWL-VCKE-USA  My Healthy Cooking Coach (US)
  TWL-VCKV-UKV  My Cooking Coach - Prepare Healthy Recipes (UK)
  TWL-VCKS-SPA  Mi Experto en Cocina - Comida Saludable
  TWL-VCKF-FRA  Mon Coach Personnel - Mes Recettes Plaisir et Ligne (F)
  TWL-VCKI-ITA  Il Mio Coach di Cucina - Prepara Cibi Sani e Gustosi (I)
  TWL-VCKD-NOE  Mein Koch-Coach - Gesund und Lecker Kochen (DE)
</TD></TR></TABLE>
You'll either need the US version for US region, or one of the various
localized versions for europe (eg. the german and UK versions are both working
in germany).<BR>
<BR>
<B>Other cartridge &amp; DSiware exploits</B><BR>
XXX...<BR>
DSiware exploits (eg. Sudokuhax) are having a double restriction: Aside from
being blocked in newer firmwares, Nintendo is also removing/replacing the game
in DSi Shop (so such exploits will work only if you are BOTH having an old
firmware version AND an old version of the game).<BR>
<BR>
<B>Proxy Servers</B><BR>
The proxy setting (in System Menu, Internet connection settings) allows to
redirect internet addresses to custom servers (combined with a custom proxy
server).<BR>
There isn't any proxy exploit for running homebrew code yet, but the project on
http://pbsds.net/ is using a custom proxy to redirect Flipnote to a homebrew
server.<BR>
<BR>
<B>Firmware Downgrading</B><BR>
Firmware downgrading works only if you've previously made a backup of YOUR own
firmware (copies from OTHER consoles won't work because firmwares are encrypted
with per-console keys). Moreover, downgrading works only by soldering wires to
the eMMC chip (or via exploits with working SD/MMC access, but if you have such
an exploit working with your firmware, then it would be rather pointless to
downgrade).<BR>
<BR>
<B>Main Memory Hacks</B><BR>
This requires to desolder the Main RAM chip, and to replace it by some external
hardware, which is allowing to log RAM accesses, and to patch the RAM contents,
and thus allowing to execute custom program code.<BR>
The patching hardware is essentially working similar to a Game Genie cheat
device. However, it envolves soldering about 50 tiny wires to the DSi
mainboard, which does require a lot of patience, a microscope may be also of
good help.<BR>
Running code works as soon as the DSi executes code in Main RAM. That is, after
leaving the BIOS boot code (thus not allowing to dump the entire BIOS memory;
this would be possible only via chip decapping). Still, it allows to execute
code before starting games (thus allowing to dump some firmware code, and to
access the whole hardware including SD/MMC slot, and allowing to dump some
keys).<BR>
The original DSi main memory hack has been done scanlime. As far as I known,
scanlime has later given the circuit to some other hacker. There appears to be
also somebody with a similar hack for 3DS. But, aside from that 3 people,
there's probably nobody else with such hardware.<BR>
Unknown if the hack can be used to dump decrypted copies of the DSi firmware
boot sectors.<BR>
<BR>
<B>Modchips (none such exist yet)</B><BR>
Modchips would allow to patch bits in Main RAM. Unlike classic Main Memory
Hacks, this would require to connect only 2 pins to the Main RAM chip.<BR>
For example, it could be combined with the Cooking Coach exploit: Patching the
STR r0,[4004008h] opcode at 2380250h should maintain full access to the whole
DSi hardware.<BR>
Even better, patching firmware code might allow to boot cartridges or SD card
files without RSA signatures (not sure if that's really possible; it would
require the RSA checks to be located in Main RAM, but won't work if they reside
in WRAM or TCM).<BR>
<BR>
<B>Flashcarts</B><BR>
As of 2015, the majority of "DSi compatible" flashcarts are merely allowing to
run games on the DSi in NDS mode (but not in DSi mode, ie. without access to
any of the new DSi hardware).<BR>
As by now, there is only one flashcart with "DSi mode" support: CycloDS
iEvolution; which is internally using the Cooking Coach exploit, giving it the
same restrictions (ie. no SD/MMC access).<BR>
Essentially, flashcarts aren't really recommended for programmers (swapping the
cart between PC and DSi is ways more uncomfortable than booting via Wifi, and
the typical flashcart bootmenus are just another obstacle for getting your code
started).<BR>
Similar as normal exploits, flashcarts are blocked in newer Firmware versions.<BR>
<BR>
<B>Dslink / DSilink</B><BR>
Dslink is allowing to upload .nds executables from PC to DS/DSi via local Wifi
network - which is extremly comfortable for programmers, and it seems to be
working quite flawless with different WLAN routers, and works fine even under
Win98. Dslink can be booted from flashcarts, or (better) it can be combined
with DSi exploits like cooking coach.<BR>
Anyways, some cautions:<BR>
Wifi access point must be already configured in SPI FLASH (ie. using a NDS game
with internet support, or via DSi bootmenu (the DSi bootmenu can configure
three old WEP and three new WPA access points separately; currently only the
old ones work for dslink)).<BR>
Dsilink installation software allows to store the dslink software on SPI flash
(required as it won't fit into 8Kbyte savegame area from DSi exploits). The
Dsilink installation software does also include the 8Kbyte savegame images (for
various localized cooking coach versions), however, it doesn't auto-install
them in cooking coach carts (there is a suggested utility for doing that on the
dslink page, but that utility is crap and doesn't work, so you will need to
write own code for transferring the eeprom image to real eeprom).<BR>
Currently only libnds-base programs can be booted via dslink - apparently there
are major initialization issues (like uninitialized stack pointers,
uninitialized RAM or I/O port contents, misconfigured protection unit, etc.).
My own nocash/a22i code is just crashing, same applies for official Wifi demos
like Eragon.<BR>
Currently only WEP encryption (or no encryption) is supported, so it won't work
if your WLAN router is configured to use WPA/WPA2. In case of trouble, try if
it works with other routers.<BR>
Currently only the NDS areas from the cart header are uploaded (this can be
used to run code in DSi mode, as long as the extra DSi areas from cart header
aren't used).<BR>
Currently only NDS-style transfer rate is supported (ie. max 2 Mbit/s even
though DSi hardware should support up to 54 Mbit/s).<BR>
The PC is using broadcast-mode to auto-connect to any DSi in your local network
- if that doesn't work for some reason (or if you have multiple DSi's in the
network) than you can specify the DSi's local IP address manually on PC side.<BR>
Currently the DS/DSi side is extremly slow on finding the access point (takes
about 1-2 seconds for unknown reason; almost looks as if it is scanning all
channels or so).<BR>
DSi exploits can have some restrictions (eg. SD/MMC hardware disabled), so same
restrictions will also when combining the exploits with dslink.<BR>
As by now, restarting dslink does require manually rebooting via power button
and completely rebooting the console (including going through unpleasant boot
menu and health and safety screens). More ideally, future homebrew games should
be allowed to use some backdoor mechanism (watching for wifi broadcasts, and
then rebooting automatically, without the boot menu and health/safety crap). To
some level that's already possible (eg. you can manually reboot the dslink
software some way of your choice).<BR>
Dslink isn't working on certain newer DSi versions, reportedly due to wifi
hardware being disabled on newer DSi, unknown what exactly is causing that
problems on which specific DSi hardware/firmware versions.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="dsiregions"></A>&nbsp;
  DSi Regions
</FONT></TD></TR></TABLE><BR>
There are several (mostly unknown) DSi regions. Some info can be found in DSi
Firmware (this should help to identify unknown regions):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Go to "System Settings"
  Check the firmware version on upper screen (eg. "Ver 1.4E" for Europe)
  Check the "Language" option, that should list languages for your region.
  Check the "Country" option, that should list all countries of your region.
</TD></TR></TABLE>
<BR>
<B>US Region</B><BR>
Unknown (supposedly including USA, and maybe Canada, South America, etc.)<BR>
<BR>
<B>JP Region</B><BR>
Unknown (supposedly including Japan)<BR>
<BR>
<B>Chinese Region</B><BR>
Unknown (supposedly including China)<BR>
<BR>
<B>Korean Region</B><BR>
Unknown (supposedly including Korea)<BR>
<BR>
<B>Australia Region - 2 countries, 1 language (as of DSi Firmware Ver 1.4.5A)</B><BR>
Languages:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  English (only english, there is no language option at all)
</TD></TR></TABLE>
Countries:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Australia
  New Zealand
</TD></TR></TABLE>
<BR>
<B>Europe Region - 47 countries, 5 languages (as of DSi Firmware Ver 1.4E)</B><BR>
Languages:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  English
  Francais (=French)
  Deutsch  (=German)
  Espanol  (=Spanish)
  Italiano (=Italian)
</TD></TR></TABLE>
Countries:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Albania
  Austria
  Belgium
  Bosnia and Herzegovnia
  Botswana
  Bulgaria
  Croatia
  Cyprus
  Czech Republic
  Denmark
  Estonia
  Finland
  France
  Germany
  Greece
  Hungary
  Iceland
  Ireland
  Italy
  Latvia
  Lesotho
  Liechtenstein
  Lithuania
  Luxembourg
  Macedonia
  Malta
  Montenegro
  Mozambique
  Namibia
  Netherlands
  Norway
  Poland
  Portugal
  Romania
  Russia
  Serbia
  Slovakia
  Slovenia
  South Africa
  Spain
  Swaziland
  Sweden
  Switzerland
  Turkey
  United Kindgom
  Zambia
  Zimbabwe
</TD></TR></TABLE>
<BR>
Note that Nintendo might expand those regions (for example, newer 'european'
firmware versions might include additional african countries; unless those
missing countries are already part of other/unknown regions).<BR>
The purpose of the "Country" option is unknown (maybe Nintendo has servers in
different countries for online games). One known effect is that the "Parental
Controls" options are localized for the country (eg. "USK ab 18" for germany,
or "18'TM" for france/finland).<BR>
The "Language" option affects the Firmware GUI, and the game title (from
Icon/Title structure). Some games are also adopting the Firmware's language
setting for choosing the in-game language.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="armcpureference"></A>&nbsp;
  ARM CPU Reference
</FONT></TD></TR></TABLE><BR>
<B>General ARM7TDMI Information</B><BR>
<A HREF="#armcpuoverview">ARM CPU Overview</A><BR>
<A HREF="#armcpuregisterset">ARM CPU Register Set</A><BR>
<A HREF="#armcpuflagsconditionfieldcond">ARM CPU Flags &amp; Condition Field (cond)</A><BR>
<A HREF="#armcpu26bitmemoryinterface">ARM CPU 26bit Memory Interface</A><BR>
<A HREF="#armcpuexceptions">ARM CPU Exceptions</A><BR>
<A HREF="#armcpumemoryalignments">ARM CPU Memory Alignments</A><BR>
<BR>
<B>ARM 32bit Instruction Set (ARM Code)</B><BR>
<A HREF="#arminstructionsummary">ARM Instruction Summary</A><BR>
<A HREF="#armopcodesbranchandbranchwithlinkbblbxblxswibkpt">ARM Opcodes: Branch and Branch with Link (B, BL, BX, BLX, SWI, BKPT)</A><BR>
<A HREF="#armopcodesdataprocessingalu">ARM Opcodes: Data Processing (ALU)</A><BR>
<A HREF="#armopcodesmultiplyandmultiplyaccumulatemulmla">ARM Opcodes: Multiply and Multiply-Accumulate (MUL, MLA)</A><BR>
<A HREF="#armopcodesspecialarm9instructionsclzqaddqsub">ARM Opcodes: Special ARM9 Instructions (CLZ, QADD/QSUB)</A><BR>
<A HREF="#armopcodespsrtransfermrsmsr">ARM Opcodes: PSR Transfer (MRS, MSR)</A><BR>
<A HREF="#armopcodesmemorysingledatatransferldrstrpld">ARM Opcodes: Memory: Single Data Transfer (LDR, STR, PLD)</A><BR>
<A HREF="#armopcodesmemoryhalfworddoublewordandsigneddatatransfer">ARM Opcodes: Memory: Halfword, Doubleword, and Signed Data Transfer</A><BR>
<A HREF="#armopcodesmemoryblockdatatransferldmstm">ARM Opcodes: Memory: Block Data Transfer (LDM, STM)</A><BR>
<A HREF="#armopcodesmemorysingledataswapswp">ARM Opcodes: Memory: Single Data Swap (SWP)</A><BR>
<A HREF="#armopcodescoprocessorinstructionsmrcmcrldcstccdpmcrrmrrc">ARM Opcodes: Coprocessor Instructions (MRC/MCR, LDC/STC, CDP, MCRR/MRRC)</A><BR>
<BR>
<B>ARM 16bit Instruction Set (THUMB Code)</B><BR>
When operating in THUMB state, cut-down 16bit opcodes are used.<BR>
THUMB is supported on T-variants of ARMv4 and up, ie. ARMv4T, ARMv5T, etc.<BR>
<A HREF="#thumbinstructionsummary">THUMB Instruction Summary</A><BR>
<A HREF="#thumbopcodesregisteroperationsalubx">THUMB Opcodes: Register Operations (ALU, BX)</A><BR>
<A HREF="#thumbopcodesmemoryloadstoreldrstr">THUMB Opcodes: Memory Load/Store (LDR/STR)</A><BR>
<A HREF="#thumbopcodesmemoryaddressingaddpcsp">THUMB Opcodes: Memory Addressing (ADD PC/SP)</A><BR>
<A HREF="#thumbopcodesmemorymultipleloadstorepushpopandldmstm">THUMB Opcodes: Memory Multiple Load/Store (PUSH/POP and LDM/STM)</A><BR>
<A HREF="#thumbopcodesjumpsandcalls">THUMB Opcodes: Jumps and Calls</A><BR>
<BR>
<B>Note</B><BR>
Switching between ARM and THUMB state can be done by using the Branch and
Exchange (BX) instruction.<BR>
<BR>
<B>Further Information</B><BR>
<A HREF="#armpseudoinstructionsanddirectives">ARM Pseudo Instructions and Directives</A><BR>
<A HREF="#armcp15systemcontrolcoprocessor">ARM CP15 System Control Coprocessor</A><BR>
<A HREF="#armcpuinstructioncycletimes">ARM CPU Instruction Cycle Times</A><BR>
<A HREF="#armcpuversions">ARM CPU Versions</A><BR>
<A HREF="#armcpudatasheet">ARM CPU Data Sheet</A><BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="armcpuoverview"></A>&nbsp;
  ARM CPU Overview
</FONT></TD></TR></TABLE><BR>
The ARM7TDMI is a 32bit RISC (Reduced Instruction Set Computer) CPU, designed
by ARM (Advanced RISC Machines), and designed for both high performance and low
power consumption.<BR>
<BR>
<B>Fast Execution</B><BR>
Depending on the CPU state, all opcodes are sized 32bit or 16bit (that's
counting both the opcode bits and its parameters bits) providing fast decoding
and execution. Additionally, pipelining allows - (a) one instruction to be
executed while (b) the next instruction is decoded and (c) the next instruction
is fetched from memory - all at the same time.<BR>
<BR>
<B>Data Formats</B><BR>
The CPU manages to deal with 8bit, 16bit, and 32bit data, that are called:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
   8bit - Byte
  16bit - Halfword
  32bit - Word
</TD></TR></TABLE>
<BR>
<B>The two CPU states</B><BR>
As mentioned above, two CPU states exist:<BR>
- ARM state: Uses the full 32bit instruction set (32bit opcodes)<BR>
- THUMB state: Uses a cutdown 16bit instruction set (16bit opcodes)<BR>
Regardless of the opcode-width, both states are using 32bit registers, allowing
32bit memory addressing as well as 32bit arithmetic/logical operations.<BR>
<BR>
<B>When to use ARM state</B><BR>
Basically, there are two advantages in ARM state:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 - Each single opcode provides more functionality, resulting
   in faster execution when using a 32bit bus memory system
   (such like opcodes stored in GBA Work RAM).
 - All registers R0-R15 can be accessed directly.
</TD></TR></TABLE>
The downsides are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 - Not so fast when using 16bit memory system
   (but it still works though).
 - Program code occupies more memory space.
</TD></TR></TABLE>
<BR>
<B>When to use THUMB state</B><BR>
There are two major advantages in THUMB state:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 - Faster execution up to approx 160% when using a 16bit bus
   memory system (such like opcodes stored in GBA GamePak ROM).
 - Reduces code size, decreases memory overload down to approx 65%.
</TD></TR></TABLE>
The disadvantages are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 - Not as multi-functional opcodes as in ARM state, so it will
   be sometimes required use more than one opcode to gain a
   similar result as for a single opcode in ARM state.
 - Most opcodes allow only registers R0-R7 to be used directly.
</TD></TR></TABLE>
<BR>
<B>Combining ARM and THUMB state</B><BR>
Switching between ARM and THUMB state is done by a normal branch (BX)
instruction which takes only a handful of cycles to execute (allowing to change
states as often as desired - with almost no overload).<BR>
<BR>
Also, as both ARM and THUMB are using the same register set, it is possible to
pass data between ARM and THUMB mode very easily.<BR>
<BR>
The best memory &amp; execution performance can be gained by combining both
states: THUMB for normal program code, and ARM code for timing critical
subroutines (such like interrupt handlers, or complicated algorithms).<BR>
<BR>
Note: ARM and THUMB code cannot be executed simultaneously.<BR>
<BR>
<B>Automatic state changes</B><BR>
Beside for the above manual state switching by using BX instructions, the
following situations involve automatic state changes:<BR>
- CPU switches to ARM state when executing an exception<BR>
- User switches back to old state when leaving an exception<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="armcpuregisterset"></A>&nbsp;
  ARM CPU Register Set
</FONT></TD></TR></TABLE><BR>
<B>Overview</B><BR>
The following table shows the ARM7TDMI register set which is available in each
mode. There's a total of 37 registers (32bit each), 31 general registers (Rxx)
and 6 status registers (xPSR).<BR>
Note that only some registers are 'banked', for example, each mode has it's own
R14 register: called R14, R14_fiq, R14_svc, etc. for each mode respectively.<BR>
However, other registers are not banked, for example, each mode is using the
same R0 register, so writing to R0 will always affect the content of R0 in
other modes also.<BR>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
<B>  System/User FIQ       Supervisor Abort     IRQ       Undefined</B>
  --------------------------------------------------------------
  R0          R0        R0         R0        R0        R0
  R1          R1        R1         R1        R1        R1
  R2          R2        R2         R2        R2        R2
  R3          R3        R3         R3        R3        R3
  R4          R4        R4         R4        R4        R4
  R5          R5        R5         R5        R5        R5
  R6          R6        R6         R6        R6        R6
  R7          R7        R7         R7        R7        R7
  --------------------------------------------------------------
  R8          R8_fiq    R8         R8        R8        R8
  R9          R9_fiq    R9         R9        R9        R9
  R10         R10_fiq   R10        R10       R10       R10
  R11         R11_fiq   R11        R11       R11       R11
  R12         R12_fiq   R12        R12       R12       R12
  R13 (SP)    R13_fiq   R13_svc    R13_abt   R13_irq   R13_und
  R14 (LR)    R14_fiq   R14_svc    R14_abt   R14_irq   R14_und
  R15 (PC)    R15       R15        R15       R15       R15
  --------------------------------------------------------------
  CPSR        CPSR      CPSR       CPSR      CPSR      CPSR
  --          SPSR_fiq  SPSR_svc   SPSR_abt  SPSR_irq  SPSR_und
  --------------------------------------------------------------
</TD></TR></TABLE>
<BR>
<B>R0-R12 Registers (General Purpose Registers)</B><BR>
These thirteen registers may be used for whatever general purposes. Basically,
each is having same functionality and performance, ie. there is no 'fast
accumulator' for arithmetic operations, and no 'special pointer register' for
memory addressing.<BR>
However, in THUMB mode only R0-R7 (Lo registers) may be accessed freely, while
R8-R12 and up (Hi registers) can be accessed only by some instructions.<BR>
<BR>
<B>R13 Register (SP)</B><BR>
This register is used as Stack Pointer (SP) in THUMB state. While in ARM state
the user may decided to use R13 and/or other register(s) as stack pointer(s),
or as general purpose register.<BR>
As shown in the table above, there's a separate R13 register in each mode, and
(when used as SP) each exception handler may (and MUST!) use its own stack.<BR>
<BR>
<B>R14 Register (LR)</B><BR>
This register is used as Link Register (LR). That is, when calling to a
sub-routine by a Branch with Link (BL) instruction, then the return address
(ie. old value of PC) is saved in this register.<BR>
Storing the return address in the LR register is obviously faster than pushing
it into memory, however, as there's only one LR register for each mode, the
user must manually push its content before issuing 'nested' subroutines.<BR>
Same happens when an exception is called, PC is saved in LR of new mode.<BR>
Note: In ARM mode, R14 may be used as general purpose register also, provided
that above usage as LR register isn't required.<BR>
<BR>
<B>R15 Register (PC)</B><BR>
R15 is always used as program counter (PC). Note that when reading R15, this
will usually return a value of PC+nn because of read-ahead (pipelining),
whereas 'nn' depends on the instruction and on the CPU state (ARM or THUMB).<BR>
<BR>
<B>CPSR and SPSR (Program Status Registers) (ARMv3 and up)</B><BR>
The current condition codes (flags) and CPU control bits are stored in the CPSR
register. When an exception arises, the old CPSR is saved in the SPSR of the
respective exception-mode (much like PC is saved in LR).<BR>
For details refer to chapter about CPU Flags.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="armcpuflagsconditionfieldcond"></A>&nbsp;
  ARM CPU Flags &amp; Condition Field (cond)
</FONT></TD></TR></TABLE><BR>
<B>ARM Condition Field {cond}</B><BR>
The opcode {cond} suffixes can be used for conditionally executed code based on
the C,N,Z,V flags in CPSR register. For example: BEQ = Branch if Equal, MOVMI =
Move if Signed.<BR>
In ARM mode, {cond} can be used with all opcodes (except for a few newer ARMv5
instructions: BKPT, PLD, CDP2, LDC2, MCR2, MRC2, STC2, and BLX_imm are
nonconditional; however BLX_reg can be conditional).<BR>
In THUMB mode, {cond} can be used only for branch opcodes.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
<B>  Code Suffix Flags         Meaning</B>
  0:   EQ     Z=1           equal (zero) (same)
  1:   NE     Z=0           not equal (nonzero) (not same)
  2:   CS/HS  C=1           unsigned higher or same (carry set)
  3:   CC/LO  C=0           unsigned lower (carry cleared)
  4:   MI     N=1           negative (minus)
  5:   PL     N=0           positive or zero (plus)
  6:   VS     V=1           overflow (V set)
  7:   VC     V=0           no overflow (V cleared)
  8:   HI     C=1 and Z=0   unsigned higher
  9:   LS     C=0 or Z=1    unsigned lower or same
  A:   GE     N=V           greater or equal
  B:   LT     N&lt;&gt;V          less than
  C:   GT     Z=0 and N=V   greater than
  D:   LE     Z=1 or N&lt;&gt;V   less or equal
  E:   AL     -             always (the "AL" suffix can be omitted)
  F:   NV     -             never (ARMv1,v2 only) (Reserved ARMv3 and up)
</TD></TR></TABLE>
Execution Time: If condition=false: 1S cycle. Otherwise: as specified for the
respective opcode.<BR>
<BR>
<B>Current Program Status Register (CPSR)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  31    N - Sign Flag       (0=Not Signed, 1=Signed)               ;\
  30    Z - Zero Flag       (0=Not Zero, 1=Zero)                   ; Condition
  29    C - Carry Flag      (0=Borrow/No Carry, 1=Carry/No Borrow) ; Code Flags
  28    V - Overflow Flag   (0=No Overflow, 1=Overflow)            ;/
  27    Q - Sticky Overflow (1=Sticky Overflow, ARMv5TE and up only)
  26-8  Reserved            (For future use) - Do not change manually!
  7     I - IRQ disable     (0=Enable, 1=Disable)                     ;\
  6     F - FIQ disable     (0=Enable, 1=Disable)                     ; Control
  5     T - State Bit       (0=ARM, 1=THUMB) - Do not change manually!; Bits
  4-0   M4-M0 - Mode Bits   (See below)                               ;/
</TD></TR></TABLE>
<BR>
<B>Bit 31-28: Condition Code Flags (N,Z,C,V)</B><BR>
These bits reflect results of logical or arithmetic instructions. In ARM mode,
it is often optionally whether an instruction should modify flags or not, for
example, it is possible to execute a SUB instruction that does NOT modify the
condition flags.<BR>
In ARM state, all instructions can be executed conditionally depending on the
settings of the flags, such like MOVEQ (Move if Z=1). While In THUMB state,
only Branch instructions (jumps) can be made conditionally.<BR>
<BR>
<B>Bit 27: Sticky Overflow Flag (Q) - ARMv5TE and ARMv5TExP and up only</B><BR>
Used by QADD, QSUB, QDADD, QDSUB, SMLAxy, and SMLAWy only. These opcodes set
the Q-flag in case of overflows, but leave it unchanged otherwise. The Q-flag
can be tested/reset by MSR/MRS opcodes only.<BR>
<BR>
<B>Bit 27-8: Reserved Bits (except Bit 27 on ARMv5TE and up, see above)</B><BR>
These bits are reserved for possible future implementations. For best forwards
compatibility, the user should never change the state of these bits, and should
not expect these bits to be set to a specific value.<BR>
<BR>
<B>Bit 7-0: Control Bits (I,F,T,M4-M0)</B><BR>
These bits may change when an exception occurs. In privileged modes (non-user
modes) they may be also changed manually.<BR>
The interrupt bits I and F are used to disable IRQ and FIQ interrupts
respectively (a setting of "1" means disabled).<BR>
The T Bit signalizes the current state of the CPU (0=ARM, 1=THUMB), this bit
should never be changed manually - instead, changing between ARM and THUMB
state must be done by BX instructions.<BR>
The Mode Bits M4-M0 contain the current operating mode.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Binary Hex Dec  Expl.
  0xx00b 00h 0  - Old User       ;\26bit Backward Compatibility modes
  0xx01b 01h 1  - Old FIQ        ; (supported only on ARMv3, except ARMv3G,
  0xx10b 02h 2  - Old IRQ        ; and on some non-T variants of ARMv4)
  0xx11b 03h 3  - Old Supervisor ;/
  10000b 10h 16 - User (non-privileged)
  10001b 11h 17 - FIQ
  10010b 12h 18 - IRQ
  10011b 13h 19 - Supervisor (SWI)
  10111b 17h 23 - Abort
  11011b 1Bh 27 - Undefined
  11111b 1Fh 31 - System (privileged 'User' mode) (ARMv4 and up)
</TD></TR></TABLE>
Writing any other values into the Mode bits is not allowed.<BR>
<BR>
<B>Saved Program Status Registers (SPSR_&lt;mode&gt;)</B><BR>
Additionally to above CPSR, five Saved Program Status Registers exist:<BR>
SPSR_fiq, SPSR_svc, SPSR_abt, SPSR_irq, SPSR_und<BR>
Whenever the CPU enters an exception, the current status register (CPSR) is
copied to the respective SPSR_&lt;mode&gt; register. Note that there is only
one SPSR for each mode, so nested exceptions inside of the same mode are
allowed only if the exception handler saves the content of SPSR in memory.<BR>
For example, for an IRQ exception: IRQ-mode is entered, and CPSR is copied to
SPSR_irq. If the interrupt handler wants to enable nested IRQs, then it must
first push SPSR_irq before doing so.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="armcpu26bitmemoryinterface"></A>&nbsp;
  ARM CPU 26bit Memory Interface
</FONT></TD></TR></TABLE><BR>
The 26bit Memory Interface was used by ARMv1 and ARMv2. The 32bit interface is
used by ARMv3 and newer, however, 26bit backward compatibility was included in
all ARMv3 (except ARMv3G), and optionally in some non-T variants of ARMv4.<BR>
<BR>
<B>Format of R15 in 26bit Mode (Program Counter Register)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Name     Expl.
  31-28 N,Z,C,V  Flags (Sign, Zero, Carry, Overflow)
  27-26 I,F      Interrupt Disable bits (IRQ, FIQ) (1=Disable)
  25-2  PC       Program Counter, 24bit, Step 4 (64M range)
  1-0   M1,M0    Mode (0=User, 1=FIQ, 2=IRQ, 3=Supervisor)
</TD></TR></TABLE>
Branches with +/-32M range wrap the PC register, and can reach all 64M memory.<BR>
<BR>
<B>Reading from R15</B><BR>
If R15 is specified in bit16-19 of an opcode, then NZCVIF and M0,1 are masked
(zero), otherwise the full 32bits are used.<BR>
<BR>
<B>Writing to R15</B><BR>
ALU opcodes with S=1, and LDM opcodes with PSR=1 can write to all 32bits in R15
(in 26bit mode, that is allowed even in user mode, though it does then affect
only NZCF, not the write protected IFMM bits ???), other opcodes which write to
R15 will modify only the program counter bits. Also, special CMP/CMN/TST/TEQ{P}
opcodes can be used to write to the PSR bits in R15 without modifying the PC
bits.<BR>
<BR>
<B>Exceptions</B><BR>
SWIs, Reset, Data/Prefetch Aborts and Undefined instructions enter Supervisor
mode. Interrupts enter IRQ and FIQ mode. Additionally, a special 26bit Address
Exception exists, which enters Supervisor mode on accesses to memory
addresses&gt;=64M as follows:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  R14_svc = PC ($+8, including old PSR bits)
  M1,M0 = 11b = supervisor mode, F=same, I=1, PC=14h,
  to continue at the fault location, return by SUBS PC,LR,8.
</TD></TR></TABLE>
32bit CPUs with 26bit compatibility mode can be configured to switch into 32bit
mode when encountering exceptions.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="armcpuexceptions"></A>&nbsp;
  ARM CPU Exceptions
</FONT></TD></TR></TABLE><BR>
<B>Exception Vectors</B><BR>
The following are the exception vectors in memory. That is, when an exception
arises, CPU is switched into ARM state, and the program counter (PC) is loaded
by the respective address.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Address  Prio  Exception                  Mode on Entry      Interrupt Flags
  BASE+00h 1     Reset                      Supervisor (_svc)  I=1, F=1
  BASE+04h 7     Undefined Instruction      Undefined  (_und)  I=1, F=unchanged
  BASE+08h 6     Software Interrupt (SWI)   Supervisor (_svc)  I=1, F=unchanged
  BASE+0Ch 5     Prefetch Abort             Abort      (_abt)  I=1, F=unchanged
  BASE+10h 2     Data Abort                 Abort      (_abt)  I=1, F=unchanged
  BASE+14h ??    Address Exceeds 26bit      Supervisor (_svc)  I=1, F=unchanged
  BASE+18h 4     Normal Interrupt (IRQ)     IRQ        (_irq)  I=1, F=unchanged
  BASE+1Ch 3     Fast Interrupt (FIQ)       FIQ        (_fiq)  I=1, F=1
</TD></TR></TABLE>
BASE is normally 00000000h, but may be optionally FFFF0000h in some ARM CPUs.
Priority for simultaneously occuring exceptions ranges from Prio=1=Highest to
Prio=7=Lowest.<BR>
As there's only space for one ARM opcode at each of the above addresses, it'd
be usually recommended to deposit a Branch opcode into each vector, which'd
then redirect to the actual exception handlers address.<BR>
<BR>
<B>Actions performed by CPU when entering an exception</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  - R14_&lt;new mode&gt;=PC+nn   ;save old PC, ie. return address
  - SPSR_&lt;new mode&gt;=CPSR   ;save old flags
  - CPSR new T,M bits      ;set to T=0 (ARM state), and M4-0=new mode
  - CPSR new I bit         ;IRQs disabled (I=1), done by ALL exceptions
  - CPSR new F bit         ;FIQs disabled (F=1), done by Reset and FIQ only
  - PC=exception_vector    ;see table above
</TD></TR></TABLE>
Above "PC+nn" depends on the type of exception. Basically, in ARM state that
nn-offset is caused by pipelining, and in THUMB state an identical ARM-style
'offset' is generated (even though the 'base address' may be only
halfword-aligned).<BR>
<BR>
<B>Required user-handler actions when returning from an exception</B><BR>
Restore any general registers (R0-R14) which might have been modified by the
exception handler. Use return-instruction as listed in the respective
descriptions below, this will both restore PC and CPSR - that automatically
involves that the old CPU state (THUMB or ARM) as well as old state of FIQ and
IRQ disable flags are restored.<BR>
As mentioned above (see action on entering...), the return address is always
saved in ARM-style format, so that exception handler may use the same
return-instruction, regardless of whether the exception has been generated from
inside of ARM or THUMB state.<BR>
<BR>
<B>FIQ (Fast Interrupt Request)</B><BR>
This interrupt is generated by a LOW level on the nFIQ input. It is supposed to
process timing critical interrupts at a high priority, as fast as possible.<BR>
Additionally to the common banked registers (R13_fiq,R14_fiq), five extra
banked registers (R8_fiq-R12_fiq) are available in FIQ mode. The exception
handler may freely access these registers without modifying the main programs
R8-R12 registers (and without having to save that registers on stack).<BR>
In privileged (non-user) modes, FIQs may be also manually disabled by setting
the F Bit in CPSR.<BR>
<BR>
<B>IRQ (Normal Interrupt Request)</B><BR>
This interrupt is generated by a LOW level on the nIRQ input. Unlike FIQ, the
IRQ mode is not having its own banked R8-R12 registers.<BR>
IRQ is having lower priority than FIQ, and IRQs are automatically disabled when
a FIQ exception becomes executed. In privileged (non-user) modes, IRQs may be
also manually disabled by setting the I Bit in CPSR.<BR>
To return from IRQ Mode (continuing at following opcode):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  SUBS PC,R14,4   ;both PC=R14_irq-4, and CPSR=SPSR_irq
</TD></TR></TABLE>
<BR>
<B>Software Interrupt</B><BR>
Generated by a software interrupt instruction (SWI). Recommended to request a
supervisor (operating system) function. The SWI instruction may also contain a
parameter in the 'comment field' of the opcode:<BR>
In case that your main program issues SWIs from both inside of THUMB and ARM
states, then your exception handler must separate between 24bit comment fields
in ARM opcodes, and 8bit comment fields in THUMB opcodes (if necessary
determine old state by examining T Bit in SPSR_svc); However, in Little Endian
mode, you could use only the most significant 8bits of the 24bit ARM comment
field (as done in the GBA, for example) - the exception handler could then
process the BYTE at [R14-2], regardless of whether it's been called from ARM or
THUMB state.<BR>
To return from Supervisor Mode (continuing at following opcode):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  MOVS PC,R14   ;both PC=R14_svc, and CPSR=SPSR_svc
</TD></TR></TABLE>
Note: Like all other exceptions, SWIs are always executed in ARM state, no
matter whether it's been caused by an ARM or THUMB state SWI instruction.<BR>
<BR>
<B>Undefined Instruction Exception (supported by ARMv3 and up)</B><BR>
This exception is generated when the CPU comes across an instruction which it
cannot handle. Most likely signalizing that the program has locked up, and that
an errormessage should be displayed.<BR>
However, it might be also used to emulate custom functions, ie. as an
additional 'SWI' instruction (which'd use R14_und and SPSR_und though, and it'd
thus allow to execute the Undefined Instruction handler from inside of
Supervisor mode without having to save R14_svc and SPSR_svc).<BR>
To return from Undefined Mode (continuing at following opcode):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  MOVS PC,R14   ;both PC=R14_und, and CPSR=SPSR_und
</TD></TR></TABLE>
Note that not all unused opcodes are necessarily producing an exception, for
example, an ARM state Multiply instruction with Bit6=1 would be blindly
accepted as 'legal' opcode.<BR>
<BR>
<B>Abort (supported by ARMv3 and up)</B><BR>
Aborts (page faults) are mostly supposed for virtual memory systems (ie. not
used in GBA, as far as I know), otherwise they might be used just to display an
error message. Two types of aborts exists:<BR>
- Prefetch Abort (occurs during an instruction prefetch)<BR>
- Prefetch Abort (also occurs on BKPT opcodes, ARMv5 and up)<BR>
- Data Abort (occurs during a data access)<BR>
A virtual memory systems abort handler would then most likely determine the
fault address: For prefetch abort that's just "R14_abt-4". For Data abort, the
THUMB or ARM instruction at "R14_abt-8" needs to be 'disassembled' in order to
determine the addressed data in memory.<BR>
The handler would then fix the error by loading the respective memory page into
physical memory, and then retry to execute the SAME instruction again, by
returning as follows:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  prefetch abort: SUBS PC,R14,#4   ;PC=R14_abt-4, and CPSR=SPSR_abt
  data abort:     SUBS PC,R14,#8   ;PC=R14_abt-8, and CPSR=SPSR_abt
</TD></TR></TABLE>
Separate exception vectors for prefetch/data abort exists, each should use the
respective return instruction as shown above.<BR>
<BR>
<B>Address Exceeds 26bit</B><BR>
This exception can occur only on old ARM CPUs with 26bit address scheme (or in
26bit backwards compatibility mode).<BR>
<BR>
<B>Reset</B><BR>
Forces PC=VVVV0000h, and forces control bits of CPSR to T=0 (ARM state), F=1
and I=1 (disable FIQ and IRQ), and M4-0=10011b (Supervisor mode).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="armcpumemoryalignments"></A>&nbsp;
  ARM CPU Memory Alignments
</FONT></TD></TR></TABLE><BR>
The CPU does NOT support accessing mis-aligned addresses (which would be rather
slow because it'd have to merge/split that data into two accesses).<BR>
When reading/writing code/data to/from memory, Words and Halfwords must be
located at well-aligned memory address, ie. 32bit words aligned by 4, and 16bit
halfwords aligned by 2.<BR>
<BR>
<B>Mis-aligned STR,STRH,STM,LDM,LDRD,STRD,PUSH,POP (forced align)</B><BR>
The mis-aligned low bit(s) are ignored, the memory access goes to a forcibly
aligned (rounded-down) memory address.<BR>
For LDRD/STRD, it isn't clearly defined if the address must be aligned by 8 (on
the NDS, align-4 seems to be okay) (align-8 may be required on other CPUs with
64bit databus).<BR>
<BR>
<B>Mis-aligned LDR,SWP (rotated read)</B><BR>
Reads from forcibly aligned address "addr AND (NOT 3)", and does then rotate
the data as "ROR (addr AND 3)*8". That effect is internally used by LDRB and
LDRH opcodes (which do then mask-out the unused bits).<BR>
The SWP opcode works like a combination of LDR and STR, that means, it does
read-rotated, but does write-unrotated.<BR>
<BR>
<B>Mis-aligned LDRH,LDRSH (does or does not do strange things)</B><BR>
On ARM9 aka ARMv5 aka NDS9:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  LDRH Rd,[odd]   --&gt;  LDRH Rd,[odd-1]        ;forced align
  LDRSH Rd,[odd]  --&gt;  LDRSH Rd,[odd-1]       ;forced align
</TD></TR></TABLE>
On ARM7 aka ARMv4 aka NDS7/GBA:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  LDRH Rd,[odd]   --&gt;  LDRH Rd,[odd-1] ROR 8  ;read to bit0-7 and bit24-31
  LDRSH Rd,[odd]  --&gt;  LDRSB Rd,[odd]         ;sign-expand BYTE value
</TD></TR></TABLE>
<BR>
<B>Mis-aligned PC/R15 (branch opcodes, or MOV/ALU/LDR with Rd=R15)</B><BR>
For ARM code, the low bits of the target address should be usually zero,
otherwise, R15 is forcibly aligned by clearing the lower two bits.<BR>
For THUMB code, the low bit of the target address may/should/must be set, the
bit is (or is not) interpreted as thumb-bit (depending on the opcode), and R15
is then forcibly aligned by clearing the lower bit.<BR>
In short, R15 will be always forcibly aligned, so mis-aligned branches won't
have effect on subsequent opcodes that use R15, or [R15+disp] as operand.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="arminstructionsummary"></A>&nbsp;
  ARM Instruction Summary
</FONT></TD></TR></TABLE><BR>
Modification of CPSR flags is optional for all {S} instructions.<BR>
<BR>
<B>Logical ALU Operations</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Instruction                      Cycles   Flags  Expl.
  MOV{cond}{S} Rd,Op2              1S+x+y    NZc-  Rd = Op2
  MVN{cond}{S} Rd,Op2              1S+x+y    NZc-  Rd = NOT Op2
  ORR{cond}{S} Rd,Rn,Op2           1S+x+y    NZc-  Rd = Rn OR Op2
  EOR{cond}{S} Rd,Rn,Op2           1S+x+y    NZc-  Rd = Rn XOR Op2
  AND{cond}{S} Rd,Rn,Op2           1S+x+y    NZc-  Rd = Rn AND Op2
  BIC{cond}{S} Rd,Rn,Op2           1S+x+y    NZc-  Rd = Rn AND NOT Op2
  TST{cond}{P}    Rn,Op2           1S+x      NZc-  Void = Rn AND Op2
  TEQ{cond}{P}    Rn,Op2           1S+x      NZc-  Void = Rn XOR Op2
</TD></TR></TABLE>
Add x=1I cycles if Op2 shifted-by-register. Add y=1S+1N cycles if Rd=R15.<BR>
Carry flag affected only if Op2 contains a non-zero shift amount.<BR>
<BR>
<B>Arithmetic ALU Operations</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Instruction                      Cycles   Flags  Expl.
  ADD{cond}{S} Rd,Rn,Op2           1S+x+y    NZCV  Rd = Rn+Op2
  ADC{cond}{S} Rd,Rn,Op2           1S+x+y    NZCV  Rd = Rn+Op2+Cy
  SUB{cond}{S} Rd,Rn,Op2           1S+x+y    NZCV  Rd = Rn-Op2
  SBC{cond}{S} Rd,Rn,Op2           1S+x+y    NZCV  Rd = Rn-Op2+Cy-1
  RSB{cond}{S} Rd,Rn,Op2           1S+x+y    NZCV  Rd = Op2-Rn
  RSC{cond}{S} Rd,Rn,Op2           1S+x+y    NZCV  Rd = Op2-Rn+Cy-1
  CMP{cond}{P}    Rn,Op2           1S+x      NZCV  Void = Rn-Op2
  CMN{cond}{P}    Rn,Op2           1S+x      NZCV  Void = Rn+Op2
</TD></TR></TABLE>
Add x=1I cycles if Op2 shifted-by-register. Add y=1S+1N cycles if Rd=R15.<BR>
<BR>
<B>Multiply</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Instruction                      Cycles   Flags  Expl.
  MUL{cond}{S} Rd,Rm,Rs            1S+mI     NZx-  Rd = Rm*Rs
  MLA{cond}{S} Rd,Rm,Rs,Rn         1S+mI+1I  NZx-  Rd = Rm*Rs+Rn
  UMULL{cond}{S} RdLo,RdHi,Rm,Rs   1S+mI+1I  NZx-  RdHiLo = Rm*Rs
  UMLAL{cond}{S} RdLo,RdHi,Rm,Rs   1S+mI+2I  NZx-  RdHiLo = Rm*Rs+RdHiLo
  SMULL{cond}{S} RdLo,RdHi,Rm,Rs   1S+mI+1I  NZx-  RdHiLo = Rm*Rs
  SMLAL{cond}{S} RdLo,RdHi,Rm,Rs   1S+mI+2I  NZx-  RdHiLo = Rm*Rs+RdHiLo
  SMLAxy{cond}  Rd,Rm,Rs,Rn     ARMv5TE(xP)  ----q Rd=HalfRm*HalfRs+Rn
  SMLAWy{cond}  Rd,Rm,Rs,Rn     ARMv5TE(xP)  ----q Rd=(Rm*HalfRs)/10000h+Rn
  SMULWy{cond}  Rd,Rm,Rs        ARMv5TE(xP)  ----  Rd=(Rm*HalfRs)/10000h
  SMLALxy{cond} RdLo,RdHi,Rm,Rs ARMv5TE(xP)  ----  RdHiLo=RdHiLo+HalfRm*HalfRs
  SMULxy{cond}  Rd,Rm,Rs        ARMv5TE(xP)  ----  Rd=HalfRm*HalfRs
</TD></TR></TABLE>
<BR>
<B>Memory Load/Store</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Instruction                      Cycles    Flags  Expl.
  LDR{cond}{B}{T} Rd,&lt;Address&gt;     1S+1N+1I+y ----  Rd=[Rn+/-&lt;offset&gt;]
  LDR{cond}H      Rd,&lt;Address&gt;     1S+1N+1I+y ----  Load Unsigned halfword
  LDR{cond}D      Rd,&lt;Address&gt;                ----  Load Dword ARMv5TE
  LDR{cond}SB     Rd,&lt;Address&gt;     1S+1N+1I+y ----  Load Signed byte
  LDR{cond}SH     Rd,&lt;Address&gt;     1S+1N+1I+y ----  Load Signed halfword
  LDM{cond}{amod} Rn{!},&lt;Rlist&gt;{^} nS+1N+1I+y ----  Load Multiple
  STR{cond}{B}{T} Rd,&lt;Address&gt;     2N         ----  [Rn+/-&lt;offset&gt;]=Rd
  STR{cond}H      Rd,&lt;Address&gt;     2N         ----  Store halfword
  STR{cond}D      Rd,&lt;Address&gt;                ----  Store Dword ARMv5TE
  STM{cond}{amod} Rn{!},&lt;Rlist&gt;{^} (n-1)S+2N  ----  Store Multiple
  SWP{cond}{B}    Rd,Rm,[Rn]       1S+2N+1I   ----  Rd=[Rn], [Rn]=Rm
  PLD             &lt;Address&gt;        1S         ----  Prepare Cache ARMv5TE
</TD></TR></TABLE>
For LDR/LDM, add y=1S+1N if Rd=R15, or if R15 in Rlist.<BR>
<BR>
<B>Jumps, Calls, CPSR Mode, and others</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Instruction                  Cycles  Flags  Expl.
  B{cond}   label              2S+1N    ----  PC=$+8+/-32M
  BL{cond}  label              2S+1N    ----  PC=$+8+/-32M, LR=$+4
  BX{cond}  Rn                 2S+1N    ----  PC=Rn, T=Rn.0 (THUMB/ARM)
  BLX{cond} Rn                 2S+1N    ----  PC=Rn, T=Rn.0, LR=PC+4, ARM9
  BLX       label              2S+1N    ----  PC=PC+$+/-32M, LR=$+4, T=1, ARM9
  MRS{cond} Rd,Psr             1S       ----  Rd=Psr
  MSR{cond} Psr{_field},Op     1S      (psr)  Psr[field]=Op
  SWI{cond} Imm24bit           2S+1N    ----  PC=8, ARM Svc mode, LR=$+4
  BKPT      Imm16bit           ???      ----  PC=C, ARM Abt mode, LR=$+4 ARM9
  The Undefined Instruction    2S+1I+1N ----  PC=4, ARM Und mode, LR=$+4
  cond=false                   1S       ----  Any opcode with condition=false
  NOP                          1S       ----  R0=R0
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  CLZ{cond} Rd,Rm              ???      ----    Count Leading Zeros ARMv5
  QADD{cond} Rd,Rm,Rn                   ----q   Rd=Rm+Rn       ARMv5TE(xP)
  QSUB{cond} Rd,Rm,Rn                   ----q   Rd=Rm-Rn       ARMv5TE(xP)
  QDADD{cond} Rd,Rm,Rn                  ----q   Rd=Rm+Rn*2     ARMv5TE(xP)
  QDSUB{cond} Rd,Rm,Rn                  ----q   Rd=Rm-Rn*2     ARMv5TE(xP)
</TD></TR></TABLE>
<BR>
<B>Coprocessor Functions (if any)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Instruction                         Cycles  Flags  Expl.
  CDP{cond} Pn,&lt;cpopc&gt;,Cd,Cn,Cm{,&lt;cp&gt;} 1S+bI   ----  Coprocessor specific
  STC{cond}{L} Pn,Cd,&lt;Address&gt;         (n-1)S+2N+bI  [address] = CRd
  LDC{cond}{L} Pn,Cd,&lt;Address&gt;         (n-1)S+2N+bI  CRd = [address]
  MCR{cond} Pn,&lt;cpopc&gt;,Rd,Cn,Cm{,&lt;cp&gt;} 1S+bI+1C      CRn = Rn {&lt;op&gt; CRm}
  MRC{cond} Pn,&lt;cpopc&gt;,Rd,Cn,Cm{,&lt;cp&gt;} 1S+(b+1)I+1C  Rn = CRn {&lt;op&gt; CRm}
  CDP2,STC2,LDC2,MCR2,MRC2 - ARMv5 Extensions similar above, without {cond}
  MCRR{cond} Pn,&lt;cpopc&gt;,Rd,Rn,Cm  ;write Rd,Rn to coproc ARMv5TE
  MRRC{cond} Pn,&lt;cpopc&gt;,Rd,Rn,Cm  ;read Rd,Rn from coproc ARMv5TE
</TD></TR></TABLE>
<BR>
<B>ARM Binary Opcode Format</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  |..3 ..................2 ..................1 ..................0|
  |1_0_9_8_7_6_5_4_3_2_1_0_9_8_7_6_5_4_3_2_1_0_9_8_7_6_5_4_3_2_1_0|
  |_Cond__|0_0_0|___Op__|S|__Rn___|__Rd___|__Shift__|Typ|0|__Rm___| DataProc
  |_Cond__|0_0_0|___Op__|S|__Rn___|__Rd___|__Rs___|0|Typ|1|__Rm___| DataProc
  |_Cond__|0_0_1|___Op__|S|__Rn___|__Rd___|_Shift_|___Immediate___| DataProc
  |_Cond__|0_0_1_1_0|P|1|0|_Field_|__Rd___|_Shift_|___Immediate___| PSR Imm
  |_Cond__|0_0_0_1_0|P|L|0|_Field_|__Rd___|0_0_0_0|0_0_0_0|__Rm___| PSR Reg
  |_Cond__|0_0_0_1_0_0_1_0_1_1_1_1_1_1_1_1_1_1_1_1|0_0|L|1|__Rn___| BX,BLX
  |1_1_1_0|0_0_0_1_0_0_1_0|_____immediate_________|0_1_1_1|_immed_| BKPT ARM9
  |_Cond__|0_0_0_1_0_1_1_0_1_1_1_1|__Rd___|1_1_1_1|0_0_0_1|__Rm___| CLZ  ARM9
  |_Cond__|0_0_0_1_0|Op_|0|__Rn___|__Rd___|0_0_0_0|0_1_0_1|__Rm___| QALU ARM9
  |_Cond__|0_0_0_0_0_0|A|S|__Rd___|__Rn___|__Rs___|1_0_0_1|__Rm___| Multiply
  |_Cond__|0_0_0_0_1|U|A|S|_RdHi__|_RdLo__|__Rs___|1_0_0_1|__Rm___| MulLong
  |_Cond__|0_0_0_1_0|Op_|0|Rd/RdHi|Rn/RdLo|__Rs___|1|y|x|0|__Rm___| MulHalfARM9
  |_Cond__|0_0_0_1_0|B|0_0|__Rn___|__Rd___|0_0_0_0|1_0_0_1|__Rm___| TransSwp12
  |_Cond__|0_0_0|P|U|0|W|L|__Rn___|__Rd___|0_0_0_0|1|S|H|1|__Rm___| TransReg10
  |_Cond__|0_0_0|P|U|1|W|L|__Rn___|__Rd___|OffsetH|1|S|H|1|OffsetL| TransImm10
  |_Cond__|0_1_0|P|U|B|W|L|__Rn___|__Rd___|_________Offset________| TransImm9
  |_Cond__|0_1_1|P|U|B|W|L|__Rn___|__Rd___|__Shift__|Typ|0|__Rm___| TransReg9
  |_Cond__|0_1_1|________________xxx____________________|1|__xxx__| Undefined
  |_Cond__|1_0_0|P|U|S|W|L|__Rn___|__________Register_List________| BlockTrans
  |_Cond__|1_0_1|L|___________________Offset______________________| B,BL,BLX
  |_Cond__|1_1_0|P|U|N|W|L|__Rn___|__CRd__|__CP#__|____Offset_____| CoDataTrans
  |_Cond__|1_1_0_0_0_1_0|L|__Rn___|__Rd___|__CP#__|_CPopc_|__CRm__| CoRR ARM9
  |_Cond__|1_1_1_0|_CPopc_|__CRn__|__CRd__|__CP#__|_CP__|0|__CRm__| CoDataOp
  |_Cond__|1_1_1_0|CPopc|L|__CRn__|__Rd___|__CP#__|_CP__|1|__CRm__| CoRegTrans
  |_Cond__|1_1_1_1|_____________Ignored_by_Processor______________| SWI
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="armopcodesbranchandbranchwithlinkbblbxblxswibkpt"></A>&nbsp;
  ARM Opcodes: Branch and Branch with Link (B, BL, BX, BLX, SWI, BKPT)
</FONT></TD></TR></TABLE><BR>
<B>Branch and Branch with Link (B, BL, BLX_imm)</B><BR>
Branch (B) is supposed to jump to a subroutine. Branch with Link is meant to be
used to call to a subroutine, return address is then saved in R14.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit    Expl.
  31-28  Condition (must be 1111b for BLX)
  27-25  Must be "101" for this instruction
  24     Opcode (0-1) (or Halfword Offset for BLX)
          0: B{cond} label    ;branch            PC=PC+8+nn*4
          1: BL{cond} label   ;branch/link       PC=PC+8+nn*4, LR=PC+4
          H: BLX label ;ARM9  ;branch/link/thumb PC=PC+8+nn*4+H*2, LR=PC+4, T=1
  23-0   nn - Signed Offset, step 4      (-32M..+32M in steps of 4)
</TD></TR></TABLE>
Branch with Link can be used to 'call' to a sub-routine, which may then
'return' by MOV PC,R14 for example.<BR>
Execution Time: 2S + 1N<BR>
Return: No flags affected.<BR>
<BR>
<B>Branch and Exchange (BX, BLX_reg)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit    Expl.
  31-28  Condition
  27-8   Must be "0001.0010.1111.1111.1111" for this instruction
  7-4    Opcode
          0001b: BX{cond}  Rn    ;PC=Rn, T=Rn.0  (ARMv4T and ARMv5 and up)
          0011b: BLX{cond} Rn    ;PC=Rn, T=Rn.0, LR=PC+4    (ARMv5 and up)
  3-0    Rn - Operand Register  (R0-R14)
</TD></TR></TABLE>
Switching to THUMB Mode: Set Bit 0 of the value in Rn to 1, program continues
then at Rn-1 in THUMB mode.<BR>
Results in undefined behaviour if using R15 (PC+8 itself) as operand. Using BLX
R14 is possible (sets PC=Old_LR, and New_LR=retadr).<BR>
Execution Time: 2S + 1N<BR>
Return: No flags affected.<BR>
<BR>
<B>Branch via ALU, LDR, LDM</B><BR>
Most ALU, LDR, LDM opcodes can also change PC/R15.<BR>
<BR>
<B>Software Interrupt (SWI/BKPT) (svc/abt exceptions)</B><BR>
SWI supposed for calls to the operating system - Enter Supervisor mode (SVC) in
ARM state. BKPT intended for debugging - enters Abort mode in ARM state via
Prefetch Abort vector.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit    Expl.
  31-28  Condition (must be 1110b for BKPT, ie. Condition=always)
  27-24  Opcode
          1111b: SWI{cond} nn   ;software interrupt
          0001b: BKPT      nn   ;breakpoint (ARMv5 and up)
  For SWI:
   23-0   nn - Comment Field, ignored by processor (24bit value)
  For BKPT:
   23-20  Must be 0010b for BKPT
   19-8   nn - upper 12bits of comment field, ignored by processor
   7-4    Must be 0111b for BKPT
   3-0    nn - lower 4bits of comment field, ignored by processor
</TD></TR></TABLE>
Execution Time: 2S+1N<BR>
The exception handler may interprete the SWI Comment Field by examining the
lower 24bit of the 32bit opcode opcode at [R14_svc-4]. If your are also using
SWI's from inside of THUMB, then the SWI handler must examine the T Bit
SPSR_svc in order to determine whether it's been a THUMB SWI - and if so,
examine the lower 8bit of the 16bit opcode opcode at [R14_svc-2].<BR>
For Returning from SWI use "MOVS PC,R14", that instruction does restore both PC
and CPSR, ie. PC=R14_svc, and CPSR=SPSR_svc.<BR>
Nesting SWIs: SPSR_svc and R14_svc should be saved on stack before either
invoking nested SWIs, or (if the IRQ handler uses SWIs) before enabling IRQs.<BR>
Execution SWI/BKPT:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  R14_svc=PC+4     R14_abt=PC+4   ;save return address
  SPSR_svc=CPSR    SPSR_abt=CPSR  ;save CPSR flags
  CPSR=&lt;changed&gt;   CPSR=&lt;changed&gt; ;Enter svc/abt, ARM state, IRQs disabled
  PC=VVVV0008h     PC=VVVV000Ch   ;jump to SWI/PrefetchAbort vector address
</TD></TR></TABLE>
<BR>
<B>Undefined Instruction (und exception)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit    Expl.
  31-28  Condition
  27-25  Must be 011b for this instruction
  24-5   Reserved for future use
  4      Must be 1b for this instruction
  3-0    Reserved for future use
</TD></TR></TABLE>
No assembler mnemonic exists, following bitstreams are (not) reserved.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  cond011xxxxxxxxxxxxxxxxxxxx1xxxx - reserved for future use (except below).
  cond01111111xxxxxxxxxxxx1111xxxx - free for user.
</TD></TR></TABLE>
Execution time: 2S+1I+1N.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="armopcodesdataprocessingalu"></A>&nbsp;
  ARM Opcodes: Data Processing (ALU)
</FONT></TD></TR></TABLE><BR>
<B>Opcode Format</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit    Expl.
  31-28  Condition
  27-26  Must be 00b for this instruction
  25     I - Immediate 2nd Operand Flag (0=Register, 1=Immediate)
  24-21  Opcode (0-Fh)               ;*=Arithmetic, otherwise Logical
           0: AND{cond}{S} Rd,Rn,Op2    ;AND logical       Rd = Rn AND Op2
           1: EOR{cond}{S} Rd,Rn,Op2    ;XOR logical       Rd = Rn XOR Op2
           2: SUB{cond}{S} Rd,Rn,Op2 ;* ;subtract          Rd = Rn-Op2
           3: RSB{cond}{S} Rd,Rn,Op2 ;* ;subtract reversed Rd = Op2-Rn
           4: ADD{cond}{S} Rd,Rn,Op2 ;* ;add               Rd = Rn+Op2
           5: ADC{cond}{S} Rd,Rn,Op2 ;* ;add with carry    Rd = Rn+Op2+Cy
           6: SBC{cond}{S} Rd,Rn,Op2 ;* ;sub with carry    Rd = Rn-Op2+Cy-1
           7: RSC{cond}{S} Rd,Rn,Op2 ;* ;sub cy. reversed  Rd = Op2-Rn+Cy-1
           8: TST{cond}{P}    Rn,Op2    ;test            Void = Rn AND Op2
           9: TEQ{cond}{P}    Rn,Op2    ;test exclusive  Void = Rn XOR Op2
           A: CMP{cond}{P}    Rn,Op2 ;* ;compare         Void = Rn-Op2
           B: CMN{cond}{P}    Rn,Op2 ;* ;compare neg.    Void = Rn+Op2
           C: ORR{cond}{S} Rd,Rn,Op2    ;OR logical        Rd = Rn OR Op2
           D: MOV{cond}{S} Rd,Op2       ;move              Rd = Op2
           E: BIC{cond}{S} Rd,Rn,Op2    ;bit clear         Rd = Rn AND NOT Op2
           F: MVN{cond}{S} Rd,Op2       ;not               Rd = NOT Op2
  20     S - Set Condition Codes (0=No, 1=Yes) (Must be 1 for opcode 8-B)
  19-16  Rn - 1st Operand Register (R0..R15) (including PC=R15)
              Must be 0000b for MOV/MVN.
  15-12  Rd - Destination Register (R0..R15) (including PC=R15)
              Must be 0000b (or 1111b) for CMP/CMN/TST/TEQ{P}.
  When above Bit 25 I=0 (Register as 2nd Operand)
    When below Bit 4 R=0 - Shift by Immediate
      11-7   Is - Shift amount   (1-31, 0=Special/See below)
    When below Bit 4 R=1 - Shift by Register
      11-8   Rs - Shift register (R0-R14) - only lower 8bit 0-255 used
      7      Reserved, must be zero  (otherwise multiply or undefined opcode)
    6-5    Shift Type (0=LSL, 1=LSR, 2=ASR, 3=ROR)
    4      R - Shift by Register Flag (0=Immediate, 1=Register)
    3-0    Rm - 2nd Operand Register (R0..R15) (including PC=R15)
  When above Bit 25 I=1 (Immediate as 2nd Operand)
    11-8   Is - ROR-Shift applied to nn (0-30, in steps of 2)
    7-0    nn - 2nd Operand Unsigned 8bit Immediate
</TD></TR></TABLE>
<BR>
<B>Second Operand (Op2)</B><BR>
This may be a shifted register, or a shifted immediate. See Bit 25 and 11-0.<BR>
Unshifted Register: Specify Op2 as "Rm", assembler converts to "Rm,LSL#0".<BR>
Shifted Register: Specify as "Rm,SSS#Is" or "Rm,SSS Rs" (SSS=LSL/LSR/ASR/ROR).<BR>
Immediate: Specify as 32bit value, for example: "#000NN000h", assembler should
automatically convert into "#0NNh,ROR#0ssh" as far as possible (ie. as far as a
section of not more than 8bits of the immediate is non-zero).<BR>
<BR>
<B>Zero Shift Amount (Shift Register by Immediate, with Immediate=0)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  LSL#0: No shift performed, ie. directly Op2=Rm, the C flag is NOT affected.
  LSR#0: Interpreted as LSR#32, ie. Op2 becomes zero, C becomes Bit 31 of Rm.
  ASR#0: Interpreted as ASR#32, ie. Op2 and C are filled by Bit 31 of Rm.
  ROR#0: Interpreted as RRX#1 (RCR), like ROR#1, but Op2 Bit 31 set to old C.
</TD></TR></TABLE>
In source code, LSR#32, ASR#32, and RRX#1 should be specified as such -
attempts to specify LSR#0, ASR#0, or ROR#0 will be internally converted to
LSL#0 by the assembler.<BR>
<BR>
<B>Using R15 (PC)</B><BR>
When using R15 as Destination (Rd), note below CPSR description and Execution
time description.<BR>
When using R15 as operand (Rm or Rn), the returned value depends on the
instruction: PC+12 if I=0,R=1 (shift by register), otherwise PC+8 (shift by
immediate).<BR>
<BR>
<B>Returned CPSR Flags</B><BR>
If S=1, Rd&lt;&gt;R15, logical operations (AND,EOR,TST,TEQ,ORR,MOV,BIC,MVN):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  V=not affected
  C=carryflag of shift operation (not affected if LSL#0 or Rs=00h)
  Z=zeroflag of result
  N=signflag of result (result bit 31)
</TD></TR></TABLE>
If S=1, Rd&lt;&gt;R15, arithmetic operations (SUB,RSB,ADD,ADC,SBC,RSC,CMP,CMN):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  V=overflowflag of result
  C=carryflag of result
  Z=zeroflag of result
  N=signflag of result (result bit 31)
</TD></TR></TABLE>
IF S=1, with unused Rd bits=1111b, {P} opcodes (CMPP/CMNP/TSTP/TEQP):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  R15=result  ;modify PSR bits in R15, ARMv2 and below only.
  In user mode only N,Z,C,V bits of R15 can be changed.
  In other modes additionally I,F,M1,M0 can be changed.
  The PC bits in R15 are left unchanged in all modes.
</TD></TR></TABLE>
If S=1, Rd=R15; should not be used in user mode:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  CPSR = SPSR_&lt;current mode&gt;
  PC = result
  For example: MOVS PC,R14  ;return from SWI (PC=R14_svc, CPSR=SPSR_svc).
</TD></TR></TABLE>
If S=0: Flags are not affected (not allowed for CMP,CMN,TEQ,TST).<BR>
<BR>
The instruction "MOV R0,R0" is used as "NOP" opcode in 32bit ARM state.<BR>
Execution Time: (1+p)S+rI+pN. Whereas r=1 if I=0 and R=1 (ie. shift by
register); otherwise r=0. And p=1 if Rd=R15; otherwise p=0.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="armopcodesmultiplyandmultiplyaccumulatemulmla"></A>&nbsp;
  ARM Opcodes: Multiply and Multiply-Accumulate (MUL, MLA)
</FONT></TD></TR></TABLE><BR>
<B>Opcode Format</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit    Expl.
  31-28  Condition
  27-25  Must be 000b for this instruction
  24-21  Opcode
          0000b: MUL{cond}{S}   Rd,Rm,Rs        ;multiply   Rd = Rm*Rs
          0001b: MLA{cond}{S}   Rd,Rm,Rs,Rn     ;mul.&amp; accumulate Rd = Rm*Rs+Rn
          0100b: UMULL{cond}{S} RdLo,RdHi,Rm,Rs ;multiply   RdHiLo=Rm*Rs
          0101b: UMLAL{cond}{S} RdLo,RdHi,Rm,Rs ;mul.&amp; acc. RdHiLo=Rm*Rs+RdHiLo
          0110b: SMULL{cond}{S} RdLo,RdHi,Rm,Rs ;sign.mul.  RdHiLo=Rm*Rs
          0111b: SMLAL{cond}{S} RdLo,RdHi,Rm,Rs ;sign.m&amp;a.  RdHiLo=Rm*Rs+RdHiLo
          1000b: SMLAxy{cond}   Rd,Rm,Rs,Rn     ;Rd=HalfRm*HalfRs+Rn
          1001b: SMLAWy{cond}   Rd,Rm,Rs,Rn     ;Rd=(Rm*HalfRs)/10000h+Rn
          1001b: SMULWy{cond}   Rd,Rm,Rs        ;Rd=(Rm*HalfRs)/10000h
          1010b: SMLALxy{cond}  RdLo,RdHi,Rm,Rs ;RdHiLo=RdHiLo+HalfRm*HalfRs
          1011b: SMULxy{cond}   Rd,Rm,Rs        ;Rd=HalfRm*HalfRs
  20     S - Set Condition Codes (0=No, 1=Yes) (Must be 0 for Halfword mul)
  19-16  Rd (or RdHi) - Destination Register (R0-R14)
  15-12  Rn (or RdLo) - Accumulate Register  (R0-R14) (Set to 0000b if unused)
  11-8   Rs - Operand Register               (R0-R14)
  For Non-Halfword Multiplies
    7-4  Must be 1001b for these instructions
  For Halfword Multiplies
    7    Must be 1 for these instructions
    6    y - Rs Top/Bottom flag (0=B=Lower 16bit, 1=T=Upper 16bit)
    5    x - Rm Top/Bottom flag (as above), or 0 for SMLAW, or 1 for SMULW
    4    Must be 0 for these instructions
  3-0    Rm - Operand Register               (R0-R14)
</TD></TR></TABLE>
<BR>
<B>Multiply and Multiply-Accumulate (MUL, MLA)</B><BR>
Restrictions: Rd may not be same as Rm. Rd,Rn,Rs,Rm may not be R15.<BR>
Note: Only the lower 32bit of the internal 64bit result are stored in Rd, thus
no sign/zero extension is required and MUL and MLA can be used for both signed
and unsigned calculations!<BR>
Execution Time: 1S+mI for MUL, and 1S+(m+1)I for MLA. Whereas 'm' depends on
whether/how many most significant bits of Rs are all zero or all one. That is
m=1 for Bit 31-8, m=2 for Bit 31-16, m=3 for Bit 31-24, and m=4 otherwise.<BR>
Flags (if S=1): Z=zeroflag, N=signflag, C=destroyed (ARMv4 and below) or C=not
affected (ARMv5 and up), V=not affected. MUL/MLA supported by ARMv2 and up.<BR>
<BR>
<B>Multiply Long and Multiply-Accumulate Long (MULL, MLAL)</B><BR>
Optionally supported, INCLUDED in ARMv3M, EXCLUDED in ARMv4xM/ARMv5xM.<BR>
Restrictions: RdHi,RdLo,Rm must be different registers. R15 may not be used.<BR>
Execution Time: 1S+(m+1)I for MULL, and 1S+(m+2)I for MLAL. Whereas 'm' depends
on whether/how many most significant bits of Rs are "all zero" (UMULL/UMLAL) or
"all zero or all one" (SMULL,SMLAL). That is m=1 for Bit31-8, m=2 for Bit31-16,
m=3 for Bit31-24, and m=4 otherwise.<BR>
Flags (if S=1): Z=zeroflag, N=signflag, C=destroyed (ARMv4 and below) or C=not
affected (ARMv5 and up), V=destroyed??? (ARMv4 and below???) or V=not affected
(ARMv5 and up).<BR>
<BR>
<B>Signed Halfword Multiply (SMLAxy,SMLAWy,SMLALxy,SMULxy,SMULWy)</B><BR>
Supported by E variants of ARMv5 and up, ie. ARMv5TE(xP).<BR>
Q-flag gets set on 32bit SMLAxy/SMLAWy addition overflows, however, the result
is NOT truncated (as it'd be done with QADD opcodes).<BR>
Q-flag is NOT affected on (rare) 64bit SMLALxy addition overflows.<BR>
SMULxy/SMULWy cannot overflow, and thus leave Q-flag unchanged as well.<BR>
NZCV-flags are not affected by Halfword multiplies.<BR>
Execution Time: 1S+Interlock (SMULxy,SMLAxy,SMULWx,SMLAWx)<BR>
Execution Time: 1S+1I+Interlock (SMLALxy)<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="armopcodesspecialarm9instructionsclzqaddqsub"></A>&nbsp;
  ARM Opcodes: Special ARM9 Instructions (CLZ, QADD/QSUB)
</FONT></TD></TR></TABLE><BR>
<B>Count Leading Zeros (CLZ)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit    Expl.
  31-28  Condition
  27-16  Must be 0001.0110.1111b for this instruction
         Opcode (fixed)
           CLZ{cond} Rd,Rm  ;Rd=Number of leading zeros in Rm
  15-12  Rd - Destination Register              (R0-R14)
  11-4   Must be 1111.0001b for this instruction
  3-0    Rm - Source Register                   (R0-R14)
</TD></TR></TABLE>
CLZ supported by ARMv5 and up. Execution time: 1S.<BR>
Return: No Flags affected. Rd=0..32.<BR>
<BR>
<B>Opcode Format (QADD/QSUB)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit    Expl.
  31-28  Condition
  27-24  Must be 0001b for this instruction
  23-20  Opcode
          0000b: QADD{cond}  Rd,Rm,Rn    ;Rd=Rm+Rn
          0010b: QSUB{cond}  Rd,Rm,Rn    ;Rd=Rm-Rn
          0100b: QDADD{cond} Rd,Rm,Rn    ;Rd=Rm+Rn*2 (doubled)
          0110b: QDSUB{cond} Rd,Rm,Rn    ;Rd=Rm-Rn*2 (doubled)
  19-16  Rn - Second Source Register            (R0-R14)
  15-12  Rd - Destination Register              (R0-R14)
  11-4   Must be 00000101b for this instruction
  3-0    Rm - First Source Register             (R0-R14)
</TD></TR></TABLE>
Supported by E variants of ARMv5 and up, ie. ARMv5TE(xP).<BR>
Execution time: 1S+Interlock.<BR>
Results truncated to signed 32bit range in case of overflows, with the Q-flag
being set (and being left unchanged otherwise). NZCV flags are not affected.<BR>
Note: Rn*2 is internally processed first, and may get truncated - even if the
final result would fit into range.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="armopcodespsrtransfermrsmsr"></A>&nbsp;
  ARM Opcodes: PSR Transfer (MRS, MSR)
</FONT></TD></TR></TABLE><BR>
<B>Opcode Format</B><BR>
These instructions occupy an unused area (TEQ,TST,CMP,CMN with S=0) of ALU
opcodes.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit    Expl.
  31-28  Condition
  27-26  Must be 00b for this instruction
  25     I - Immediate Operand Flag  (0=Register, 1=Immediate) (Zero for MRS)
  24-23  Must be 10b for this instruction
  22     Psr - Source/Destination PSR  (0=CPSR, 1=SPSR_&lt;current mode&gt;)
  21     Opcode
           0: MRS{cond} Rd,Psr          ;Rd = Psr
           1: MSR{cond} Psr{_field},Op  ;Psr[field] = Op
  20     Must be 0b for this instruction (otherwise TST,TEQ,CMP,CMN)
  For MRS:
    19-16   Must be 1111b for this instruction (otherwise SWP)
    15-12   Rd - Destination Register  (R0-R14)
    11-0    Not used, must be zero.
  For MSR:
    19      f  write to flags field     Bit 31-24 (aka _flg)
    18      s  write to status field    Bit 23-16 (reserved, don't change)
    17      x  write to extension field Bit 15-8  (reserved, don't change)
    16      c  write to control field   Bit 7-0   (aka _ctl)
    15-12   Not used, must be 1111b.
  For MSR Psr,Rm (I=0)
    11-4    Not used, must be zero. (otherwise BX)
    3-0     Rm - Source Register &lt;op&gt;  (R0-R14)
  For MSR Psr,Imm (I=1)
    11-8    Shift applied to Imm   (ROR in steps of two 0-30)
    7-0     Imm - Unsigned 8bit Immediate
    In source code, a 32bit immediate should be specified as operand.
    The assembler should then convert that into a shifted 8bit value.
</TD></TR></TABLE>
MSR/MRS and CPSR/SPSR supported by ARMv3 and up.<BR>
ARMv2 and below contained PSR flags in R15, accessed by CMP/CMN/TST/TEQ{P}.<BR>
The field mask bits specify which bits of the destination Psr are write-able
(or write-protected), one or more of these bits should be set, for example,
CPSR_fsxc (aka CPSR aka CPSR_all) unlocks all bits (see below user mode
restriction though).<BR>
Restrictions:<BR>
In non-privileged mode (user mode): only condition code bits of CPSR can be
changed, control bits can't.<BR>
Only the SPSR of the current mode can be accessed; In User and System modes no
SPSR exists.<BR>
The T-bit may not be changed; for THUMB/ARM switching use BX instruction.<BR>
Unused Bits in CPSR are reserved for future use and should never be changed
(except for unused bits in the flags field).<BR>
Execution Time: 1S.<BR>
<BR>
Note: The A22i assembler recognizes MOV as alias for both MSR and MRS because
it is practically not possible to remember whether MSR or MRS was the load or
store opcode, and/or whether it does load to or from the Psr register.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="armopcodesmemorysingledatatransferldrstrpld"></A>&nbsp;
  ARM Opcodes: Memory: Single Data Transfer (LDR, STR, PLD)
</FONT></TD></TR></TABLE><BR>
<B>Opcode Format</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit    Expl.
  31-28  Condition (Must be 1111b for PLD)
  27-26  Must be 01b for this instruction
  25     I - Immediate Offset Flag (0=Immediate, 1=Shifted Register)
  24     P - Pre/Post (0=post; add offset after transfer, 1=pre; before trans.)
  23     U - Up/Down Bit (0=down; subtract offset from base, 1=up; add to base)
  22     B - Byte/Word bit (0=transfer 32bit/word, 1=transfer 8bit/byte)
  When above Bit 24 P=0 (Post-indexing, write-back is ALWAYS enabled):
    21     T - Memory Management (0=Normal, 1=Force non-privileged access)
  When above Bit 24 P=1 (Pre-indexing, write-back is optional):
    21     W - Write-back bit (0=no write-back, 1=write address into base)
  20     L - Load/Store bit (0=Store to memory, 1=Load from memory)
          0: STR{cond}{B}{T} Rd,&lt;Address&gt;   ;[Rn+/-&lt;offset&gt;]=Rd
          1: LDR{cond}{B}{T} Rd,&lt;Address&gt;   ;Rd=[Rn+/-&lt;offset&gt;]
         (1: PLD &lt;Address&gt; ;Prepare Cache for Load, see notes below)
          Whereas, B=Byte, T=Force User Mode (only for POST-Indexing)
  19-16  Rn - Base register               (R0..R15) (including R15=PC+8)
  15-12  Rd - Source/Destination Register (R0..R15) (including R15=PC+12)
  When above I=0 (Immediate as Offset)
    11-0   Unsigned 12bit Immediate Offset (0-4095, steps of 1)
  When above I=1 (Register shifted by Immediate as Offset)
    11-7   Is - Shift amount      (1-31, 0=Special/See below)
    6-5    Shift Type             (0=LSL, 1=LSR, 2=ASR, 3=ROR)
    4      Must be 0 (Reserved, see The Undefined Instruction)
    3-0    Rm - Offset Register   (R0..R14) (not including PC=R15)
</TD></TR></TABLE>
<BR>
<B>Instruction Formats for &lt;Address&gt;</B><BR>
An expression which generates an address:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  &lt;expression&gt;                  ;an immediate used as address
  ;*** restriction: must be located in range PC+/-4095+8, if so,
  ;*** assembler will calculate offset and use PC (R15) as base.
</TD></TR></TABLE>
Pre-indexed addressing specification:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  [Rn]                          ;offset = zero
  [Rn, &lt;#{+/-}expression&gt;]{!}   ;offset = immediate
  [Rn, {+/-}Rm{,&lt;shift&gt;} ]{!}   ;offset = register shifted by immediate
</TD></TR></TABLE>
Post-indexed addressing specification:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  [Rn], &lt;#{+/-}expression&gt;      ;offset = immediate
  [Rn], {+/-}Rm{,&lt;shift&gt;}       ;offset = register shifted by immediate
</TD></TR></TABLE>
Whereas...<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  &lt;shift&gt;  immediate shift such like LSL#4, ROR#2, etc. (see ALU opcodes).
  {!}      exclamation mark ("!") indicates write-back (Rn will be updated).
</TD></TR></TABLE>
<BR>
<B>Notes</B><BR>
Shift amount 0 has special meaning, as described for ALU opcodes.<BR>
When writing a word (32bit) to memory, the address should be word-aligned.<BR>
When reading a byte from memory, upper 24 bits of Rd are zero-extended.<BR>
LDR PC,&lt;op&gt; on ARMv4 leaves CPSR.T unchanged.<BR>
LDR PC,&lt;op&gt; on ARMv5 sets CPSR.T to &lt;op&gt; Bit0, (1=Switch to Thumb).<BR>
<BR>
When reading a word from a halfword-aligned address (which is located in the
middle between two word-aligned addresses), the lower 16bit of Rd will contain
[address] ie. the addressed halfword, and the upper 16bit of Rd will contain
[Rd-2] ie. more or less unwanted garbage. However, by isolating lower bits this
may be used to read a halfword from memory. (Above applies to little endian
mode, as used in GBA.)<BR>
<BR>
In a virtual memory based environment (ie. not in the GBA), aborts (ie. page
faults) may take place during execution, if so, Rm and Rn should not specify
the same register when post-indexing is used, as the abort-handler might have
problems to reconstruct the original value of the register.<BR>
<BR>
Return: CPSR flags are not affected.<BR>
Execution Time: For normal LDR: 1S+1N+1I. For LDR PC: 2S+2N+1I. For STR: 2N.<BR>
<BR>
<B>PLD &lt;Address&gt; ;Prepare Cache for Load</B><BR>
PLD must use following settings cond=1111b, P=1, B=1, W=0, L=1, Rd=1111b, the
address may not use post-indexing, and may not use writeback, the opcode is
encoded identical as LDRNVB R15,&lt;Address&gt;.<BR>
PLD signalizes to the memory system that a specific memory address will be soon
accessed, the memory system may use this hint to prepare caching/pipelining,
aside from that, PLD does not have any affect to the program logic, and behaves
identical as NOP.<BR>
PLD supported by ARMv5TE only, not ARMv5, not ARMv5TExP.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="armopcodesmemoryhalfworddoublewordandsigneddatatransfer"></A>&nbsp;
  ARM Opcodes: Memory: Halfword, Doubleword, and Signed Data Transfer
</FONT></TD></TR></TABLE><BR>
<B>Opcode Format</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit    Expl.
  31-28  Condition
  27-25  Must be 000b for this instruction
  24     P - Pre/Post (0=post; add offset after transfer, 1=pre; before trans.)
  23     U - Up/Down Bit (0=down; subtract offset from base, 1=up; add to base)
  22     I - Immediate Offset Flag (0=Register Offset, 1=Immediate Offset)
  When above Bit 24 P=0 (Post-indexing, write-back is ALWAYS enabled):
    21     Not used, must be zero (0)
  When above Bit 24 P=1 (Pre-indexing, write-back is optional):
    21     W - Write-back bit (0=no write-back, 1=write address into base)
  20     L - Load/Store bit (0=Store to memory, 1=Load from memory)
  19-16  Rn - Base register                (R0-R15) (Including R15=PC+8)
  15-12  Rd - Source/Destination Register  (R0-R15) (Including R15=PC+12)
  11-8   When above Bit 22 I=0 (Register as Offset):
           Not used. Must be 0000b
         When above Bit 22 I=1 (immediate as Offset):
           Immediate Offset (upper 4bits)
  7      Reserved, must be set (1)
  6-5    Opcode (0-3)
         When Bit 20 L=0 (Store) (and Doubleword Load/Store):
          0: Reserved for SWP instruction
          1: STR{cond}H  Rd,&lt;Address&gt;  ;Store halfword   [a]=Rd
          2: LDR{cond}D  Rd,&lt;Address&gt;  ;Load Doubleword  R(d)=[a], R(d+1)=[a+4]
          3: STR{cond}D  Rd,&lt;Address&gt;  ;Store Doubleword [a]=R(d), [a+4]=R(d+1)
         When Bit 20 L=1 (Load):
          0: Reserved.
          1: LDR{cond}H  Rd,&lt;Address&gt;  ;Load Unsigned halfword (zero-extended)
          2: LDR{cond}SB Rd,&lt;Address&gt;  ;Load Signed byte (sign extended)
          3: LDR{cond}SH Rd,&lt;Address&gt;  ;Load Signed halfword (sign extended)
  4      Reserved, must be set (1)
  3-0    When above Bit 22 I=0:
           Rm - Offset Register            (R0-R14) (not including R15)
         When above Bit 22 I=1:
           Immediate Offset (lower 4bits)  (0-255, together with upper bits)
</TD></TR></TABLE>
STRH,LDRH,LDRSB,LDRSH supported on ARMv4 and up.<BR>
STRD/LDRD supported on ARMv5TE only, not ARMv5, not ARMv5TExP.<BR>
STRD/LDRD: base writeback: Rn should not be same as R(d) or R(d+1).<BR>
STRD: index register: Rm should not be same as R(d) or R(d+1).<BR>
STRD/LDRD: Rd must be an even numbered register (R0,R2,R4,R6,R8,R10,R12).<BR>
STRD/LDRD: Address must be double-word aligned (multiple of eight).<BR>
<BR>
<B>Instruction Formats for &lt;Address&gt;</B><BR>
An expression which generates an address:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  &lt;expression&gt;                  ;an immediate used as address
  ;*** restriction: must be located in range PC+/-255+8, if so,
  ;*** assembler will calculate offset and use PC (R15) as base.
</TD></TR></TABLE>
Pre-indexed addressing specification:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  [Rn]                          ;offset = zero
  [Rn, &lt;#{+/-}expression&gt;]{!}   ;offset = immediate
  [Rn, {+/-}Rm]{!}              ;offset = register
</TD></TR></TABLE>
Post-indexed addressing specification:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  [Rn], &lt;#{+/-}expression&gt;      ;offset = immediate
  [Rn], {+/-}Rm                 ;offset = register
</TD></TR></TABLE>
Whereas...<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  {!}      exclamation mark ("!") indicates write-back (Rn will be updated).
</TD></TR></TABLE>
<BR>
Return: No Flags affected.<BR>
Execution Time: For Normal LDR, 1S+1N+1I. For LDR PC, 2S+2N+1I. For STRH 2N.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="armopcodesmemoryblockdatatransferldmstm"></A>&nbsp;
  ARM Opcodes: Memory: Block Data Transfer (LDM, STM)
</FONT></TD></TR></TABLE><BR>
<B>Opcode Format</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit    Expl.
  31-28  Condition
  27-25  Must be 100b for this instruction
  24     P - Pre/Post (0=post; add offset after transfer, 1=pre; before trans.)
  23     U - Up/Down Bit (0=down; subtract offset from base, 1=up; add to base)
  22     S - PSR &amp; force user bit (0=No, 1=load PSR or force user mode)
  21     W - Write-back bit (0=no write-back, 1=write address into base)
  20     L - Load/Store bit (0=Store to memory, 1=Load from memory)
          0: STM{cond}{amod} Rn{!},&lt;Rlist&gt;{^}  ;Store (Push)
          1: LDM{cond}{amod} Rn{!},&lt;Rlist&gt;{^}  ;Load  (Pop)
          Whereas, {!}=Write-Back (W), and {^}=PSR/User Mode (S)
  19-16  Rn - Base register                (R0-R14) (not including R15)
  15-0   Rlist - Register List
  (Above 'offset' is meant to be the number of words specified in Rlist.)
</TD></TR></TABLE>
Return: No Flags affected.<BR>
Execution Time: For normal LDM, nS+1N+1I. For LDM PC, (n+1)S+2N+1I. For STM
(n-1)S+2N. Where n is the number of words transferred.<BR>
<BR>
<B>Addressing Modes {amod}</B><BR>
The IB,IA,DB,DA suffixes directly specify the desired U and P bits:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  IB  increment before          ;P=1, U=1
  IA  increment after           ;P=0, U=1
  DB  decrement before          ;P=1, U=0
  DA  decrement after           ;P=0, U=0
</TD></TR></TABLE>
Alternately, FD,ED,FA,EA could be used, mostly to simplify mnemonics for stack
transfers.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ED  empty stack, descending   ;LDM: P=1, U=1  ;STM: P=0, U=0
  FD  full stack,  descending   ;     P=0, U=1  ;     P=1, U=0
  EA  empty stack, ascending    ;     P=1, U=0  ;     P=0, U=1
  FA  full stack,  ascending    ;     P=0, U=0  ;     P=1, U=1
</TD></TR></TABLE>
Ie. the following expressions are aliases for each other:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  STMFD=STMDB=PUSH   STMED=STMDA   STMFA=STMIB   STMEA=STMIA
  LDMFD=LDMIA=POP    LDMED=LDMIB   LDMFA=LDMDA   LDMEA=LDMDB
</TD></TR></TABLE>
Note: The equivalent THUMB functions use fixed organization:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  PUSH/POP: full descending     ;base register SP (R13)
  LDM/STM:  increment after     ;base register R0..R7
</TD></TR></TABLE>
Descending is common stack organization as used in 80x86 and Z80 CPUs, SP is
decremented when pushing/storing data, and incremented when popping/loading
data.<BR>
<BR>
<B>When S Bit is set (S=1)</B><BR>
If instruction is LDM and R15 is in the list: (Mode Changes)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  While R15 loaded, additionally: CPSR=SPSR_&lt;current mode&gt;
</TD></TR></TABLE>
Otherwise: (User bank transfer)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Rlist is referring to User Bank Registers, R0-R15 (rather than
  register related to the current mode, such like R14_svc etc.)
  Base write-back should not be used for User bank transfer.
<B>  Caution - When instruction is LDM:</B>
  If the following instruction reads from a banked register (eg. R14_svc),
  then CPU might still read R14 instead; if necessary insert a dummy NOP.
</TD></TR></TABLE>
<BR>
<B>Notes</B><BR>
The base address should be usually word-aligned.<BR>
LDM Rn,...,PC on ARMv4 leaves CPSR.T unchanged.<BR>
LDR Rn,...,PC on ARMv5 sets CPSR.T to &lt;op&gt; Bit0, (1=Switch to Thumb).<BR>
<BR>
<B>Transfer Order</B><BR>
The lowest Register in Rlist (R0 if its in the list) will be loaded/stored
to/from the lowest memory address.<BR>
Internally, the rlist register are always processed with INCREASING addresses
(ie. for DECREASING addressing modes, the CPU does first calculate the lowest
address, and does then process rlist with increasing addresses; this detail can
be important when accessing memory mapped I/O ports).<BR>
<BR>
<B>Strange Effects on Invalid Rlist's</B><BR>
Empty Rlist: R15 loaded/stored (ARMv4 only), and Rb=Rb+/-40h (ARMv4-v5).<BR>
Writeback with Rb included in Rlist: Store OLD base if Rb is FIRST entry in
Rlist, otherwise store NEW base (STM/ARMv4), always store OLD base (STM/ARMv5),
no writeback (LDM/ARMv4), writeback if Rb is "the ONLY register, or NOT the
LAST register" in Rlist (LDM/ARMv5).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="armopcodesmemorysingledataswapswp"></A>&nbsp;
  ARM Opcodes: Memory: Single Data Swap (SWP)
</FONT></TD></TR></TABLE><BR>
<B>Opcode Format</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit    Expl.
  31-28  Condition
  27-23  Must be 00010b for this instruction
         Opcode (fixed)
           SWP{cond}{B} Rd,Rm,[Rn]      ;Rd=[Rn], [Rn]=Rm
  22     B - Byte/Word bit (0=swap 32bit/word, 1=swap 8bit/byte)
  21-20  Must be 00b for this instruction
  19-16  Rn - Base register                     (R0-R14)
  15-12  Rd - Destination Register              (R0-R14)
  11-4   Must be 00001001b for this instruction
  3-0    Rm - Source Register                   (R0-R14)
</TD></TR></TABLE>
SWP/SWPB supported by ARMv2a and up.<BR>
Swap works properly including if Rm and Rn specify the same register.<BR>
R15 may not be used for either Rn,Rd,Rm. (Rn=R15 would be MRS opcode).<BR>
Upper bits of Rd are zero-expanded when using Byte quantity. For info about
byte and word data memory addressing, read LDR and STR opcode description.<BR>
Execution Time: 1S+2N+1I. That is, 2N data cycles, 1S code cycle, plus 1I.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="armopcodescoprocessorinstructionsmrcmcrldcstccdpmcrrmrrc"></A>&nbsp;
  ARM Opcodes: Coprocessor Instructions (MRC/MCR, LDC/STC, CDP, MCRR/MRRC)
</FONT></TD></TR></TABLE><BR>
<B>Coprocessor Register Transfers (MRC, MCR) (with ARM Register read/write)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit    Expl.
  31-28  Condition (or 1111b for MRC2/MCR2 opcodes on ARMv5 and up)
  27-24  Must be 1110b for this instruction
  23-21  CP Opc - Coprocessor operation code         (0-7)
  20     ARM-Opcode (0-1)
          0: MCR{cond} Pn,&lt;cpopc&gt;,Rd,Cn,Cm{,&lt;cp&gt;}   ;move from ARM to CoPro
          0: MCR2      Pn,&lt;cpopc&gt;,Rd,Cn,Cm{,&lt;cp&gt;}   ;move from ARM to CoPro
          1: MRC{cond} Pn,&lt;cpopc&gt;,Rd,Cn,Cm{,&lt;cp&gt;}   ;move from CoPro to ARM
          1: MRC2      Pn,&lt;cpopc&gt;,Rd,Cn,Cm{,&lt;cp&gt;}   ;move from CoPro to ARM
  19-16  Cn     - Coprocessor source/dest. Register  (C0-C15)
  15-12  Rd     - ARM source/destination Register    (R0-R15)
  11-8   Pn     - Coprocessor number                 (P0-P15)
  7-5    CP     - Coprocessor information            (0-7)
  4      Reserved, must be one (1) (otherwise CDP opcode)
  3-0    Cm     - Coprocessor operand Register       (C0-C15)
</TD></TR></TABLE>
MCR/MRC supported by ARMv2 and up, MCR2/MRC2 by ARMv5 and up.<BR>
A22i syntax allows to use MOV with Rd specified as first (dest), or last
(source) operand. Native MCR/MRC syntax uses Rd as middle operand, &lt;cp&gt;
can be ommited if &lt;cp&gt; is zero.<BR>
When using MCR with R15: Coprocessor will receive a data value of PC+12.<BR>
When using MRC with R15: Bit 31-28 of data are copied to Bit 31-28 of CPSR (ie.
N,Z,C,V flags), other data bits are ignored, CPSR Bit 27-0 are not affected,
R15 (PC) is not affected.<BR>
Execution time: 1S+bI+1C for MCR, 1S+(b+1)I+1C for MRC.<BR>
Return: For MRC only: Either R0-R14 modified, or flags affected (see above).<BR>
For details refer to original ARM docs. The opcodes irrelevant for GBA/NDS7
because no coprocessor exists (except for a dummy CP14 unit). However, NDS9
includes a working CP15 unit.<BR>
<A HREF="#armcp14icebreakerdebugcommunicationschannel">ARM CP14 ICEbreaker Debug Communications Channel</A><BR>
<A HREF="#armcp15systemcontrolcoprocessor">ARM CP15 System Control Coprocessor</A><BR>
<BR>
<B>Coprocessor Data Transfers (LDC, STC) (with Memory read/write)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit    Expl.
  31-28  Condition (or 1111b for LDC2/STC2 opcodes on ARMv5 and up)
  27-25  Must be 110b for this instruction
  24     P - Pre/Post (0=post; add offset after transfer, 1=pre; before trans.)
  23     U - Up/Down Bit (0=down; subtract offset from base, 1=up; add to base)
  22     N - Transfer length (0-1, interpretation depends on co-processor)
  21     W - Write-back bit (0=no write-back, 1=write address into base)
  20     Opcode (0-1)
          0: STC{cond}{L} Pn,Cd,&lt;Address&gt;  ;Store to memory (from coprocessor)
          0: STC2{L}      Pn,Cd,&lt;Address&gt;  ;Store to memory (from coprocessor)
          1: LDC{cond}{L} Pn,Cd,&lt;Address&gt;  ;Read from memory (to coprocessor)
          1: LDC2{L}      Pn,Cd,&lt;Address&gt;  ;Read from memory (to coprocessor)
          whereas {L} indicates long transfer (Bit 22: N=1)
  19-16  Rn     - ARM Base Register              (R0-R15)     (R15=PC+8)
  15-12  Cd     - Coprocessor src/dest Register  (C0-C15)
  11-8   Pn     - Coprocessor number             (P0-P15)
  7-0    Offset - Unsigned Immediate, step 4     (0-1020, in steps of 4)
</TD></TR></TABLE>
LDC/STC supported by ARMv2 and up, LDC2/STC2 by ARMv5 and up.<BR>
Execution time: (n-1)S+2N+bI, n=number of words transferred.<BR>
For details refer to original ARM docs, irrelevant in GBA because no
coprocessor exists.<BR>
<BR>
<B>Coprocessor Data Operations (CDP) (without Memory or ARM Register operand)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit    Expl.
  31-28  Condition (or 1111b for CDP2 opcode on ARMv5 and up)
  27-24  Must be 1110b for this instruction
         ARM-Opcode (fixed)
           CDP{cond} Pn,&lt;cpopc&gt;,Cd,Cn,Cm{,&lt;cp&gt;}
           CDP2      Pn,&lt;cpopc&gt;,Cd,Cn,Cm{,&lt;cp&gt;}
  23-20  CP Opc - Coprocessor operation code       (0-15)
  19-16  Cn     - Coprocessor operand Register     (C0-C15)
  15-12  Cd     - Coprocessor destination Register (C0-C15)
  11-8   Pn     - Coprocessor number               (P0-P15)
  7-5    CP     - Coprocessor information          (0-7)
  4      Reserved, must be zero (otherwise MCR/MRC opcode)
  3-0    Cm     - Coprocessor operand Register     (C0-C15)
</TD></TR></TABLE>
CDP supported by ARMv2 and up, CDP2 by ARMv5 and up.<BR>
Execution time: 1S+bI, b=number of cycles in coprocessor busy-wait loop.<BR>
Return: No flags affected, no ARM-registers used/modified.<BR>
For details refer to original ARM docs, irrelevant in GBA because no
coprocessor exists.<BR>
<BR>
<B>Coprocessor Double-Register Transfer (MCRR, MRRC) - ARMv5TE only</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit    Expl.
  31-28  Condition
  27-21  Must be 1100010b for this instruction
  20     L - Opcode (Load/Store)
          0: MCRR{cond} Pn,opcode,Rd,Rn,Cm  ;write Rd,Rn to coproc
          1: MRRC{cond} Pn,opcode,Rd,Rn,Cm  ;read Rd,Rn from coproc
  19-16  Rn - Second source/dest register      (R0-R14)
  15-12  Rd - First source/dest register       (R0-R14)
  11-8   Pn     - Coprocessor number           (P0-P15)
  7-4    CP Opc - Coprocessor operation code   (0-15)
  3-0    Cm     - Coprocessor operand Register (C0-C15)
</TD></TR></TABLE>
Supported by ARMv5TE only, not ARMv5, not ARMv5TExP.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="thumbinstructionsummary"></A>&nbsp;
  THUMB Instruction Summary
</FONT></TD></TR></TABLE><BR>
The table below lists all THUMB mode instructions with clock cycles, affected
CPSR flags, Format/chapter number, and description.<BR>
Only register R0..R7 can be used in thumb mode (unless R8-15,SP,PC are
explicitly mentioned).<BR>
<BR>
<B>Logical Operations</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Instruction        Cycles Flags Format Expl.
  MOV Rd,Imm8bit      1S     NZ--  3   Rd=nn
  MOV Rd,Rs           1S     NZ00  2   Rd=Rs+0
  MOV R0..14,R8..15   1S     ----  5   Rd=Rs
  MOV R8..14,R0..15   1S     ----  5   Rd=Rs
  MOV R15,R0..15      2S+1N  ----  5   PC=Rs
  MVN Rd,Rs           1S     NZ--  4   Rd=NOT Rs
  AND Rd,Rs           1S     NZ--  4   Rd=Rd AND Rs
  TST Rd,Rs           1S     NZ--  4 Void=Rd AND Rs
  BIC Rd,Rs           1S     NZ--  4   Rd=Rd AND NOT Rs
  ORR Rd,Rs           1S     NZ--  4   Rd=Rd OR Rs
  EOR Rd,Rs           1S     NZ--  4   Rd=Rd XOR Rs
  LSL Rd,Rs,Imm5bit   1S     NZc-  1   Rd=Rs SHL nn
  LSL Rd,Rs           1S+1I  NZc-  4   Rd=Rd SHL (Rs AND 0FFh)
  LSR Rd,Rs,Imm5bit   1S     NZc-  1   Rd=Rs SHR nn
  LSR Rd,Rs           1S+1I  NZc-  4   Rd=Rd SHR (Rs AND 0FFh)
  ASR Rd,Rs,Imm5bit   1S     NZc-  1   Rd=Rs SAR nn
  ASR Rd,Rs           1S+1I  NZc-  4   Rd=Rd SAR (Rs AND 0FFh)
  ROR Rd,Rs           1S+1I  NZc-  4   Rd=Rd ROR (Rs AND 0FFh)
  NOP                 1S     ----  5   R8=R8
</TD></TR></TABLE>
Carry flag affected only if shift amount is non-zero.<BR>
<BR>
<B>Arithmetic Operations and Multiply</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Instruction        Cycles Flags Format Expl.
  ADD Rd,Rs,Imm3bit   1S     NZCV  2   Rd=Rs+nn
  ADD Rd,Imm8bit      1S     NZCV  3   Rd=Rd+nn
  ADD Rd,Rs,Rn        1S     NZCV  2   Rd=Rs+Rn
  ADD R0..14,R8..15   1S     ----  5   Rd=Rd+Rs
  ADD R8..14,R0..15   1S     ----  5   Rd=Rd+Rs
  ADD R15,R0..15      2S+1N  ----  5   PC=Rd+Rs
  ADD Rd,PC,Imm8bit*4 1S     ---- 12   Rd=(($+4) AND NOT 2)+nn
  ADD Rd,SP,Imm8bit*4 1S     ---- 12   Rd=SP+nn
  ADD SP,Imm7bit*4    1S     ---- 13   SP=SP+nn
  ADD SP,-Imm7bit*4   1S     ---- 13   SP=SP-nn
  ADC Rd,Rs           1S     NZCV  4   Rd=Rd+Rs+Cy
  SUB Rd,Rs,Imm3Bit   1S     NZCV  2   Rd=Rs-nn
  SUB Rd,Imm8bit      1S     NZCV  3   Rd=Rd-nn
  SUB Rd,Rs,Rn        1S     NZCV  2   Rd=Rs-Rn
  SBC Rd,Rs           1S     NZCV  4   Rd=Rd-Rs-NOT Cy
  NEG Rd,Rs           1S     NZCV  4   Rd=0-Rs
  CMP Rd,Imm8bit      1S     NZCV  3 Void=Rd-nn
  CMP Rd,Rs           1S     NZCV  4 Void=Rd-Rs
  CMP R0-15,R8-15     1S     NZCV  5 Void=Rd-Rs
  CMP R8-15,R0-15     1S     NZCV  5 Void=Rd-Rs
  CMN Rd,Rs           1S     NZCV  4 Void=Rd+Rs
  MUL Rd,Rs           1S+mI  NZx-  4   Rd=Rd*Rs
</TD></TR></TABLE>
<BR>
<B>Jumps and Calls</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Instruction        Cycles    Flags Format Expl.
  B disp              2S+1N     ---- 18  PC=$+/-2048
  BL disp             3S+1N     ---- 19  PC=$+/-4M, LR=$+5
  B{cond=true} disp   2S+1N     ---- 16  PC=$+/-0..256
  B{cond=false} disp  1S        ---- 16  N/A
  BX R0..15           2S+1N     ----  5  PC=Rs, ARM/THUMB (Rs bit0)
  SWI Imm8bit         2S+1N     ---- 17  PC=8, ARM SVC mode, LR=$+2
  BKPT Imm8bit        ???       ---- 17  ??? ARM9 Prefetch Abort
  BLX disp            ???       ---- ??? ??? ARM9
  BLX R0..R14         ???       ---- ??? ??? ARM9
  POP {Rlist,}PC   (n+1)S+2N+1I ---- 14
  MOV R15,R0..15      2S+1N     ----  5  PC=Rs
  ADD R15,R0..15      2S+1N     ----  5  PC=Rd+Rs
</TD></TR></TABLE>
The thumb BL instruction occupies two 16bit opcodes, 32bit in total.<BR>
<BR>
<B>Memory Load/Store</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Instruction        Cycles    Flags Format Expl.
  LDR  Rd,[Rb,5bit*4] 1S+1N+1I  ----  9  Rd = WORD[Rb+nn]
  LDR  Rd,[PC,8bit*4] 1S+1N+1I  ----  6  Rd = WORD[PC+nn]
  LDR  Rd,[SP,8bit*4] 1S+1N+1I  ---- 11  Rd = WORD[SP+nn]
  LDR  Rd,[Rb,Ro]     1S+1N+1I  ----  7  Rd = WORD[Rb+Ro]
  LDRB Rd,[Rb,5bit*1] 1S+1N+1I  ----  9  Rd = BYTE[Rb+nn]
  LDRB Rd,[Rb,Ro]     1S+1N+1I  ----  7  Rd = BYTE[Rb+Ro]
  LDRH Rd,[Rb,5bit*2] 1S+1N+1I  ---- 10  Rd = HALFWORD[Rb+nn]
  LDRH Rd,[Rb,Ro]     1S+1N+1I  ----  8  Rd = HALFWORD[Rb+Ro]
  LDSB Rd,[Rb,Ro]     1S+1N+1I  ----  8  Rd = SIGNED_BYTE[Rb+Ro]
  LDSH Rd,[Rb,Ro]     1S+1N+1I  ----  8  Rd = SIGNED_HALFWORD[Rb+Ro]
  STR  Rd,[Rb,5bit*4] 2N        ----  9  WORD[Rb+nn] = Rd
  STR  Rd,[SP,8bit*4] 2N        ---- 11  WORD[SP+nn] = Rd
  STR  Rd,[Rb,Ro]     2N        ----  7  WORD[Rb+Ro] = Rd
  STRB Rd,[Rb,5bit*1] 2N        ----  9  BYTE[Rb+nn] = Rd
  STRB Rd,[Rb,Ro]     2N        ----  7  BYTE[Rb+Ro] = Rd
  STRH Rd,[Rb,5bit*2] 2N        ---- 10  HALFWORD[Rb+nn] = Rd
  STRH Rd,[Rb,Ro]     2N        ----  8  HALFWORD[Rb+Ro]=Rd
  PUSH {Rlist}{LR}    (n-1)S+2N ---- 14
  POP  {Rlist}{PC}              ---- 14  (ARM9: with mode switch)
  STMIA Rb!,{Rlist}   (n-1)S+2N ---- 15
  LDMIA Rb!,{Rlist}   nS+1N+1I  ---- 15
</TD></TR></TABLE>
<BR>
<B>THUMB Binary Opcode Format</B><BR>
This table summarizes the position of opcode/parameter bits for THUMB mode
instructions, Format 1-19.<BR>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 Form|_15|_14|_13|_12|_11|_10|_9_|_8_|_7_|_6_|_5_|_4_|_3_|_2_|_1_|_0_|
 __1_|_0___0___0_|__Op___|_______Offset______|____Rs_____|____Rd_____|Shifted
 __2_|_0___0___0___1___1_|_I,_Op_|___Rn/nn___|____Rs_____|____Rd_____|ADD/SUB
 __3_|_0___0___1_|__Op___|____Rd_____|_____________Offset____________|Immedi.
 __4_|_0___1___0___0___0___0_|______Op_______|____Rs_____|____Rd_____|AluOp
 __5_|_0___1___0___0___0___1_|__Op___|Hd_|Hs_|____Rs_____|____Rd_____|HiReg/BX
 __6_|_0___1___0___0___1_|____Rd_____|_____________Word______________|LDR PC
 __7_|_0___1___0___1_|__Op___|_0_|___Ro______|____Rb_____|____Rd_____|LDR/STR
 __8_|_0___1___0___1_|__Op___|_1_|___Ro______|____Rb_____|____Rd_____|""H/SB/SH
 __9_|_0___1___1_|__Op___|_______Offset______|____Rb_____|____Rd_____|""{B}
 _10_|_1___0___0___0_|Op_|_______Offset______|____Rb_____|____Rd_____|""H
 _11_|_1___0___0___1_|Op_|____Rd_____|_____________Word______________|"" SP
 _12_|_1___0___1___0_|Op_|____Rd_____|_____________Word______________|ADD PC/SP
 _13_|_1___0___1___1___0___0___0___0_|_S_|___________Word____________|ADD SP,nn
 _14_|_1___0___1___1_|Op_|_1___0_|_R_|____________Rlist______________|PUSH/POP
 _17_|_1___0___1___1___1___1___1___0_|___________User_Data___________|BKPT ARM9
 _15_|_1___1___0___0_|Op_|____Rb_____|____________Rlist______________|STM/LDM
 _16_|_1___1___0___1_|_____Cond______|_________Signed_Offset_________|B{cond}
 _U__|_1___1___0___1___1___1___1___0_|_____________var_______________|UndefARM9
 _17_|_1___1___0___1___1___1___1___1_|___________User_Data___________|SWI
 _18_|_1___1___1___0___0_|________________Offset_____________________|B
 _19_|_1___1___1___0___1_|_________________________var___________|_0_|BLX.ARM9
 _U__|_1___1___1___0___1_|_________________________var___________|_1_|UndefARM9
 _19_|_1___1___1___1_|_H_|______________Offset_Low/High______________|BL,BLX
</TD></TR></TABLE>
<BR>
Further UNDEFS ??? ARM9?<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 1011 0001 xxxxxxxx (reserved)
 1011 0x1x xxxxxxxx (reserved)
 1011 10xx xxxxxxxx (reserved)
 1011 1111 xxxxxxxx (reserved)
 1101 1110 xxxxxxxx (free for user)
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="thumbopcodesregisteroperationsalubx"></A>&nbsp;
  THUMB Opcodes: Register Operations (ALU, BX)
</FONT></TD></TR></TABLE><BR>
<B>THUMB.1: move shifted register</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-13  Must be 000b for 'move shifted register' instructions
  12-11  Opcode
           00b: LSL Rd,Rs,#Offset   (logical/arithmetic shift left)
           01b: LSR Rd,Rs,#Offset   (logical    shift right)
           10b: ASR Rd,Rs,#Offset   (arithmetic shift right)
           11b: Reserved (used for add/subtract instructions)
  10-6   Offset                     (0-31)
  5-3    Rs - Source register       (R0..R7)
  2-0    Rd - Destination register  (R0..R7)
</TD></TR></TABLE>
Example: LSL Rd,Rs,#nn ; Rd = Rs &lt;&lt; nn ; ARM equivalent: MOVS Rd,Rs,LSL
#nn<BR>
Zero shift amount is having special meaning (same as for ARM shifts), LSL#0
performs no shift (the the carry flag remains unchanged), LSR/ASR#0 are
interpreted as LSR/ASR#32. Attempts to specify LSR/ASR#0 in source code are
automatically redirected as LSL#0, and source LSR/ASR#32 is redirected as
opcode LSR/ASR#0.<BR>
Execution Time: 1S<BR>
Flags: Z=zeroflag, N=sign, C=carry (except LSL#0: C=unchanged), V=unchanged.<BR>
<BR>
<B>THUMB.2: add/subtract</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-11  Must be 00011b for 'add/subtract' instructions
  10-9   Opcode (0-3)
           0: ADD Rd,Rs,Rn   ;add register        Rd=Rs+Rn
           1: SUB Rd,Rs,Rn   ;subtract register   Rd=Rs-Rn
           2: ADD Rd,Rs,#nn  ;add immediate       Rd=Rs+nn
           3: SUB Rd,Rs,#nn  ;subtract immediate  Rd=Rs-nn
         Pseudo/alias opcode with Imm=0:
           2: MOV Rd,Rs      ;move (affects cpsr) Rd=Rs+0
  8-6    For Register Operand:
           Rn - Register Operand (R0..R7)
         For Immediate Operand:
           nn - Immediate Value  (0-7)
  5-3    Rs - Source register       (R0..R7)
  2-0    Rd - Destination register  (R0..R7)
</TD></TR></TABLE>
Return: Rd contains result, N,Z,C,V affected (including MOV).<BR>
Execution Time: 1S<BR>
<BR>
<B>THUMB.3: move/compare/add/subtract immediate</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-13  Must be 001b for this type of instructions
  12-11  Opcode
           00b: MOV Rd,#nn      ;move     Rd   = #nn
           01b: CMP Rd,#nn      ;compare  Void = Rd - #nn
           10b: ADD Rd,#nn      ;add      Rd   = Rd + #nn
           11b: SUB Rd,#nn      ;subtract Rd   = Rd - #nn
  10-8   Rd - Destination Register  (R0..R7)
  7-0    nn - Unsigned Immediate    (0-255)
</TD></TR></TABLE>
ARM equivalents for MOV/CMP/ADD/SUB are MOVS/CMP/ADDS/SUBS same format.<BR>
Execution Time: 1S<BR>
Return: Rd contains result (except CMP), N,Z,C,V affected (for MOV only N,Z).<BR>
<BR>
<B>THUMB.4: ALU operations</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-10  Must be 010000b for this type of instructions
  9-6    Opcode (0-Fh)
           0: AND Rd,Rs     ;AND logical       Rd = Rd AND Rs
           1: EOR Rd,Rs     ;XOR logical       Rd = Rd XOR Rs
           2: LSL Rd,Rs     ;log. shift left   Rd = Rd &lt;&lt; (Rs AND 0FFh)
           3: LSR Rd,Rs     ;log. shift right  Rd = Rd &gt;&gt; (Rs AND 0FFh)
           4: ASR Rd,Rs     ;arit shift right  Rd = Rd SAR (Rs AND 0FFh)
           5: ADC Rd,Rs     ;add with carry    Rd = Rd + Rs + Cy
           6: SBC Rd,Rs     ;sub with carry    Rd = Rd - Rs - NOT Cy
           7: ROR Rd,Rs     ;rotate right      Rd = Rd ROR (Rs AND 0FFh)
           8: TST Rd,Rs     ;test            Void = Rd AND Rs
           9: NEG Rd,Rs     ;negate            Rd = 0 - Rs
           A: CMP Rd,Rs     ;compare         Void = Rd - Rs
           B: CMN Rd,Rs     ;neg.compare     Void = Rd + Rs
           C: ORR Rd,Rs     ;OR logical        Rd = Rd OR Rs
           D: MUL Rd,Rs     ;multiply          Rd = Rd * Rs
           E: BIC Rd,Rs     ;bit clear         Rd = Rd AND NOT Rs
           F: MVN Rd,Rs     ;not               Rd = NOT Rs
  5-3    Rs - Source Register       (R0..R7)
  2-0    Rd - Destination Register  (R0..R7)
</TD></TR></TABLE>
ARM equivalent for NEG would be RSBS.<BR>
Return: Rd contains result (except TST,CMP,CMN),<BR>
Affected Flags:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  N,Z,C,V for  ADC,SBC,NEG,CMP,CMN
  N,Z,C   for  LSL,LSR,ASR,ROR (carry flag unchanged if zero shift amount)
  N,Z,C   for  MUL on ARMv4 and below: carry flag destroyed
  N,Z     for  MUL on ARMv5 and above: carry flag unchanged
  N,Z     for  AND,EOR,TST,ORR,BIC,MVN
</TD></TR></TABLE>
Execution Time:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1S      for  AND,EOR,ADC,SBC,TST,NEG,CMP,CMN,ORR,BIC,MVN
  1S+1I   for  LSL,LSR,ASR,ROR
  1S+mI   for  MUL on ARMv4 (m=1..4; depending on MSBs of incoming Rd value)
  1S+mI   for  MUL on ARMv5 (m=3; fucking slow, no matter of MSBs of Rd value)
</TD></TR></TABLE>
<BR>
<B>THUMB.5: Hi register operations/branch exchange</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-10  Must be 010001b for this type of instructions
  9-8    Opcode (0-3)
           0: ADD Rd,Rs   ;add        Rd = Rd+Rs
           1: CMP Rd,Rs   ;compare  Void = Rd-Rs  ;CPSR affected
           2: MOV Rd,Rs   ;move       Rd = Rs
           2: NOP         ;nop        R8 = R8
           3: BX  Rs      ;jump       PC = Rs     ;may switch THUMB/ARM
           3: BLX Rs      ;call       PC = Rs     ;may switch THUMB/ARM (ARM9)
  7      MSBd - Destination Register most significant bit (or BL/BLX flag)
  6      MSBs - Source Register most significant bit
  5-3    Rs - Source Register        (together with MSBs: R0..R15)
  2-0    Rd - Destination Register   (together with MSBd: R0..R15)
</TD></TR></TABLE>
Restrictions: For ADD/CMP/MOV, MSBs and/or MSBd must be set, ie. it is not
allowed that both are cleared.<BR>
When using R15 (PC) as operand, the value will be the address of the
instruction plus 4 (ie. $+4). Except for BX R15: CPU switches to ARM state, and
PC is auto-aligned as (($+4) AND NOT 2).<BR>
For BX, MSBs may be 0 or 1, MSBd must be zero, Rd is not used/zero.<BR>
For BLX, MSBs may be 0 or 1, MSBd must be set, Rd is not used/zero.<BR>
For BX/BLX, when Bit 0 of the value in Rs is zero:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Processor will be switched into ARM mode!
  If so, Bit 1 of Rs must be cleared (32bit word aligned).
  Thus, BX PC (switch to ARM) may be issued from word-aligned address
  only, the destination is PC+4 (ie. the following halfword is skipped).
</TD></TR></TABLE>
BLX may not use R15. BLX saves the return address as LR=PC+3 (with thumb bit).<BR>
Using BLX R14 is possible (sets PC=Old_LR, and New_LR=retadr).<BR>
Assemblers/Disassemblers should use MOV R8,R8 as NOP (in THUMB mode).<BR>
Return: Only CMP affects CPSR condition flags!<BR>
Execution Time:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 1S     for ADD/MOV/CMP
 2S+1N  for ADD/MOV with Rd=R15, and for BX
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="thumbopcodesmemoryloadstoreldrstr"></A>&nbsp;
  THUMB Opcodes: Memory Load/Store (LDR/STR)
</FONT></TD></TR></TABLE><BR>
<B>THUMB.6: load PC-relative (for loading immediates from literal pool)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-11  Must be 01001b for this type of instructions
  N/A    Opcode (fixed)
           LDR Rd,[PC,#nn]      ;load 32bit    Rd = WORD[PC+nn]
  10-8   Rd - Destination Register   (R0..R7)
  7-0    nn - Unsigned offset        (0-1020 in steps of 4)
</TD></TR></TABLE>
The value of PC will be interpreted as (($+4) AND NOT 2).<BR>
Return: No flags affected, data loaded into Rd.<BR>
Execution Time: 1S+1N+1I<BR>
<BR>
<B>THUMB.7: load/store with register offset</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-12  Must be 0101b for this type of instructions
  11-10  Opcode (0-3)
          0: STR  Rd,[Rb,Ro]   ;store 32bit data  WORD[Rb+Ro] = Rd
          1: STRB Rd,[Rb,Ro]   ;store  8bit data  BYTE[Rb+Ro] = Rd
          2: LDR  Rd,[Rb,Ro]   ;load  32bit data  Rd = WORD[Rb+Ro]
          3: LDRB Rd,[Rb,Ro]   ;load   8bit data  Rd = BYTE[Rb+Ro]
  9      Must be zero (0) for this type of instructions
  8-6    Ro - Offset Register              (R0..R7)
  5-3    Rb - Base Register                (R0..R7)
  2-0    Rd - Source/Destination Register  (R0..R7)
</TD></TR></TABLE>
Return: No flags affected, data loaded either into Rd or into memory.<BR>
Execution Time: 1S+1N+1I for LDR, or 2N for STR<BR>
<BR>
<B>THUMB.8: load/store sign-extended byte/halfword</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-12  Must be 0101b for this type of instructions
  11-10  Opcode (0-3)
          0: STRH Rd,[Rb,Ro]  ;store 16bit data          HALFWORD[Rb+Ro] = Rd
          1: LDSB Rd,[Rb,Ro]  ;load sign-extended 8bit   Rd = BYTE[Rb+Ro]
          2: LDRH Rd,[Rb,Ro]  ;load zero-extended 16bit  Rd = HALFWORD[Rb+Ro]
          3: LDSH Rd,[Rb,Ro]  ;load sign-extended 16bit  Rd = HALFWORD[Rb+Ro]
  9      Must be set (1) for this type of instructions
  8-6    Ro - Offset Register              (R0..R7)
  5-3    Rb - Base Register                (R0..R7)
  2-0    Rd - Source/Destination Register  (R0..R7)
</TD></TR></TABLE>
Return: No flags affected, data loaded either into Rd or into memory.<BR>
Execution Time: 1S+1N+1I for LDR, or 2N for STR<BR>
<BR>
<B>THUMB.9: load/store with immediate offset</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-13  Must be 011b for this type of instructions
  12-11  Opcode (0-3)
          0: STR  Rd,[Rb,#nn]  ;store 32bit data   WORD[Rb+nn] = Rd
          1: LDR  Rd,[Rb,#nn]  ;load  32bit data   Rd = WORD[Rb+nn]
          2: STRB Rd,[Rb,#nn]  ;store  8bit data   BYTE[Rb+nn] = Rd
          3: LDRB Rd,[Rb,#nn]  ;load   8bit data   Rd = BYTE[Rb+nn]
  10-6   nn - Unsigned Offset              (0-31 for BYTE, 0-124 for WORD)
  5-3    Rb - Base Register                (R0..R7)
  2-0    Rd - Source/Destination Register  (R0..R7)
</TD></TR></TABLE>
Return: No flags affected, data loaded either into Rd or into memory.<BR>
Execution Time: 1S+1N+1I for LDR, or 2N for STR<BR>
<BR>
<B>THUMB.10: load/store halfword</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-12  Must be 1000b for this type of instructions
  11     Opcode (0-1)
          0: STRH Rd,[Rb,#nn]  ;store 16bit data   HALFWORD[Rb+nn] = Rd
          1: LDRH Rd,[Rb,#nn]  ;load  16bit data   Rd = HALFWORD[Rb+nn]
  10-6   nn - Unsigned Offset              (0-62, step 2)
  5-3    Rb - Base Register                (R0..R7)
  2-0    Rd - Source/Destination Register  (R0..R7)
</TD></TR></TABLE>
Return: No flags affected, data loaded either into Rd or into memory.<BR>
Execution Time: 1S+1N+1I for LDR, or 2N for STR<BR>
<BR>
<B>THUMB.11: load/store SP-relative</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-12  Must be 1001b for this type of instructions
  11     Opcode (0-1)
          0: STR  Rd,[SP,#nn]  ;store 32bit data   WORD[SP+nn] = Rd
          1: LDR  Rd,[SP,#nn]  ;load  32bit data   Rd = WORD[SP+nn]
  10-8   Rd - Source/Destination Register  (R0..R7)
  7-0    nn - Unsigned Offset              (0-1020, step 4)
</TD></TR></TABLE>
Return: No flags affected, data loaded either into Rd or into memory.<BR>
Execution Time: 1S+1N+1I for LDR, or 2N for STR<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="thumbopcodesmemoryaddressingaddpcsp"></A>&nbsp;
  THUMB Opcodes: Memory Addressing (ADD PC/SP)
</FONT></TD></TR></TABLE><BR>
<B>THUMB.12: get relative address</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-12  Must be 1010b for this type of instructions
  11     Opcode/Source Register (0-1)
          0: ADD  Rd,PC,#nn    ;Rd = (($+4) AND NOT 2) + nn
          1: ADD  Rd,SP,#nn    ;Rd = SP + nn
  10-8   Rd - Destination Register         (R0..R7)
  7-0    nn - Unsigned Offset              (0-1020, step 4)
</TD></TR></TABLE>
Return: No flags affected, result in Rd.<BR>
Execution Time: 1S<BR>
<BR>
<B>THUMB.13: add offset to stack pointer</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-8   Must be 10110000b for this type of instructions
  7      Opcode/Sign
          0: ADD  SP,#nn       ;SP = SP + nn
          1: ADD  SP,#-nn      ;SP = SP - nn
  6-0    nn - Unsigned Offset    (0-508, step 4)
</TD></TR></TABLE>
Return: No flags affected, SP adjusted.<BR>
Execution Time: 1S<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="thumbopcodesmemorymultipleloadstorepushpopandldmstm"></A>&nbsp;
  THUMB Opcodes: Memory Multiple Load/Store (PUSH/POP and LDM/STM)
</FONT></TD></TR></TABLE><BR>
<B>THUMB.14: push/pop registers</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-12  Must be 1011b for this type of instructions
  11     Opcode (0-1)
          0: PUSH {Rlist}{LR}   ;store in memory, decrements SP (R13)
          1: POP  {Rlist}{PC}   ;load from memory, increments SP (R13)
  10-9   Must be 10b for this type of instructions
  8      PC/LR Bit (0-1)
          0: No
          1: PUSH LR (R14), or POP PC (R15)
  7-0    Rlist - List of Registers (R7..R0)
</TD></TR></TABLE>
In THUMB mode stack is always meant to be 'full descending', ie. PUSH is
equivalent to 'STMFD/STMDB' and POP to 'LDMFD/LDMIA' in ARM mode.<BR>
Examples:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 PUSH {R0-R3}     ;push R0,R1,R2,R3
 PUSH {R0,R2,LR}  ;push R0,R2,LR
 POP  {R4,R7}     ;pop R4,R7
 POP  {R2-R4,PC}  ;pop R2,R3,R4,PC
</TD></TR></TABLE>
Note: When calling to a sub-routine, the return address is stored in LR
register, when calling further sub-routines, PUSH {LR} must be used to save
higher return address on stack. If so, POP {PC} can be later used to return
from the sub-routine.<BR>
POP {PC} ignores the least significant bit of the return address (processor
remains in thumb state even if bit0 was cleared), when intending to return with
optional mode switch, use a POP/BX combination (eg. POP {R3} / BX R3).<BR>
ARM9: POP {PC} copies the LSB to thumb bit (switches to ARM if bit0=0).<BR>
Return: No flags affected, SP adjusted, registers loaded/stored.<BR>
Execution Time: nS+1N+1I (POP), (n+1)S+2N+1I (POP PC), or (n-1)S+2N (PUSH).<BR>
<BR>
<B>THUMB.15: multiple load/store</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-12  Must be 1100b for this type of instructions
  11     Opcode (0-1)
          0: STMIA Rb!,{Rlist}   ;store in memory, increments Rb
          1: LDMIA Rb!,{Rlist}   ;load from memory, increments Rb
  10-8   Rb - Base register (modified) (R0-R7)
  7-0    Rlist - List of Registers     (R7..R0)
</TD></TR></TABLE>
Both STM and LDM are incrementing the Base Register.<BR>
The lowest register in the list (ie. R0, if it's in the list) is stored/loaded
at the lowest memory address.<BR>
Examples:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 STMIA R7!,{R0-R2}  ;store R0,R1,R2
 LDMIA R0!,{R1,R5}  ;store R1,R5
</TD></TR></TABLE>
Return: No flags affected, Rb adjusted, registers loaded/stored.<BR>
Execution Time: nS+1N+1I for LDM, or (n-1)S+2N for STM.<BR>
<BR>
<B>Strange Effects on Invalid Rlist's</B><BR>
Empty Rlist: R15 loaded/stored (ARMv4 only), and Rb=Rb+40h (ARMv4-v5).<BR>
Writeback with Rb included in Rlist: Store OLD base if Rb is FIRST entry in
Rlist, otherwise store NEW base (STM/ARMv4), always store OLD base (STM/ARMv5),
no writeback (LDM/ARMv4/ARMv5; at this point, THUMB opcodes work different than
ARM opcodes).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="thumbopcodesjumpsandcalls"></A>&nbsp;
  THUMB Opcodes: Jumps and Calls
</FONT></TD></TR></TABLE><BR>
<B>THUMB.16: conditional branch</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-12  Must be 1101b for this type of instructions
  11-8   Opcode/Condition (0-Fh)
          0: BEQ label        ;Z=1         ;equal (zero) (same)
          1: BNE label        ;Z=0         ;not equal (nonzero) (not same)
          2: BCS/BHS label    ;C=1         ;unsigned higher or same (carry set)
          3: BCC/BLO label    ;C=0         ;unsigned lower (carry cleared)
          4: BMI label        ;N=1         ;negative (minus)
          5: BPL label        ;N=0         ;positive or zero (plus)
          6: BVS label        ;V=1         ;overflow (V set)
          7: BVC label        ;V=0         ;no overflow (V cleared)
          8: BHI label        ;C=1 and Z=0 ;unsigned higher
          9: BLS label        ;C=0 or Z=1  ;unsigned lower or same
          A: BGE label        ;N=V         ;greater or equal
          B: BLT label        ;N&lt;&gt;V        ;less than
          C: BGT label        ;Z=0 and N=V ;greater than
          D: BLE label        ;Z=1 or N&lt;&gt;V ;less or equal
          E: Undefined, should not be used
          F: Reserved for SWI instruction (see SWI opcode)
  7-0    Signed Offset, step 2 ($+4-256..$+4+254)
</TD></TR></TABLE>
Destination address must by halfword aligned (ie. bit 0 cleared)<BR>
Return: No flags affected, PC adjusted if condition true<BR>
Execution Time:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  2S+1N   if condition true (jump executed)
  1S      if condition false
</TD></TR></TABLE>
<BR>
<B>BX and ADD/MOV PC</B><BR>
See also THUMB.5: BX Rs, and ADD/MOV PC,Rs.<BR>
<BR>
<B>THUMB.18: unconditional branch</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-11  Must be 11100b for this type of instructions
  N/A    Opcode (fixed)
          B label   ;branch (jump)
  10-0   Signed Offset, step 2 ($+4-2048..$+4+2046)
</TD></TR></TABLE>
Return: No flags affected, PC adjusted.<BR>
Execution Time: 2S+1N<BR>
<BR>
<B>THUMB.19: long branch with link</B><BR>
This may be used to call (or jump) to a subroutine, return address is saved in
LR (R14).<BR>
Unlike all other THUMB mode instructions, this instruction occupies 32bit of
memory which are split into two 16bit THUMB opcodes.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 First Instruction - LR = PC+4+(nn SHL 12)
  15-11  Must be 11110b for BL/BLX type of instructions
  10-0   nn - Upper 11 bits of Target Address
 Second Instruction - PC = LR + (nn SHL 1), and LR = PC+2 OR 1 (and BLX: T=0)
  15-11  Opcode
          11111b: BL label   ;branch long with link
          11101b: BLX label  ;branch long with link switch to ARM mode (ARM9)
  10-0   nn - Lower 11 bits of Target Address (BLX: Bit0 Must be zero)
</TD></TR></TABLE>
The destination address range is (PC+4)-400000h..+3FFFFEh, ie. PC+/-4M.<BR>
Target must be halfword-aligned. As Bit 0 in LR is set, it may be used to
return by a BX LR instruction (keeping CPU in THUMB mode).<BR>
Return: No flags affected, PC adjusted, return address in LR.<BR>
Execution Time: 3S+1N (first opcode 1S, second opcode 2S+1N).<BR>
Note: Exceptions may or may not occur between first and second opcode, this is
"implementation defined" (unknown how this is implemented in GBA and NDS).<BR>
Using only the 2nd half of BL as "BL LR+imm" is possible (for example, Mario
Golf Advance Tour for GBA uses opcode F800h as "BL LR+0").<BR>
<BR>
<B>THUMB.17: software interrupt and breakpoint</B><BR>
SWI supposed for calls to the operating system - Enter Supervisor mode (SVC) in
ARM state. BKPT intended for debugging - enters Abort mode in ARM state via
Prefetch Abort vector.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15-8   Opcode
          11011111b: SWI nn   ;software interrupt
          10111110b: BKPT nn  ;software breakpoint (ARMv5 and up)
  7-0    nn - Comment Field, ignored by processor (8bit value) (0-255)
</TD></TR></TABLE>
Execution Time: 2S+1N<BR>
The exception handler may interprete the SWI Comment Field by examining the
lower 8bit of the 16bit opcode opcode at [R14_svc-2].<BR>
If your are also using SWI's from inside of ARM mode, then the SWI handler must
examine the T Bit SPSR_svc in order to determine whether it's been a ARM SWI -
and if so, examine the lower 24bit of the 32bit opcode opcode at [R14_svc-4].<BR>
For Returning from SWI use "MOVS PC,R14", that instruction does restore both PC
and CPSR, ie. PC=R14_svc, and CPSR=SPSR_svc, and (as called from THUMB mode),
it'll also restore THUMB mode.<BR>
Nesting SWIs: SPSR_svc and R14_svc should be saved on stack before either
invoking nested SWIs, or (if the IRQ handler uses SWIs) before enabling IRQs.<BR>
Execution SWI/BKPT:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  R14_svc=PC+2     R14_abt=PC+4   ;save return address
  SPSR_svc=CPSR    SPSR_abt=CPSR  ;save CPSR flags
  CPSR=&lt;changed&gt;   CPSR=&lt;changed&gt; ;Enter svc/abt, ARM state, IRQs disabled
  PC=VVVV0008h     PC=VVVV000Ch   ;jump to SWI/PrefetchAbort vector address
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="armpseudoinstructionsanddirectives"></A>&nbsp;
  ARM Pseudo Instructions and Directives
</FONT></TD></TR></TABLE><BR>
<B>ARM Pseudo Instructions</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  nop              mov r0,r0
  ldr Rd,=Imm      ldr Rd,[r15,disp] ;use .pool as parameter field
  add Rd,=addr     add/sub Rd,r15,disp
  adr Rd,addr      add/sub Rd,r15,disp
  adrl Rd,addr     two add/sub opcodes with disp=xx00h+00yyh
  mov Rd,Imm       mvn Rd,NOT Imm    ;or vice-versa
  and Rd,Rn,Imm    bic Rd,Rn,NOT Imm ;or vice-versa
  cmp Rd,Rn,Imm    cmn Rd,Rn,-Imm    ;or vice-versa
  add Rd,Rn,Imm    sub Rd,Rn,-Imm    ;or vice-versa
</TD></TR></TABLE>
All above opcodes may be made conditional by specifying a {cond} field.<BR>
<BR>
<B>THUMB Pseudo Instructions</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  nop              mov r8,r8
  ldr Rd,=Imm      ldr Rd,[r15,disp] ;use .pool as parameter field
  add Rd,=addr     add Rd,r15,disp
  adr Rd,addr      add Rd,r15,disp
  mov Rd,Rs        add Rd,Rs,0       ;with Rd,Rs in range r0-r7 each
</TD></TR></TABLE>
<BR>
<B>A22i Directives</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  org  adr     assume following code from this address on
  .gba         indicate GBA program
  .nds         indicate NDS program
  .dsi         indicate DSi program
  .fix         fix GBA/NDS/DSi header checksum
  .ereader_create_bmp      create GBA e-Reader dotcode .BMP file(s) (bitmaps)
  .ereader_create_raw      create GBA e-Reader dotcode .RAW file (useless)
  .ereader_create_bin      create GBA e-Reader dotcode .BIN file (smallest)
  .ereader_japan_plus      japanese/plus     (default is non-japanese)
  .ereader_japan_original  japanese/original (with Z80-stub for GBA-code)
  .title 'Txt' defines a title (used for e-Reader dotcodes)
  .norewrite   do not delete existing output file (keep following data in file)
  .data?       following defines RAM data structure (assembled to nowhere)
  .code        following is normal ROM code/data (assembled to ROM image)
  .include     includes specified source code file (no nesting/error handling)
  .import      imports specified binary file (optional parameters: ,begin,len)
  .radix nn    changes default numeric format (nn=2,8,10,16 = bin/oct/dec/hex)
  .errif expr  generates an error message if expression is nonzero
  .if expr     assembles following code only if expression is nonzero
  .else        invert previous .if condition
  .endif       terminate .if/.ifdef/.ifndef
  .ifdef sym   assemble following only if symbol is defined
  .ifndef sym  assemble following only if symbol is not defined
  .align nn    aligns to an address divisible-by-nn, inserts 00's
  .msg         defines a no$gba debugmessage string, such like .msg 'Init Okay'
  .brk         defines a no$gba source code break opcode
  l equ n      l=n
  l:   [cmd]   l=$   (global label)
  @@l: [cmd]   @@l=$ (local label, all locals are reset at next global label)
  end          end of source code
  db ...       define 8bit data (bytes)
  dw ...       define 16bit data (halfwords)
  dd ...       define 32bit data (words)
  defs nn      define nn bytes space (zero-filled)
  ;...         defines a comment (ignored by the assembler)
  //           alias for CRLF, eg. allows &lt;db 'Text',0 // dw addr&gt; in one line
</TD></TR></TABLE>
<BR>
<B>A22i Alias Directives (for compatibility with other assemblers)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  align        .align 4          code16    .thumb
  align nn     .align nn         .code 16  .thumb
  % nn         defs nn           code32    .arm
  .space nn    defs nn           .code 32  .arm
  ..ds nn      defs nn           ltorg     .pool
  x=n          x equ n           .ltorg    .pool
  .equ x,n     x equ n           ..ltorg   .pool
  .define x n  x equ n           dcb       db (8bit data)
  incbin       .import           defb      db (8bit data)
  @@@...       ;comment          .byte     db (8bit data)
  @ ...        ;comment          .ascii    db (8bit string)
  @*...        ;comment          dcw       dw (16bit data)
  @...         ;comment          defw      dw (16bit data)
  .text        .code             .hword    dw (16bit data)
  .bss         .data?            dcd       dd (32bit data)
  .global      (ignored)         defd      dd (32bit data)
  .extern      (ignored)         .long     dd (32bit data)
  .thumb_func  (ignored)         .word     dw/dd, don't use
  #directive   .directive        .end      end
  .fill nn,1,0 defs nn
</TD></TR></TABLE>
<BR>
<B>Alias Conditions, Opcodes, Operands</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  hs   cs   ;condition higher or same = carry set
  lo   cc   ;condition lower = carry cleared
  asl  lsl  ;arithmetic shift left = logical shift left
</TD></TR></TABLE>
<BR>
<B>A22i Numeric Formats &amp; Dialects</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Type          Normal       Alias
  Decimal       85           #85  &amp;d85
  Hexadecimal   55h          #55h  0x55  #0x55  $55  &amp;h55
  Octal         125o         0o125  &amp;o125
  Ascii         'U'          "U"
  Binary        01010101b    %01010101  0b01010101  &amp;b01010101
  Roman         &amp;rLXXXV      (very useful for arrays of kings and chapters)
</TD></TR></TABLE>
Note: The default numeric format can be changed by the .radix directive
(usually 10=decimal). For example, with radix 16, values like "85" and "0101b"
are treated as hexadecimal numbers (in that case, decimal and binary numbers
can be still defined with prefixes &amp;d and &amp;b).<BR>
<BR>
<B>A22i Numeric Operators Priority</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Prio  Operator           Aliases
  8     (,) brackets
  7     +,- sign
  6     *,/,MOD,SHL,SHR    MUL,DIV,&lt;&lt;,&gt;&gt;
  5     +,- operation
  4     EQ,GE,GT,LE,LT,NE  =,&gt;=,&gt;,&lt;=,&lt;,&lt;&gt;,==,!=
  3     NOT
  2     AND
  1     OR,XOR             EOR
</TD></TR></TABLE>
Operators of same priority are processed from left to right.<BR>
Boolean operators (priority 4) return 1=TRUE, 0=FALSE.<BR>
<BR>
<B>A22i Nocash Syntax</B><BR>
Even though A22i does recognize the official ARM syntax, it's also allowing to
use friendly code:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  mov   r0,0ffh         ;no C64-style "#", and no C-style "0x" required
  stmia [r7]!,r0,r4-r5  ;square [base] brackets, no fancy {rlist} brackets
  mov   r0,cpsr         ;no confusing MSR and MRS (whatever which is which)
  mov   r0,p0,0,c0,c0,0 ;no confusing MCR and MRC (whatever which is which)
  ldr   r0,[score]      ;allows to use clean brackets for relative addresses
  push  rlist           ;alias for stmfd [r13]!,rlist (and same for pop/ldmfd)
  label:                ;label definitions recommended to use ":" colons
</TD></TR></TABLE>
<BR>
[A22i is the no$gba debug version's built-in source code assembler.]<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="armcp14icebreakerdebugcommunicationschannel"></A>&nbsp;
  ARM CP14 ICEbreaker Debug Communications Channel
</FONT></TD></TR></TABLE><BR>
The ICEbreaker aka EmbeddedICE module may be found in ARM7TDMI and possibly
also in other ARM processors. The main functionality of the module relies on
external inputs (BREAKPT signal, etc.) being controlled by external debugging
hardware. At software side, ICEbreaker contains a Debug Communications Channel
(again to access external hardware), which can be accessed as coprocessor 14
via following opcodes:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  MRC{cond} P14,0,Rd,C0,C0,0  ;Read Debug Comms Control Register
  MRC{cond} P14,0,Rd,C1,C0,0  ;Read Debug Comms Data Register
  MRC{cond} P14,0,Rd,C2,C0,0  ;Read Debug Comms Status Register
  MCR{cond} P14,0,Rd,C1,C0,0  ;Write Debug Comms Data Register
  MCR{cond} P14,0,Rd,C2,C0,0  ;Write Debug Comms Status Register
</TD></TR></TABLE>
The Control register consists of Bit31-28=ICEbreaker version (0001b for
ARM7TDMI), Bit27-2=Not specified, Bit0/Bit1=Data Read/Write Status Flags.<BR>
<BR>
The NDS7 and GBA allow to access CP14 (unlike as for CP0..CP13 &amp; CP15,
access to CP14 doesn't generate any exceptions), however, the ICEbreaker module
appears to be disabled (or completely unimplemented), any reads from
P14,0,Rd,C0,C0,0 through P14,7,Rd,C15,C15,7 are simply returning the prefetched
opcode value from [$+8]. ICEbreaker might be eventually used and enabled in
Nintendo's hardware debuggers, although external breakpoints are reportedly
implemented via /FIQ input rather than via ICEbreaker hardware.<BR>
The NDS9 doesn't include a CP14 unit (or it is fully disabled), any attempts to
access it are causing invalid instruction exceptions.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="armcp15systemcontrolcoprocessor"></A>&nbsp;
  ARM CP15 System Control Coprocessor
</FONT></TD></TR></TABLE><BR>
<A HREF="#armcp15overview">ARM CP15 Overview</A><BR>
<A HREF="#armcp15idcodes">ARM CP15 ID Codes</A><BR>
<A HREF="#armcp15controlregister">ARM CP15 Control Register</A><BR>
<A HREF="#armcp15memorymanagmentunitmmu">ARM CP15 Memory Managment Unit (MMU)</A><BR>
<A HREF="#armcp15protectionunitpu">ARM CP15 Protection Unit (PU)</A><BR>
<A HREF="#armcp15cachecontrol">ARM CP15 Cache Control</A><BR>
<A HREF="#armcp15tightlycoupledmemorytcm">ARM CP15 Tightly Coupled Memory (TCM)</A><BR>
<A HREF="#armcp15misc">ARM CP15 Misc</A><BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="armcp15overview"></A>&nbsp;
  ARM CP15 Overview
</FONT></TD></TR></TABLE><BR>
<B>CP15</B><BR>
In many ARM CPUs, particulary such with memory control facilities, coprocessor
number 15 (CP15) is used as built-in System Control Coprocessor.<BR>
CPUs without memory control functions typically don't include a CP15 at all, in
that case even an attempt to read the Main ID register will cause an Undefined
Instruction exception.<BR>
<BR>
<B>CP15 Opcodes</B><BR>
CP15 can be accessed via MCR and MRC opcodes, with Pn=P15, and &lt;cpopc&gt;=0.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  MCR{cond} P15,0,Rd,Cn,Cm,&lt;cp&gt;   ;move from ARM to CP15
  MRC{cond} P15,0,Rd,Cn,Cm,&lt;cp&gt;   ;move from CP15 to ARM
</TD></TR></TABLE>
Rd can be any ARM register in range R0-R14, R15 should not be used with P15.<BR>
Cn,Cm,&lt;cp&gt; are used to select a CP15 register, eg. C0,C0,0 = Main ID
Register.<BR>
Other coprocessor opcodes (CDP, LDC, STC) cannot be used with P15.<BR>
<BR>
<B>CP15 Register List</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Register     Expl.
  C0,C0,0      Main ID Register (R)
  C0,C0,1      Cache Type and Size (R)
  C0,C0,2      TCM Physical Size (R)
  C1,C0,0      Control Register (R/W, or R=Fixed)
  C2,C0,0      PU Cachability Bits for Data/Unified Protection Region
  C2,C0,1      PU Cachability Bits for Instruction Protection Region
  C3,C0,0      PU Write-Bufferability Bits for Data Protection Regions
  C5,C0,0      PU Access Permission Data/Unified Protection Region
  C5,C0,1      PU Access Permission Instruction Protection Region
  C5,C0,2      PU Extended Access Permission Data/Unified Protection Region
  C5,C0,3      PU Extended Access Permission Instruction Protection Region
  C6,C0..C7,0  PU Protection Unit Data/Unified Region 0..7
  C6,C0..C7,1  PU Protection Unit Instruction Region 0..7
  C7,Cm,Op2    Cache Commands and Halt Function (W)
  C9,C0,0      Cache Data Lockdown
  C9,C0,1      Cache Instruction Lockdown
  C9,C1,0      TCM Data TCM Base and Virtual Size
  C9,C1,1      TCM Instruction TCM Base and Virtual Size
  C13,Cm,Op2   Misc Process ID registers
  C15,Cm,Op2   Misc Implementation Defined and Test/Debug registers
</TD></TR></TABLE>
<BR>
<B>Data/Unified Registers</B><BR>
Some Cache/PU/TCM registers are declared as "Data/Unified".<BR>
That registers are used for Data accesses in case that the CPU contains
separate Data and Instruction registers, otherwise the registers are used for
both (unified) Data and Instruction accesses.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="armcp15idcodes"></A>&nbsp;
  ARM CP15 ID Codes
</FONT></TD></TR></TABLE><BR>
<B>C0,C0,0 - Main ID Register (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  12-15 ARM Era (0=Pre-ARM7, 7=ARM7, other=Post-ARM7)
</TD></TR></TABLE>
Post-ARM7 Processors<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-3   Revision Number
  4-15  Primary Part Number (Bit12-15 must be other than 0 or 7)
        (eg. 946h for ARM946)
  16-19 Architecture        (1=v4, 2=v4T, 3=v5, 4=v5T, 5=v5TE)
  20-23 Variant Number
  24-31 Implementor         (41h=ARM, 44h=Digital Equipment Corp, 69h=Intel)
</TD></TR></TABLE>
ARM7 Processors<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-3   Revision Number
  4-15  Primary Part Number (Bit12-15 must be 7)
  16-22 Variant Number
  23    Architecture        (0=v3, 1=v4T)
  24-31 Implementor         (41h=ARM, 44h=Digital Equipment Corp, 69h=Intel)
</TD></TR></TABLE>
Pre-ARM7 Processors<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-3   Revision Number
  4-11  Processor ID LSBs (30h=ARM3/v2, 60h,61h,62=ARM600,610,620/v3)
  12-31 Processor ID MSBs (fixed, 41560h)
</TD></TR></TABLE>
Note: On the NDS9, this register is 41059461h. NDS7 and GBA don't have CP15s.<BR>
<BR>
<B>C0,C0,1 - Cache Type Register (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-11  Instruction Cache (bits 0-1=len, 2=m, 3-5=assoc, 6-8=size, 9-11=zero)
  12-23 Data Cache        (bits 0-1=len, 2=m, 3-5=assoc, 6-8=size, 9-11=zero)
  24    Separate Cache Flag (0=Unified, 1=Separate Data/Instruction Caches)
  25-28 Cache Type (0,1,2,6,7=see below, other=reserved)
         Type Method         Cache cleaning         Cache lock-down
         0    Write-through  Not needed             Not supported
         1    Write-back     Read data block        Not supported
         2    Write-back     Register 7 operations  Not supported
         6    Write-back     Register 7 operations  Format A
         7    Write-back     Register 7 operations  Format B
  29-31 Reserved (zero)
</TD></TR></TABLE>
The 12bit Instruction/Data values are decoded as shown below,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Cache Absent  = (ASSOC=0 and M=1)       ;in that case overriding below
  Cache Size    = 200h+(100h*M) shl SIZE  ;min 0.5Kbytes, max 96Kbytes
  Associativity = (1+(0.5*M)) shl ASSOC   ;min 1-way,     max 192-way
  Line Length   = 8 shl LEN               ;min 8 bytes,   max 64 bytes
</TD></TR></TABLE>
For Unified cache (Bit 24=0), Instruction and Data values are identical.<BR>
<BR>
<B>C0,C0,2 - Tightly Coupled Memory (TCM) Size Register (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-1   Reserved    (0)
  2     ITCM Absent (0=Present, 1=Absent)
  3-5   Reserved    (0)
  6-9   ITCM Size   (Size = 512 SHL N) (or 0=None)
  10-13 Reserved    (0)
  14    DTCM Absent (0=Present, 1=Absent)
  15-17 Reserved    (0)
  18-21 DTCM Size   (Size = 512 SHL N) (or 0=None)
  22-31 Reserved    (0)
</TD></TR></TABLE>
<BR>
<B>C0,C0,3..7 - Reserved (R)</B><BR>
Unused/Reserved registers, containing the same value as C0,C0,0.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="armcp15controlregister"></A>&nbsp;
  ARM CP15 Control Register
</FONT></TD></TR></TABLE><BR>
<B>C1,C0,0 - Control Register (R/W, or R=Fixed)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0  MMU/PU Enable         (0=Disable, 1=Enable) (Fixed 0 if none)
  1  Alignment Fault Check (0=Disable, 1=Enable) (Fixed 0/1 if none/always on)
  2  Data/Unified Cache    (0=Disable, 1=Enable) (Fixed 0/1 if none/always on)
  3  Write Buffer          (0=Disable, 1=Enable) (Fixed 0/1 if none/always on)
  4  Exception Handling    (0=26bit, 1=32bit)    (Fixed 1 if always 32bit)
  5  26bit-address faults  (0=Enable, 1=Disable) (Fixed 1 if always 32bit)
  6  Abort Model (pre v4)  (0=Early, 1=Late Abort) (Fixed 1 if ARMv4 and up)
  7  Endian                (0=Little, 1=Big)     (Fixed 0/1 if fixed)
  8  System Protection bit (MMU-only)
  9  ROM Protection bit    (MMU-only)
  10 Implementation defined
  11 Branch Prediction     (0=Disable, 1=Enable)
  12 Instruction Cache     (0=Disable, 1=Enable) (ignored if Unified cache)
  13 Exception Vectors     (0=00000000h, 1=FFFF0000h)
  14 Cache Replacement     (0=Normal/PseudoRandom, 1=Predictable/RoundRobin)
  15 Pre-ARMv5 Mode        (0=Normal, 1=Pre ARMv5; LDM/LDR/POP_PC.Bit0/Thumb)
  16 DTCM Enable           (0=Disable, 1=Enable)
  17 DTCM Load Mode        (0=R/W, 1=DTCM Write-only)
  18 ITCM Enable           (0=Disable, 1=Enable)
  19 ITCM Load Mode        (0=R/W, 1=ITCM Write-only)
  20-31 Reserved           (keep these bits unchanged) (usually zero)
</TD></TR></TABLE>
Various bits in this register may be read-only (fixed 0 if unsupported, or
fixed 1 if always activated).<BR>
On the NDS bit0,2,7,12..19 are R/W, Bit3..6 are always set, all other bits are
always zero.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="armcp15memorymanagmentunitmmu"></A>&nbsp;
  ARM CP15 Memory Managment Unit (MMU)
</FONT></TD></TR></TABLE><BR>
Function of some registers depends on whether the CPU contains a MMU or PU.<BR>
MMU handles virtual addressing tables.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  C2,Cm,Op2  MMU Translation Table Base
  C3,Cm,Op2  MMU Domain Access Control
  C5,Cm,Op2  MMU Fault Status
  C6,Cm,Op2  MMU Fault Address
  C8,Cm,Op2  MMU TLB Control
  C10,Cm,Op2 MMU TLB Lockdown
</TD></TR></TABLE>
The GBA, and Nintendo DS do not have a MMU.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="armcp15protectionunitpu"></A>&nbsp;
  ARM CP15 Protection Unit (PU)
</FONT></TD></TR></TABLE><BR>
Protection Unit can be enabled in Bit0 of C1,C0,0 (Control Register).<BR>
<BR>
<B>C2,C0,0 - Cachability Bits for Data/Unified Protection Region (R/W)</B><BR>
<B>C2,C0,1 - Cachability Bits for Instruction Protection Region (if any) (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-7  Cachable (C) bits for region 0-7
  8-31 Reserved/zero
</TD></TR></TABLE>
<BR>
<B>C3,C0,0 - Write-Bufferability Bits for Data Protection Regions (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-7  Bufferable (B) bits for region 0-7
  8-31 Reserved/zero
</TD></TR></TABLE>
Instruction fetches are, obviously, always read-operations. So, there are no
write-bufferability bits for Instruction Protection Regions.<BR>
<BR>
<B>C5,C0,0 - Access Permission Data/Unified Protection Region (R/W)</B><BR>
<B>C5,C0,1 - Access Permission Instruction Protection Region (if any) (R/W)</B><BR>
<B>C5,C0,2 - Extended Access Permission Data/Unified Protection Region (R/W)</B><BR>
<B>C5,C0,3 - Extended Access Permission Instruction Protection Region (if any) (R/W)</B><BR>
For C5,C0,0 and C5,C0,1:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15  Access Permission (AP) bits for region 0-7 (Bits 0-1=AP0, 2-3=AP1, etc)
  16-31 Reserved/zero
</TD></TR></TABLE>
For C5,C0,2 and C5,C0,3 (Extended):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-31  Access Permission (AP) bits for region 0-7 (Bits 0-3=AP0, 4-7=AP1, etc)
</TD></TR></TABLE>
The possible AP settings (0-3 for C5,C0,0..1, or 0-15 for C5,C0,2..3) are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  AP  Privileged User
  0   -          -
  1   R/W        -
  2   R/W        R
  3   R/W        R/W
  5   R          -
  6   R          R
</TD></TR></TABLE>
Settings 5,6 only for Extended Registers, settings 4,7..15 are Reserved.<BR>
<BR>
<B>C6,C0..C7,0 - Protection Unit Data/Unified Region 0..7 (R/W)</B><BR>
<B>C6,C0..C7,1 - Protection Unit Instruction Region 0..7 (R/W) if any</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Protection Region Enable (0=Disable, 1=Enable)
  1-5   Protection Region Size   (2 SHL X) ;min=(X=11)=4KB, max=(X=31)=4GB
  6-11  Reserved/zero
  12-31 Protection Region Base address (Addr = Y*4K; must be SIZE-aligned)
</TD></TR></TABLE>
Overlapping Regions are allowed, Region 7 is having highest priority, region 0
lowest priority.<BR>
<BR>
<B>Background Region</B><BR>
Additionally, any memory areas outside of the eight Protection Regions are
handled as Background Region, this region has neither Read nor Write access.<BR>
<BR>
<B>Unified Region Note</B><BR>
On the NDS, the Region registers are unified (C6,C0..C7,1 are read/write-able
mirrors of C6,C0..C7,0). Nethertheless, the Cachabilty and Permission registers
are NOT unified (separate registers exists for code and data settings).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="armcp15cachecontrol"></A>&nbsp;
  ARM CP15 Cache Control
</FONT></TD></TR></TABLE><BR>
Cache enabled/controlled by Bit 2,3,12,14 in Control Register.<BR>
Cache type detected in Cache Type Register.<BR>
<BR>
<B>C7,C0..C15,0..7 - Cache Commands (W)</B><BR>
Write-only Cache Command Register. Cm,Op2 operands used to select a specific
command, with parameter value in Rd.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Cn,Cm,Op2 Rd   ARM9 Command
  C7,C0,4   0    Yes  Wait For Interrupt (Halt)
  C7,C5,0   0    Yes  Invalidate Entire Instruction Cache
  C7,C5,1   VA   Yes  Invalidate Instruction Cache Line
  C7,C5,2   S/I  -    Invalidate Instruction Cache Line
  C7,C5,4   0    -    Flush Prefetch Buffer
  C7,C5,6   0    -    Flush Entire Branch Target Cache
  C7,C5,7   IMP? -    Flush Branch Target Cache Entry
  C7,C6,0   0    Yes  Invalidate Entire Data Cache
  C7,C6,1   VA   Yes  Invalidate Data Cache Line
  C7,C6,2   S/I  -    Invalidate Data Cache Line
  C7,C7,0   0    -    Invalidate Entire Unified Cache
  C7,C7,1   VA   -    Invalidate Unified Cache Line
  C7,C7,2   S/I  -    Invalidate Unified Cache Line
  C7,C8,2   0    Yes  Wait For Interrupt (Halt), alternately to C7,C0,4
  C7,C10,1  VA   Yes  Clean Data Cache Line
  C7,C10,2  S/I  Yes  Clean Data Cache Line
  C7,C10,4  0    -    Drain Write Buffer
  C7,C11,1  VA   -    Clean Unified Cache Line
  C7,C11,2  S/I  -    Clean Unified Cache Line
  C7,C13,1  VA   Yes  Prefetch Instruction Cache Line
  C7,C14,1  VA   Yes  Clean and Invalidate Data Cache Line
  C7,C14,2  S/I  Yes  Clean and Invalidate Data Cache Line
  C7,C15,1  VA   -    Clean and Invalidate Unified Cache Line
  C7,C15,2  S/I  -    Clean and Invalidate Unified Cache Line
</TD></TR></TABLE>
Parameter values (Rd) formats:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0    Not used, should be zero
  VA   Virtual Address
  S/I  Set/index; Bit 31..(32-A) = Index, Bit (L+S-1)..L = Set ?
</TD></TR></TABLE>
<BR>
<B>C9,C0,0 - Data Cache Lockdown</B><BR>
<B>C9,C0,1 - Instruction Cache Lockdown</B><BR>
(Width (W) of index field depends on cache ASSOCIATIVETY.)<BR>
Format A:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0..(31-W)  Reserved/zero
  (32-W)..31 Lockdown Block Index
</TD></TR></TABLE>
Format B:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0..(W-1)   Lockdown Block Index
  W..30      Reserved/zero
  31         L
</TD></TR></TABLE>
<BR>
Cache/Write-buffer should not be enabled for the whole 4GB memory area,
high-speed TCM memory doesn't require caching, and caching would have fatal
results on I/O ports. So, cache can be used only in combination with the
Protection Unit, which allows to enable/disable caching in specified regions.<BR>
<BR>
<B>Note</B><BR>
ARMv5 instruction set supports a Cache Prepare for Load opcode (PLD), see<BR>
<A HREF="#armopcodesmemorysingledatatransferldrstrpld">ARM Opcodes: Memory: Single Data Transfer (LDR, STR, PLD)</A><BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="armcp15tightlycoupledmemorytcm"></A>&nbsp;
  ARM CP15 Tightly Coupled Memory (TCM)
</FONT></TD></TR></TABLE><BR>
TCM is high-speed memory, directly contained in the ARM CPU core.<BR>
<BR>
<B>TCM and DMA</B><BR>
TCM doesn't use the ARM bus. A minor disadvantage is that TCM cannot be
accessed by DMA. However, the main advantage is that, when using TCM, the CPU
can be kept running without any waitstates even while the bus is used for DMA
transfers. Operation during DMA works only if all code/data is located in TCM,
waitstates are generated if any code/data outside TCM is accessed; in worst
case (if there are no gaps in the DMA) then the CPU is halted until the DMA
finishes.<BR>
<BR>
<B>TCM and DMA and IRQ</B><BR>
No idea if/how IRQs are handled during DMA? Eventually (unlikely) code in TCM
is kept executed until DMA finishes (ie. until the IRQ vector can be accessed.
Eventually the IRQ vector is instantly accessed (causing to halt the CPU until
DMA finishes). In both cases: Assuming that IRQs are enabled, and that the IRQ
vector and/or IRQ handler are located outside TCM.<BR>
<BR>
<B>Separate Instruction (ITCM) and Data (DTCM) Memory</B><BR>
DTCM can be used only for Data accesses, typically used for stacks and other
frequently accessed data.<BR>
ITCM is primarily intended for instruction accesses, but it can be also used
for Data accesses (among others allowing to copy code to ITCM), however,
performance isn't optimal when simultaneously accessing ITCM for code and data
(such like opcodes in ITCM that use literal pool values in ITCM).<BR>
<BR>
<B>TCM Enable, TCM Load Mode</B><BR>
CP15 Control Register allows to enable ITCM and DTCM, and to switch ITCM/DTCM
into Load Mode. In Load Mode (when TCM is enabled), TCM becomes write-only;
this allows to read data from source addresses in main memory, and to write
data to destination addresses in TCM by using the same addresses; useful for
initializing TCM with overlapping source/dest addresses; Load mode works with
all Load/Store opcodes, it does NOT work with SWP/SWPB opcodes.<BR>
<BR>
TCM Physical Size can be detected in 3rd ID Code Register. (C0,C0,2)<BR>
<BR>
<B>C9,C1,0 - Data TCM Size/Base (R/W)</B><BR>
<B>C9,C1,1 - Instruction TCM Size/Base (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Reserved     (0)
  1-5   Virtual Size (Size = 512 SHL N) ;min=(N=3)=4KB, max=(N=23)=4GB
  6-11  Reserved     (0)
  12-31 Region Base  (Base = X SHL 12)  ;Base must be Size-aligned
</TD></TR></TABLE>
The Virtual size settings should be normally same as the Physical sizes (see
C0,C0,2). However, smaller sizes are allowed (using only the 1st some KB), as
well as bigger sizes (TCM area is then filled with mirrors of physical TCM).<BR>
The ITCM region base may be fixed (read-only), for example, on the NDS, ITCM
base is always 00000000h, nethertheless the virtual size may be changed
(allowing to mirror ITCM to higher addresses).<BR>
If DTCM and ITCM do overlap, then ITCM appears to have priority.<BR>
<BR>
<B>TCM and PU</B><BR>
TCM can be used without Protection Unit.<BR>
When the protection unit is enabled, TCM is controlled by the PU just like
normal memory, the PU should provide R/W Access Permission for TCM regions;
cache and write-buffer are not required for high-speed TCM (so both should be
disabled for TCM regions).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="armcp15misc"></A>&nbsp;
  ARM CP15 Misc
</FONT></TD></TR></TABLE><BR>
<B>C13,C0,0 - Process ID for Fast Context Switch Extension (FCSE) (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-24  Reserved/zero
  25-31 Process ID (PID) (0-127) (0=Disable)
</TD></TR></TABLE>
The FCSE allows different processes (each assembled with ORG 0) to be located
at virtual addresses in the 1st 32MB area. The FCSE splits the total 4GB
address space into blocks of 32MB, accesses to Block(0) are redirected to
Block(PID):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  IF addr&lt;32M then addr=addr+PID*32M
  Respectively, with PID=0, the address remains unchanged (FCSE disabled).
</TD></TR></TABLE>
The CPU-to-Memory address handling is shown below:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1. CPU outputs a virtual address (VA)
  2. FCSE adjusts the VA to a modified virtual address (MVA)
  3. Cache hits determined by examining the MVA, continue below if no hit
  4. MMU translates MVA to physical address (PA) (if no MMU present: PA=MVA)
  5. Memory access occurs at PA
</TD></TR></TABLE>
The FCSE allows limited virtual addressing even if no MMU is present.<BR>
If the MMU is present, then either the FCSE and/or the MMU can be used for
virtual addressing; the advantage of using the FCSE (a single write to
C13,C0,0) is less overload; using the MMU for the same purpose would require to
change virtual address translation table in memory, and to flush the cache.<BR>
The NDS doesn't have a FCSE (the FCSE register is read-only, always zero).<BR>
<BR>
<B>C13,C0,1 - Trace Process ID (R/W)</B><BR>
<B>C13,C1,1 - Trace Process ID (Mirror) (R/W)</B><BR>
This value is output to ETMPROCID pins (if any), allowing to notify external
hardware about the currently executed process within multi-tasking programs.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-31  Process ID
</TD></TR></TABLE>
C13,C1,1 is a mirror of C13,C0,1 (for compatibility with other ARM processors).<BR>
Both registers are read/write-able on NDS9, but there are no external pin-outs.<BR>
<BR>
<B>&lt;cpopc&gt;</B><BR>
Unlike for all other CP15 registers, the &lt;cpopc&gt; operand of the MRC/MCR
opcodes isn't always zero for below registers, so below registers are using
"cpopc,Cn,Cm,op2" notation (instead of the normal "Cn,Cm,op2" notation).<BR>
<BR>
<B>Built-In-Self-Test (BIST)</B><BR>
Allows to test internal memory (ie. TCM, Cache Memory, and Cache TAGs). The
tests are filling (and verifying) the selected memory region thrice (once with
the fillvalue, then with the inverted fillvalue, and then again with the
fillvalue). The BIST functions are intended for diagnostics purposes only, not
for use in normal program code (ARM doesn't guarantee future processors to have
backwards compatible BIST functions).<BR>
<BR>
<B>0,C15,C0,1 - BIST TAG Control Register (R/W)</B><BR>
<B>1,C15,C0,1 - BIST TCM Control Register (R/W)</B><BR>
<B>2,C15,C0,1 - BIST Cache Control Register (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15  Data Control (see below)
  16-31 Instruction Control (see below)
</TD></TR></TABLE>
The above 16bit control values are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Start bit     (Write: 1=Start) (Read: 1=Busy)
  1     Pause bit     (1=Pause)
  2     Enable bit    (1=Enable)
  3     Fail Flag     (1=Error) (Read Only)
  4     Complete Flag (1=Ready) (Read Only)
  5-15  Size (2^(N+2) bytes) (min=N=1=8bytes, max=N=24=64MB)
</TD></TR></TABLE>
Size and Pause are not supported in all implementations.<BR>
Caution: While and as long as the Enable bit is set, the corresponding memory
region(s) will be disabled. Eg. when testing &lt;either&gt; DTCM &lt;and/or&gt;
ITCM, &lt;both&gt; DTCM &lt;and&gt; ITCM are forcefully disabled in C1,C0,0
(Control Register), after the test the software must first clear the BIST
enable bit, and then restore DTCM/ITCM bits in C1,C0,0. And of course, the
content of the tested memory region must be restored when needed.<BR>
<BR>
<B>0,C15,C0,2 - BIST Instruction TAG Address (R/W)</B><BR>
<B>1,C15,C0,2 - BIST Instruction TCM Address (R/W)</B><BR>
<B>2,C15,C0,2 - BIST Instruction Cache Address (R/W)</B><BR>
<B>0,C15,C0,6 - BIST Data TAG Address (R/W)</B><BR>
<B>1,C15,C0,6 - BIST Data TCM Address (R/W)</B><BR>
<B>2,C15,C0,6 - BIST Data Cache Address (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-31  Word-aligned Destination Address within Memory Block (eg. within ITCM)
</TD></TR></TABLE>
On the NDS9, bit0-1, and bit21-31 are always zero.<BR>
<BR>
<B>0,C15,C0,3 - BIST Instruction TAG Fillvalue (R/W)</B><BR>
<B>1,C15,C0,3 - BIST Instruction TCM Fillvalue (R/W)</B><BR>
<B>2,C15,C0,3 - BIST Instruction Cache Fillvalue (R/W)</B><BR>
<B>0,C15,C0,7 - BIST Data TAG Fillvalue (R/W)</B><BR>
<B>1,C15,C0,7 - BIST Data TCM Fillvalue (R/W)</B><BR>
<B>2,C15,C0,7 - BIST Data Cache Fillvalue (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-31  Fillvalue for BIST
</TD></TR></TABLE>
After BIST, the selected memory region is filled by that value. That is, on the
NDS9 at least, all words will be filled with the SAME value (ie. NOT with
increasing or randomly generated numbers).<BR>
<BR>
<B>0,C15,C0,0 - Cache Debug Test State Register (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-8    Reserved (zero)
  9      Disable Instruction Cache Linefill
  10     Disable Data Cache Linefill
  11     Disable Instruction Cache Streaming
  12     Disable Data Cache Streaming
  13-31  Reserved (zero/unpredictable)
</TD></TR></TABLE>
<BR>
<B>3,C15,C0,0 - Cache Debug Index Register (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0..1    Reserved (zero)
  2..4    Word Address
  5..N    Index
  N+1..29 Reserved (zero)
  30..31  Segment
</TD></TR></TABLE>
<BR>
<B>3,C15,C0,1 - Cache Debug Instruction TAG (R/W)</B><BR>
<B>3,C15,C0,2 - Cache Debug Data TAG (R/W)</B><BR>
<B>3,C15,C0,3 - Cache Debug Instruction Cache (R/W)</B><BR>
<B>3,C15,C0,4 - Cache Debug Data Cache (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0..1    Set
  2..3    Dirty Bits
  4       Valid
  5..N    Index
  N+1..31 TAG Address
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="armcpuinstructioncycletimes"></A>&nbsp;
  ARM CPU Instruction Cycle Times
</FONT></TD></TR></TABLE><BR>
Instruction Cycle Summary<BR>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
<B>  Instruction      Cycles      Additional</B>
  ---------------------------------------------------------------------
  ALU              1S          +1S+1N if R15 loaded, +1I if SHIFT(Rs)
  MSR,MRS          1S
  LDR              1S+1N+1I    +1S+1N if R15 loaded
  STR              2N
  LDM              nS+1N+1I    +1S+1N if R15 loaded
  STM              (n-1)S+2N
  SWP              1S+2N+1I
  BL (THUMB)       3S+1N
  B,BL             2S+1N
  SWI,trap         2S+1N
  MUL              1S+ml
  MLA              1S+(m+1)I
  MULL             1S+(m+1)I
  MLAL             1S+(m+2)I
  CDP              1S+bI
  LDC,STC          (n-1)S+2N+bI
  MCR              1N+bI+1C
  MRC              1S+(b+1)I+1C
  {cond} false     1S
</TD></TR></TABLE>
<BR>
<BR>
ARM9:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Q{D}ADD/SUB      1S+Interlock.
  CLZ              1S.
  LDR              1S+1N+1L
  LDRB,LDRH,LDRmis 1S+1N+2L
  LDR PC ...
  STR              1S+1N        (not 2N, and both in parallel)
</TD></TR></TABLE>
Execution Time: 1S+Interlock    (SMULxy,SMLAxy,SMULWx,SMLAWx)<BR>
Execution Time: 1S+1I+Interlock (SMLALxy)<BR>
<BR>
<BR>
Whereas,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  n = number of words transferred
  b = number of cycles spent in coprocessor busy-wait loop
  m = depends on most significant byte(s) of multiplier operand
</TD></TR></TABLE>
Above 'trap' is meant to be the execution time for exceptions. And '{cond}
false' is meant to be the execution time for conditional instructions which
haven't been actually executed because the condition has been false.<BR>
<BR>
The separate meaning of the N,S,I,C cycles is:<BR>
<BR>
<B>N - Non-sequential cycle</B><BR>
Requests a transfer to/from an address which is NOT related to the address used
in the previous cycle. (Called 1st Access in GBA language).<BR>
The execution time for 1N is 1 clock cycle (plus non-sequential access
waitstates).<BR>
<BR>
<B>S - Sequential cycle</B><BR>
Requests a transfer to/from an address which is located directly after the
address used in the previous cycle. Ie. for 16bit or 32bit accesses at
incrementing addresses, the first access is Non-sequential, the following
accesses are sequential. (Called 2nd Access in GBA language).<BR>
The execution time for 1S is 1 clock cycle (plus sequential access waitstates).<BR>
<BR>
<B>I - Internal Cycle</B><BR>
CPU is just too busy, not even requesting a memory transfer for now.<BR>
The execution time for 1I is 1 clock cycle (without any waitstates).<BR>
<BR>
<B>C - Coprocessor Cycle</B><BR>
The CPU uses the data bus to communicate with the coprocessor (if any), but no
memory transfers are requested.<BR>
<BR>
<B>Memory Waitstates</B><BR>
Ideally, memory may be accessed free of waitstates (1N and 1S are then equal to
1 clock cycle each). However, a memory system may generate waitstates for
several reasons: The memory may be just too slow. Memory is currently accessed
by DMA, eg. sound, video, memory transfers, etc. Or when data is squeezed
through a 16bit data bus (in that special case, 32bit access may have more
waitstates than 8bit and 16bit accesses). Also, the memory system may separate
between S and N cycles (if so, S cycles would be typically faster than N
cycles).<BR>
<BR>
<B>Memory Waitstates for Different Memory Areas</B><BR>
Different memory areas (eg. ROM and RAM) may have different waitstates. When
executing code in one area which accesses data in another area, then the S+N
cycles must be split into code and data accesses: 1N is used for data access,
plus (n-1)S for LDM/STM, the remaining S+N are code access. If an instruction
jumps to a different memory area, then all code cycles for that opcode are
having waitstate characteristics of the NEW memory area (except Thumb BL which
still executes 1S in OLD area).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="armcpuversions"></A>&nbsp;
  ARM CPU Versions
</FONT></TD></TR></TABLE><BR>
<B>Version Numbers</B><BR>
ARM CPUs are distributed by name ARM#, and are described as ARMv# in
specifications, whereas "#" is NOT the same than "v#", for example, ARM7TDMI is
ARMv4TM. That is so confusing, that ARM didn't even attempt to clarify the
relationship between the various "#" and "v#" values.<BR>
<BR>
<B>Version Variants</B><BR>
Suffixes like "M" (long multiply), "T" (Thumb support), "E" (Enhanced DSP)
indicate presence of special features, additionally to the standard instruction
set of a given version, or, when preceded by an "x", indicate the absence of
that features.<BR>
<BR>
<B>ARMv1 aka ARM1</B><BR>
Some sort of a beta version, according to ARM never been used in any commercial
products.<BR>
<BR>
<B>ARMv2 and up</B><BR>
MUL,MLA<BR>
CDP,LDC,MCR,MRC,STC<BR>
SWP/SWPB (ARMv2a and up only)<BR>
Two new FIQ registers<BR>
<BR>
<B>ARMv3 and up</B><BR>
MRS,MSR opcodes (instead CMP/CMN/TST/TEQ{P} opcodes)<BR>
CPSR,SPSR registers (instead PSR bits in R15)<BR>
Removed never condition, cond=NV no longer valid<BR>
32bit addressing (instead 26bit addressing in older versions)<BR>
26bit addressing backwards comptibility mode (except v3G)<BR>
Abt and Und modes (instead handling aborts/undefined in Svc mode)<BR>
SMLAL,SMULL,UMLAL,UMULL (optionally, INCLUDED in v3M, EXCLUDED in v4xM/v5xM)<BR>
<BR>
<B>ARMv4 aka ARM7 and up</B><BR>
LDRH,LDRSB,LDRSH,STRH<BR>
Sys mode (privileged user mode)<BR>
BX (only ARMv4T, and any ARMv5 or ARMv5T and up)<BR>
THUMB code (only T variants, ie. ARMv4T, ARMv5T)<BR>
<BR>
<B>ARMv5 aka ARM9 and up</B><BR>
BKPT,BLX,CLZ (BKPT,BLX also in THUMB mode)<BR>
LDM/LDR/POP PC with mode switch (POP PC also in THUMB mode)<BR>
CDP2,LDC2,MCR2,MRC2,STC2 (new coprocessor opcodes)<BR>
C-flag unchanged by MUL (instead undefined flag value)<BR>
changed instruction cycle timings / interlock ??? or not ???<BR>
QADD,QDADD,QDSUB,QSUB opcodes, CPSR.Q flag (v5TE and V5TExP only)<BR>
SMLAxy,SMLALxy,SMLAWy,SMULxy,SMULWy (v5TE and V5TExP only)<BR>
LDRD,STRD,PLD,MCRR,MRRC (v5TE only, not v5, not v5TExP)<BR>
<BR>
<B>ARMv6</B><BR>
No public specifications available.<BR>
<BR>
<B>A Milestone in Computer History</B><BR>
Original ARMv2 has been used in the relative rare and expensive Archimedes
deluxe home computers in the late eighties, the Archimedes has caught a lot of
attention, particularly for being the first home computer that used a BIOS
being programmed in BASIC language - which has been a absolutely revolutionary
decadency at that time.<BR>
Inspired, programmers all over the world have successfully developed even
slower and much more inefficient programming languages, which are nowadays
consequently used by nearly all ARM programmers, and by most non-ARM
programmers as well.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="armcpudatasheet"></A>&nbsp;
  ARM CPU Data Sheet
</FONT></TD></TR></TABLE><BR>
This present document is an attempt to supply a brief ARM7TDMI reference,
hopefully including all information which is relevant for programmers.<BR>
<BR>
Some details that I have treated as meaningless for GBA programming aren't
included - such like Big Endian format, and Virtual Memory data aborts, and
most of the chapters listed below.<BR>
<BR>
Have a look at the complete data sheet (URL see below) for more detailed
verbose information about ARM7TDMI instructions. That document also includes:<BR>
<BR>
- Signal Description<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Pins of the original CPU, probably other for GBA.
</TD></TR></TABLE>
- Memory Interface<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Optional virtual memory circuits, etc. not for GBA.
</TD></TR></TABLE>
- Coprocessor Interface<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  As far as I know, none such in GBA.
</TD></TR></TABLE>
- Debug Interface<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  For external hardware-based debugging.
</TD></TR></TABLE>
- ICEBreaker Module<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  For external hardware-based debugging also.
</TD></TR></TABLE>
- Instruction Cycle Operations<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Detailed: What happens during each cycle of each instruction.
</TD></TR></TABLE>
- DC Parameters (Power supply)<BR>
- AC Parameters (Signal timings)<BR>
<BR>
The official ARM7TDMI data sheet can be downloaded from ARMs webpage,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  http://www.arm.com/Documentation/UserMans/PDF/ARM7TDMI.html
</TD></TR></TABLE>
Be prepared for bloated PDF Format, approx 1.3 MB, about 200 pages.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="biosfunctions"></A>&nbsp;
  BIOS Functions
</FONT></TD></TR></TABLE><BR>
The BIOS includes several System Call Functions which can be accessed by SWI
instructions. Incoming parameters are usually passed through registers
R0,R1,R2,R3. Outgoing registers R0,R1,R3 are typically containing either
garbage, or return value(s). All other registers (R2,R4-R14) are kept
unchanged.<BR>
<BR>
<B>Caution</B><BR>
When invoking SWIs from inside of ARM state specify SWI NN*10000h, instead of
SWI NN as in THUMB state.<BR>
<BR>
<B>Overview</B><BR>
<A HREF="#biosfunctionsummary">BIOS Function Summary</A><BR>
<A HREF="#biosdifferencesbetweengbaandndsfunctions">BIOS Differences between GBA and NDS functions</A><BR>
<BR>
<B>All Functions Described</B><BR>
<A HREF="#biosarithmeticfunctions">BIOS Arithmetic Functions</A><BR>
<A HREF="#biosrotationscalingfunctions">BIOS Rotation/Scaling Functions</A><BR>
<A HREF="#biosdecompressionfunctions">BIOS Decompression Functions</A><BR>
<A HREF="#biosmemorycopy">BIOS Memory Copy</A><BR>
<A HREF="#bioshaltfunctions">BIOS Halt Functions</A><BR>
<A HREF="#biosresetfunctions">BIOS Reset Functions</A><BR>
<A HREF="#biosmiscfunctions">BIOS Misc Functions</A><BR>
<A HREF="#biosmultibootsinglegamepak">BIOS Multi Boot (Single Game Pak)</A><BR>
<A HREF="#biossoundfunctions">BIOS Sound Functions</A><BR>
<A HREF="#biossha1functionsdsionly">BIOS SHA1 Functions (DSi only)</A><BR>
<A HREF="#biosrsafunctionsdsionly">BIOS RSA Functions (DSi only)</A><BR>
<BR>
<B>RAM Usage, BIOS Dumps</B><BR>
<A HREF="#biosramusage">BIOS RAM Usage</A><BR>
<A HREF="#biosdumping">BIOS Dumping</A><BR>
<BR>
<B>How BIOS Processes SWIs</B><BR>
SWIs can be called from both within THUMB and ARM mode. In ARM mode, only the
upper 8bit of the 24bit comment field are interpreted.<BR>
Each time when calling a BIOS function 4 words (SPSR, R11, R12, R14) are saved
on Supervisor stack (_svc). Once it has saved that data, the SWI handler
switches into System mode, so that all further stack operations are using user
stack.<BR>
In some cases the BIOS may allow interrupts to be executed from inside of the
SWI procedure. If so, and if the interrupt handler calls further SWIs, then
care should be taken that the Supervisor Stack does not overflow.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="biosfunctionsummary"></A>&nbsp;
  BIOS Function Summary
</FONT></TD></TR></TABLE><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
<B>  GBA  NDS7 NDS9 DSi7 DSi9 Basic Functions</B>
  00h  00h  00h  -    -    SoftReset
  01h  -    -    -    -    RegisterRamReset
  02h  06h  06h  06h  06h  Halt
  03h  07h  -    07h  -    Stop/Sleep
  04h  04h  04h  04h  04h  IntrWait       ;DSi7/DSi9: both bugged?
  05h  05h  05h  05h  05h  VBlankIntrWait ;DSi7/DSi9: both bugged?
  06h  09h  09h  09h  09h  Div
  07h  -    -    -    -    DivArm
  08h  0Dh  0Dh  0Dh  0Dh  Sqrt
  09h  -    -    -    -    ArcTan
  0Ah  -    -    -    -    ArcTan2
  0Bh  0Bh  0Bh  0Bh  0Bh  CpuSet
  0Ch  0Ch  0Ch  0Ch  0Ch  CpuFastSet
  0Dh  -    -    -    -    GetBiosChecksum
  0Eh  -    -    -    -    BgAffineSet
  0Fh  -    -    -    -    ObjAffineSet
<B>  GBA  NDS7 NDS9 DSi7 DSi9 Decompression Functions</B>
  10h  10h  10h  10h  10h  BitUnPack
  11h  11h  11h  11h  11h  LZ77UnCompReadNormalWrite8bit   ;"Wram"
  12h  -    -    -    -    LZ77UnCompReadNormalWrite16bit  ;"Vram"
  -    -    -    01h  01h  LZ77UnCompReadByCallbackWrite8bit
  -    12h  12h  02h  02h  LZ77UnCompReadByCallbackWrite16bit
  -    -    -    19h  19h  LZ77UnCompReadByCallbackWrite16bit (same as above)
  13h  -    -    -    -    HuffUnCompReadNormal
  -    13h  13h  13h  13h  HuffUnCompReadByCallback
  14h  14h  14h  14h  14h  RLUnCompReadNormalWrite8bit     ;"Wram"
  15h  -    -    -    -    RLUnCompReadNormalWrite16bit    ;"Vram"
  -    15h  15h  15h  15h  RLUnCompReadByCallbackWrite16bit
  16h  -    16h  -    16h  Diff8bitUnFilterWrite8bit       ;"Wram"
  17h  -    -    -    -    Diff8bitUnFilterWrite16bit      ;"Vram"
  18h  -    18h  -    18h  Diff16bitUnFilter
<B>  GBA  NDS7 NDS9 DSi7 DSi9 Sound (and Multiboot/HardReset/CustomHalt)</B>
  19h  08h  -    08h  -    SoundBias
  1Ah  -    -    -    -    SoundDriverInit
  1Bh  -    -    -    -    SoundDriverMode
  1Ch  -    -    -    -    SoundDriverMain
  1Dh  -    -    -    -    SoundDriverVSync
  1Eh  -    -    -    -    SoundChannelClear
  1Fh  -    -    -    -    MidiKey2Freq
  20h  -    -    -    -    SoundWhatever0
  21h  -    -    -    -    SoundWhatever1
  22h  -    -    -    -    SoundWhatever2
  23h  -    -    -    -    SoundWhatever3
  24h  -    -    -    -    SoundWhatever4
  25h  -    -    -    -    MultiBoot
  26h  -    -    -    -    HardReset
  27h  1Fh  -    1Fh  -    CustomHalt
  28h  -    -    -    -    SoundDriverVSyncOff
  29h  -    -    -    -    SoundDriverVSyncOn
  2Ah  -    -    -    -    SoundGetJumpList
<B>  GBA  NDS7 NDS9 DSi7 DSi9 New NDS Functions</B>
  -    03h  03h  03h  03h  WaitByLoop
  -    0Eh  0Eh  0Eh  0Eh  GetCRC16
  -    0Fh  0Fh  -    -    IsDebugger
  -    1Ah  -    1Ah  -    GetSineTable
  -    1Bh  -    1Bh  -    GetPitchTable (DSi7: bugged)
  -    1Ch  -    1Ch  -    GetVolumeTable
  -    1Dh  -    1Dh  -    GetBootProcs (DSi7: only 1 proc)
  -    -    1Fh  -    1Fh  CustomPost
<B>  GBA  NDS7 NDS9 DSi7 DSi9 New DSi Functions (RSA/SHA1)</B>
  -    -    -    20h  20h  RSA_Init_crypto_heap
  -    -    -    21h  21h  RSA_Decrypt
  -    -    -    22h  22h  RSA_Decrypt_Unpad
  -    -    -    23h  23h  RSA_Decrypt_Unpad_GetChunk04
  -    -    -    24h  24h  SHA1_Init
  -    -    -    25h  25h  SHA1_Update
  -    -    -    26h  26h  SHA1_Finish
  -    -    -    27h  27h  SHA1_Init_update_fin
  -    -    -    28h  28h  SHA1_Compare_20_bytes
  -    -    -    29h  29h  SHA1_Random_maybe
<B>  GBA  NDS7 NDS9 DSi7 DSi9 Invalid Functions</B>
  2Bh+ 20h+ 20h+ -    -    Crash (SWI xxh..FFh do jump to garbage addresses)
  -    xxh  xxh  -    -    Jump to 0   (on any SWI numbers not listed above)
  -    -    -    12h  12h  No function (ignored)
  -    -    -    2Bh  2Bh  No function (ignored)
  -    -    -    40h+ 40h+ Mirror      (SWI 40h..FFh mirror to 00h..3Fh)
  -    -    -    xxh  xxh  Hang        (on any SWI numbers not listed above)
</TD></TR></TABLE>
Invalid NDS functions: NDS7 SWI 01h, 02h, 0Ah, 16h-19h, 1Eh, and NDS9 SWI 01h,
02h, 07h, 08h, 0Ah, 17h, 19h-1Eh will jump to zero (ie. to the NDS7 reset
vector, or to NDS9 unused (usually PU-locked ITCM) memory, which will be both
redirected to the debug handler, if any).<BR>
Invalid DSi functions: DSi9 SWI 00h, 07h-08h, 0Ah, 0Fh, 17h, 1Ah-1Eh, 2Ah,
2Ch-3Fh do hang in endless loop.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="biosdifferencesbetweengbaandndsfunctions"></A>&nbsp;
  BIOS Differences between GBA and NDS functions
</FONT></TD></TR></TABLE><BR>
<B>Differences between GBA and NDS BIOS functions</B><BR>
- SoftReset uses different addresses<BR>
- SWI numbers for Halt, Stop/Sleep, Div, Sqrt have changed<BR>
- Halt destroys r0 on NDS9, IntrWait bugged on NDS9<BR>
- CpuFastSet allows 4-byte blocks (nice), but...<BR>
- CpuFastSet works very SLOW because of a programming bug (uncool)<BR>
- Some of the decompression functions are now using callbacks<BR>
- SoundBias uses new delay parameter<BR>
And, a number of GBA functions have been removed, and some new NDS functions
have been added, see:<BR>
<A HREF="#biosfunctionsummary">BIOS Function Summary</A><BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="biosarithmeticfunctions"></A>&nbsp;
  BIOS Arithmetic Functions
</FONT></TD></TR></TABLE><BR>
Div<BR>
DivArm<BR>
Sqrt<BR>
ArcTan<BR>
ArcTan2<BR>
<BR>
<B>SWI 06h (GBA) or SWI 09h (NDS7/NDS9/DSi7/DSi9) - Div</B><BR>
Signed Division, r0/r1.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  r0  signed 32bit Number
  r1  signed 32bit Denom
</TD></TR></TABLE>
Return:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  r0  Number DIV Denom ;signed
  r1  Number MOD Denom ;signed
  r3  ABS (Number DIV Denom) ;unsigned
</TD></TR></TABLE>
For example, incoming -1234, 10 should return -123, -4, +123.<BR>
The function usually gets caught in an endless loop upon division by zero.<BR>
Note: The NDS9 and DSi9 additionally support hardware division, by math
coprocessor, accessed via I/O Ports, however, the SWI function is a raw
software division.<BR>
<BR>
<B>SWI 07h (GBA) - DivArm</B><BR>
Same as above (SWI 06h Div), but incoming parameters are exchanged, r1/r0
(r0=Denom, r1=number). For compatibility with ARM's library. Slightly slower (3
clock cycles) than SWI 06h.<BR>
<BR>
<B>SWI 08h (GBA) or SWI 0Dh (NDS7/NDS9/DSi7/DSi9) - Sqrt</B><BR>
Calculate square root.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  r0   unsigned 32bit number
</TD></TR></TABLE>
Return:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  r0   unsigned 16bit number
</TD></TR></TABLE>
The result is an integer value, so Sqrt(2) would return 1, to avoid this
inaccuracy, shift left incoming number by 2*N as much as possible (the result
is then shifted left by 1*N). Ie. Sqrt(2 shl 30) would return 1.41421 shl 15.<BR>
Note: The NDS9 and DSi9 additionally support hardware square root calculation,
by math coprocessor, accessed via I/O Ports, however, the SWI function is a raw
software calculation.<BR>
<BR>
<B>SWI 09h (GBA) - ArcTan</B><BR>
Calculates the arc tangent.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  r0   Tan, 16bit (1bit sign, 1bit integral part, 14bit decimal part)
</TD></TR></TABLE>
Return:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  r0   "-PI/2&lt;THETA/&lt;PI/2" in a range of C000h-4000h.
</TD></TR></TABLE>
Note: there is a problem in accuracy with "THETA&lt;-PI/4, PI/4&lt;THETA".<BR>
<BR>
<B>SWI 0Ah (GBA) - ArcTan2</B><BR>
Calculates the arc tangent after correction processing.<BR>
Use this in normal situations.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  r0   X, 16bit (1bit sign, 1bit integral part, 14bit decimal part)
  r1   Y, 16bit (1bit sign, 1bit integral part, 14bit decimal part)
</TD></TR></TABLE>
Return:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  r0   0000h-FFFFh for 0&lt;=THETA&lt;2PI.
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="biosrotationscalingfunctions"></A>&nbsp;
  BIOS Rotation/Scaling Functions
</FONT></TD></TR></TABLE><BR>
BgAffineSet<BR>
ObjAffineSet<BR>
<BR>
<B>SWI 0Eh (GBA) - BgAffineSet</B><BR>
Used to calculate BG Rotation/Scaling parameters.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  r0   Pointer to Source Data Field with entries as follows:
        s32  Original data's center X coordinate (8bit fractional portion)
        s32  Original data's center Y coordinate (8bit fractional portion)
        s16  Display's center X coordinate
        s16  Display's center Y coordinate
        s16  Scaling ratio in X direction (8bit fractional portion)
        s16  Scaling ratio in Y direction (8bit fractional portion)
        u16  Angle of rotation (8bit fractional portion) Effective Range 0-FFFF
  r1   Pointer to Destination Data Field with entries as follows:
        s16  Difference in X coordinate along same line
        s16  Difference in X coordinate along next line
        s16  Difference in Y coordinate along same line
        s16  Difference in Y coordinate along next line
        s32  Start X coordinate
        s32  Start Y coordinate
  r2   Number of Calculations
</TD></TR></TABLE>
Return: No return value, Data written to destination address.<BR>
<BR>
<B>SWI 0Fh (GBA) - ObjAffineSet</B><BR>
Calculates and sets the OBJ's affine parameters from the scaling ratio and
angle of rotation.<BR>
The affine parameters are calculated from the parameters set in Srcp.<BR>
The four affine parameters are set every Offset bytes, starting from the Destp
address.<BR>
If the Offset value is 2, the parameters are stored contiguously. If the value
is 8, they match the structure of OAM.<BR>
When Srcp is arrayed, the calculation can be performed continuously by
specifying Num.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  r0   Source Address, pointing to data structure as such:
        s16  Scaling ratio in X direction (8bit fractional portion)
        s16  Scaling ratio in Y direction (8bit fractional portion)
        u16  Angle of rotation (8bit fractional portion) Effective Range 0-FFFF
  r1   Destination Address, pointing to data structure as such:
        s16  Difference in X coordinate along same line
        s16  Difference in X coordinate along next line
        s16  Difference in Y coordinate along same line
        s16  Difference in Y coordinate along next line
  r2   Number of calculations
  r3   Offset in bytes for parameter addresses (2=continuous, 8=OAM)
</TD></TR></TABLE>
Return: No return value, Data written to destination address.<BR>
<BR>
For both Bg- and ObjAffineSet, Rotation angles are specified as 0-FFFFh
(covering a range of 360 degrees), however, the GBA BIOS recurses only the
upper 8bit; the lower 8bit may contain a fractional portion, but it is ignored
by the BIOS.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="biosdecompressionfunctions"></A>&nbsp;
  BIOS Decompression Functions
</FONT></TD></TR></TABLE><BR>
BitUnPack<BR>
Diff8bitUnFilter<BR>
HuffUnComp<BR>
LZ77UnComp<BR>
RLUnComp<BR>
<BR>
<B>Decompression Read/Write Variants</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ReadNormal:      Fast (src must be memory mapped)
  ReadByCallback:  Slow (src can be non-memory, eg. serial Firmware SPI bus)
  Write8bitUnits:  Fast (dest must support 8bit writes, eg. not VRAM)
  Write16bitUnits: Slow (dest must be halfword-aligned) (for VRAM)
</TD></TR></TABLE>
<BR>
<B>BitUnPack - SWI 10h (GBA/NDS7/NDS9/DSi7/DSi9)</B><BR>
Used to increase the color depth of bitmaps or tile data. For example, to
convert a 1bit monochrome font into 4bit or 8bit GBA tiles. The Unpack Info is
specified separately, allowing to convert the same source data into different
formats.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  r0  Source Address      (no alignment required)
  r1  Destination Address (must be 32bit-word aligned)
  r2  Pointer to UnPack information:
       16bit  Length of Source Data in bytes     (0-FFFFh)
       8bit   Width of Source Units in bits      (only 1,2,4,8 supported)
       8bit   Width of Destination Units in bits (only 1,2,4,8,16,32 supported)
       32bit  Data Offset (Bit 0-30), and Zero Data Flag (Bit 31)
      The Data Offset is always added to all non-zero source units.
      If the Zero Data Flag was set, it is also added to zero units.
</TD></TR></TABLE>
Data is written in 32bit units, Destination can be Wram or Vram. The size of
unpacked data must be a multiple of 4 bytes. The width of source units (plus
the offset) should not exceed the destination width.<BR>
Return: No return value, Data written to destination address.<BR>
<BR>
<B>Diff8bitUnFilterWrite8bit (Wram) - SWI 16h (GBA/NDS9/DSi9)</B><BR>
<B>Diff8bitUnFilterWrite16bit (Vram) - SWI 17h (GBA)</B><BR>
<B>Diff16bitUnFilter - SWI 18h (GBA/NDS9/DSi9)</B><BR>
These aren't actually real decompression functions, destination data will have
exactly the same size as source data. However, assume a bitmap or wave form to
contain a stream of increasing numbers such like 10..19, the
filtered/unfiltered data would be:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  unfiltered:   10  11  12  13  14  15  16  17  18  19
  filtered:     10  +1  +1  +1  +1  +1  +1  +1  +1  +1
</TD></TR></TABLE>
In this case using filtered data (combined with actual compression algorithms)
will obviously produce better compression results.<BR>
Data units may be either 8bit or 16bit used with Diff8bit or Diff16bit
functions respectively.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  r0  Source address (must be aligned by 4) pointing to data as follows:
       Data Header (32bit)
         Bit 0-3   Data size (must be 1 for Diff8bit, 2 for Diff16bit)
         Bit 4-7   Type (must be 8 for DiffFiltered)
         Bit 8-31  24bit size after decompression
       Data Units (each 8bit or 16bit depending on used SWI function)
         Data0          ;original data
         Data1-Data0    ;difference data
         Data2-Data1    ;...
         Data3-Data2
         ...
  r1  Destination address
</TD></TR></TABLE>
Return: No return value, Data written to destination address.<BR>
<BR>
<B>HuffUnCompReadNormal - SWI 13h (GBA)</B><BR>
<B>HuffUnCompReadByCallback - SWI 13h (NDS/DSi)</B><BR>
The decoder starts in root node, the separate bits in the bitstream specify if
the next node is node0 or node1, if that node is a data node, then the data is
stored in memory, and the decoder is reset to the root node. The most often
used data should be as close to the root node as possible. For example, the
4-byte string "Huff" could be compressed to 6 bits: 10-11-0-0, with root.0
pointing directly to data "f", and root.1 pointing to a child node, whose nodes
point to data "H" and data "u".<BR>
Data is written in units of 32bits, if the size of the compressed data is not a
multiple of 4, please adjust it as much as possible by padding with 0.<BR>
Align the source address to a 4Byte boundary.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  r0  Source Address, aligned by 4, pointing to:
       Data Header (32bit)
         Bit0-3   Data size in bit units (normally 4 or 8)
         Bit4-7   Compressed type (must be 2 for Huffman)
         Bit8-31  24bit size of decompressed data in bytes
       Tree Size (8bit)
         Bit0-7   Size of Tree Table/2-1 (ie. Offset to Compressed Bitstream)
       Tree Table (list of 8bit nodes, starting with the root node)
        Root Node and Non-Data-Child Nodes are:
         Bit0-5   Offset to next child node,
                  Next child node0 is at (CurrentAddr AND NOT 1)+Offset*2+2
                  Next child node1 is at (CurrentAddr AND NOT 1)+Offset*2+2+1
         Bit6     Node1 End Flag (1=Next child node is data)
         Bit7     Node0 End Flag (1=Next child node is data)
        Data nodes are (when End Flag was set in parent node):
         Bit0-7   Data (upper bits should be zero if Data Size is less than 8)
       Compressed Bitstream (stored in units of 32bits)
         Bit0-31  Node Bits (Bit31=First Bit)  (0=Node0, 1=Node1)
  r1  Destination Address
  r2  Callback temp buffer      ;\for NDS/DSi "ReadByCallback" variants only
  r3  Callback structure        ;/(see Callback notes below)
</TD></TR></TABLE>
Return: No return value, Data written to destination address.<BR>
<BR>
<B>LZ77UnCompReadNormalWrite8bit (Wram) - SWI 11h (GBA/NDS7/NDS9/DSi7/DSi9)</B><BR>
<B>LZ77UnCompReadNormalWrite16bit (Vram) - SWI 12h (GBA)</B><BR>
<B>LZ77UnCompReadByCallbackWrite8bit - SWI 01h (DSi7/DSi9)</B><BR>
<B>LZ77UnCompReadByCallbackWrite16bit - SWI 12h (NDS), SWI 02h or 19h (DSi)</B><BR>
Expands LZ77-compressed data. The Wram function is faster, and writes in units
of 8bits. For the Vram function the destination must be halfword aligned, data
is written in units of 16bits.<BR>
CAUTION: Writing 16bit units to [dest-1] instead of 8bit units to [dest] means
the reading from [dest-1] won't work, ie. the "Vram" function works only with
disp=001h..FFFh, but not with disp=000h.<BR>
If the size of the compressed data is not a multiple of 4, please adjust it as
much as possible by padding with 0. Align the source address to a 4-Byte
boundary.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  r0  Source address, pointing to data as such:
       Data header (32bit)
         Bit 0-3   Reserved
         Bit 4-7   Compressed type (must be 1 for LZ77)
         Bit 8-31  Size of decompressed data
       Repeat below. Each Flag Byte followed by eight Blocks.
       Flag data (8bit)
         Bit 0-7   Type Flags for next 8 Blocks, MSB first
       Block Type 0 - Uncompressed - Copy 1 Byte from Source to Dest
         Bit 0-7   One data byte to be copied to dest
       Block Type 1 - Compressed - Copy N+3 Bytes from Dest-Disp-1 to Dest
         Bit 0-3   Disp MSBs
         Bit 4-7   Number of bytes to copy (minus 3)
         Bit 8-15  Disp LSBs
  r1  Destination address
  r2  Callback parameter        ;\for NDS/DSi "ReadByCallback" variants only
  r3  Callback structure        ;/(see Callback notes below)
</TD></TR></TABLE>
Return: No return value.<BR>
<BR>
<B>RLUnCompReadNormalWrite8bit (Wram) - SWI 14h (GBA/NDS7/NDS9/DSi7/DSi9)</B><BR>
<B>RLUnCompReadNormalWrite16bit (Vram) - SWI 15h (GBA)</B><BR>
<B>RLUnCompReadByCallbackWrite16bit - SWI 15h (NDS7/NDS9/DSi7/DSi9)</B><BR>
Expands run-length compressed data. The Wram function is faster, and writes in
units of 8bits. For the Vram function the destination must be halfword aligned,
data is written in units of 16bits.<BR>
If the size of the compressed data is not a multiple of 4, please adjust it as
much as possible by padding with 0. Align the source address to a 4Byte
boundary.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  r0  Source Address, pointing to data as such:
       Data header (32bit)
         Bit 0-3   Reserved
         Bit 4-7   Compressed type (must be 3 for run-length)
         Bit 8-31  Size of decompressed data
       Repeat below. Each Flag Byte followed by one or more Data Bytes.
       Flag data (8bit)
         Bit 0-6   Expanded Data Length (uncompressed N-1, compressed N-3)
         Bit 7     Flag (0=uncompressed, 1=compressed)
       Data Byte(s) - N uncompressed bytes, or 1 byte repeated N times
  r1  Destination Address
  r2  Callback parameter        ;\for NDS/DSi "ReadByCallback" variants only
  r3  Callback structure        ;/(see Callback notes below)
</TD></TR></TABLE>
Return: No return value, Data written to destination address.<BR>
<BR>
<B>NDS/DSi Decompression Callbacks</B><BR>
On NDS and DSi, the "ReadByCallback" variants are reading source data from
callback functions (rather than directly from memory). The callback functions
may read normal data from memory, or from other devices, such like directly
from the gamepak bus, without storing the source data in memory. The downside
is that the callback mechanism makes the function very slow, furthermore,
NDS7/NDS9 SWI 12h, 13h, 15h are using THUMB code, and variables on stack,
alltogether that makes the whole shit very-very-very slow.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  r2 = user defined callback parameter (passed on to Open function)
        (or, for Huffman: pointer to temp buffer, max 200h bytes needed)
  r3 = pointer to callback structure
</TD></TR></TABLE>
Callback structure (five 32bit pointers to callback functions)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Open_and_get_32bit (eg. LDR r0,[r0], get header)
  Close              (optional, 0=none)
  Get_8bit           (eg. LDRB r0,[r0])
  Get_16bit          (not used)
  Get_32bit          (used by Huffman only)
</TD></TR></TABLE>
All functions may use ARM or THUMB code (indicated by address bit0). The
current source address (r0) is passed to all callback functions. Additionally,
the initial destination address (r1), and a user defined parameter (r2) are
passed to the Open function. For Huffman r2 must point to a temp buffer (max
200h bytes needed, internally used by the SWI function to make a copy of the
huffman tree; needed for random-access to the tree, which wouldn't work with
the sequentially reading callbacks).<BR>
All functions have return values in r0. The Open function normally returns the
first word (containing positive length and type), alternatively it may return a
negative error code to abort/reject decompression. The Close function, if it is
defined, should return zero (or any positive value), or a negative errorcode.
The other functions return raw data, without errorcodes. The SWI returns the
length of decompressed data, or the signed errorcode from the Open/Close
functions.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="biosmemorycopy"></A>&nbsp;
  BIOS Memory Copy
</FONT></TD></TR></TABLE><BR>
CpuFastSet<BR>
CpuSet<BR>
<BR>
<B>SWI 0Ch (GBA/NDS7/NDS9/DSi7/DSi9) - CpuFastSet</B><BR>
Memory copy/fill in units of 32 bytes. Memcopy is implemented as repeated
LDMIA/STMIA [Rb]!,r2-r9 instructions. Memfill as single LDR followed by
repeated STMIA [Rb]!,r2-r9.<BR>
After processing all 32-byte-blocks, the NDS/DSi additonally processes the
remaining words as 4-byte blocks. BUG: The NDS/DSi uses the fast 32-byte-block
processing only for the first N bytes (not for the first N words), so only the
first quarter of the memory block is FAST, the remaining three quarters are
SLOWLY copied word-by-word.<BR>
The length is specifed as wordcount, ie. the number of bytes divided by 4.<BR>
On the GBA, the length should be a multiple of 8 words (32 bytes) (otherwise
the GBA is forcefully rounding-up the length). On NDS/DSi, the length may be
any number of words (4 bytes).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  r0    Source address        (must be aligned by 4)
  r1    Destination address   (must be aligned by 4)
  r2    Length/Mode
          Bit 0-20  Wordcount (GBA: rounded-up to multiple of 8 words)
          Bit 24    Fixed Source Address (0=Copy, 1=Fill by WORD[r0])
</TD></TR></TABLE>
Return: No return value, Data written to destination address.<BR>
<BR>
<B>SWI 0Bh (GBA/NDS7/NDS9/DSi7/DSi9) - CpuSet</B><BR>
Memory copy/fill in units of 4 bytes or 2 bytes. Memcopy is implemented as
repeated LDMIA/STMIA [Rb]!,r3 or LDRH/STRH r3,[r0,r5] instructions. Memfill as
single LDMIA or LDRH followed by repeated STMIA [Rb]!,r3 or STRH r3,[r0,r5].<BR>
The length must be a multiple of 4 bytes (32bit mode) or 2 bytes (16bit mode).
The (half)wordcount in r2 must be length/4 (32bit mode) or length/2 (16bit
mode), ie. length in word/halfword units rather than byte units.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  r0    Source address        (must be aligned by 4 for 32bit, by 2 for 16bit)
  r1    Destination address   (must be aligned by 4 for 32bit, by 2 for 16bit)
  r2    Length/Mode
          Bit 0-20  Wordcount (for 32bit), or Halfwordcount (for 16bit)
          Bit 24    Fixed Source Address (0=Copy, 1=Fill by {HALF}WORD[r0])
          Bit 26    Datasize (0=16bit, 1=32bit)
</TD></TR></TABLE>
Return: No return value, Data written to destination address.<BR>
<BR>
Note: On GBA, NDS7 and DSi7, these two functions will silently reject to do
anything if the source start or end addresses are reaching into the BIOS area.
The NDS9 and DSi9 don't have such read-proctections.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="bioshaltfunctions"></A>&nbsp;
  BIOS Halt Functions
</FONT></TD></TR></TABLE><BR>
Halt<BR>
IntrWait<BR>
VBlankIntrWait<BR>
Stop/Sleep<BR>
CustomHalt<BR>
<BR>
<B>SWI 02h (GBA) or SWI 06h (NDS7/NDS9/DSi7/DSi9) - Halt</B><BR>
Halts the CPU until an interrupt request occurs. The CPU is switched into
low-power mode, all other circuits (video, sound, timers, serial, keypad,
system clock) are kept operating.<BR>
Halt mode is terminated when any enabled interrupts are requested, that is when
(IE AND IF) is not zero, the GBA locks up if that condition doesn't get true.
However, the state of CPUs IRQ disable bit in CPSR register, and the IME
register are don't care, Halt passes through even if either one has disabled
interrupts.<BR>
On GBA and NDS7/DSi7, Halt is implemented by writing to HALTCNT, Port 4000301h.
On NDS9/DSi9, Halt is implemted by writing to System Control Coprocessor (mov
p15,0,c7,c0,4,r0 opcode), this opcode hangs if IME=0.<BR>
No parameters, no return value.<BR>
(GBA/NDS7/DSi7: all registers unchanged, NDS9/DSi9: R0 destroyed)<BR>
<BR>
<B>SWI 04h (GBA/NDS7/NDS9/DSi7/DSi9) - IntrWait ;DSi7/DSi9=bugged?</B><BR>
Continues to wait in Halt state until one (or more) of the specified
interrupt(s) do occur. The function forcefully sets IME=1. When using multiple
interrupts at the same time, this function is having less overhead than
repeatedly calling the Halt function.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  r0    0=Return immediately if an old flag was already set (NDS9: bugged!)
        1=Discard old flags, wait until a NEW flag becomes set
  r1    Interrupt flag(s) to wait for (same format as IE/IF registers)
  r2    DSi7 only: Extra flags (same format as DSi7's IE2/IF2 registers)
</TD></TR></TABLE>
Caution: When using IntrWait or VBlankIntrWait, the user interrupt handler MUST
update the BIOS Interrupt Flags value in RAM; when acknowleding processed
interrupt(s) by writing a value to the IF register, the same value should be
also ORed to the BIOS Interrupt Flags value, at following memory location:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Host     GBA (16bit)  NDS7 (32bit)  NDS9 (32bit)  DSi7-IF2 (32bit)
  Address  [3007FF8h]   [380FFF8h]    [DTCM+3FF8h]  [380FFC0h]
</TD></TR></TABLE>
NDS9: BUG: No Discard (r0=0) doesn't work. The function always waits for at
least one IRQ to occur (no matter which, including IRQs that are not selected
in r1), even if the desired flag was already set. NB. the same bug is also
found in the GBA/NDS7 functions, but it's compensated by a second bug, ie. the
GBA/NDS7 functions are working okay because their "bug doesn't work".<BR>
Return: No return value, the selected flag(s) are automatically reset in BIOS
Interrupt Flags value in RAM upon return.<BR>
DSi9: BUG: The function tries to enter Halt state via Port 4000301h (which
would be okay on ARM7, but it's probably ignored on ARM9, which should normally
use CP15 to enter Halt state; if Port 4000301h is really ignored, then the
function will "successfully" wait for interrupts, but without actually entering
any kind of low power mode).<BR>
DSi7: BUG: The function tries to wait for IF and IF2 interrupts, but it does
accidently ignore the old IF interrupts, and works only with new IF2 ones.<BR>
<BR>
<B>SWI 05h (GBA/NDS7/NDS9/DSi7/DSi9) - VBlankIntrWait ;DSi7/DSi9=bugged?</B><BR>
Continues to wait in Halt status until a new V-Blank interrupt occurs.<BR>
The function sets r0=1 and r1=1 (plus r2=0 on DSi7) and does then execute
IntrWait (SWI 04h), see IntrWait for details.<BR>
No parameters, no return value.<BR>
<BR>
<B>SWI 03h (GBA) - Stop</B><BR>
Switches the GBA into very low power mode (to be used similar as a
screen-saver). The CPU, System Clock, Sound, Video, SIO-Shift Clock, DMAs, and
Timers are stopped.<BR>
Stop state can be terminated by the following interrupts only (as far as
enabled in IE register): Joypad, Game Pak, or General-Purpose-SIO.<BR>
"The system clock is stopped so the IF flag is not set."<BR>
Preparation for Stop:<BR>
Disable Video before implementing Stop (otherwise Video just freezes, but still
keeps consuming battery power). Possibly required to disable Sound also?
Obviously, it'd be also recommended to disable any external hardware (such like
Rumble or Infra-Red) as far as possible.<BR>
No parameters, no return value.<BR>
<BR>
<B>SWI 07h (NDS7/DSi7) - Sleep</B><BR>
No info, probably similar as GBA SWI 03h (Stop). Sleep is implemented for ARM7
only, not for ARM9. But maybe the ARM7 function does stop &lt;both&gt; ARM7 and
ARM9 (?)<BR>
<BR>
<B>SWI 27h (GBA) or SWI 1Fh (NDS7/DSi7) - CustomHalt (Undocumented)</B><BR>
Writes the 8bit parameter value to HALTCNT, below values are equivalent to Halt
and Stop/Sleep functions, other values reserved, purpose unknown.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  r2  8bit parameter (GBA: 00h=Halt, 80h=Stop) (NDS7/DSi7: 80h=Halt, C0h=Sleep)
</TD></TR></TABLE>
No return value.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="biosresetfunctions"></A>&nbsp;
  BIOS Reset Functions
</FONT></TD></TR></TABLE><BR>
SoftReset<BR>
RegisterRamReset<BR>
HardReset<BR>
<BR>
<B>SWI 00h (GBA/NDS7/NDS9) - SoftReset</B><BR>
Clears 200h bytes of RAM (containing stacks, and BIOS IRQ vector/flags),
initializes system, supervisor, and irq stack pointers, sets R0-R12, LR_svc,
SPSR_svc, LR_irq, and SPSR_irq to zero, and enters system mode.<BR>
Note that the NDS9 stack registers are hardcoded (the DTCM base should be set
to the default setting of 0800000h). The NDS9 function additionally flushes
caches and write buffer, and sets the CP15 control register to 12078h.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Host  sp_svc    sp_irq    sp_sys    zerofilled area       return address
  GBA   3007FE0h  3007FA0h  3007F00h  [3007E00h..3007FFFh]  Flag[3007FFAh]
  NDS7  380FFDCh  380FFB0h  380FF00h  [380FE00h..380FFFFh]  Addr[27FFE34h]
  NDS9  0803FC0h  0803FA0h  0803EC0h  [DTCM+3E00h..3FFFh]   Addr[27FFE24h]
</TD></TR></TABLE>
The NDS7/NDS9 return addresses at [27FFE34h/27FFE24h] are usually containing
copies of Cartridge Header [034h/024h] entry points, which may select ARM/THUMB
state via bit0. The GBA return address 8bit flag is interpreted as 00h=8000000h
(ROM), or 01h-FFh=2000000h (RAM), entered in ARM state.<BR>
Note: The reset is applied only to the CPU that has executed the SWI (ie. on
the NDS, the other CPU will remain unaffected).<BR>
Return: Does not return to calling procedure, instead, loads the above return
address into R14, and then jumps to that address by a "BX R14" opcode.<BR>
<BR>
<B>SWI 01h (GBA) - RegisterRamReset</B><BR>
Resets the I/O registers and RAM specified in ResetFlags. However, it does not
clear the CPU internal RAM area from 3007E00h-3007FFFh.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  r0  ResetFlags
       Bit   Expl.
       0     Clear 256K on-board WRAM  ;-don't use when returning to WRAM
       1     Clear 32K on-chip WRAM    ;-excluding last 200h bytes
       2     Clear Palette
       3     Clear VRAM
       4     Clear OAM              ;-zerofilled! does NOT disable OBJs!
       5     Reset SIO registers    ;-switches to general purpose mode!
       6     Reset Sound registers
       7     Reset all other registers (except SIO, Sound)
</TD></TR></TABLE>
Return: No return value.<BR>
Bug: LSBs of SIODATA32 are always destroyed, even if Bit5 of R0 was cleared.<BR>
The function always switches the screen into forced blank by setting
DISPCNT=0080h (regardless of incoming R0, screen becomes white).<BR>
<BR>
<B>SWI 26h (GBA) - HardReset (Undocumented)</B><BR>
This function reboots the GBA (including for getting through the time-consuming
nintendo intro, which is making the function particularly useless and
annoying).<BR>
Parameters: None. Return: Never/Reboot.<BR>
Execution Time: About 2 seconds (!)<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="biosmiscfunctions"></A>&nbsp;
  BIOS Misc Functions
</FONT></TD></TR></TABLE><BR>
GetBiosChecksum<BR>
WaitByLoop<BR>
GetCRC16<BR>
IsDebugger<BR>
GetSineTable<BR>
GetPitchTable<BR>
GetVolumeTable<BR>
CustomPost<BR>
GetBootProcs<BR>
<BR>
<B>SWI 0Dh (GBA) - GetBiosChecksum (Undocumented)</B><BR>
Calculates the checksum of the BIOS ROM (by reading in 32bit units, and adding
up these values). IRQ and FIQ are disabled during execution.<BR>
The checksum is BAAE187Fh (GBA and GBA SP), or BAAE1880h (DS in GBA mode,
whereas the only difference is that the byte at [3F0Ch] is changed from 00h to
01h, otherwise the BIOS is 1:1 same as GBA BIOS, it does even include multiboot
code).<BR>
Parameters: None. Return: r0=Checksum.<BR>
<BR>
<B>SWI 03h (NDS7/NDS9/DSi7/DSi9) - WaitByLoop</B><BR>
Performs a "LOP: SUB R0,1 / BGT LOP" wait loop, the loop is executed in BIOS
memory, which provides reliable timings (regardless of the memory waitstates
&amp; cache state of the calling procedure). Intended only for short delays
(eg. flash memory programming cycles).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  r0  Delay value (should be in range 1..7FFFFFFFh)
</TD></TR></TABLE>
Execution Time: NDS7: R0*4 cycles, plus some overload on SWI handling.<BR>
Execution Time: NDS9: R0*2 (cache on), or R0*8 (cache off), plus overload.<BR>
Note: Both NDS7 and NDS9 timings are counted in 33.51MHz units.<BR>
Return: No return value.<BR>
<BR>
<B>SWI 0Eh (NDS7/NDS9) - GetCRC16</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  r0  Initial CRC value (16bit, usually FFFFh)
  r1  Start Address   (must be aligned by 2)
  r2  Length in bytes (must be aligned by 2)
</TD></TR></TABLE>
CRC16 checksums can be calculated as such:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  val[0..7] = C0C1h,C181h,C301h,C601h,CC01h,D801h,F001h,A001h
  for i=start to end
    crc=crc xor byte[i]
    for j=0 to 7
      crc=crc shr 1:if carry then crc=crc xor (val[j] shl (7-j))
    next j
  next i
</TD></TR></TABLE>
Return:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  r0  Calculated 16bit CRC Value
</TD></TR></TABLE>
Additionally, if the length is nonzero, r3 contains the last processed halfword
at [addr+len-2]. Unlike most other NDS7/DSi7 SWI functions (which do reject
reading from BIOS memory), this allows to dump the NDS7/DSi7 BIOS (except for
the memory region that is locked via BIOSPROT Port 4000308h).<BR>
<BR>
<B>SWI 0Fh (NDS7/NDS9) - IsDebugger</B><BR>
Detects if 4MB (normal) or 8MB (debug version) Main RAM installed.<BR>
Caution: Fails on ARM9 when cache is enabled (always returns 8MB state).<BR>
Return: r0 = result (0=normal console 4MB, 1=debug version 8MB)<BR>
Destroys halfword at [27FFFFAh] (NDS7) or [27FFFF8h] (NDS9)!<BR>
The SWI 0Fh function doesn't work stable if it gets interrupted by an interrupt
which is calling SWI 0Fh, which would destroy the above halfword scratch value
(unless the IRQ handler has saved/restored the halfword).<BR>
<BR>
<B>SWI 1Ah (NDS7/DSi7) - GetSineTable</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  r0  Index (0..3Fh) (must be in that range, otherwise returns garbage)
</TD></TR></TABLE>
Return: r0 = Desired Entry (0000h..7FF5h) ;SIN(0 .. 88.6 degrees)*8000h<BR>
<BR>
<B>SWI 1Bh (NDS7/DSi7) - GetPitchTable (DSi7: bugged)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  r0  Index (0..2FFh) (must be in that range, otherwise returns garbage)
</TD></TR></TABLE>
BUG: DSi7 accidently reads from SineTable instead of PitchTable, as workaround
for obtaining PitchTable values, one can set "r0=(0..2FFh)-46Ah" on DSi.<BR>
Return: r0 = Desired Entry (0000h..FF8Ah) (unsigned)<BR>
<BR>
<B>SWI 1Ch (NDS7/DSi7) - GetVolumeTable</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  r0  Index (0..2D3h) (must be in that range, otherwise returns garbage)
</TD></TR></TABLE>
Return: r0 = Desired Entry (00h..7Fh) (unsigned)<BR>
<BR>
<B>SWI 1Fh (NDS9/DSi7) - CustomPost</B><BR>
Writes to the POSTFLG register, probably for use by Firmware boot procedure.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  r0  32bit value, to be written to POSTFLG, Port 4000300h
</TD></TR></TABLE>
Return: No return value.<BR>
<BR>
<B>SWI 1Dh (NDS7/DSi7) - GetBootProcs</B><BR>
Returns addresses of Gamecart boot procedure/interrupt handler, probably for
use by Firmware boot procedure. Most of the returned NDS7 functions won't work
if the POSTFLG register is set.<BR>
The return values are somewhat XORed by each other (on DSi7 most of the values
are zero; which does rather negate the XORing effect, and, as a special
gimmick, one of the zero values is XORed by incoming r2).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="biosmultibootsinglegamepak"></A>&nbsp;
  BIOS Multi Boot (Single Game Pak)
</FONT></TD></TR></TABLE><BR>
MultiBoot<BR>
<BR>
<B>SWI 25h (GBA) - MultiBoot</B><BR>
This function uploads &amp; starts program code to slave GBAs, allowing to
launch programs on slave units even if no cartridge is inserted into the slaves
(this works because all GBA BIOSes contain built-in download procedures in
ROM).<BR>
However, the SWI 25h BIOS upload function covers only 45% of the required
Transmission Protocol, the other 55% must be coded in the master cartridge (see
Transmission Protocol below).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  r0  Pointer to MultiBootParam structure
  r1  Transfer Mode (undocumented)
       0=256KHz, 32bit, Normal mode    (fast and stable)
       1=115KHz, 16bit, MultiPlay mode (default, slow, up to three slaves)
       2=2MHz,   32bit, Normal mode    (fastest but maybe unstable)
  Note: HLL-programmers that are using the MultiBoot(param_ptr) macro cannot
  specify the transfer mode and will be forcefully using MultiPlay mode.
</TD></TR></TABLE>
Return:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  r0  0=okay, 1=failed
</TD></TR></TABLE>
See below for more details.<BR>
<BR>
<B>Multiboot Parameter Structure</B><BR>
Size of parameter structure should be 4Ch bytes (the current GBA BIOS uses only
first 44h bytes though). The following entries must be set before calling SWI
25h:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Addr Size Name/Expl.
  14h  1    handshake_data (entry used for normal mode only)
  19h  3    client_data[1,2,3]
  1Ch  1    palette_data
  1Eh  1    client_bit (Bit 1-3 set if child 1-3 detected)
  20h  4    boot_srcp  (typically 8000000h+0C0h)
  24h  4    boot_endp  (typically 8000000h+0C0h+length)
</TD></TR></TABLE>
The transfer length (excluding header data) should be a multiple of 10h,
minimum length 100h, max 3FF40h (ca. 256KBytes). Set palette_data as
"81h+color*10h+direction*8+speed*2", or as "0f1h+color*2" for fixed palette,
whereas color=0..6, speed=0..3, direction=0..1. The other entries
(handshake_data, client_data[1-3], and client_bit) must be same as specified in
Transmission Protocol (see below hh,cc,y).<BR>
<BR>
<B>Multiboot Transfer Protocol</B><BR>
Below describes the complete transfer protocol, normally only the Initiation
part must be programmed in the master cartridge, the main data transfer can be
then performed by calling SWI 25h, the slave program is started after SWI 25h
completion.<BR>
The ending handshake is normally not required, when using it, note that you
will need custom code in BOTH master and slave programs.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Times  Send   Receive  Expl.
  -----------------------Required Transfer Initiation in master program
  ...    6200   FFFF     Slave not in multiplay/normal mode yet
  1      6200   0000     Slave entered correct mode now
  15     6200   720x     Repeat 15 times, if failed: delay 1/16s and restart
  1      610y   720x     Recognition okay, exchange master/slave info
  60h    xxxx   NN0x     Transfer C0h bytes header data in units of 16bits
  1      6200   000x     Transfer of header data completed
  1      620y   720x     Exchange master/slave info again
  ...    63pp   720x     Wait until all slaves reply 73cc instead 720x
  1      63pp   73cc     Send palette_data and receive client_data[1-3]
  1      64hh   73uu     Send handshake_data for final transfer completion
  -----------------------Below is SWI 25h MultiBoot handler in BIOS
  DELAY  -      -        Wait 1/16 seconds at master side
  1      llll   73rr     Send length information and receive random data[1-3]
  LEN    yyyy   nnnn     Transfer main data block in units of 16 or 32 bits
  1      0065   nnnn     Transfer of main data block completed, request CRC
  ...    0065   0074     Wait until all slaves reply 0075 instead 0074
  1      0065   0075     All slaves ready for CRC transfer
  1      0066   0075     Signalize that transfer of CRC follows
  1      zzzz   zzzz     Exchange CRC must be same for master and slaves
  -----------------------Optional Handshake (NOT part of master/slave BIOS)
  ...    ....   ....     Exchange whatever custom data
</TD></TR></TABLE>
Legend for above Protocol<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  y     client_bit, bit(s) 1-3 set if slave(s) 1-3 detected
  x     bit 1,2,or 3 set if slave 1,2,or 3
  xxxx  header data, transferred in 16bit (!) units (even in 32bit normal mode)
  nn    response value for header transfer, decreasing 60h..01h
  pp    palette_data
  cc    random client_data[1..3] from slave 1-3, FFh if slave not exists
  hh    handshake_data, 11h+client_data[1]+client_data[2]+client_data[3]
  uu    random data, not used, ignore this value
</TD></TR></TABLE>
Below automatically calculated by SWI 25h BIOS function (don't care about)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  llll  download length/4-34h
  rr    random data from each slave for encryption, FFh if slave not exists
  yyyy  encoded data in 16bit (multiplay) or 32bit (normal mode) units
  nnnn  response value, lower 16bit of destadr in GBA memory (00C0h and up)
  zzzz  16bit download CRC value, must be same for master and slaves
</TD></TR></TABLE>
Pseudo Code for SWI 25h Transfer with Checksum and Encryption calculations<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  if normal_mode    then c=C387h:x=C37Bh:k=43202F2Fh
  if multiplay_mode then c=FFF8h:x=A517h:k=6465646Fh
  m=dword(pp,cc,cc,cc):f=dword(hh,rr,rr,rr)
  for ptr=000000C0h to (file_size-4) step 4
    c=c xor data[ptr]:for i=1 to 32:c=c shr 1:if carry then c=c xor x:next
    m=(6F646573h*m)+1
    send_32_or_2x16 (data[ptr] xor (-2000000h-ptr) xor m xor k)
  next
  c=c xor f:for i=1 to 32:c=c shr 1:if carry then c=c xor x:next
  wait_all_units_ready_for_checksum:send_32_or_1x16 (c)
</TD></TR></TABLE>
Whereas, explained: c=chksum,x=chkxor,f=chkfin,k=keyxor,m=keymul<BR>
<BR>
<B>Multiboot Communication</B><BR>
In Multiplay mode, master sends 16bit data, and receives 16bit data from each
slave (or FFFFh if none). In Normal mode, master sends 32bit data (upper 16bit
zero, lower 16bit as for multiplay mode), and receives 32bit data (upper 16bit
as for multiplay mode, and lower 16bit same as lower 16bit previously sent by
master). Because SIODATA32 occupies same addresses as SIOMULTI0-1, the same
transfer code can be used for both multiplay and normal mode (in normal mode
SIOMULTI2-3 should be forced to FFFFh though). After each transfer, master
should wait for Start bit cleared in SIOCNT register, followed by a 36us delay.<BR>
Note: The multiboot slave would also recognize data being sent in Joybus mode,
however, master GBAs cannot use joybus mode (because GBA hardware cannot act as
master in joybus mode).<BR>
<BR>
<B>Multiboot Slave Header</B><BR>
The transferred Header block is written to 2000000-20000BFh in slave RAM, the
header must contain valid data (identically as for normal ROM-cartridge
headers, including a copy of the Nintendo logo, correct header CRC, etc.), in
most cases it'd be recommended just to transfer a copy of the master cartridges
header from 8000000h-80000BFh.<BR>
<BR>
<B>Multiboot Slave Program/Data</B><BR>
The transferred main program/data block is written to 20000C0h and up (max
203FFFFh) in slave RAM, note that absolute addresses in the program must be
then originated at 2000000h rather than 8000000h. In case that the master
cartridge is 256K or less, it could just transfer a copy of the whole cartridge
at 80000C0h and up, the master should then copy &amp; execute its own ROM data
into RAM as well.<BR>
<BR>
<B>Multiboot Slave Extended Header</B><BR>
For Multiboot slaves, separate Entry Point(s) must be defined at the beginning
of the Program/Data block (the Entry Point in the normal header is ignored),
also some reserved bytes in this section are overwritten by the Multiboot
procedure. For more information see chapter about Cartridge Header.<BR>
<BR>
<B>Multiboot Slave with Cartridge</B><BR>
Beside for slaves without cartridge, multiboot can be also used for slaves
which do have a cartridge inserted, if so, SELECT and START must be kept held
down during power-on in order to switch the slave GBA into Multiboot mode (ie.
to prevent it from starting the cartridge as normally).<BR>
The general idea is to enable newer programs to link to any existing older GBA
programs, even if these older programs originally didn't have been intended to
support linking.<BR>
The uploaded program may access the slaves SRAM, Flash ROM, or EEPROM (if any,
allowing to read out or modify slave game positions), as well as cartridge ROM
at 80000A0h-8000FFFh (the first 4KBytes, excluding the nintendo logo, allowing
to read out the cartridge name from the header, for example).<BR>
The main part of the cartridge ROM is meant to be locked out in order to
prevent software pirates from uploading "intruder" programs which would send
back a copy of the whole cartridge to the master, however, for good or evil, at
present time, current GBA models and GBA carts do not seem to contain any such
protection.<BR>
<BR>
<B>Uploading Programs from PC</B><BR>
Beside for the ability to upload a program from one GBA to another, this
feature can be also used to upload small programs from a PC to a GBA. For more
information see chapter about External Connectors.<BR>
<BR>
<B>Nintendo DS</B><BR>
The GBA multiboot function requires a link port, and so, works on GBA and GBA
SP only. The Nintendo DS in GBA mode does include the multiboot BIOS function,
but it won't be of any use as the DS doesn't have a link port.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="biossoundfunctions"></A>&nbsp;
  BIOS Sound Functions
</FONT></TD></TR></TABLE><BR>
MidiKey2Freq<BR>
SoundBias<BR>
SoundChannelClear<BR>
SoundDriverInit<BR>
SoundDriverMain<BR>
SoundDriverMode<BR>
SoundDriverVSync<BR>
SoundDriverVSyncOff<BR>
SoundDriverVSyncOn<BR>
SoundWhatever0..4<BR>
SoundGetJumpList<BR>
<BR>
<B>SWI 1Fh (GBA) - MidiKey2Freq</B><BR>
Calculates the value of the assignment to ((SoundArea)sa).vchn[x].fr when
playing the wave data, wa, with the interval (MIDI KEY) mk and the fine
adjustment value (halftones=256) fp.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  r0  WaveData* wa
  r1  u8 mk
  r2  u8 fp
</TD></TR></TABLE>
Return:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  r0  u32
</TD></TR></TABLE>
This function is particularly popular because it allows to read from BIOS
memory without copy protection range checks. The formula to read one byte (a)
from address (i, 0..3FFF) is:<BR>
a = (MidiKey2Freq(i-(((i AND 3)+1)OR 3), 168, 0) * 2) SHR 24<BR>
<BR>
<B>SWI 19h (GBA) or SWI 08h (NDS7/DSi7) - SoundBias</B><BR>
Increments or decrements the current level of the SOUNDBIAS register (with
short delays) until reaching the desired new level. The upper bits of the
register are kept unchanged.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  r0   BIAS level (0=Level 000h, any other value=Level 200h)
  r1   Delay Count (NDS/DSi only) (GBA uses a fixed delay count of 8)
</TD></TR></TABLE>
Return: No return value.<BR>
<BR>
<B>SWI 1Eh (GBA) - SoundChannelClear</B><BR>
Clears all direct sound channels and stops the sound.<BR>
This function may not operate properly when the library which expands the sound
driver feature is combined afterwards. In this case, do not use it.<BR>
No parameters, no return value.<BR>
<BR>
<B>SWI 1Ah (GBA) - SoundDriverInit</B><BR>
Initializes the sound driver. Call this only once when the game starts up.<BR>
It is essential that the work area already be secured at the time this function
is called.<BR>
You cannot execute this driver multiple times, even if separate work areas have
been prepared.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  r0  Pointer to work area for sound driver, SoundArea structure as follows:
       SoundArea (sa) Structure
        u32    ident      Flag the system checks to see whether the
                          work area has been initialized and whether it
                          is currently being accessed.
        vu8    DmaCount   User access prohibited
        u8     reverb     Variable for applying reverb effects to direct sound
        u16    d1         User access prohibited
        void   (*func)()  User access prohibited
        int    intp       User access prohibited
        void*  NoUse      User access prohibited
        SndCh  vchn[MAX]  The structure array for controlling the direct
                          sound channels (currently 8 channels are
                          available). The term "channel" here does
                          not refer to hardware channels, but rather to
                          virtual constructs inside the sound driver.
        s8     pcmbuf[PCM_BF*2]
       SoundChannel Structure
        u8         sf     The flag indicating the status of this channel.
                          When 0 sound is stopped.
                          To start sound, set other parameters and
                          then write 80h to here.
                          To stop sound, logical OR 40h for a
                          release-attached off (key-off), or write zero
                          for a pause. The use of other bits is
                          prohibited.
        u8         r1     User access prohibited
        u8         rv     Sound volume output to right side
        u8         lv     Sound volume output to left side
        u8         at     The attack value of the envelope. When the
                          sound starts, the volume begins at zero and
                          increases every 1/60 second. When it
                          reaches 255, the process moves on to the
                          next decay value.
        u8         de     The decay value of the envelope. It is
                          multiplied by "this value/256" every 1/60
                          sec. and when sustain value is reached, the
                          process moves to the sustain condition.
        u8         su     The sustain value of the envelope. The
                          sound is sustained by this amount.
                          (Actually, multiplied by rv/256, lv/256 and
                          output left and right.)
        u8         re     The release value of the envelope. Key-off
                          (logical OR 40h in sf) to enter this state.
                          The value is multiplied by "this value/256"
                          every 1/60 sec. and when it reaches zero,
                          this channel is completely stopped.
        u8         r2[4]  User access prohibited
        u32        fr     The frequency of the produced sound.
                          Write the value obtained with the
                          MidiKey2Freq function here.
        WaveData*  wp     Pointer to the sound's waveform data. The waveform
                          data can be generated automatically from the AIFF
                          file using the tool (aif2agb.exe), so users normally
                          do not need to create this themselves.
        u32        r3[6]  User access prohibited
        u8         r4[4]  User access prohibited
       WaveData Structure
        u16   type    Indicates the data type. This is currently not used.
        u16   stat    At the present time, non-looped (1 shot) waveform
                      is 0000h and forward loop is 4000h.
        u32   freq    This value is used to calculate the frequency.
                      It is obtained using the following formula:
                      sampling rate x 2^((180-original MIDI key)/12)
        u32   loop    Loop pointer (start of loop)
        u32   size    Number of samples (end position)
        s8    data[]  The actual waveform data. Takes (number of samples+1)
                      bytes of 8bit signed linear uncompressed data. The last
                      byte is zero for a non-looped waveform, and the same
                      value as the loop pointer data for a looped waveform.
</TD></TR></TABLE>
Return: No return value.<BR>
<BR>
<B>SWI 1Ch (GBA) - SoundDriverMain</B><BR>
Main of the sound driver.<BR>
Call every 1/60 of a second. The flow of the process is to call
SoundDriverVSync, which is explained later, immediately after the V-Blank
interrupt.<BR>
After that, this routine is called after BG and OBJ processing is executed.<BR>
No parameters, no return value.<BR>
<BR>
<B>SWI 1Bh (GBA) - SoundDriverMode</B><BR>
Sets the sound driver operation mode.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  r0  Sound driver operation mode
       Bit    Expl.
       0-6    Direct Sound Reverb value (0-127, default=0) (ignored if Bit7=0)
       7      Direct Sound Reverb set (0=ignore, 1=apply reverb value)
       8-11   Direct Sound Simultaneously-produced (1-12 channels, default 8)
       12-15  Direct Sound Master volume (1-15, default 15)
       16-19  Direct Sound Playback Frequency (1-12 = 5734,7884,10512,13379,
              15768,18157,21024,26758,31536,36314,40137,42048, def 4=13379 Hz)
       20-23  Final number of D/A converter bits (8-11 = 9-6bits, def. 9=8bits)
       24-31  Not used.
</TD></TR></TABLE>
Return: No return value.<BR>
<BR>
<B>SWI 1Dh (GBA) - SoundDriverVSync</B><BR>
An extremely short system call that resets the sound DMA. The timing is
extremely critical, so call this function immediately after the V-Blank
interrupt every 1/60 second.<BR>
No parameters, no return value.<BR>
<BR>
<B>SWI 28h (GBA) - SoundDriverVSyncOff</B><BR>
Due to problems with the main program if the V-Blank interrupts are stopped,
and SoundDriverVSync cannot be called every 1/60 a second, this function must
be used to stop sound DMA.<BR>
Otherwise, even if you exceed the limit of the buffer the DMA will not stop and
noise will result.<BR>
No parameters, no return value.<BR>
<BR>
<B>SWI 29h (GBA) - SoundDriverVSyncOn</B><BR>
This function restarts the sound DMA stopped with the previously described
SoundDriverVSyncOff.<BR>
After calling this function, have a V-Blank occur within 2/60 of a second and
call SoundDriverVSync.<BR>
No parameters, no return value.<BR>
<BR>
<B>SWI 20h..24h (GBA) - SoundWhatever0..4 (Undocumented)</B><BR>
Whatever undocumented sound-related BIOS functions.<BR>
<BR>
<B>SWI 2Ah (GBA) - SoundGetJumpList (Undocumented)</B><BR>
Receives pointers to 36 additional sound-related BIOS functions.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  r0  Destination address (must be aligned by 4) (120h bytes buffer)
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="biossha1functionsdsionly"></A>&nbsp;
  BIOS SHA1 Functions (DSi only)
</FONT></TD></TR></TABLE><BR>
SHA1_Init(struct)<BR>
SHA1_Update(struct,src,srclen)<BR>
SHA1_Finish(dst,struct)<BR>
SHA1_Init_Update_Finish(dst,src,srclen)<BR>
SHA1_Init_Update_Finish_Mess(dst,dstlen,src,srclen)<BR>
SHA1_Compare_20_Bytes(src1,src2)<BR>
SHA1_Default_Callback(struct,src,len)<BR>
<BR>
<B>SWI 24h (DSi9/DSi7) - SHA1_Init(struct)</B><BR>
Initializes a 64h-byte structure for SHA1 calculations:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  [struct+00h] = 67452301h      ;\
  [struct+04h] = EFCDAB89h      ;
  [struct+08h] = 98BADCFEh      ; initial SHA1 checksum value
  [struct+0Ch] = 10325476h      ;
  [struct+10h] = C3D2E1F0h      ;/
  [struct+14h] = 00000000h ;lsw ;\total len in bits, initially zero
  [struct+18h] = 00000000h ;msw ;/
  [struct+1Ch] = uninitialzed   ;-buffer for incomplete fragment (40h bytes)
  [struct+5Ch] = 00000000h      ;-incomplete fragment size
  if [struct+60h] = 00000000h then [struct+60h] = SHA1_Default_Callback
</TD></TR></TABLE>
Observe that the incoming [struct+60h] value should be 00000000h, otherwise the
default callback isn't installed (using a different callback doesn't make too
much sense, and it's probably not done by any DSi programs) (the callback
feature might be intended to mount hardware accelleration, or to hook,
customize, encrypt, or replace the SHA1 functionality).<BR>
<BR>
<B>SWI 25h (DSi9/DSi7) - SHA1_Update(struct,src,srclen)</B><BR>
This function should be placed between Init and Finish. The Update function can
be called multiple times if the source data is split into separate blocks.
There's no alignment requirement (though the function works faster if src is
4-byte aligned).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  [struct+14h]=[struct+14h]+len*8  ;64bit value ;-raise total len in bits
  if [struct+5Ch]&lt;&gt;0 and [struct+5Ch]+len&gt;=40h  ;\
    for i=[struct+5Ch] to 3Fh                   ; merge old incomplete chunk
      [struct+1Ch+i]=[src], src=src+1, len=len-1; with new data and process it
    SHA1_Callback(struct,struct+1Ch,40h)        ; (if it gives a full chunk)
    [struct+5Ch]=0                              ;/
  if len&gt;=40h then                              ;\process full 40h-byte chunks
    SHA1_Callback(struct,src,len AND NOT 3Fh)   ; (if src isn't 4-byte aligned
    src=src+(len AND NOT 3Fh)                   ; then the DSi BIOS internally
    len=len AND 3Fh                             ;/copies all chunks to struct)
  if len&gt;0 then                                 ;\
    for i=[struct+5Ch] to [struct+5Ch]+len-1    ; memorize remaining bytes
      [struct+1Ch+i]=[src], src=src+1, len=len-1; as incomplete chunk
      [struct+5Ch]=[struct+5Ch]+1               ;/
</TD></TR></TABLE>
<BR>
<B>SWI 26h (DSi9/DSi7) - SHA1_Finish(dst,struct)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  [total_len]=bswap8byte([struct+14h]) ;get total len in bits in big-endian
  SHA1_Update(struct,value_80h,1)                            ;append end byte
  while [struct+5Ch]&lt;&gt;38h do SHA1_Update(struct,value_00h,1) ;append padding
  SHA1_Update(struct,total_len,8)                            ;append 64bit len
  [struct+14h]=bswap8byte([total_len]) ;restore total len, exclude above update
  [dst+00h]=bswap([struct+00h]  ;msw   ;\
  [dst+04h]=bswap([struct+04h]         ; store SHA1 result at dst
  [dst+08h]=bswap([struct+08h]         ; (in big-endian)
  [dst+0Ch]=bswap([struct+0Ch]         ;
  [dst+10h]=bswap([struct+10h]  ;lsw   ;/
</TD></TR></TABLE>
<BR>
<B>SHA1_Default_Callback(struct,src,len)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  for j=1 to len/40h
    a=[struct+0], b=[struct+4], c=[struct+8], d=[struct+0Ch], e=[struct+00h]
    for i=0 to 79
      if i=0..15  then w[i] = bswap([src]), src=src+4
      if i=16..79 then w[i] = (w[i-3] xor w[i-8] xor w[i-14] xor w[i-16]) rol 1
      if i=0..19  then f=5A827999h + e + (d xor (b and (c xor d)))
      if i=20..39 then f=6ED9EBA1h + e + (b xor c xor d)
      if i=40..59 then f=8F1BBCDCh + e + ((b and c) or (d and (b or c)))
      if i=60..79 then f=CA62C1D6h + e + (b xor c xor d)
      e=d, d=c, c=(b ror 2), b=a, a=f + (a rol 5) + w[i]
    [struct+0]=[struct+0]+a, [struct+4]=[struct+4]+b, [struct+8]=[struct+8]+c
    [struct+0Ch]=[struct+0Ch]+d, [struct+10h]=[struct+10h]+e
</TD></TR></TABLE>
<BR>
<B>SWI 27h (DSi9/DSi7) - SHA1_Init_Update_Finish(dst,src,srclen)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  [struct+60h]=00000000h  ;want Init to install the default SHA1 callback
  SHA1_Init(struct)
  SHA1_Update(struct,src,srclen)
  SHA1_Finish(dst,struct)
</TD></TR></TABLE>
Always returns r0=1.<BR>
<BR>
<B>SWI 29h (DSi9/DSi7) - SHA1_Init_Update_Finish_Mess(dst,dstlen,src,srclen)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  if dst=0 then exit(r0=1)  ;uh, that's same return value as when okay
  if src=0 and srclen&lt;&gt;0 then exit(r0=0)
  [struct+60h]=00000000h                ;\
  SHA1_Init(struct)                     ; first compute normal SHA1
  SHA1_Update(struct,src,srclen)        ; (same as SHA1_Init_Update_Finish)
  SHA1_Finish(first_sha1,struct)        ;/
 @@lop1:
  i=13h  ;start with LSB of big-endian 20-byte value  ;\increment SHA1 value
 @@lop2:                                              ; by one (with somewhat
  [first_sha1+i]=[first_sha1+i]+1, i=i-1              ; uncommon/bugged carry-
  if i&gt;=0 and [first_sha1+i+1]=01h then goto @@lop2   ;/out to higher bytes)
  SHA1_Update(struct,first_sha1,14h)    ;\compute 2nd SHA1 across 1st SHA1,
  SHA1_Finish(second_sha1,struct)       ;/done without re-initializing struct
  for i=0 to min(14h,dstlen)-1, [dst]=[second_sha1+i], dst=dst+1
  dstlen=dstlen-min(14h,dstlen)
  if dstlen&lt;&gt;0 then goto @@lop1 else exit(r0=1)
</TD></TR></TABLE>
<BR>
<B>SHA1_Init_Update_Finish_HMAC(dst,key,src,srclen)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  if len(key)&lt;40h then zero-pad key to 40h bytes length
  for i=0 to 3Fh, [inner_key+i]=[key+i] xor 36h ;\
  [struct+60h]=00000000h                        ;
  SHA1_Init(struct)                             ; compute 1st SHA1
  SHA1_Update(struct,inner_key,40h)             ; across inner key and data
  SHA1_Update(struct,src,srclen)                ;
  SHA1_Finish(first_sha1,struct)                ;/
  for i=0 to 3Fh, [outer_key+i]=[key+i] xor 5Ch ;\
  [struct+60h]=00000000h                        ;
  SHA1_Init(struct)                             ; compute final SHA1
  SHA1_Update(struct,outer_key,40h)             ; across outer key and 1st SHA1
  SHA1_Update(struct,first_sha1,14h)            ;
  SHA1_Finish(dst,struct)                       ;/
</TD></TR></TABLE>
<BR>
<B>SWI 28h (DSi9/DSi7) - SHA1_Compare_20_Bytes(src1,src2)</B><BR>
Out: r0=1=match, r0=0=mismatch/error (error occurs if src1=0 or src2=0).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="biosrsafunctionsdsionly"></A>&nbsp;
  BIOS RSA Functions (DSi only)
</FONT></TD></TR></TABLE><BR>
RSA_Init_crypto_heap(heap_nfo,heap_start,heap_size)<BR>
RSA_Decrypt(heap_nfo,struct,dest4)<BR>
RSA_Decrypt_Unpad(heap_nfo,dst,src,key)<BR>
RSA_Decrypt_Unpad_GetChunk04(heap_nfo,dst,src,key)<BR>
<BR>
RSA is important because the DSi cartridge header contains a RSA signature.
Which makes it impossible to create unlicensed software (without knowing
Nintendo's private key).<BR>
<BR>
<B>SWI 20h (DSi9/DSi7) - RSA_Init_crypto_heap(heap_nfo,heap_start,heap_size)</B><BR>
Initializes the heap for use with SWI 21h..23h. heap_nfo is a 0Ch-byte
structure, which gets set to:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  [heap_nfo+0] = heap_start (rounded-up to 4-byte boundary)
  [heap_nfo+4] = heap_end   (start+size, rounded-down to 4-byte boundary)
  [heap_nfo+8] = heap_size  (matched to above rounded values)
</TD></TR></TABLE>
heap_start should point to a free memory block which will be used as heap,
heap_size should be usually 1000h.<BR>
<BR>
<B>SWI 21h (DSi9/DSi7) - RSA_Decrypt(heap_nfo,ptr_nfo,len_dest)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  [ptr_nfo+0] = dst
  [ptr_nfo+4] = src
  [ptr_nfo+8] = key
</TD></TR></TABLE>
This a subfunction for SWI 22h/23h. It's returning raw decrypted data (without
unpadding, and without extracting chunks). The length of the decrypted data is
returned at [len_dest].<BR>
<BR>
<B>SWI 22h (DSi9/DSi7) - RSA_Decrypt_Unpad(heap_nfo,dst,src,key)</B><BR>
Decrypts something. src,dst,key should be 80h-bytes. The output at dst can be
theoretically max 80h-bytes (or shorter due to removed padding). In practice,
the DSi is often using only the first 14h-bytes at dst (aka the last 14h-bytes
from src) as SHA1 or SHA1-HMAC value (RSA SHA1). Return value (r0) is:
0=failed, 1=okay.<BR>
<BR>
<B>SWI 23h (DSi9/DSi7) - RSA_Decrypt_Unpad_GetChunk04(heap_nfo,dst,src,key)</B><BR>
Same as SWI 22h, but with some extra processing (DER related?) on the final
decrypted &amp; unpadded data:<BR>
The data must consist of five chunks (with IDs 30h,30h,06h,05h,04h), the last
chunk (with ID=04h) must be 14h bytes in size, and the 14h-byte chunk data is
then copied to dst. The other four chunks must exist, but their content is just
skipped. Handling of chunks bigger than 7Fh looks quite weird/bugged.<BR>
<BR>
<B>Key.Bit0</B><BR>
The DSi BIOS contains two different RSA core modes (either one of them is used,
depending on whether BIT0 of the FIRST BYTE of the "key" is set or cleared).
The purpose &amp; difference between those two modes is unknown. Also, dunno if
that BIT0 thing is something common in the RSA world?<BR>
<BR>
<B>DSi Public RSA Keys (public keys for decryption/verification)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ARM9BIOS:FFFF87F4h (ROM Key #0)  System Menu (Launcher)
  ARM9BIOS:FFFF8874h (ROM Key #1)  System Fun Tools and Wifi Firmware
  ARM9BIOS:FFFF88F4h (ROM Key #2)  System Base Tools (Settings, Shop)
  ARM9BIOS:FFFF8974h (ROM Key #3)  DSiWare and DSi ROM Cartridges
  ARM9BIOS:FFFF89F4h (ROM Key #4)  Unknown (probably a RSA key)
  ARM9BIOS:FFFF8A74h (ROM Key #5)  Unknown (probably a RSA key)
  ARM9BIOS:FFFF8AF4h (ROM Key #6)  Unknown (probably a RSA key)
  ARM9BIOS:FFFF8B74h (ROM Key #7)  Unknown (probably a RSA key)
  ARM9BIOS:FFFF9920h (ROM Stuff)   Unknown (maybe not a RSA key)
  Launcher (9F,80,BC,5F,...)       Version Data and TWLFontTable.dat
  Launcher (9E,C1,CC,C0,...)       Unknown (probably a RSA key)
  TWL_FIRM (F1,F5,1A,FF,...)       eMMC Boot Info
  Unknown                          DS Cart Whitelist (probably has RSA)
  Unknown                          HWINFO_S.dat (probably has RSA)
  Unknown                          HWID.sgn (is that RSA, too?)
  Unknown                          Newer NDS ROM Cartridges (have RSA, too?)
  Unknown                          ...?
</TD></TR></TABLE>
<BR>
<B>DSi Private RSA Keys (keys for encryption/signing)</B><BR>
Nintendo's private keys should be known only by Nintendo.<BR>
The console might have a few "own" private keys (eg. for signing &amp; sending
data to Nintendo; though unknown if there are any DSi programs with RSA
encryption support).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="biosramusage"></A>&nbsp;
  BIOS RAM Usage
</FONT></TD></TR></TABLE><BR>
Below contains info about RAM contents at cartridge boot time (as initialized
by the BIOS/Firmware), plus info about RAM locations used by IRQ handlers and
SWI functions.<BR>
<BR>
<B>GBA BIOS RAM Usage</B><BR>
Below memory at 3007Fxxh is often accessed directly, or via mirrors at
3FFFFxxh.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  3000000h 7F00h User Memory and User Stack              (sp_usr=3007F00h)
  3007F00h A0h   Default Interrupt Stack (6 words/time)  (sp_irq=3007FA0h)
  3007FA0h 40h   Default Supervisor Stack (4 words/time) (sp_svc=3007FE0h)
  3007FE0h 10h   Debug Exception Stack (4 words/time)    (sp_xxx=3007FF0h)
  3007FF0h 4     Pointer to Sound Buffer (for SWI Sound functions)
  3007FF4h 3     Reserved (unused)
  3007FF7h 1     Reserved (intro/nintendo logo related)
  3007FF8h 2     IRQ IF Check Flags (for SWI IntrWait/VBlankIntrWait functions)
  3007FFAh 1     Soft Reset Re-entry Flag (for SWI SoftReset function)
  3007FFBh 1     Reserved (intro/multiboot slave related)
  3007FFCh 4     Pointer to user IRQ handler (to 32bit ARM code)
</TD></TR></TABLE>
<BR>
<B>NDS BIOS RAM Usage</B><BR>
Below memory at 27FFxxxh is mirrored to 23FFxxxh (on retail consoles with 4MB
RAM), however, it should be accessed via address 27FFxxxh (for compatibility
with debug consoles with 8MB RAM). Accessing it via mirrors at 2FFFxxxh is also
valid (this is done by DSi enhanced games; even when running in non-DSi mode;
this allows DSi games to use the same memory addresses in NDS and DSi mode).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  2000000h ...   ARM7 and ARM9 bootcode can be loaded here (2000000h..23BFDFFh)
  2400000h ...   Debug bootcode can be loaded here (2400000h..27BFDFFh)
  23FEE00h 168h  Fragments of NDS9 firmware boot code
  27FF800h 4     NDS Gamecart Chip ID 1
  27FF804h 4     NDS Gamecart Chip ID 2
  27FF808h 2     NDS Cart Header CRC (verified)            ;hdr[15Eh]
  27FF80Ah 2     NDS Cart Secure Area CRC (not verified ?) ;hdr[06Ch]
  27FF80Ch 2     NDS Cart Missing/Bad CRC (0=Okay, 1=Missing/Bad)
  27FF80Eh 2     NDS Cart Secure Area Bad (0=Okay, 1=Bad)
  27FF810h 2     Boot handler task number (usually FFFFh at cart boot time)
  27FF812h 2     Secure disable (0=Normal, 1=Disable; Cart[078h]=BIOS[1088h])
  27FF814h 2     SIO Debug Connection Exists (0=No, 1=Yes)
  27FF816h 2     RTC Status?                 (0=Okay, 1=Bad)
  27FF818h 1     Random RTC    ;random LSB from SIO debug detect handshake
  27FF819h 37h   Zerofilled by firmware
  27FF850h 2     NDS7 BIOS CRC (5835h)
  27FF860h 4     Somewhat copy of Cart[038h], nds7 ram addr (?)
  27FF864h 4     Wifi FLASH User Settings Bad (0=Okay, 1=Bad)
  27FF868h 4     Wifi FLASH User Settings FLASH Address (fmw[20h]*8)
                   maybe recommended to use above RAM cell instead FLASH entry?
  27FF86Ch 4     Whatever (seems to be zero at cart boot time)
  27FF870h 4     Whatever (seems to be zero at cart boot time)
  27FF874h 2     Wifi FLASH firmware part5 crc16 (359Ah) (fmw[026h])
  27FF876h 2     Wifi FLASH firmware part3/part4 crc16 (fmw[004h] or ZERO)
                   Above is usually ZERO at cart boot (set to fmw[004h] only
                   when running pictochat, or maybe also when changing user
                   settings)
  27FF878h 08h   Not used
  27FF880h 4     Message from NDS9 to NDS7  (=7 at cart boot time)
  27FF884h 4     NDS7 Boot Task (also checked by NDS9) (=6 at cart boot time)
  27FF888h ..    Whatever (seems to be zero at cart boot time)
  27FF890h 4     Somewhat boot flags (somewhat B0002A22h)
                   bit10 part3/part4 loaded/decoded (bit3 set if bad crc)
                   bit28 part5 loaded/decoded with good crc
  27FF894h 36Ch  Not used (zero)
  27FFC00h 4     NDS Gamecart Chip ID 1   (copy of 27FF800h)
  27FFC04h 4     NDS Gamecart Chip ID 2   (copy of 27FF804h)
  27FFC08h 2     NDS Cart Header CRC      (copy of 27FF808h)
  27FFC0Ah 2     NDS Cart Secure Area CRC (copy of 27FF80Ah)
  27FFC0Ch 2     NDS Cart Missing/Bad CRC (copy of 27FF80Ch)
  27FFC0Eh 2     NDS Cart Secure Area Bad (copy of 27FF80Eh)
  27FFC10h 2     NDS7 BIOS CRC (5835h)    (copy of &lt;27FF850h&gt;)
  27FFC12h 2     Secure Disable           (copy of 27FF812h)
  27FFC14h 2     SIO Debug Exist          (copy of 27FF814h)
  27FFC16h 1     RTC Status?              (&lt;8bit&gt; copy of 27FF816h)
  27FFC17h 1     Random 8bit              (copy of &lt;27FF818h&gt;)
  27FFC18h 18h   Not used (zero)
  27FFC30h 2     GBA Cartridge Header[BEh], Reserved
  27FFC32h 3     GBA Cartridge Header[B5h..B7h], Reserved
  27FFC35h 1     Whatever flags ?
  27FFC36h 2     GBA Cartridge Header[B0h], Maker Code
  27FFC38h 4     GBA Cartridge Header[ACh], Gamecode
  27FFC3Ch 4     Frame Counter (eg. 00000332h in no$gba with original firmware)
  27FFC40h 2     Boot Indicator (0001h=normal; required for some NDS games)
  27FFC42h 3Eh   Not used (zero)
  27FFC80h 70h   Wifi FLASH User Settings (fmw[newest_user_settings])
  27FFCF0h 10h   Not used (zero)
  27FFDxxh ..    NDS9 Debug Exception Stack (stacktop=27FFD9Ch)
  27FFD9Ch 4     NDS9 Debug Exception Vector (0=None)
  27FFDA0h ..    ...
  27FFE00h 170h  NDS Cart Header at 27FFE00h+0..16Fh
  27FFF70h ..    Not used (zerofilled at cart boot time)
  27FFFF8h 2     NDS9 Scratch addr for SWI IsDebugger check
  27FFFFAh 2     NDS7 Scratch addr for SWI IsDebugger check
  27FFFFCh ..    ...
  27FFFFEh 2     Main Memory Control (on-chip power-down I/O port)
  DTCM+3FF8h 4   NDS9 IRQ IF Check Bits (hardcoded RAM address)
  DTCM+3FFCh 4   NDS9 IRQ Handler (hardcoded RAM address)
  37F8000h FE00h ARM7 bootcode can be loaded here (37F8000h..3807DFFh)
  380F700h 1D4h  Fragments of NDS7 firmware boot code
  380F980h 4     Unknown/garbage (set to FBDD37BBh, purpose unknown)
                   NOTE: Cooking Coach is doing similar crap at 37FCF1Ch ?!?!
  380FFC0h 4     DSi7 IRQ IF2 Check Bits (hardcoded RAM address) (DSi only)
  380FFDCh ..    NDS7 Debug Stacktop / Debug Vector (0=None)
  380FFF8h 4     NDS7 IRQ IF Check Bits (hardcoded RAM address)
  380FFFCh 4     NDS7 IRQ Handler (hardcoded RAM address)
  ---
  summary of nds memory used at cartridge boot time:
  (all other memory zero-filled unless containing cartridge data)
  37F8000h..3807E00h  ;cartridge area (nds7 only)
  2000000h..23BFE00h  ;cartridge area (nds9 and nds7)
  2400000h..27BFE00h  ;cartridge area (debug ver)
  23FEE00h..23FEF68h  ;fragments of NDS9 firmware boot code
  27FF800h..27FF85Fh  ;various values (from BIOS boot code)
  27FF860h..27FF893h  ;various values (from Firmware boot code)
  27FFC00h..27FFC41h  ;various values (from Firmware boot code)
  27FFC80h..27FFCE6h  ;firmware user settings
  27FFE00h..27FFF6Fh  ;cart header
  380F700h..380F8D4h  ;fragments of NDS7 firmware boot code
  380F980h            ;set to FBDD37BBh
  ---
  register settings at cartridge boot time:
  nds9 r0..r11     = zero
  nds9 r12,r14,r15 = entrypoint
  nds9 r13         = 3002F7Ch (!)
  nds9 r13_irq     = 3003F80h
  nds9 r13_svc     = 3003FC0h
  nds9 r14/spsr_irq= zero
  nds9 r14/spsr_svc= zero
  ---
  nds7 r0..r11     = zero
  nds7 r12,r14,r15 = entrypoint
  nds7 r13         = 380FD80h
  nds7 r13_irq     = 380FF80h
  nds7 r13_svc     = 380FFC0h
  nds7 r14/spsr_irq= zero
  nds7 r14/spsr_svc= zero
  ---
  Observe that SWI SoftReset applies different stack pointers:
  Host  sp_svc    sp_irq    sp_sys    zerofilled area       return address
  NDS7  380FFDCh  380FFB0h  380FF00h  [380FE00h..380FFFFh]  Addr[27FFE34h]
  NDS9  0803FC0h  0803FA0h  0803EC0h  [DTCM+3E00h..3FFFh]   Addr[27FFE24h]
</TD></TR></TABLE>
<BR>
<B>DSi BIOS RAM</B><BR>
Not too much known for sure (because DSi exploits may change RAM before
allowing to execute custom diagnostics tools, and decrypting/emulating DSi
firmware isn't yet possible).<BR>
Parts of memory are probably same as on NDS (but moved from 27FFxxxh to
2FFFxxxh). Some additional DSi specific memory areas:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  2000400h 128h  System Settings from TWLCFGn.dat file (bytes 088h..1AFh)
  2FF80xxh
  2FF82xxh
  2FF83xxh
  2FF89xxh
  2FF8Axxh
  2FF8Bxxh
  2FF8Cxxh
  2FF8Dxxh       ... Wifi MAC address, channel mask, etc.
  2FF8Fxxh
  2FF90xxh
  2FF91xxh
  2FF9208h       FBDD37BBh (that odd "garbage" value occurs also on NDS)
  2FFA1xxh
  2FFA2xxh
  2FFA5xxh
  2FFA6xxh
  2FFA680h 12    02FD4D80h,00000000h,00001980h
  2FFA68Ch ..    Zerofilled
  2FFC000h 1000h DSi Full Cart Header (same as at 2FFE000h)
  2FFD000h 7B0h  Zerofilled
  2FFD7B0h 12    Unknown (30,30,30,30,30,30,30,34,00,50,00,00)
  2FFD7BCh 15    eMMC 120bit CID (dd,ss,ss,ss,ss,03,4D,30,30,46,50,41,00,00,15)
  2FFD7CBh 1     Zero (maybe padding for above)
  2FFD7CCh 15    eMMC 120bit CSD (40,40,96,E9,7F,DB,F6,DF,01,59,0F,2A,01,26,90)
  2FFD7DBh 1     Zero (maybe padding for above)
  2FFD7DCh 16    ? (80 80 FF 80 00 04 00 00 00 00 00 00 01 00 01 00)
  2FFD7ECh 16    ? (00 00 00 00 00 00 00 00 00 09 00 00 00 01 E0 40)
  2FFD7FCh 4     ? (00 00 01 00)
  2FFD800h 1     Unknown 05h (maybe number of IDs at 2FFD850h?)
  2FFD801h 2Fh   Zerofilled
  2FFD830h 1     Unknown 1Fh
  2FFD831h 1Fh   Zerofilled
  2FFD850h 5x8   Five Title IDs (ROM Cart, and HNBP, HNDA, HNEA, HNGP) why?
  2FFD878h 788h  Zerofilled
  2FFE000h 1000h DSi Full Cart Header (additionally to short headers)
  2FFF000h 0Ch   Zerofilled
  2FFF00Ch 4     ? 0000007Fh
  2FFF010h 4     ? 550E25B8h
  2FFF014h 4     ? 02FF4000h
  2FFF018h A68h  Zerofilled
  2FFFA80h 160h  Short Cart header (same as at 2FFFE00h)
  2FFFBE0h 20h   Zerofilled
</TD></TR></TABLE>
Below resembles NDS area at 27FFC00h (with added/removed stuff)...<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  2FFFC00h 4     NDS Gamecart Chip ID
  2FFFC04h 20h   Zerofilled
  2FFFC24h 5     ? (04 00 73 01 03)
  2FFFC29h 7     Zerofilled
  2FFFC30h 12    GBA Cartridge Header (FF FF FF FF FF 00 FF FF FF FF FF FF)
  2FFFC3Ch 4     Frame Counter maybe? (eg. 1F 01 00 00 in cooking coach)
  2FFFC40h 2     Boot Indicator (0001h=normal; required for some NDS games)
  2FFFC42h 3Eh   Not used (zero)
  2FFFC80h 70h   Wifi FLASH User Settings (fmw[newest_user_settings])
  2FFFCF0h 4     ?           (3D 00 01 6E)
  2FFFCF4h 6     MAC Address (00 23 CC xx xx xx) (fmw[036h])
  2FFFCFAh 6     ?           (41 10 00 00 00 00)
  2FFFD00h 68h   Zerofilled
  2FFFD68h 9     ? (3E 00 00 00 00 00 00 00 02)       ;from HWINFO_S.dat
  2FFFD71h 12    Serial/Barcode (ASCII, 11-12 characters; see console sticker)
  2FFFD7Dh 3     ? (00 00 3C)                         ;from HWINFO_S.dat
  2FFFD80h 1Ch   Zerofilled
  2FFFD9Ch 4     020D3E64h
  2FFFDA0h 4     02F80000h
  2FFFDA4h 4     02FFA674h
  2FFFDA8h 4     00000000h zero
  2FFFDACh 4     01FF86E0h itcm?
  2FFFDB0h 4     027C00C0h
  2FFFDB4h 4     02FFF000h
  2FFFDB8h 4     03040000h wram?
  2FFFDBCh 4     03800000h wram?
  2FFFDC0h 4     0380C3B4h wram?
  2FFFDC4h 4     02F80000h
  2FFFDC8h 4     02FFC000h ptr to DSi Full Cart Header
  2FFFDCCh 4     00000000h zero
  2FFFDD0h 4     02000000h ram bottom?
  2FFFDD4h 4     027C0780h
  2FFFDD8h 4     02FFF680h
  2FFFDDCh 4     03040000h wram?
  2FFFDE0h 4     03800000h wram?
  2FFFDE4h 4     0380F780h wram?
  2FFFDE8h 4     RTC Date at Boot (BCD) (yy,mm,dd,XX) (XX=maybe day-of-week?)
  2FFFDECh 4     RTC Time at Boot (BCD) (hh,ss,mm,0) (hh.bit6=maybe PM or 24h?)
  2FFFDF0h 4     13FBFB06h ?
  2FFFDF4h 4     0000F0C4h ?
  2FFFDF8h 4     01800000h tcm or rather sth else?
  2FFFDFCh 4     Pointer to TWLCFGn.dat (usually 2000400h) (or 0=2000400h)
  2FFFE00h 160h  Short Cart header (unlike NDS, only 160h, not 170h)
  2FFFF60h A0h   Zerofilled
  xxxxxxxh ?     ARM7i and ARM9 bootcode can be loaded WHERE and WHERE?
  cart_header[1D4h] base address where various structures and parameters...?
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="biosdumping"></A>&nbsp;
  BIOS Dumping
</FONT></TD></TR></TABLE><BR>
<B>BIOSes</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  GBA BIOS 16K  (fully dumpable)
  NDS7 BIOS 16K (fully dumpable)
  NDS9 BIOS 4K  (fully dumpable)
  DSi7 BIOS 64K (about 41K dumpable)
  DSi9 BIOS 64K (about 41K dumpable)
</TD></TR></TABLE>
<BR>
<B>GBA BIOS</B><BR>
Contains SWI Functions and Bootcode (for starting cartridges, or booting via
Serial Port). The GBA BIOS can be read only by opcodes executed in BIOS area,
for example, via the MidiKey2Freq function (most other SWI Functions (like
CpuSet) are refusing source addresses within BIOS area).<BR>
<BR>
<B>NDS BIOSes</B><BR>
Contains SWI Functions and Bootcode (for booting from SPI Bus Firmware FLASH
memory). The NDS9 BIOS can be dumped without restrictions (eg. via CpuSet, or
via LDR opcodes in RAM). The NDS7 BIOS has same restrictions as GBA, ie.
reading works only by BIOS opcodes, and not by functions like CpuSet. The
GetCRC16 functions does work though (at least for memory at 1204h..3FFFh). As
an additional obstacle, memory at 0000h..1203h can be dumped only by opcodes
within 0000h..1203h (that memory does mainly contain data, but some of the data
values can serve as THUMB LDR opcodes). For details see:<BR>
<A HREF="#dsmemorycontrolbios">DS Memory Control - BIOS</A><BR>
Note: DSi consoles are containing a copy of the NDS BIOSes, but with BIOSPROT
set to 0020h (even when running in NDS mode), so the first 20h bytes of the
DSi's NDS7 BIOS aren't dumpable (except via tracing, see below), that 20h bytes
should be just same as on original NDS7 though.<BR>
<BR>
<B>DSi BIOSes</B><BR>
Contains SWI Functions (in lower 32K halves) and Bootcode (for booting from
eMMC memory, in upper 32K halves). The upper 32K of the DSi9 and DSi7 BIOSes
are locked at some point during booting, and there's no known way to dump them
yet. However, portions of that memory are relocated to RAM/TCM before locking,
and that relocated copies can be dumped (at least via Main Memory hacks, ie.
with complex external hardware soldered to the mainboard):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ROM:FFFF87F4h / TCM:1FFC400h (400h)  (C3 02 93 DE ..) Whatever, 8x80h RSA?
  ROM:FFFF9920h / TCM:1FFC800h (80h)   (30 33 26 D5 ..) Whatever
  ROM:FFFF99A0h / TCM:1FFC894h (1048h) (99 D5 20 5F ..) Blowfish/NDS-mode
  ROM:FFFFA9E8h / TCM:1FFD8DCh (1048h) (D8 18 FA BF ..) Blowfish/unused?
  ROM:00008188h / RAM:3FFC400h (200h)  (CA 13 31 79 ..) Whatever, 32x10h AES?
  ROM:0000B5D8h / RAM:3FFC600h (40h)   (AF 1B F5 16 ..) Whatever, "common key"?
  ROM:0000C6D0h / RAM:3FFC654h (1048h) (59 AA 56 8E ..) Blowfish/DSi-mode
  ROM:0000D718h / RAM:3FFD69Ch (1048h) (54 86 13 3B ..) Blowfish/unused?
</TD></TR></TABLE>
The lower 32K of DSi9 doesn't have any restricions. The lower 32K of DSi7 has
similar restrictions as NDS7, but with BIOSPROT set to 0020h (instead of
1204h), this is making it more easy to dump memory at 0020h..7FFFh (eg. via
GetCRC16), but makes it impossible to dump the exception vectors at
0000h..001Fh, however, they can be deduced by tracing (with timer IRQs):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ROM:00000000h  EA000006  b 20h   ;dsi7_reset_vector
  ROM:00000004h  EA000006  b 24h   ;dsi7_undef_handler
  ROM:00000008h  EA00001F  b 8Ch   ;dsi7_swi_handler
  ROM:0000000Ch  EA000004  b 24h   ;dsi7_prefetch_abort_handler
  ROM:00000010h  EA000003  b 24h   ;dsi7_data_abort_handler
  ROM:00000014h  EAFFFFFE  b 14h   ;reserved_vector
  ROM:00000018h  EA000013  b 6Ch   ;dsi7_irq_handler
  ROM:0000001Ch  EA000000  b 24h   ;dsi7_fiq_handler
</TD></TR></TABLE>
Aside from branch opcodes, above could theoretically contain ALU opcodes that
modify R15 (but that would be very unlikely, and would make no difference).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="externalconnectors"></A>&nbsp;
  External Connectors
</FONT></TD></TR></TABLE><BR>
<B>External Connectors</B><BR>
<A HREF="#auxgbagamepakbus">AUX GBA Game Pak Bus</A><BR>
<A HREF="#auxdsgamecardslot">AUX DS Game Card Slot</A><BR>
<A HREF="#auxlinkport">AUX Link Port</A><BR>
<A HREF="#auxsoundheadphonesocketandbatterypowersupply">AUX Sound/Headphone Socket and Battery/Power Supply</A><BR>
<A HREF="#auxdsisdmmcpinouts">AUX DSi SD/MMC Pin-Outs</A><BR>
<BR>
<B>Getting access to Internal Pins</B><BR>
<A HREF="#auxopeningthegba">AUX Opening the GBA</A><BR>
<A HREF="#auxmainboard">AUX Mainboard</A><BR>
<A HREF="#auxdsicomponentlists">AUX DSi Component Lists</A><BR>
<A HREF="#auxdsiinternalconnectors">AUX DSi Internal Connectors</A><BR>
<A HREF="#auxdsichipsetpinouts">AUX DSi Chipset Pinouts</A><BR>
<BR>
<B>More Internal Stuff</B><BR>
<A HREF="#pinoutscpusignalsummary">Pinouts - CPU - Signal Summary</A><BR>
<A HREF="#pinoutscpupinouts">Pinouts - CPU - Pinouts</A><BR>
<A HREF="#pinoutsaudioamplifiers">Pinouts - Audio Amplifiers</A><BR>
<A HREF="#pinoutslcdcables">Pinouts - LCD Cables</A><BR>
<A HREF="#pinoutspowerswitchesdcdcconvertersresetgenerators">Pinouts - Power Switches, DC/DC Converters, Reset Generators</A><BR>
<A HREF="#pinoutswifi">Pinouts - Wifi</A><BR>
<A HREF="#pinoutsvarious">Pinouts - Various</A><BR>
<BR>
<B>Xboo Multiboot Cable</B><BR>
<A HREF="#auxxboopctogbamultibootcable">AUX Xboo PC-to-GBA Multiboot Cable</A><BR>
<A HREF="#auxxbooflashcardupload">AUX Xboo Flashcard Upload</A><BR>
<A HREF="#auxxbooburstbootbackdoor">AUX Xboo Burst Boot Backdoor</A><BR>
<A HREF="#dsxboo">DS Xboo</A><BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="auxgbagamepakbus"></A>&nbsp;
  AUX GBA Game Pak Bus
</FONT></TD></TR></TABLE><BR>
<B>Game Pak Bus - 32pin cartridge slot</B><BR>
The cartridge bus may be used for both CGB and GBA game paks. In GBA mode, it
is used as follows:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 Pin    Name    Dir  Expl.
 1      VDD     O    Power Supply 3.3V DC
 2      PHI     O    System Clock (selectable none, 4.19MHz, 8.38MHz, 16.78MHz)
 3      /WR     O    Write Select    ;\latched address to be incremented on
 4      /RD     O    Read Select     ;/rising edges of /RD or /WR signals
 5      /CS     O    ROM Chip Select ;-A0..A15 to be latched on falling edge
 6-21   AD0-15  I/O  lower 16bit Address    and/or  16bit ROM-data (see below)
 22-29  A16-23  I/O  upper 8bit ROM-Address   or    8bit SRAM-data (see below)
 30     /CS2    O    SRAM Chip Select
 31     /REQ    I    Interrupt request (/IREQ) or DMA request (/DREQ)
 32     GND     O    Ground 0V
</TD></TR></TABLE>
When accessing game pak SRAM, a 16bit address is output through AD0-AD15, then
8bit of data are transferred through A16-A23.<BR>
When accessing game pak ROM, a 24bit address is output through AD0-AD15 and
A16-A23, then 16bit of data are transferred through AD0-AD15.<BR>
The 24bit address is formed from the actual 25bit memory address (byte-steps),
divided by two (halfword-steps).<BR>
Pin Pitch is 1.5mm.<BR>
<BR>
<B>8bit-Gamepak-Switch (GBA, GBA SP only) (not DS)</B><BR>
A small switch is located inside of the cartridge slot, the switch is pushed
down when an 8bit cartridge is inserted, it is released when a GBA cartridge is
inserted (or if no cartridge is inserted).<BR>
The switch mechanically controls whether VDD3 or VDD5 are output at VDD35; ie.
in GBA mode 3V power supply/signals are used for the cartridge slot and link
port, while in 8bit mode 5V are used.<BR>
The switch additionally drags IN35 to 3V when an 8bit cart is inserted, the
current state of IN35 can be determined in GBA mode via Port 4000204h
(WAITCNT), if the switch is pushed, then CGB mode can be activated via Port
4000000h (DISPCNT.3), this bit can be set ONLY by opcodes in BIOS region (eg.
via CpuSet SWI function).<BR>
In 8bit mode, the cartridge bus works much like for GBA SRAM, however, the 8bit
/CS signal is expected at Pin 5, while GBA SRAM /CS2 at Pin 30 is interpreted
as /RESET signal by the 8bit MBC chip (if any). In practice, this appears to
result in 00h being received as data when attempting to read-out 8bit
cartridges from inside of GBA mode.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="auxdsgamecardslot"></A>&nbsp;
  AUX DS Game Card Slot
</FONT></TD></TR></TABLE><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Pin    Dir  Name  Connection in cartridge
  1   &gt;  -    GND   (ROM all unused Pins, EEPROM Pin 4 = VSS)
  2      Out  CLK   (4MB/s, ROM Pin 5, EEPROM Pin 6 = CLK)
  3   N  -    ?     (ROM Pin 17) (Seems to be not connected in console)
  4   i  Out  /CS1  (ROM Pin 44) ROM Chipselect
  5   n  Out  /RES  (ROM Pin 42) Reset, switches ROM to unencrypted mode
  6   t  Out  /CS2  (EPROM Pin 1) EEPROM Chipselect
  7   e  In   IRQ   (GND)
  8   n  -    3.3V  (ROM Pins 2, 23, EEPROM Pins 3,7,8 = /W,/HOLD,VCC)
  9   d  I/O  D0    (ROM Pin 18)
  10  o  I/O  D1    (ROM Pin 19)
  11     I/O  D2    (ROM Pin 20)
  12  C  I/O  D3    (ROM Pin 21)
  13  0  I/O  D4    (ROM Pin 24)
  14  1  I/O  D5    (ROM Pin 25)
  15  -  I/O  D6    (ROM Pin 26, EEPROM Pin 2 = Q = Data EEPROM to NDS)
  16  0  I/O  D7    (ROM Pin 27, EEPROM Pin 5 = D = Data NDS to EEPROM)
  17  1  -    GND   (ROM all unused Pins, EEPROM Pin 4 = VSS)
</TD></TR></TABLE>
<BR>
Chipselect High-to-Low transitions are invoking commands, which are transmitted
through data lines during next following eight CLK pulses, after the command
transmission, further CLK pulses are used to transfer data, the data transfer
ends at chipselect Low-to-High transition.<BR>
Data should be stable during CLK=LOW period throughout CLK rising edge.<BR>
Note: Supply Pins (1,8,17) are slightly longer than other pins. Pin pitch is
1.5mm.<BR>
<BR>
The DS does also have a 32pin cartridge slot, that slot is used to run GBA
carts in GBA mode, it can be also used as expansion port in DS mode.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="auxlinkport"></A>&nbsp;
  AUX Link Port
</FONT></TD></TR></TABLE><BR>
<B>Serial Link Port Pin-Out (GBA:"EXT" - GBA SP:"EXT.1")</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Pin  Name  Cable
  1    VDD35 N/A       GBA Socket     GBA Plug   Old "8bit" Plug
  2    SO    Red       ___________    _________    ___________
  3    SI    Orange   |  2  4  6  |  / 2  4  6 \  |  2  4  6  |
  4    SD    Brown     \_1_ 3 _5_/   \_1_ 3 _5_/   \_1__3__5_/
  5    SC    Green         '-'           '-'
  6    GND   Blue      Socket Outside View / Plug Inside View
  Shield     Shield
</TD></TR></TABLE>
Note: The pin numbers and names are printed on the GBA mainboard, colors as
used in Nintendo's AGB-005 and older 8bit cables.<BR>
<BR>
<B>Serial Link/Power Supply Port (GBA-Micro: "EXT.")</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1  In  DC (Supply 5.2VDC)  ___________________
  2  Out V3 (SIO 3.3VDC)    |  1 2 3 4 5 6 7 8  |
  3  I/O SO (SIO RCNT.3)    | ================= |
  4  I/O SI (SIO RCNT.2)     \_________________/
  5  I/O SD (SIO RCNT.1)
  6  I/O SC (SIO RCNT.0)
  7  OUT DG (SIO GROUND)
  8  In  DG (Supply GROUND)
  -  -   -  (Shield not connected)
</TD></TR></TABLE>
<BR>
<B>Cable Diagrams (Left: GBA Cable, Right: 8bit Gameboy Cable)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Big Plug  Middle Socket  Small Plug    Plug 1         Plug 2
   SI _________________     ____ SI       SI ______  ______SI
   SO ____________SO   |__ | ___ SO       SO ______&gt;&lt;______SO
   GND____________GND______|____GND       GND_____________GND
   SD ____________SD____________ SD       SD               SD
   SC ____________SC____________ SC       SC _____________ SC
   Shield_______Shield_______Shield       Shield_______Shield
</TD></TR></TABLE>
<BR>
<B>Normal Connection</B><BR>
Just connect the plugs to the two GBAs and leave the Middle Socket
disconnected, in this mode both GBAs may behave as master or slave, regardless
of whether using big or small plugs.<BR>
The GBA is (NOT ???) able to communicate in Normal mode with MultiPlay cables
which do not have crossed SI/SO lines.<BR>
<BR>
<B>Multi-Play Connection</B><BR>
Connect two GBAs as normal, for each further GBAs connect an additional cable
to the Middle socket of the first (or further) cable(s), up to four GBAs may be
connected by using up to three cables.<BR>
The GBA which is connected to a Small Plug is master, the slaves are all
connected to Large Plugs. (Only small plugs fit into the Middle Socket, so it's
not possible to mess up something here).<BR>
<BR>
<B>Multi-Boot Connection</B><BR>
MultiBoot (SingleGamepak) is typically using Multi-Play communication, in this
case it is important that the Small plug is connected to the master/sender (ie.
to the GBA that contains the cartridge).<BR>
<BR>
<B>Non-GBA Mode Connection</B><BR>
First of all, it is not possible to link between 32bit GBA games and 8bit
games, parts because of different cable protocol, and parts because of
different signal voltages.<BR>
However, when a 8bit cartridge is inserted (the GBA is switched into 8bit
compatibility mode) it may be connected to other 8bit games (monochrome
gameboys, CGBs, or to other GBAs which are in 8bit mode also, but not to GBAs
in 32bit mode).<BR>
When using 8bit link mode, an 8bit link cable must be used. The GBA link cables
won't work, see below modification though.<BR>
<BR>
<B>Using a GBA 32bit cable for 8bit communication</B><BR>
Open the middle socket, and disconnect Small Plugs SI from GND, and connect SI
to Large Plugs SO instead. You may also want to install a switch that allows to
switch between SO and GND, the GND signal should be required for MultiPlay
communication only though.<BR>
Also, cut off the plastic ledge from the plugs so that they fit into 8bit
gameboy sockets.<BR>
<BR>
<B>Using a GBA 8bit cable for 32bit communication</B><BR>
The cable should theoretically work as is, as the grounded SI would be required
for MultiPlay communication only. However, software that uses SD for
Slave-Ready detection won't work unless when adding a SD-to-SD connection (the
8bit plugs probably do not even contain SD pins though).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="auxsoundheadphonesocketandbatterypowersupply"></A>&nbsp;
  AUX Sound/Headphone Socket and Battery/Power Supply
</FONT></TD></TR></TABLE><BR>
<B>GBA, GBA-Micro, NDS, and NDS-Lite: Stereo Sound Connector (3.5mm, female)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Tip     Audio Left         ___ ___ _____+-----------+
  Middle  Audio Right       (___|___|_____|           |
  Base    Ground              L   R   GND +-----------+
</TD></TR></TABLE>
The NDS socket doesn't fully match regular 3.5mm plugs, one needs to cut-off a
portion of the DS case to be able to fully insert the plug, which still
requires a lot of pressure, furthermore, when fully inserted, left/right become
shortcut to mono, so one needs to pull-back the plug a bit to gain stereo
output.<BR>
<BR>
<B>GBA SP and NDS - Power/Headphone Socket (EXT.2)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Pin SP   NDS  Expl.
  1   P31  SL   Audio LOUT                          _____________
  2   P32  VIN  Supply Input (DC 5.2V)           SW| 5   ___   1 |SL
  3   P33  SR   Audio ROUT                         | ----   ---- |
  4   P34  SG   Audio GND (via 100uF to GND)       |_6__4   3__2_|
  5   P35  SW   Audio Speaker Disable (GND=Dis)    GND SG\_/SR VIN
  6        GND  Supply GND
  Shield        GND
</TD></TR></TABLE>
External power input is used to charge the built-in battery, it cannot be used
to run the SP without that battery.<BR>
<BR>
<B>NDS-Lite - Power Socket</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Pin  Expl.                                          __________
  1    Supply Input (DC 5.2V)                        /  ======  \
  2    Supply GND                                GND |___2__1___| VIN
</TD></TR></TABLE>
<BR>
<B>GBA-Micro - Power Socket</B><BR>
Uses an 8pin socket (which combines SIO and Power), for pin-outs, see<BR>
<A HREF="#auxlinkport">AUX Link Port</A><BR>
<BR>
<B>External Power Supply</B><BR>
GBA: DC 3.3V (no separate power socket, requires 2xAA-battery-shaped adapter)<BR>
GBA-SP/NDS: DC 5.2V (or DC 5V) (special connector on power/headphone socket)<BR>
NDS-Lite: DC 5.2V (or DC 5V) (another special connector on power socket)<BR>
<BR>
<B>Internal Battery Supply</B><BR>
GBA: 2xAA (3V)<BR>
GBA-SP: Li-ion 3.7V, 600mAh (built-in, recharge-able)<BR>
GBA-Micro: Li-ion 3.8V, 460mAh (built-in, recharge-able)<BR>
NDS: Li-ion 3.7V, 850mAh (built-in, recharge-able)<BR>
NDS-Lite: Li-ion 3.7V, 1000mAh (built-in, recharge-able)<BR>
<BR>
<B>Using PC +5V DC as Power Supply</B><BR>
Developers whom are using a PC for GBA programming will probably want to use
the PC power supply (gained from disk drive power supply cable) for the GBA as
well rather than dealing with batteries or external power supplies.<BR>
GBA: To lower the voltage to approximately 3 Volts use two diodes, type 1N 4004
or similar, the ring printed onto the diodes points towards the GBA side,
connected as such:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  PC +5V (red)   --------|&gt;|---|&gt;|--------  GBA BT+
  PC GND (black) -------------------------  GBA BT-
</TD></TR></TABLE>
GBA SP, GBA Micro, NDS, and NDS-Lite: Works directly at +5V connected to EXT.2
socket (not to the internal battery pins), without any diodes.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="auxdsisdmmcpinouts"></A>&nbsp;
  AUX DSi SD/MMC Pin-Outs
</FONT></TD></TR></TABLE><BR>
<B>SD/MMC Transfer Modes</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Transfer Modes        SPI-Mode    1-bit-Bus  4-bit-Bus   SDIO
  MMC Cards             Optional    Yes        MMCplus     No
  SD Cards              Yes         Yes        Optional??  Optional
</TD></TR></TABLE>
Note: SDIO is an extension to the SD protocol, allowing to access other
non-memory-card hardware (such like cameras or network adaptors) via SD
connectors.<BR>
Note: Original MMC cards don't support 4-bit bus, but there are revisions like
MMCplus and MMCmobile (with extra pin rows) which do support 4-bit and 8bit
bus.<BR>
<BR>
<B>SD/MMC Pin-Outs</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  MMC  MMCplus SD  miniSD microSD SPI-Mode    1-bit-Bus   4-bit/8bit-Bus
  1    1       1   1      2       /CS         CardDetect  Data3
  2    2       2   2      3       DataIn      CMD/REPLY   CMD/REPLY
  3    3       3   3      --      GND         GND         GND
  4    4       4   4      4       VDD         VDD         VDD
  5    5       5   5      5       CLK         CLK         CLK
  6    6       6   6      6       GND         GND         GND
  7    7       7   7      7       DataOut     Data        Data0
  --   8       8   8      8       /IRQ (SDIO) /IRQ (SDIO) Data1 or /IRQ (SDIO)
  --   9       9   9      1       NC          NC          Data2
  --   10      --  --     --      NC          NC          Data4  ;\
  --   11      --  --     --      NC          NC          Data5  ; MMCplus
  --   12      --  --     --      NC          NC          Data6  ; 8bit
  --   13      --  --     --      NC          NC          Data7  ;/
  --   --      --  10     --      Reserved    Reserved    Reserved
  --   --      --  11     --      Reserved    Reserved    Reserved
</TD></TR></TABLE>
Moreover, the card sockets (not the cards themselves) are usually containing a
Card Detect switch, and, for SD card sockets, also a write protect switch:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  --   --      CD  CD     CD      Card Detect (senses if card is inserted)
  --   ---     WP  --     --      Write Protect (senses position of LOCK tab)
</TD></TR></TABLE>
Note that the LOCK tab on SD cards is just a small piece of plastic without any
electronics attached to it, the actual switch/sensor is located in the SD card
socket (ie. the LOCK works much like the write-protect tabs on audio tapes,
video tapes, and floppy discs).<BR>
<BR>
<B>SD/MMC Card Shapes</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
     ______________________________
    /    __ __ __ __ __ __ __      |
   /    |  |  |  |  |  |  |  |     |
  |     | 1| 2| 3| 4| 5| 6| 7|     |
  | MMC |__|__|__|__|__|__|__|     |
  |    ______________________________
  |   /    __ __ __ __ __ __ __ _    |
  |  /  __|  |  |  |  |  |  |  | |   |
  | |  |  | 1| 2| 3| 4| 5| 6| 7|8|   | MMCplus:
  | |  | 9|__|__|__|__|__|__|__| |   | pinout is same as 9pin SD cards,
  | |  |_ |_ __ __       __ __ | |   | with extra DAT4-7 on pin10-13
  | |    |  | 1| 1|     | 1| 1|  |   |
  | |MMC | 9| 0| 1|     | 2| 3| 8|   |
  | |plus|__|__|__|     |__|__|__|   |
  | |    ______________________________
  | |   /    __ __ __ __ __ __ __ _    |
  | |  /  __|  |  |  |  |  |  |  | |   |
  | | |  |  | 1| 2| 3| 4| 5| 6| 7|8|   |
  | | |  | 9|__|__|__|__|__|__|__|_|   |
  | | '. |__| SD                      .'      SD Write Protect Tab
  | |  |  _________________________   |   &lt;-- Unlock position
  | | .' |  _ _ _ _ _ _ _ _ _ _ _  |  |#  &lt;-- LOCK position
  | | |  | | | | | |1|1| | | | | | |  '.
  | | |  | |9|1|2|3|0|1|4|5|6|7|8| |   |
  |_| |  | |_|_|_|_|_|_|_|_|_|_|_| |   |
    | |  |   miniSD                 \  |
    | |  |     _________________     | |
    | |  |    | _ _ _ _ _ _ _ _ |    | |
    | |  |    || | | | | | | | ||    | |
    |_|  |    ||1|2|3|4|5|6|7|8||    | |
      |  |    ||_|_|_|_|_|_|_|_||    | |
      |  |   /                  |    | |
      |  |  |_  microSD         |    | |
      |  |    |                 |    | |
      |  |   /                  |    | |
      |  |  |                   |    | |
      |  |  |                   |    | |
      |  |_ |                   | ___| |
      |____ |___________________| _____|
</TD></TR></TABLE>
<BR>
<B>SD/MMC Signals for on-board eMMC chip on DSi Mainboard "C/TWL-CPU-01"</B><BR>
Below are the required eMMC signals. Low-end hardware may get away with using
Data0 as single data line (eg. small microprocessors with few I/O pins), but
higher quality hardware should support 4bit data mode (eg. off-the-shelve SD
card interfaces may insist on all four data lines being connected). Data3 (aka
CardDetect) might be also needed even in 1bit data mode.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
                         _______ CLK (SPI: CLK)    _______ Data3 (SPI: /CS)
                        |                         | ______ Data0 (SPI: DataOut)
                 &lt;#&gt;  &lt;#&gt;  &lt;#&gt;                    || _____ Data1
                EM14  R113 C130                   ||| ____ Data2
        .------------------------.                ||||
        |                        |          &lt;#&gt;  &lt;####&gt; #  #
        |                        |     U5   C57   RA4  C54 C55
        |  Shielding-plate       '---.  o .------------------.
        |                            |    |o                 |
        |                            |    |                  |
        |                            |    |  Samsung     834 |
        |                            |    |  KMAPF0000M-S998 |
        |  CPU              RAM      |    |                  |
        |                            |    |                  |
        |                            |    '------------------'
        '----------------------------'     R94 R54  C50 C51
             |                             &lt;#&gt; &lt;#&gt;  &lt;#&gt; &lt;#&gt;
             |                               |
             |___ shield = GND               |___ CMD/REPLY (SPI: DataIn)
</TD></TR></TABLE>
<BR>
The KMAPF0000M chip does probably NOT support SPI mode, and it does probably
support only MMC protocol (not SD protocol). That, assuming that the chip does
have similar capabilities as in KMCEN0000M datasheet (there's no KMAPF0000M
datasheet online).<BR>
<BR>
<B>Soldering Notes</B><BR>
Connect CLK/CMD to the pins on right side of R113/R94 (as shown in the
drawing). Connect Data3/0/1/2 to the LOWER pins of RA4 (unlike as shown in the
drawing, ie. NOT to the upper pins), or alternately, connect them to the four
vias below of RA4. Connect GND somewhere to shielding plate, for example.<BR>
My own setup is: A 8pin ribbon cable soldered to a spare SD-to-SDmicro adapter
(used as connector for SD/MMC slots), the ribbon cable is wired to a small
circuit board, which is soldered to the shielding of the DSi's game cartridge
slot (just for mechanical stability). Next, some fragile wires are forwarded
from the circuit board to the actual mainboard pins.<BR>
<BR>
<B>Software Notes</B><BR>
Remove the DSi wifiboard (not absolutely required, but doing so will hang the
DSi before accessing the eMMC, which ensures that the eMMC won't be accessed
simultaneously by the DSi and PC). Switch on the DSi. Connect it to SD/MMC card
reader. Under Windows, the eMMC should show up as MMC-storagedevice in Windows
Explorer (alongsides with your HDD drives), due to the encryption it isn't
possible to access the filesystem or logical partitions of the chip. However,
the physical sectors can be accessed.<BR>
For example, using HxD hex editor: Click Extras, Open Disk, and select the MMC
(in HxD it shows up under Physical Discs: as Removeable Disk). Click Edit,
Select All, Copy. Click File, New. Then Edit, Paste. And finally File, Save As
for saving an image of the whole 240MByte FLASH chip.<BR>
I've tried accessing the eMMC on two PCs, one worked, the other didn't:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Win98 with External Card reader: Windows didn't recognize the MMC chip
  Win7  with External Card reader: Okay (recognized as "unformatted" disk)
  Win7  with Internal Card reader: Okay (recognized as "unformatted" disk)
</TD></TR></TABLE>
For testing the Operating System/Card Reader side: Connect a normal SD card to
the card reader. If HxD is showing it as both Logical Disc and Physical Disc,
then you are fine. If it shows up as Logical Disc only, then your setup won't
work for accessing the eMMC chip.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="auxopeningthegba"></A>&nbsp;
  AUX Opening the GBA
</FONT></TD></TR></TABLE><BR>
Since Nintendo uses special screws with Y-shaped heads to seal the GBA (as well
as older 8bit gameboys), it's always a bit difficult to loosen these screws.<BR>
<BR>
<B>Using Screwdrivers</B><BR>
One possible method is to use a small flat screwdriver, which might work, even
though it'll most likely damage the screwdriver.<BR>
Reportedly, special Y-shaped screwdrivers for gameboys are available for sale
somewhere (probably not at your local dealer, but you might find some in the
internet or elsewhere).<BR>
<BR>
<B>Destroying the Screws</B><BR>
A more violent method is to take an electric drill, and drill-off the screw
heads, this might also slightly damage the GBA plastic chase, also take care
that the metal spoons from the destroyed screws don't produce shortcuts on the
GBA mainboard.<BR>
<BR>
<B>Using a selfmade Screwdriver</B><BR>
A possible method is to take a larger screw (with a normal I-shaped, or
X-shaped head), and to cut the screw-tip into Y-shape, you'll then end up with
an "adapter" which can be placed in the middle between a normal screwdriver and
gameboy screws.<BR>
Preferably, first cut the screw-tip into a shape like a "sharp three sided
pyramid", next cut notches into each side. Access to a grinding-machine will be
a great benefit, but you might get it working by using a normal metal-file as
well.<BR>
<BR>
<B>Opening the GBA Micro</B><BR>
- open the case with appropriate screwdriver or drilling machine or whatever<BR>
- remove the plastic front-plate (there are two snap-ins inside at ONE side)<BR>
- remove the mainboard and screen and plastic skeleton from the metal case<BR>
- remove the start/select daughter-board from the plastic skeleton<BR>
- remove the plastic skeleton (move the screen through the skeleton)<BR>
- remove the screen (lift lcd socket front-side, backlight socket rear-side)<BR>
<BR>
<B>Opening the NDS-Lite</B><BR>
- open the case with appropriate screwdriver or drilling machine or whatever<BR>
- remove the RFU unit, and the 4-pin touch-screen cable (under the RFU unit)<BR>
- remove the mainboard together with the lower screen<BR>
- remove the upper/lower screen cables (on the rear-side of the mainboard)<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="auxmainboard"></A>&nbsp;
  AUX Mainboard
</FONT></TD></TR></TABLE><BR>
Other possibly useful signals on the mainboard...<BR>
<BR>
<B>FIQ Signal</B><BR>
The FIQ (Fast Interrupt) signal (labeled FIQ on the mainboard) could be used as
external interrupt (or debugging break) signal.<BR>
Caution: By default, the FIQ input is directly shortcut to VDD35 (+3V or +5V
power supply voltage), this can be healed by scratching off the CL1 connection
located close to the FIQ pin (FIQ still appears to have an internal pull-up, so
that an external resistor is not required).<BR>
The GBA BIOS rejects FIQs if using normal ROM cartridge headers (or when no
cartridge is inserted). When using a FIQ-compatible ROM header, Fast Interrupts
can be then requested by pulling FIQ to ground, either by a push button, or by
remote controlled signals.<BR>
<BR>
<B>RESET Signal</B><BR>
The RESET signal (found on the mainboard) could be used to reset the GBA by
pulling the signal to ground for a few microseconds (or longer). The signal can
be directly used (it is not shortcut to VDD35, unlike FIQ).<BR>
Note: A reset always launches Nintendo's time-consuming and annoying boot/logo
procedure, so that it'd be recommend to avoid this "feature" when possible.<BR>
<BR>
<B>Joypad Signals</B><BR>
The 10 direction/button signals are each directly shortcut to ground when
pressed, and pulled up high otherwise (unlike 8bit gameboys which used a 2x4
keyboard matrix), it'd be thus easy to connect a remote keyboard, keypad,
joypad, or read-only 12bit parallel port.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="auxdsicomponentlists"></A>&nbsp;
  AUX DSi Component Lists
</FONT></TD></TR></TABLE><BR>
<B>DSi Mainboard "C/TWL-CPU-01" Components</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  U1   ?pin   CPU TWL       (under shielding plate)                    ;\under
  U2   ?pin   RAM 8Mx16, Fujitsu MB82DBS08164D-70L, NEC uPD46128512AF1 ;/shield
  U3  56pin   "TexasIns 72071B0" or "Mitsumi 3317A" (powerman?) (right of NAND)
  U4  48pin   "AIC3000D, TI 89K, EXDK G4" (PAIC3 codec? above headphone socket)
  U5   ?pin   Samsung KMAPF0000M-S998 (eMMC, 256Mbyte NAND FLASH)
  U6  36pin   "BPTWL, K007K, 0902KM00D" (small/square, left of cartridge slot)
  U7   4pin   "AOK, S8BXS" (ISL95810, i2c potentiometer)         ;\on PCB
  U8   4pin   "7BDS" (PCA9306, i2c voltage translator)           ;/backside
  U9  12pin   "199A, 01IU" (Seiko S-35199A01) (RTC) ;under shielding plate (A)
  U10  4pin   "6800" or "688F" Hinge Magnet Sensor (PCB backside, near A/B/X/Y)
  U11 10pin   ",\\ 908, 335A" or "2005D, 8350" (right of cartridge slot)
  U12  5pin   "L8NX" or "C7JHN" (upper-right of PCB back-side) ;text layer (B)
  U13  5pin   Backlight 1, "U01" or "KER"  ;\lower-right board edge
  U14  5pin   Backlight 2, "U01" or "KER"  ;/see text-layer (B)
  U15  4pin   ",\\ T34" (near external power input)
  U16     -   N/A
  U17  6pin   "VY" or "Z198" (in lower-right, on PCB backside)
  U18  6pin   "YJ" (above headphone socket)
  U19  5pin   "E30H6" or "L2SX" (at lower right of cartridge slot)
  Q1   6pin   external power supply related
  Q2    pin   N/A ?
  Q3   6pin   ... above battery plug
  Q4   3pin   maybe MUTE for SR  ;\old TWL-CPU-01 mainboard only
  Q5   3pin   maybe MUTE for SL  ;/(replaced by Q17?/Q18? on newer boards)
  Q6   6pin   MC1_VDD power ON (supply)
  Q7   3pin   MC1_VDD power OFF (pulldown)
  Q8    pin   N/A ?
  Q9    pin   N/A ?
  Q10   pin   N/A ?
  Q11  3pin   BLUE (LED)   ;\LEDs (note: the other LEDs, ORANGE
  Q12  3pin   YELLOW (LED) ;      and YELLOW, are driven directly)
  Q13  3pin   CAM_LED      ;/
  Q14  3pin   not installed (above powerman chip)
  Q15  3pin   not installed (above powerman chip)
  Q16  3pin   VDD-5 related, near DPAD socket
  Q17? 6pin   maybe MUTE  ;\  ;\new TWL-CPU-10 mainboard only
  Q18? 6pin   maybe MUTE  ;/  ;/(formerly Q4/Q5 on older boards)
  X1   4pin   16.756  (rectangular oscillator)        ;\under shielding plate
  X2   4pin   CB837 or CB822 (long slim osc) for RTC? ;/text layer: see (A)
  F1   2pin   Fuse for external power input
  SW1  2pin   Button A (right)
  SW2  2pin   Button B (lower)
  SW3  2pin   Button X (upper)
  SW4  2pin   Button Y (left)
  SW5  2pin   Button Select (lower)
  SW6  2pin   Button Start  (upper)
  P1  19pin   NDS/DSi cartridge slot (17pin slot + 2pin switch at right side)
  P2      -   N/A
  P3      -   N/A
  P4   8pin   External microphone/headphone combo socket
  P5  50pin   Wifi-Daughterboard
  P6      -   N/A
  P7  47pin   To UPPER lcd screen (video+backlight+speakers) (on PCB backside)
  P8  37pin   To LOWER lcd screen (video signals)
  P9  25pin   To UPPER lcd screen (signals for both cameras, and camera led)
  P10  4pin   To LOWER lcd screen (touchpad X-,Y-,X+,Y+)
  P11  2pin   External Power Supply input (4.6V DC IN)
  P12     -   N/A
  P13     -   N/A
  P14     -   N/A
  P15 15pin   To battery/DPAD/PowerButton board (and onwards to 3xLEDs)
  P16 26pin   To bottom cover (SD Slot and L/R/VOL+/- buttons)
  P17  2pin   Battery cable (lower-right) ;see text-layer (B)
  P18  4pin   To LOWER lcd screen (backlight cathode/anode)
  P19  1pin   Shielding-Plate for CPU (lower clip)
  P20  1pin   Shielding-Plate for CPU (upper clip)
  P21  1pin   Shielding-Plate for CPU (right clip)
  P22     -   N/A
  P23  2pin   To Internal Microphone (via orange shielded wire)
</TD></TR></TABLE>
DSi Front/bottom-Side Text Layer sections (in upper left of mainboard)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  (A)  For components underneath of shielding plate
  (B)  For components in lower-right board edge (near battery connector)
  (C)  For components at middle/right of cartridge slot
  (D)  For components left of U4 (left board edge)
  (E)  For components right of U4 (above headphone socket)
  (F)  For components at lower/right of cartridge slot
</TD></TR></TABLE>
DSi Back/top-Side Text Layer sections (at various places)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  (A)  at top/middle,  for components at upper right edge
  (B)  at middle/left, for components near upper right edge
  (C)  at lower/left,  for components left of Y-button
  (D)  at lower/righz, for components at right edge
</TD></TR></TABLE>
<BR>
<B>DSi Wifi Daughterboard (DWM-W015) (old DSi version)</B><BR>
PCB Text: "RU (S)-717V 01 ,\\" or "RU (S)-717V 03 ,\\" or "FK RU 06 ,\\"<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  U   56pin "Mitsumi, Japan, 844L, MM3218" (same as in DS Lite)
  U   ??pin "ROCm, Atheros, AR6002G-AC1B, E19077.1B, 0844, Taiwan"
  U    8pin "408F, B837"
  U    8pin FLASH big chip "45PE10V6, HPASC VS, KOR 8364, ST"  ;\either one
  U    8pin FLASH tiny chip "5A32, 8936?"                      ;/installed
  U    8pin "4P, K" or "S6, K" (odd 3+1+3+1 pin package, near antenna)
  U    4pin "3VP, OT" or "3VB, OS" (at board edge, near 50pin connector)
  X    4pin "26.000, 9848" (bigger oscillator, near ROCm chip)
  X    4pin "22.000, xxxx" (smaller oscillator, near mitsumi chip)
  P   50pin Connector to Mainboard
  P    2pin Connector for Antenna (shielded white cable)
</TD></TR></TABLE>
White PCB sticker (underneath of the black isolation sticker): "DWM-W015,
IC:4250A-DWMW015, FCC ID:EW4DWMW015, [R]003WWA080444, [T]D080261003, MADE IN
PHILIPINES, MITSUMI ELEC. CO., LTD."<BR>
<BR>
<B>DSi Wifi Daughterboard (DWM-W024) (new DSi XL version)</B><BR>
PCB Text: "FB RU 06 ,\\"<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  U   76pin "ROCm, Atheros, AR6013G-AL1C" (or 80pin, with 4pins at edges?)
  U    8pin "4DA?, D940?"
  U    8pin "5A32, 8937?"   ;FLASH (small solder pads)
  U    8pin not installed (alternate bigger solder pads for FLASH?)
  U    4pin "?" (at board edge, near 50pin connector)
  X    4pin "??" (oscillator, near ROCm chip)
  P   50pin Connector to Mainboard
  P    2pin Connector for Antenna (shielded white cable)
</TD></TR></TABLE>
<BR>
<B>DSi Battery/DPAD Daughterboard "C/TWL-SUB-01"</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  TH1  2pin  Battery Thermal Sensor maybe? (about 10kOhm at room temperature)
  F1   2pin  Battery Fuse
  SW1  2pin  DPAD Up Button
  SW2  2pin  DPAD Down Button
  SW3  2pin  DPAD Left Button
  SW4  2pin  DPAD Right Button
  SW5  2pin  Power/Reset Button
  P1  15pin  To Mainboard (P15) (button/led signals) (wire "15P-01")
  P2   6pin  To 3xLEDs
  P3   3pin  To battery (TWL-003 3.6V 840mAh 3Wh C/TWL-A-BP, Li-ion 00"
  Wire 2pin  To Mainboard (P17) (battery supply) (red=vcc, black=gnd)
</TD></TR></TABLE>
<BR>
<B>DSi LED Board/Foil "LED-01, (DF)"</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  D    2pin  Left LED      ;-wifi
  D    2pin  Middle LED    ;-charge
  D    2pin  Right LED 1   ;\power "two-color-LED"
  D    2pin  Right LED 2   ;/composed of 2 single LEDs
  Wire 6pin  To Battery/DPAD Daughterboard
</TD></TR></TABLE>
<BR>
<B>DSi Lower Screen with Touchpad</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Wire 4pin  Touchpad
  Wire 4pin  Backlight (actually 2pins, each 2 pins are same)
  Wire xxpin Video Signals
  LCD  "LS033A1DG48R, 8X16Q U0003986"
</TD></TR></TABLE>
<BR>
<B>DSi Upper Screen with Speakers &amp; Cameras &amp; LED &amp; Microphone</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Orange Ribbon Cable: Video Signals, Backlight, and Speakers
  Black Ribbon Cable: Cameras and Camera LED
  Shielded Orange 2pin Wire: Microphone
  Shielded White 2pin Wire: Wifi PCB Antenna
  LCD  "LS033A1DG38R, BX16Q L0005532"
  The speakers use red/black wires, which connect to the orange ribbon cable
</TD></TR></TABLE>
<BR>
<B>DSi Upper Screen Area Extra Components: Speakers &amp; Cameras &amp; LED &amp; Microphone</B><BR>
<BR>
<B>DSi Lower Case (SD Slot, L/R and VOL+/- Buttons, and screen calibration)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Whatever, not checked yet
</TD></TR></TABLE>
<BR>
<B>DSi Disassembly Notes</B><BR>
Bottom Cover Screws:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7 screws (two are under battery cover)
</TD></TR></TABLE>
Remove bottom cover, and:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  P16: To bottom cover (SD Slot and L/R/VOL+/-) --&gt; pull (away from board)
</TD></TR></TABLE>
Remove Wifi Daughterboard:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  P5:  Wifi-board (without cable)               --&gt; pull (away from board)
  WHITE: Wifi-Antenna (shielded 2pin)           --&gt; pull (away from wifi-board)
</TD></TR></TABLE>
Remove mainboard:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ORANGE P24 (shielded 2pin)  --&gt; pull (away from board)
  WHITE SUPPLY                --&gt; lift (use screwdriver &amp; push away from board)
  3x bigger white/black connectors --&gt; lift black lid (at cable-side)
  2x smaller black connectors      --&gt; lift black lid (at cable-end) (!!!)
</TD></TR></TABLE>
Turn mainboard over, then unlock the connector at back side:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1x bigger white/black connector  --&gt; lift black lid (at cable-side)
</TD></TR></TABLE>
Remove Battery board:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1x smaller black connector       --&gt; lift black lid (at cable-end) (!!!)
  1x bigger white/black connectors --&gt; lift black lid (at cable-side)
  (don't disconnect bigger connector if the other cable end is already
  disconnected from mainboard) (or if you did do, reassemble as follows:
  longer cable end to battery board, short cable end to mainboard)
  1x battery cable (disconnect at mainboard side, see there)
</TD></TR></TABLE>
Top Cover Disassembly:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Disconnect upper LCD and mic/antenna from mainboard (see above)
  Remove 4 screws (all hidden under square rubber pieces)
  slide rear bezel upwards by two millimeters?
  push metal hinge inwards by three millimeters (under LED unit)
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="auxdsiinternalconnectors"></A>&nbsp;
  AUX DSi Internal Connectors
</FONT></TD></TR></TABLE><BR>
<B>P1  19pin   NDS/DSi cartridge slot (17pin slot + 2pin switch at right side)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1   GND
  2   MC1_CLK
  3   -
  4   MC1_CS
  5   MC1_RES
  6   MC1_CS2
  7   MC1_IREQ
  8   MC1_VDD via Q6 to VDD33 (cpu signal preamplified from Q7)
  9   MC1_IO0
  10  MC1_IO1
  11  MC1_IO2
  12  MC1_IO3
  13  MC1_IO4
  14  MC1_IO5
  15  MC1_IO6
  16  MC1_IO7
  17  GND
  18  MC1_DET           ;\switch closed when cart inserted
  19  GND               ;/
  Shield GND
</TD></TR></TABLE>
<BR>
<B>P4   8pin   External microphone/headphone combo socket</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1  GND    ;\      ;\
  2  SL     ; head- ; headphone gnd/left/right
  3  SR     ; phone ;/
  4  GND    ;       ;\headphone/speaker switch (pin 4+5 shortcut with each
  5  HP#SP  ;/      ;/other when no headphone connected)
  6  MIC    ;\    ;\microphone switch (pin6+7 shortcut when no mic connected)
  7  Switch ; mic ;/(internal mic from P23 is then passed from pin7 to pin6)
  8  GND    ;/
</TD></TR></TABLE>
<BR>
<B>P5  50pin   Wifi-Daughterboard</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
                           GND   2  1
                         VDD18   4  3   GND
                         VDD18   6  5
                           GND   8  7
                         VDD33  10  9
                         VDD33  12  11
                           GND  14  13
                      ATH_TX_H  16  15  DSi: NC (connected at wifi side!!!)
                     /WIFI_RST  18  17  DSi: NC (connected at wifi side?)
  NC (connected at wifi side?)  20  19  GND
  NC (connected at wifi side?)  22  21  RTC_FOUT (or RTC_F32K?)
  NC (connected at wifi side?)  24  23  GND
  IRQ? (goes near CPU irq pins) 26  25  DSi: NC (wifi: via 0 ohm MM3218.pin47)
               /FLASH_WP (R122) 28  27  SPI_CS2 (wifi FLASH memory)
                       SPI_SCK  30  29  ... to MM3218.pin42
                      SPI_MISO  32  31  ... to MM3218.pin41
                      SPI_MOSI  34  33  ... to MM3218.pin38
           to MM3218.pin15 ...  36  35  ... to MM3218.pin37
                       WL_RXPE  38  37  ... to MM3218.pin36
           to MM3218.pin19 ...  40  39  ... to MM3218.pin35
                           GND  42  41  ... to MM3218.pin34
           to MM3218.pin21 ...  44  43  ... to MM3218.pin28 (via 0 ohm) (+cap)
           to MM3218.pin18 ...  46  45  GND
                       WL_TXPE  48  47  ... to MM3218.pin23 (via XX and CLxx)
                         RESET  50  49  GND
</TD></TR></TABLE>
<BR>
<B>P7  47pin   To UPPER lcd screen (video+backlight+speakers) (on PCB backside)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
                          BLA2   1  2   BLC2    ;-backlight
                          SPLN   3  4   SPLN    ;\left speaker
                          SPLP   5  6   SPLP    ;/
                          SPRN   7  8   SPRN    ;\right speaker
                          SPRP   9  10  SPRP    ;/
                         VDD-5  11  12  VDD10
                          VDD5  13  14  GND
                          VSHD  15  16  VSHD
                           INI  17  18  GSP
                           GCK  19  20  LDB20
                         LDB21  21  22  LDB22
                         LDB23  23  24  LDB24
                         LDB25  25  26  LDG20
                         LDG21  27  28  LDG22
                           GND  29  30  LDG23
                         LDG24  31  32  LDG25
                         LDR20  33  34  LDR21
                         LDR22  35  36  LDR23
                         LDR24  37  38  LDR25
                           GND  39  40  DCLK
                           SPL  41  42  LS
                           GND  43  44  via C79 to COM2
                           REV  45  46  GND
                          COM2  47
</TD></TR></TABLE>
<BR>
<B>P8  37pin   To LOWER lcd screen (video signals)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
                         VDD-5   1  2   VDD10
                          VDD5   3  4   GND
                          VSHD   5  6   VSHD
                           INI   7  8   GSP
                           GCK   9  10  LDB10
                         LDB11  11  12  LDB12
                         LDB13  13  14  LDB14
                         LDB15  15  16  LDG10
                         LDG11  17  18  LDG12
                           GND  19  20  LDG13
                         LDG14  21  22  LDG15
                         LDR10  23  24  LDR11
                         LDR12  25  26  LDR13
                         LDR14  27  28  LDR15
                           GND  29  30  DCLK
                           SPL  31  32  LS
                           GND  33  34  via C93 to COM1
                           REV  35  36  GND
                          COM1  37
</TD></TR></TABLE>
<BR>
<B>P9  25pin   To UPPER lcd screen (signals for both cameras, and camera led)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
                           GND   1  2   CAM_LED
                         VDD42   3  4   GND
                  R100    RCLK   5  6   GND
                           GND   7  8   HSYNC
                         VSYNC   9  10  CAM_D5  RA7
                   RA7  CAM_D6  11  12  CAM_D4  RA7
                       CAM_RST  13  14  SCL
                           SDA  15  16  CAM_D7  RA7
                   RA6  CAM_D0  17  18  CAM_D3  RA6
                   RA6  CAM_D1  19  20  CAM_D2  RA6
                         VDD28  21  22  GND
                           CKI  23  24  GND
                         VDD18  25
</TD></TR></TABLE>
<BR>
<B>P10  4pin   To LOWER lcd screen (touchpad X-,Y-,X+,Y+)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1 X-
  2 Y-
  3 X+
  4 Y+
</TD></TR></TABLE>
<BR>
<B>P11  2pin   External Power Supply input (4.6V DC IN)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1 VIN  (+4.6V)
  2 VGND (GND)
  Shield (GND)
</TD></TR></TABLE>
<BR>
<B>P15 15pin   To battery/DPAD/PowerButton board (and onwards to 3xLEDs)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  dpad up button      P06  1  2  ORANGE (LED)
  dpad right button   P04  3  4  BLUE (LED)
  dpad left button    P05  5  6  YELLOW (LED)
  dpad down button    P07  7  8  RED (LED)
                      GND  9  10 VDD42 (to LEDs)
                      GND 11  12 TH on DPAD board (via R102 to TH on main)
  middle battery pin  DET 13  14 GND
  power button       PWSW 15
</TD></TR></TABLE>
Note: On Daughterboard, pins are mirrored (eg. PWSW=Pin1 instead Pin15)<BR>
<BR>
<B>P16 26pin   To bottom cover (SD Slot and L/R/VOL+/- buttons)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
                      GND  2  1  SD10_CLK                   ;\
               SD10_DATA0  4  3  SD10_VDD (aka VDD33)       ;
               SD10_DATA1  6  5  SD10_VDD (aka VDD33)       ; pin 1..18
                  SD10_WP  8  7  GND                        ; to RIGHT side:
                      GND 10  9  SD10_CMD                   ; R-button, and
  shoulder button R   P08 12  11 GND                        ; SD-card slot
                      GND 14  13 SD10_DATA3                 ;
                  SD10_CD 16  15 SD10_DATA2                 ;
                      GND 18  17 GND                        ;/
                      GND 20  19 GND                        ;\pin 19..20
  maybe display ;\   VDD5 22  21 VOLP (aka volume plus?)    ; to LEFT side:
  calibration?  ;    COM1 24  23 VOLN (aka volume minus?)   ; L-button, VOL +/-
  (at battery)  ;/   COM2 26  25 P09   shoulder button L    ;/and calibration
</TD></TR></TABLE>
<BR>
<B>P17  2pin   Battery cable (lower-right) ;see text-layer (B)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  + BT+ (plus) (red wire)
  - BT- (GND)  (black wire)
</TD></TR></TABLE>
<BR>
<B>P18  4pin   To LOWER lcd screen (backlight cathode/anode)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1 BLC1  ;\both same
  2 BLC1  ;/
  3 BLA1  ;\both same
  4 BLA1  ;/
</TD></TR></TABLE>
<BR>
<B>P19  1pin   Shielding-Plate for CPU (lower clip)</B><BR>
<B>P20  1pin   Shielding-Plate for CPU (upper clip)</B><BR>
<B>P21  1pin   Shielding-Plate for CPU (right clip)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Shield GND
</TD></TR></TABLE>
<BR>
<B>P23  2pin   To Internal Microphone (via orange shielded wire)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Pin  MIC (from P4.Pin7, disconnected when external microphone connected)
  Shield GND
</TD></TR></TABLE>
<BR>
<B>DPAD-BOARD P2  6pin</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1  YELLOW
  2  BLUE
  3  ORANGE
  4  GND   (for red+orange)
  5  RED
  6  VDD42 (for yellow+blue)
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="auxdsichipsetpinouts"></A>&nbsp;
  AUX DSi Chipset Pinouts
</FONT></TD></TR></TABLE><BR>
A photo of the DSi mainboard (with extra text layer on vias and solderpads) can
be found at:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  http://problemkaputt.de/twl-core.jpg
</TD></TR></TABLE>
<BR>
<B>DSi U1 - TWL-CPU (19x19 pin grid) (=361 pins, minus middle 3x3 pins)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
       Wifi   MC2 maybe      MC1           SD/MMC  eMMC  SPI     RTC   IRQs
  .---.---.---------------.---------------.-------.---.-------.-------.---.---.
  |NC |WIF|NC  NC  NC  NC |D7  D3  IRQ CLK|D0  CLK|CLK|CS3 SCK|CS  SCK|R7 |NC |
  +---'   |               |               |       |   |       |   .---'   '---+
  |WIF WIF|NC  NC  NC  NC |D6  D2  DET CS |D1  CMD|D0 |CS2 MIS|SIO|PEN NC  WIF|
  |       |               |               |       |   |       +---+---.   .---+
  |WIF WIF|NC  NC  NC  NC |D5  D1  PWR CS2|D2  CD |D1 |CS1 MOS|R00 R01|RTC|P09|
  |       '---.       .---+           .---'   .---'   '---.---+       '---'   |
  |WIF WIF WIF|NC  NC |V33|D4  D0  RES|D3  WP |D3  D2  CMD| ? |P08 P07 P06 P05|
  |           '---+---'   '-----------'-------'-----------'---+               |
  |WIF WIF RXP TXP|GND V12 V33 GND V12 V33 G?  V12 V33 GND V33|P04 P03 P02 P01|
  |               |                                           +-----------.   |
  |WIF WIF WIF ?  |GND V33 V12 GND GND GND V33 G?  GND V33 V12| ?  RES NC |P00|
  |               |                                           |           '---+
  |WIF WIF WIF WIF|V33 GND V12 V33 GND V12 G?  V12 GND GND V33|PMO VC5 PMS X  |
  +-----------.   |                                           '-----------.   |
  |V33 NC  GND|WIF|V12 GND V33 GND V12 V33 GND V33 V12 V12 V33 GND GND GND|X  |
  |           '---'               .-----------.               .-----------'   |
  |V33 NC  V33 V33 GND V33 GND V33|-   -   -  |GND GND GND GND|HP# IRQ ?   GND|
  +---.   .---.                   |           |               |               |
  |B15|V33|NC |V33 V12 GND V12 V12|-   -   -  |V12 V18 GND V12|NC  NC  NC  GP |
  |   '---'---'---.               |           |               +---------------+
  |B14 B13 B12 B11|V33 GND V33 GND|-   -   -  |V18 GND V18 GND|A1  D1  A0  D0 |
  |               |               '-----------'               |               |
  |B10 G15 G14 G13|GND V33 V12 GND V18 V12 V18 GND V18 V12 V18|A3  D3  A2  D2 |
  |               |                                           |               |
  |G12 G11 G10 R15|V33 V12 GND V12 GND V18 GND V12 GND V18 GND|A5  D5  A4  D4 |
  |               |                                           |               |
  |R14 R13 R12 R11|GND V33 V18 GND V18 V12 V18 GND V18 V12 V18|A7  D7  A6  D6 |
  +-----------.   |                                           |               |
  |DCK GSP SPL|R10|V33 V12 GND V18 GND V18 GND V12 GND V18 GND|A9  D9  A8  D8 |
  |       .---'---'-------.-------.---.---.-------.-----------'               |
  |LS  REV|B22 G24 G20 R22|D7  D3 |NC |RST|SCK WS |CE1 /OE A20 A11 D11 A10 D10|
  |   .---'               |       |   |   |       |                           |
  |GCK|B25 B21 G23 R25 R21|D6  D2 |NC |VSY|MCK SDO|NC  CE2 A19 A13 D13 A12 D12|
  |   |                   |       |   |   +---.   |                           |
  |INI|B24 B20 G22 R24 R20|D5  D1 |NC |HSY|SDA|SDI|/LB CLK A18 A21 A14 D15 D14|
  +---+               .---+       '---'   |   +---'                       .---+
  |NC |B23 G25 G21 R23|NC |D4  D0  CKI RCK|SCL|/UB ADV /WE A15 A17 A22 A16|NC |
  '---'---------------'---'---------------'---'---------------------------'---'
          LCD                  CAM         I2C SND          RAM               o
</TD></TR></TABLE>
<BR>
<B>DSi U2 - Main RAM (8Mx16) (Fujitsu MB82DBS08164, or NEC uPD46128512)</B><BR>
DSi mainboard solder pads (12x8 grid, within 14x10 grid):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
       A    B    C    D    E    F    G    H    J    K    L    M    N    P
  10   -    -    -    -    -    -    -    -    -    -    -    -    -    -
  9    -    NC   NC   -    A15  A21  A22  A16  NC   VSS  -    NC   NC   -
  8    -    NC   NC   A11  A12  A13  A14  NC   DQ15 DQ7  DQ14 NC   NC   -
  7    -    -    -    A8   A19  A9   A10  DQ6  DQ13 DQ12 DQ5  -    -    -
  6    -    -    -    /WE  CE2  A20  -    -    DQ4  VDD  NC   -    -    -
  5    -    -    -    CLK  /ADV (W)  -    -    DQ3  VDD  DQ11 -    -    -
  4    -    -    -    /LB  /UB  A18  A17  DQ1  DQ9  DQ10 DQ2  -    -    -
  3    -    NC   -    A7   A6   A5   A4   VSS  /OE  DQ0  DQ8  NC   NC   -
  2    -    NC   NC   -    A3   A2   A1   A0   NC   /CE1 -    NC   NC   -
  1 o  -    -    -    -    -    -    -    -    -    -    -    -    -    -
</TD></TR></TABLE>
DSi RAM - Fujitsu MB82DBS08164 (14x10 grid):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
       A    B    C    D    E    F    G    H    J    K    L    M    N    P
  10   NC   NC   NC   NC   NC   NC   VDD  VSS  NC   NC   NC   NC   NC   NC
  9    NC   NC   NC   NC   A15  A21  A22  A16  NC   VSS  NC   NC   NC   NC
  8    -    -    NC   A11  A12  A13  A14  NC   DQ15 DQ7  DQ14 NC   -    -
  7    -    -    NC   A8   A19  A9   A10  DQ6  DQ13 DQ12 DQ5  NC   -    -
  6    -    -    NC   /WE  CE2  A20  NC   NC   DQ4  VDD  NC   NC   -    -
  5    -    -    NC   CLK  /ADV /WAI NC   VDD  DQ3  VDD  DQ11 VDD  -    -
  4    -    -    NC   /LB  /UB  A18  A17  DQ1  DQ9  DQ10 DQ2  VSS  -    -
  3    -    -    VSS  A7   A6   A5   A4   VSS  /OE  DQ0  DQ8  NC   -    -
  2    NC   NC   NC   NC   A3   A2   A1   A0   NC   /CE1 NC   NC   NC   NC
  1 o  NC   NC   -    NC   NC   NC   VDD  VSS  NC   NC   NC   NC   NC   NC
</TD></TR></TABLE>
DSi RAM - NEC uPD46128512 (14x10 grid):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
       A    B    C    D    E    F    G    H    J    K    L    M    N    P
  10   NC   NC   NC   -    -    -    NC   NC   -    -    -    NC   NC   NC
  9    -    NC   NC   -    A15  A21  A22  A16  NC   VSS  -    NC   NC   -
  8    -    -    NC   A11  A12  A13  A14  NC   DQ15 DQ7  DQ14 NC   -    -
  7    -    -    -    A8   A19  A9   A10  DQ6  DQ13 DQ12 DQ5  -    -    -
  6    -    -    NC   /WE  CE2  A20  NC   NC   DQ4  VCC  NC   NC   -    -
  5    -    -    NC   CLK  /ADV /WAI NC   NC   DQ3  VCC  DQ11 NC   -    -
  4    -    -    -    /LB  /UB  A18  A17  DQ1  DQ9  DQ10 DQ2  -    -    -
  3    -    -    NC   A7   A6   A5   A4   GND  /OE  DQ0  DQ8  NC   -    -
  2    -    NC   NC   NC   A3   A2   A1   A0   NC   /CE1 -    NC   NC   -
  1 o  NC   NC   NC   -    -    -    NC   NC   -    -    -    NC   NC   NC
</TD></TR></TABLE>
The Fujitsu &amp; NEC datasheets are specifing 14x10 grid (the chips are
essentially pin-compatible, except that: NEC has removed some NC pins, changed
some supply pins to NC, and (attempted to) rename VSS to GND).<BR>
However, the DSi mainboard has 12x8 grid solder pads (and the installed
NEC/Fujitsu chip/packages are actually only 12x8, too).<BR>
The DSi debug version is said to have 32Mbyte RAM, there is no provision for
that feature on DSi retail boards; dev boards are probably somewhere having an
extra address line (or an extra chip select for a 2nd RAM chip).<BR>
<BR>
<B>DSi U3 - Power Managment (Texas Instruments 72071B0, or Mitsumi 3317A)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1   GND (via CL9)
  2   ADPO
  3   EXTB+
  4   VDD33
  5   RESET         ;\
  6   SPI_SCK       ; main cpu bus
  7   SPI_MOSI      ; (reset and spi)
  8   SPI_MISO      ;
  9   SPI_CS1       ;/  &lt;-- powerman (this does ALSO connect to U4)
  10  GND
  11  PMOFF
  12  PWSWO
  13  VCNT5
  14  PM_SLP
  ---
  15  B+
  16  VDD12 via L1
  17  VDD12
  18  GND
  19  BLC1          ;\
  20  BLA1 via U13  ; backlight 1+2
  21  BLA2 via U14  ; anode/cathode
  22  BLC2          ;/
  23  GND
  24  B+
  25  B+
  26  VDD18 via L2
  27  VDD18 via L2
  28  VDD18
  ---
  29  DET     ;\battery contacts
  30  BT+     ;/    ;\these are almost shortcut
  31  VDET-         ;/with each other (via 0 ohm R71)
  32  PVDD
  33  PWSW (when off: very few ohms to PVDD)
  34        ... via R104 (100K) to Q3 (B+ enable or so?)
  35  B+
  36        ... via to C18 to GND (seems to have no other connection)
  37  GND
  38  AOUT  ;\to U6
  39  GND   ;
  40  SCL1  ;   ;\secondary IC2 bus (to U6)
  41  SDA1  ;/  ;/
  42  VDD33
  ---
  43  GND via CL10
  44  VDD5 input (sense if VDD5/C16 has reached voltage)
  45  charge-pump for VDD5 (L7 and via DA3 to VDD5/C16)
  46  charge-pump for VDD5 (L5 and C14)
  47  VDD33 (via CL5)
  48  VDD33 (via L3)
  49  VDD33
  50  VDD33
  51  B+
  52  B+
  53  B+
  54  charge-pump for VDD42 (L7 and C23)
  55  charge-pump for VDD42 (L7 and via D3 to VDD42/C22)
  56  VDD42 input (sense if VDD42/C22 has reached voltage)
</TD></TR></TABLE>
<BR>
<B>DSi U4 - Sound and Touchscreen controller (AIC3000D)</B><BR>
AIC3000D pinout is same as in TSC2117 datasheet (aside from GPIx/GPIOx pins).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Pin TSC2117 AIC3000D
  1   MISO    SPI_MISO
  2   MOSI    SPI_MOSI
  3   /SS     SPI_CS1 (powerman, this does ALSO connect to U3)
  4   SCLK    SPI_SCLK
  5   GPIO1   SPI_CS3 (touchscreen)
  6   GPIO2   PENIRQ
  7   IOVSS   GND
  8   IOVDD   VDD33
  9   DVDD    VDD18
  10  SDOUT   SND_SDI              ;\
  11  SDIN    SND_SDO              ;
  12  WLCK    SND_WS               ; serial sound input from main cpu
  ---                              ; (and serial output? microphone maybe?)
  13  BCLK    SND_SCLK             ;
  14  MCLK    SND_MCLK             ;/
  15  SDA       ... via R107 to VDD18  ;\unused I2C bus (?)
  16  SCL       ... via R106 to VDD18  ;/
  17  VOL/M   wiper (sound volume, from i2c potentiometer) "VOL/MICDET?"
  18  MICBIAS   LIN-related-1 ... to 6pin U18
  19  MIC     LIN (aka MIC via C31)
  20  AUX1      LIN-related-2   ;\via 0ohm R108 to ... something on U18
  21  AUX2      LIN-related-2   ;/                     that is almost GND
  22  AVSS    GND
  23  AVDD    VDD33
  24  VBAT    GND
  ---
  25  VREF    VDD33
  26  TSVSS   GND
  27  YN      Y-                   ;\
  28  XN      X-                   ;
  29  DVSS    GND                  ; touchscreen input
  30  YP      Y+                   ;
  31  XP      X+                   ;/
  32  TSVDD   VDD33
  33  SPLN    SPLN                 ;\
  34  SLVSS   GND                  ;
  35  SLVDD   B+                   ; speaker output
  36  SPLP    SPLP                 ;
  ---                              ;
  37  SPRN    SPRN                 ;
  38  SRVDD   B+                   ;
  39  SRVSS   GND                  ;
  40  SPRP    SPRP                 ;/
  41  HPL     SL via CP2 and R88      ;\
  42  HVDD    VDD33                   ;
  43  HVSS    GND                     ; headphone output
  44  HPR     SR via CP3 and R89      ;
  45  GPI3    MUTE via Q4/Q5 to SR/SL ;
  46  GPI2    HP#SP switch            ;/
  47  GPI1    VCNT5
  48  /RESET  RESET
</TD></TR></TABLE>
<BR>
<B>DSi U5 - 256Mbyte eMMC NAND (14x14 grid)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
       1    2    3    4    5    6    7    8    9    10   11   12   13   14
  o A  NC   NC   DAT0 DAT1 DAT2 NC   NC   NC   NC   NC   NC   NC   NC   NC
    B  NC   DAT3 DAT4 DAT5 DAT6 DAT7 NC   NC   NC   NC   NC   NC   NC   NC
    C  NC   VDDI NC   VSSQ NC   VCCQ NC   NC   NC   NC   NC   NC   NC   NC
    D  NC   NC   NC   NC   -    -    -    -    -    -    -    NC   NC   NC
    E  NC   NC   NC   -    NC   VCC  VSS  NC   NC   NC   -    NC   NC   NC
    F  NC   NC   NC   -    VCC  -    -    -    -    NC   -    NC   NC   NC
    G  NC   NC   NC   -    VSS  -    -    -    -    NC   -    NC   NC   NC
    H  NC   NC   NC   -    NC   -    -    -    -    VSS  -    NC   NC   NC
    J  NC   NC   NC   -    NC   -    -    -    -    VCC  -    NC   NC   NC
    K  NC   NC   NC   -    NC   NC   NC   VSS  VCC  NC   -    NC   NC   NC
    L  NC   NC   NC   -    -    -    -    -    -    -    -    NC   NC   NC
    M  NC   NC   NC   VCCQ CMD  CLK  NC   NC   NC   NC   NC   NC   NC   NC
    N  NC   VSSQ NC   VCCQ VSSQ NC   NC   NC   NC   NC   NC   NC   NC   NC
    P  NC   NC   VCCQ VSSQ VCCQ VSSQ NC   NC   NC   NC   NC   NC   NC   NC
</TD></TR></TABLE>
Note: The pinout follows JEDEC's eMMC standard. The "NC" pins are GNDed in DSi,
the "DAT4..DAT7" pins seem to be not connected in DSi. The "VDDI" pin isn't
wired to VDD, instead it goes to a capacitor (0.1uF min) "for internal power
stability".<BR>
<BR>
<B>DSi U6 - "BPTWL" - I2C bus(ses), LEDs, volume, power, wifi (6x6 grid)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
       GND         WL_TXPE     P02(button) SDA'33      ADPO        GND       o
       ATH_TX_H    BLUE(LED)   RED(LED)    SCL'33      V33         GND
       YELLOW(LED) VOLP button VOLN button PM_SLP      V33'        /WIFI_RST
       SDA1        RESET       SCL1        to C46      GND         to U17
       VDD28       GND         CAM_LED     PWSWO       mFE         /mRST
       GND         AOUT        mFE'(R79)   WL_RXPE     /IRQ_O      GND
</TD></TR></TABLE>
<BR>
<B>DSi U7 - i2c bus potentiometer (ISL95810) (Device 50h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1  /WP (DSi: VDD33)  writeprotect
  2  SCL (DSi: SCL1)   i2c bus   ;\from U6
  3  SDA (DSi: SDA1)   i2c bus   ;/
  4  GND (DSi: GND)    ground
  5  RW  (DSi: wiper)  pot.wiper ;-to U4
  6  RL  (DSi: VDD18)  pot.L
  7  RH  (DSi: GND)    pot.H
  8  VCC (DSi: VDD33)  supply
</TD></TR></TABLE>
<BR>
<B>DSi U8 - bidirectional i2c voltage translator (PCA9306)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1  GND   (DSi: GND)
  2  VREF1 (DSi: VDD18)
  3  SCL1  (DSi: SCL)     ;\to U1 (CPU)
  4  SDA1  (DSi: SDA)     ;/
  5  SDA2  (DSi: SDA'33)  ;\to U6 (LED/stuff)
  6  SCL2  (DSi: SCL'33)  ;/
  7  VREF2 (DSi: VDD33)
  8  EN    (DSi: VDD33)
</TD></TR></TABLE>
<BR>
<B>DSi U9 - RTC - Seiko S-35199A01 (4x3 grid)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
       A    B    C    D
  3    CS   /SCK VDD  F32K
  2    SIO  CTRL /INT FOUT
  1 o  VSS  XIN  XOUT VDDL
</TD></TR></TABLE>
<BR>
<B>DSi U10 - Magnet Sensor (for hinge, aka shell opened/closed)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1  VDD33
  2  R7 (HINGE)  ;to U1
  3  GND
  4  GND
</TD></TR></TABLE>
<BR>
<B>DSi U11 - charge</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1  EXTB+
  2  Rosc
  3  ORANGE (via R2)              ;-charge LED
  4  GND
  5  TH' (via R76 to TH)          ;\thermal sensor
  6  TH  (via R102 to DPAD board) ;/for battery?
  7  B+  (?)
  8  RICHG
  9  BT+
  10 BT+
</TD></TR></TABLE>
<BR>
<B>DSi U12 - 5pin, VDD33 to VDD28 converter? (near upper screen socket)</B><BR>
<B>DSi U13 - 5pin, Backlight 1, near power managment chip</B><BR>
<B>DSi U14 - 5pin, Backlight 2, near power managment chip</B><BR>
<B>DSi U15 - 4pin, something near external power input</B><BR>
<B>DSi U16 - N/A</B><BR>
<B>DSi U17 - 6pin, something near headphone socket, connects to U6, and MUTE</B><BR>
<B>DSi U18 - 6pin, something near headphone socket, MIC/LIN related</B><BR>
<B>DSi U19 - 5pin, something near dpad socket</B><BR>
Smaller misc chips.<BR>
<BR>
<B>DSi LEDs:</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  CAM_LED (via R68 and Q13)  ;\
  BLUE    (via R21 and Q11)  ; from U6
  YELLOW  (via R22 and Q12)  ;/
  RED     (via R20)          ;-from U6 (or to U6 ?)
  ORANGE  (via R2)           ;-from U11
</TD></TR></TABLE>
<BR>
<B>DSi Wifi Daughterboard - MM3218 chip (same chip as in DS Lite)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1  VDD18
  2  GND
  3  VDD18
  4  Antenna signal
  5  Antenna shield
  6  VDD18
  7  VDD18
  8  GND
  9
  10 GND
  11 GND
  12 GND
  13
  14 /RESET
  ---
  15 ... to DSi mainboard connector pin 36
  16 WL_TXPE
  17 WL_RXPE
  18 ... to DSi mainboard connector pin 46  !!!
  19 ... to DSi mainboard connector pin 40
  20 VDD33
  21 ... to DSi mainboard connector pin 44
  22 GND
  23 ... via nearby big component ... to DSi mainboard connector pin 47 ?
  24 VDD18
  25
  26 22MHz
  27 22MHz'
  28 ... to DSi mainboard connector pin 43 (with cap to GND and via 0 ohm)
  ---
  29 VDD33
  30 via capacitor to VDD33
  31 via 1K2 + 120K to GND (aka via 121.2K to GND)
  32 VDD18
  33 VDD18
  34 ... to DSi mainboard connector pin 41
  35 ... to DSi mainboard connector pin 39
  36 ... to DSi mainboard connector pin 37
  37 ... to DSi mainboard connector pin 35
  38 ... to DSi mainboard connector pin 33
  39 GND
  40 VDD33
  41 ... to DSi mainboard connector pin 31
  42 ... to DSi mainboard connector pin 29
  ---
  43 VDD18
  44 ... shortcut to MM3218.pin50, and via resistor to MM3218.pin46
  45 VDD33
  46 ... via resistor to MM3218.pin44+50
  47 ... to DSi mainboard connector pin 25 (via 0 ohm) (+cap) (NC in DSi)
  48 VDD33
  49 GND
  50 ... shortcut to MM3218.pin44, and via resistor to MM3218.pin46
  51 ... via resistor to GND
  52 VDD18
  53
  54
  55
  56
</TD></TR></TABLE>
<BR>
<B>DSi Wifi Daughterboard - ROCm Atheros AR6002G-AC1B chip</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Unknown pinout
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="pinoutscpusignalsummary"></A>&nbsp;
  Pinouts - CPU - Signal Summary
</FONT></TD></TR></TABLE><BR>
<B>Advance Gameboy CPU Signal Summary</B><BR>
Cart Bus: D0-D7, A0-A15, /CS, /RD, /WR (different usage in GBA/DMG mode)<BR>
WRAM Bus: WA0-WA16, WD0-WD15, /WLB, /WUB, /WWE, /WOE (used in GBA mode only)<BR>
LCD Bus : LDR1-5, LDG1-5, LDB1-5, DCK, LP, PS, SPL, CLS, SPS, MOD, REVC<BR>
Joypad: TP0-3 (Buttons), TP4-7 (Directions), TP8-9 (L/R-Buttons, via R43/R44)<BR>
Serial Link: SC, SD (aka P14?), SI, SO - Audio: SO1-2, Vin<BR>
Other: CK1-2, PHI, IN35, VCNT5, /FIQ (via CL1 to VDD3), /RESET (IN), /RES (OUT)<BR>
Supply: VDD35, VDD3, VDD2, GND (some are probably undoc inputs)<BR>
GBA SP: Same as GBA, plus VDD1, plus duplicated supply pins, plus pin 152.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="pinoutscpupinouts"></A>&nbsp;
  Pinouts - CPU - Pinouts
</FONT></TD></TR></TABLE><BR>
<B>Advance Gameboy CPU Pinouts (CPU AGB)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1 VDD3  17 D0   33 A0    49 WA4   65 VDD2  81 WD9   97 LDB5   113 CK1
  2 IN35  18 A15  34 /CS   50 WA5   66 WD5   82 WD1   98 LDB4   114 CK2
  3 TP8   19 A14  35 /RD   51 WA6   67 WD13  83 /WOE  99 LDB3   115 VDD2
  4 TP0   20 A13  36 /WR   52 WA7   68 WD6   84 DCK   100 LDB2  116 GND
  5 TP1   21 A12  37 PHI   53 /WLB  69 WD14  85 LP    101 LDB1  117 VDD2
  6 SO1   22 A11  38 VDD35 54 /WUB  70 WD7   86 PS    102 GND   118 VCNT5
  7 SO2   23 A10  39 GND   55 /WWE  71 WD15  87 LDR5  103 VDD3  119 TP9
  8 Vin   24 A9   40 SC    56 WA8   72 WD8   88 LDR4  104 SPL   120 TP6
  9 /RES  25 A8   41 SD    57 WA9   73 WD16  89 LDR3  105 CLS   121 TP5
  10 D7   26 A7   42 SI    58 WA10  74 WA16  90 LDR2  106 SPS   122 TP7
  11 D6   27 A6   43 SO    59 WA11  75 WD12  91 LDR1  107 MOD   123 TP4
  12 D5   28 A5   44 VDD2  60 WA12  76 WD4   92 LDG5  108 REVC  124 /FIQ
  13 D4   29 A4   45 WA0   61 WA13  77 WD11  93 LDG4  109 GNDed 125 /RESET
  14 D3   30 A3   46 WA1   62 WA14  78 WD3   94 LDG3  110 GNDed 126 TP2
  15 D2   31 A2   47 WA2   63 WA15  79 WD10  95 LDG2  111 GNDed 127 TP3
  16 D1   32 A1   48 WA3   64 GND   80 WD2   96 LDG1  112 GNDed 128 GND
</TD></TR></TABLE>
<BR>
<B>GBA SP CPU Pinouts (CPU AGB B)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1 IN35   21 D0    41 A0    61 WA4   81 WD13  101 GND   121 LDB4  141 GND
  2 TP8    22 A15   42 /CS   62 WA5   82 WD6   102 VDD1  122 LDB3  142 VDD3
  3 TP0    23 A14   43 /RD   63 WA6   83 WD14  103 GND   123 LDB2  143 GND
  4 TP1    24 A13   44 /WR   64 WA7   84 WD7   104 VDD3  124 LDB1  144 VCNT5
  5 SO1    25 A12   45 PHI   65 /WLB  85 WD15  105 DCK   125 GND   145 TP9
  6 SO2    26 A11   46 VDD35 66 /WUB  86 WD8   106 LP    126 VDD3  146 TP6
  7 Vin    27 GND   47 GND   67 GND   87 WD16  107 PS    127 SPL   147 TP5
  8 VDD1   28 VDD35 48 SC    68 VDD2  88 WA16  108 LDR5  128 CLS   148 TP7
  9 GND    29 A10   49 SD    69 /WWE  89 VDD2  109 LDR4  129 SPS   149 TP4
  10 VDD35 30 A9    50 SI    70 WA8   90 GND   110 LDR3  130 MOD   150 /FIQ
  11 /RES  31 A8    51 SO    71 WA9   91 WD12  111 LDR2  131 REVC  151 /RESET
  12 D7    32 A7    52 VDD35 72 WA10  92 WD4   112 LDR1  132 GND   152 ?
  13 D6    33 A6    53 GND   73 WA11  93 WD11  113 LDG5  133 GND   153 TP3
  14 D5    34 A5    54 VDD1  74 WA12  94 WD3   114 LDG4  134 GND   154 TP2
  15 D4    35 A4    55 GND   75 WA13  95 WD10  115 LDG3  135 GND   155 VDD3
  16 D3    36 GND   56 VDD2  76 WA14  96 WD2   116 LDG2  136 VDD1  156 GND
  17 D2    37 VDD35 57 WA0   77 WA15  97 WD9   117 LDG1  137 GND
  18 GND   38 A3    58 WA1   78 GND   98 WD1   118 GND   138 CK1
  19 VDD35 39 A2    59 WA2   79 VDD2  99 /WOE  119 VDD3  139 CK2
  20 D1    40 A1    60 WA3   80 WD5   100 VDD2 120 LDB5  140 VDD2
</TD></TR></TABLE>
Pin 152 seems to be not connected on the mainboard, maybe an undoc output.<BR>
<BR>
<B>GBA-Micro, NDS, NDS-Lite, and DSi CPU Pinouts</B><BR>
Unknown. The CPU Pins are hidden underneath of the CPU. And, in NDS and
NDS-Lite, the CPU itself hides underneath of the DS Cartridge Slot. In the DSi
it's hidden underneath of a shielding plate (which is itself underneath of the
removeable wifi daughterboard).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="pinoutsaudioamplifiers"></A>&nbsp;
  Pinouts - Audio Amplifiers
</FONT></TD></TR></TABLE><BR>
<B>Advance Gameboy Audio Amplifier (AMP AGB IR3R60N) (U6)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1   2   3   4   5   6   7   8   9   10  11  12   13   14   15   16   17  18
  C38 FR1 FR2 FL1 FL2 GND RIN LIN C39 VOL SW  VDD5 LOUT VCC3 ROUT VCC3 SP  GND
</TD></TR></TABLE>
SW=Headphone Switch (grounded when none connected).<BR>
<BR>
<B>GBA SP Audio Amplifier (uses AMB AGB IR3R60N, too) (U3)</B><BR>
Same connection as in GBA, except that pin14/16 connect to VR21 (instead VCC3),
and pin1/9 connect to different capacitors.<BR>
<BR>
<B>NDS - National Semiconductor LM4880M Dual 250mW Audio Power Amplifier (U12)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1-OUT A  2-IN A  3-BYPASS  4-GND  5-SHUTDOWN  6-IN B  7-OUT A  8-VDD.VQ5
</TD></TR></TABLE>
NDS-Lite: No external amplifier (Mitsumi 3205B Powermanagment Device contains
internal amplifier).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="pinoutslcdcables"></A>&nbsp;
  Pinouts - LCD Cables
</FONT></TD></TR></TABLE><BR>
<B>Advance Gameboy Display Socket</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1 ?     6 GND    11 LDR2   16 LDG2   21 LDB3   26 SPS     31 P2-VSS  36 V4
  2 VSHD  7 VSHD   12 LDR1   17 LDG1   22 LDB2   27 ?       32 P2-VCC  37 V3
  3 DCK   8 LDR5   13 LDG5   18 GND    23 LDB1   28 MOD     33 ?       38 V2
  4 LP    9 LDR4   14 LDG4   19 LDB5   24 SPL    29 VCOM    34 VDD5    39 V1
  5 PS    10 LDR3  15 LDG3   20 LDB4   25 CLS    30 P2-VEE  35 GND     40 V0
</TD></TR></TABLE>
<BR>
<B>GBA SP Display Socket</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1 VSHD 5 VSHD  9 LDR3   13 LDG4  17 GND   21 LDB2  25 SPS   29 P2VSS 33 U83
  2 DCK  6 GND   10 LDR2  14 LDG3  18 LDB5  22 LDB1  26 MOD   30 COM   34 VDD5
  3 LP   7 LDR5  11 LDR1  15 LDG2  19 LDB4  23 SPL   27 REVC  31 VDD5
  4 PS   8 LDR4  12 LDG5  16 LDG1  20 LDB3  24 CLS   28 P2VDD 32 GND
</TD></TR></TABLE>
<BR>
<B>GBA Micro Display Sockets</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  __GBA Mirco display socket (P1)____________________________________
  1-PS    6-5bit  11-MD    16-5bit  21-5bit  26-CL             31-GND
  2-RV    7-5bit  12-SL    17-5bit  22-5bit  27-SS             32-GND
  3-GND   8-5bit  13-CK    18-5bit  23-5bit  28-via C5 to VR1  33-V10
  4-5bit  9-LP    14-GND   19-5bit  24-5bit  29-V5             34-V-5
  5-5bit  10-VD   15-5bit  20-GND   25-5bit  30-to VR1
  __GBA Mirco backlight socket (P3)__________________________________
  1-LC  2-LC  3-LA  4-LA
</TD></TR></TABLE>
<BR>
<B>NDS Upper/Lower Display Sockets</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ___NDS upper screen/upper backlight/speakers socket (P3)_____________________
  1-SPLO 7-PS2   13-LDR2  19-GND   25-LDG2  31-LDB2  37-MOD2  43-VDD15  49-SPRO
  2-SPLO 8-REV2  14-LDR1  20-DCLK2 26-LDG1  32-LDB1  38-GND   44-VDD-5  50-GND
  3-SSC2 9-GND   15-LDR0  21-GND   27-LDG0  33-LDB0  39-VDD5  45-VDD-10 51-GND
  4-ASC2 10-LDR5 16-LS2   22-LDG5  28-LDB5  34-GCK2  40-VDD10 46-LEDC2
  5-GND  11-LDR4 17-VSHD  23-LDG4  29-LDB4  35-GSP2  41-COM2  47-LEDA2
  6-SPL2 12-LDR3 18-DISP1 24-LDG3  30-LDB3  36-GND   42-GND   48-SPRO
  ___NDS lower screen socket (P4)______________________________________________
  1-SSC1 6-REV1  11-LDR2  16-DISP0 21-LDG4  26-LDB5  31-LDB0  36-GND  41-VDD15
  2-ASC1 7-GND   12-LDR1  17-SPL1  22-LDG3  27-LDB4  32-GCK1  37-?    42-VDD10
  3-GND  8-LDR5  13-LDR0  18-DCLK1 23-LDG2  28-LDB3  33-GSP1  38-VDD5 43-GND
  4-?    9-LDR4  14-LS1   19-GND   24-LDG1  29-LDB2  34-VSHD  39-COM1 44-VDD-5
  5-PS1  10-LDR3 15-VSHD  20-LDG5  25-LDG0  30-LDB1  35-MOD1  40-GND  45-VDD-10
  ___NDS lower backlight socket (P5)____   ___NDS touchscreen socket (P6)______
  1:LEDA1  2:LEDA1  3:LEDC1  4:LEDC1       1:Y-    2:X-    3:Y+    4:X+
</TD></TR></TABLE>
<BR>
<B>NDS-Lite Upper/Lower Display Sockets</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ___NDS-Lite upper screen/upper backlight/speakers socket (P3)________________
  1-VDD-5 6-MOD    11-LD2xx 16-LD2xx 21-LD2xx 26-LD2xx 31-LS   36-GND   41-SPRO
  2-VDD10 7-GSP    12-LD2xx 17-LD2xx 22-LD2xx 27-LD2xx 32-VSHD 37-COM2  42-SG
  3-VDD5  8-GCK    13-LD2xx 18-GND   23-LD2xx 28-GND   33-GND  38-LEDA2 43-SG
  4-GND   9-LD2xx  14-LD2xx 19-LD2xx 24-LD2xx 29-DCLK  34-xx2? 39-LEDC2 44-SPLO
  5-VSHD  10-LD2xx 15-LD2xx 20-LD2xx 25-LD2xx 30-SPL   35-REV  40-SPRO  45-SPLO
  ___NDS-Lite lower screen/lower backlight (P4)________________________________
  1-VDD-5 6-MOD    11-LD1xx 16-LD1xx 21-LD1xx 26-LD1xx 31-LS   36-GND
  2-VDD10 7-GSP    12-LD1xx 17-LD1xx 22-LD1xx 27-LD1xx 32-VSHD 37-COM1
  3-VDD5  8-GCK    13-LD1xx 18-GND   23-LD1xx 28-GND   33-GND  38-LEDA1
  4-GND   9-LD1xx  14-LD1xx 19-LD1xx 24-LD1xx 29-DCLK  34-xx1? 39-LEDC1
  5-VSHD  10-LD1xx 15-LD1xx 20-LD1xx 25-LD1xx 30-SPL   35-REV
  ___NDS-Lite touchscreen socket (P6)______   ___NDS-Lite white coax (P12)_____
  1:X-  2:Y-  3:X+  4:Y+                      Center:MICIN  Shield:GND
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="pinoutspowerswitchesdcdcconvertersresetgenerators"></A>&nbsp;
  Pinouts - Power Switches, DC/DC Converters, Reset Generators
</FONT></TD></TR></TABLE><BR>
<B>Advance Gameboy Power Switch (2-position slider, with two common pins)</B><BR>
<B>GBA SP Power Switch (same as GBA)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1 via resistor to GND (OFF)
  2 VS (BT+) (ON)
  C VCC (to board)
</TD></TR></TABLE>
<BR>
<B>GBA Micro Power Switch</B><BR>
Same as GBA and GBA SP, but Pin 1 and 2 exchanged.<BR>
<BR>
<B>Advance Gameboy Cartridge Slot Switch (integrated 4pin micro switch)</B><BR>
<B>GBA SP Cartridge Slot Switch (separate 4pin micro switch)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  C1 VDD35  (to S2 when PRESSED, to S1 when RELEASED)
  S1 VDD3   (to C2 when PRESSED, to C1 when RELEASED)
  C2 IN35   (to S1 when PRESSED)
  S2 VDD5   (to C1 when PRESSED)
</TD></TR></TABLE>
Pressed=8bit DMG/MGB/CGB cart, Released=32bit GBA cart (or no cart inserted)<BR>
GBA: switch integrated in cart socket, GBA-SP: separate switch next to socket.<BR>
<BR>
<B>Advance Gameboy Power Controller (M 121 514X) (U4)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1-VIN    2-VOUT5  3-CSS5    4-VDRV5  5-GND    6-VDRV3    7-CSS3    8-VOUT3
  9-VCNT5  10-CSCP  11-REGEXT 12-VDD3  13-VDD2  14-/RESET  15-LOWBAT 16-VDD13
</TD></TR></TABLE>
/RESET is passed to the CPU, and then forwarded to /RES pin on cart slot.<BR>
<BR>
<B>Advance Gameboy LCD Regulator (AGB-REG IR3E09N) (U3)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1  2  3    4      5   6   7   8   9   10   11  12  13  14  15  16   17     18
  ?  ?  REVC U3-COM V0  V1  ?   ?   ?   GND  ?   V2  ?   V3  V4  VDD5 U3-VDD ?
</TD></TR></TABLE>
<BR>
<B>GBA SP Power Controller 1 (S6403 AU227 9276) (U4)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1-VCC    2-SCP1   3-SCP2 4-VDRV3 5-VOUT3/VDD3 6-VDD2  7-VOUT1/VDD1  8-VDRV1
  9-LOWBAT 10-VCNT5 11-LS5 12-?    13-GND       14-?    15-VOUT5/VDD5 16-VDRV5
</TD></TR></TABLE>
<BR>
<B>GBA SP Power Controller 2 (2253B 2808) (U5)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1-TIN     2-U5C3     3-ADJ  4-U5VDD  5-VIN   6-?    7-U57  8-?
  9-to-C29  10-to-C30  11-?   12-GND   13-VS   14-S-  15-S+  16-U5OUT
</TD></TR></TABLE>
<BR>
<B>GBA Micro - Power Managment Device (U2)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 1 via C43 to GND
 2 via R24 to C34 to R25 back to U2.2
 3 via C35 to GND
 4 via C36 to GND
 5
 6 audio.in ? (see BP)
 7   via C48 to GND
 8   via R21 to C46 to C47 to C38 to R23 to phones
 9  VL (to U4)
 10  via R27 to C33 to C44 to C49 to R22 to phones
 11  via C45 to GND
 12 audio.in ? (see BP)
 13  via C41 to GND
 14 phones (switch)
 15 phones (tip via R22)
 16 phones (mid via R23)
 17 VCS
 18 SP
 19 GND
 20 LB
 21 via C52 to GND
 22 via C53 to GND
 23 RS         (looks like RESET output)
 24 to R37/C56 (looks like RESET input)
 25
 26
 27 via C54 to V3
 28 V3
 29 GND
 30 V3
 31 VC
 32 to C58
 33 to R41/C58
 34 GND
 35
 36 VC
 37 VC
 38
 39 V5
 40 GND
 41 GND
 42
 43
 44
 45 B+
 46 S-
 47 S+
 48
</TD></TR></TABLE>
<BR>
<B>GBA Micro - Volume/Backlight Level Up/Down Controller (U5)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1-     5-GND  9-      13-XD      17-     21-     25-    29-
  2-     6-GND  10-     14-to U4.7 18-XR   22-CN   26-    30-
  3-     7-     11-XC   15-        19-V+   23-CNS  27-    31-BP
  4-LN   8-     12-GND  16-        20-V-   24-     28-V3  32-
</TD></TR></TABLE>
<BR>
<B>NDS Powermanagment Device (Mitsumi 3152A) (U3)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1 R50-EXTB+        17               33 LEDC1           49 VCNT5
  2 R39-ORANGE       18               34 GND             50
  3 GND              19 VQ5           35 LEDC2           51 RST
  4                  20               36                 52
  5 Rxx-Q4           21               37 U10-LEDA2       53
  6 INS+             22 GND           38                 54
  7 INS-             23 VQ5           39 MIC.C53-AIN     55 VQ5
  8                  24               40 MIC.TSC.AUX     56 R24-SR
  9 VDET             25 VDD3.3        41 GND             57
  10 PVDD            26 GND           42 R38-RED         58 R22-SL
  11                 27 CL60-VDD3.3   43 R37-GREEN       59 GND
  12 PWSW            28 VSHD          44 VDD3.3          60 VR3.PIN2
  13                 29               45 PWM.SPI.CLK     61
  14 GND             30 VDD5          46 PWM.SPI.D       62
  15 GND             31 U9-LEDA1      47 PWM.SPI.Q       63
  16 VQ5             32               48 PWM.SPI.SEL     64 GND
</TD></TR></TABLE>
<BR>
<B>NDS-LITE Powermanagment Device (Mitsumi 3205B) (U3)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1 SW               17               33 LEDC1           49 VCNT5
  2 R50-EXTB+        18               34 GND             50
  3 R39-ORANGE       19 VQ5           35 LEDC2           51 RST
  4 GND              20               36                 52
  5                  21               37 U10-LEDA2       53
  6 R30-Q4           22 GND           38                 54
  7 INS+             23 VQ5           39 MIC.C53-AIN     55 CL63-VQ5
  8 INS-             24               40 MIC.TSC.AUX     56 R24-SR
  9 VDET             25 VDD3.3        41 GND             57 SPRO
  10 PVDD            26 GND           42 R38-RED         58 SPLO
  11                 27 CL60-VDD3.3   43 R37-GREEN       59 R22-SL
  12 PWSW            28 VSHD          44 VDD3.3          60 GND
  13 GND             29               45 PWM.SPI.CLK     61 R79-VR3.PIN2
  14 GND             30 VDD5          46 PWM.SPI.D       62
  15 GND             31 U9-LEDA1      47 PWM.SPI.Q       63
  16 VQ5             32               48 PWM.SPI.SEL     64
</TD></TR></TABLE>
<BR>
<B>NDS-LITE Power Switch</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1 PWSW (grounded when switch is pulled)
  2 GND
  3 GND
  4 NC? (grounded when switch is not pulled)
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="pinoutswifi"></A>&nbsp;
  Pinouts - Wifi
</FONT></TD></TR></TABLE><BR>
<B>NDS RFU Daughter Board (Firmware FLASH, Wifi BB/RF Chips)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1 N/A      6 FMW.CLK    11 ENABLE 16 RX.DTA? 21 BB./CS     26 22MHz   31 GND
  2 GND      7 FMW./SEL   12 GND    17 TX.MAIN 22 RF./CS     27 GND     32 GND
  3 high?    8 FMW.DTA.Q  13 GND    18 GND     23 BB.RF.CLK  28 VDD3.3  33 GND
  4 RXTX.ON  9 FMW.DTA.D  14 TX.ON  19 TX.CLK  24 BB.RF.RD   29 VDD1.8
  5 FMW./WP  10 FMW./RES  15 RX.ON  20 TX.DTA  25 BB.RF.WR   30 GND
</TD></TR></TABLE>
<BR>
<B>NDS-Lite RFU Daughter Board (Firmware FLASH, Wifi BB/RF Chip)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1 GND      6 GND      11 BB.RF.WR  16 VDD3.3  21 hi?       26 FMW.Q
  2 lo?      7 hi?      12 BB.RF.CLK 17 GND     22 FMW./RES  27 FMW./WP
  3 hi?      8 hi?      13 GND       18 RF./CS  23 GND       28 FMW./CS
  4 hi?      9 GND      14 hi?       19 hi?     24 FMW.CLK   29 hi?
  5 hi?      10 hi?     15 GND       20 BB./CS  25 FMW.D     30 GND
</TD></TR></TABLE>
<BR>
<B>Wifi RF Chip: RF9008, 0441, E0121Q (32 pin)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1       5       9       13      17         21 RF.CLK  25        29
  2       6       10      14 GND  18         22         26        30
  3       7       11      15      19 RF.RD   23         27        31
  4       8       12      16      20 RF./CS  24         28        32
</TD></TR></TABLE>
Pin19 RF.RD (oops, should be WR, maybe I've exchanged RD-WR?)<BR>
Pin20 RF./CS (via 10ohm)<BR>
Pin21 RF.CLK (via 10ohm)<BR>
<BR>
<B>Wifi BB Chip: Mitsumi, Japan, 4418, MM3155 (48 pins)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1 GND   7       13 GND     19      25       31         37 TX.MAIN 43
  2       8       14         20      26       32 BB./CS  38 RX.DTA? 44
  3       9       15 BB.CLK  21      27       33 TX.DTA  39 RX.ON   45 GND
  4       10      16 BB.WR   22      28 RST   34 RXTX.ON 40 TX.ON   46
  5       11      17 BB.RD   23      29       35 TX.CLK  41         47
  6       12      18 22MHz   24      30       36         42         48
</TD></TR></TABLE>
Pin15 BB.CLK (via 10ohm to RFU.23)<BR>
Pin16 BB.WR (RFU.25)<BR>
Pin17 BB.RD (RFU.24)<BR>
Pin18 22MHz (via 50ohm)<BR>
Pin28 RST (same as FMW./RES)<BR>
Pin32 BB./CS (RFU.21)<BR>
<BR>
<B>NDS-LITE BB/RF-Chip Mitsumi MM3218 (56 pins)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1-    8-GND   15-    22-GND 29-    36-    43-    50-
  2-GND 9-      16-    23-    30-    37-    44-    51-
  3-    10-GND  17-    24-    31-    38-    45-    52-
  4-    11-GND  18-    25-    32-    39-GND 46-    53-
  5-    12-GND  19-    26-    33-    40-    47-    54-
  6-    13-     20-    27-    34-    41-    48-    55-
  7-    14-     21-    28-    35-    42-    49-GND 56-
</TD></TR></TABLE>
Note: Pinout should be same as in DSi (see DSi pinout for details).<BR>
<BR>
<B>TX Signal/Timing Chart (Host Game)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  RX.DTA?  __________________________________________________________
  RXTX.ON  __-----------------------_________________________________
  RX.ON    __---_______-------------_________________________________
  TX.ON    _____-------______________________________________________
  TX.MAIN  ________----______________________________________________
  TX.CLK   _____#__####______________________________________________
  TX.DTA   _____#__####______________________________________________
</TD></TR></TABLE>
This example shows a host sending beacons. The pre-beacon receive period is
probably to sense conflicts with other transmitters. The post-beacon receive
period is to get responses from other players. The two transmit parts are: The
hardware header, followed by inactivity on the tx pins during the rest of the
preamble period, then followed by the actual IEEE frame. The rest of the time
is spent in idle mode to reduce power consumption.<BR>
<BR>
<B>RX Signal/Timing Chart (Join Game)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  RX.DTA?  __________________________________________________________
  RXTX.ON  -----------------------------------------------______-----
  RX.ON    -----------------------------------------------_________--
  TX.ON    __________________________________________________________
  TX.MAIN  __________________________________________________________
  TX.CLK   __________________________________________________________
  TX.DTA   _______________________________________________---________
</TD></TR></TABLE>
This example shows a client trying to receive beacons, so most of the time is
spent in receive mode (the short idle periods are probably occuring when it is
switching to another channel). Once when it has associated with a host, the
client may spend more time in idle mode, and needs to be in receive mode only
when expecting to receive beacons or other data.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="pinoutsvarious"></A>&nbsp;
  Pinouts - Various
</FONT></TD></TR></TABLE><BR>
<B>Advance Gameboy 256Kbytes RAM 128Kx16bit (NEC D442012LGY-B85x-MJH) (wide)</B><BR>
<B>GBA SP 256Kbytes RAM 128Kx16bit (F 82D12160-10FN) (square)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1 A15   7 A9    13 IC    19 A6   25 A0   31 D2   37 VCC  43 D15
  2 A14   8 A8    14 /UB   20 A5   26 /CE1 32 D10  38 D5   44 D8
  3 A13   9 NC    15 /LB   21 A4   27 GND  33 D3   39 D13  45 D16
  4 A12   10 NC   16 NC    22 A3   28 /OE  34 D11  40 D6   46 GND
  5 A11   11 /WE  17 NC    23 A2   29 D1   35 D4   41 D14  47 NC
  6 A10   12 CE2  18 A7    24 A1   30 D9   36 D12  42 D7   48 A16
</TD></TR></TABLE>
Connection in GBA and GBA SP: IC-GND, /CE1-GND, CE2-VDD2, VCC-VDD2, Pin16-VDD2,
the other NC pins seem to be actually not connected, all other pins connect to
the corresponding Wxx CPU pins. Note: Both GBA and GBA SP have soldering points
for wide (12x18mm) and square (12x14mm) RAMs, so either could be used.<BR>
The GBA additionally contains 32K built-in WRAM, and built-in VRAM, so the
above 256K RAM chip is probably not used in 8bit classic/color gameboy mode.<BR>
Note: In the GBA Micro, the 256K RAM are contained on-chip in the CPU.<BR>
<BR>
<B>Advance Gameboy Schematic Fragments</B><BR>
P2-VSS = VDD-15<BR>
VIN = VCC3 via R33<BR>
REGEXT (on my modified board, REGEXT underneath of my diodes)<BR>
/RES (OUT) (via R40)<BR>
/CS (via R39)<BR>
/WR (via R38)<BR>
SC (via Rxx)<BR>
SD (via Rxx)<BR>
SI (via Rxx)<BR>
SO (via Rxx)<BR>
DCK (via R36)<BR>
A-GND via CP4 (100uF) to GND (used speaker, and on headphone socket)<BR>
<BR>
<B>GBA SP Schematic Fragments</B><BR>
P2VDD = VDD13<BR>
P2VSS = VDD15<BR>
/RES via R46<BR>
/CS via R45<BR>
/WR via R44<BR>
DCK via R20<BR>
VS=BT+<BR>
In my repaired GBA-SP: CK1 test-point is disconnected (instead GND'ed).<BR>
In my repaired GBA-SP: broken oscillator replaced<BR>
In my repaired GBA-SP: broken r1 1mOhm replaced (near oscillator)<BR>
In my repaired GBA-SP: broken EXT2 socket metal-spring/snapper removed<BR>
CL1 FIQ (near SW4)<BR>
CL2 ?<BR>
CL3 ?<BR>
CL4 VOUT1/VDD1 (near U4)<BR>
CL5 VOUT3/VDD3 (near U4)<BR>
CL6 VOUT5/VDD5 (near U4)<BR>
DL1-red (power low) ---R32--Q4--R6--<BR>
DL2-green (power good) ---Q6--LOWBAT/R34-VDD3<BR>
DL3-orange (charge) --R24--Q2--VIN/U57<BR>
P2VDD--VDD13<BR>
P2VSS--VDD15<BR>
S+ and S- are (almost) shortcut by R23 (1.0 ohm)<BR>
S+ via Q1 to VIN<BR>
VS via D1 to S-<BR>
A-GND via CP1 (100uF) to GND<BR>
U4 pin 12 to r6 (towards red led)<BR>
U4 pin 14 to D6---to U7<BR>
SC (CPU pin48) with R7 100K ohm pullup to VDD35<BR>
P35 via Q11 to SW (speaker disable)<BR>
<BR>
<B>GBA SP Backlight-Button Schematic (U6,U8,Q12)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
        ______                _____
  GND--|1 U8 6|-- U85        |     |--VDD5
  U82--|2    5|-- U85    U61-| Q12 |         U83  ------&gt; to display
  U83--|3____4|-- U82        |_____|--Q12B   Q12B &lt;------ from button
  U61--|1 U6 8|--VDD5    (X)---R51--VDD5    (X)---C70--GND
  U62--|2    7|--VDD5    U62---R49--VDD5    U61---R40--GND
  U62--|3    6|--(X)     Q12B--R39--VDD5    U82---R38--GND
  GND--|4____5|--NC?     Q12B--C69--VDD5    U85---R50--U62
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="auxxboopctogbamultibootcable"></A>&nbsp;
  AUX Xboo PC-to-GBA Multiboot Cable
</FONT></TD></TR></TABLE><BR>
Below describes how to connect a PC parallel port to the GBA link port,
allowing to upload small programs (max 256 KBytes) from no$gba's Utility menu
into real GBAs.<BR>
<BR>
This is possible because the GBA BIOS includes a built-in function for
downloading &amp; executing program code even when no cartridge is inserted.
The program is loaded to 2000000h and up in GBA memory, and must contain
cartridge header information just as for normal ROM cartridges (nintendo logo,
checksum, etc., plus some additional multiboot info).<BR>
<BR>
<B>Basic Cable Connection</B><BR>
The general connection is very simple (only needs four wires), the only problem
is that you need a special GBA plug or otherwise need to solder wires directly
to the GBA mainboard (see Examples below).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  GBA  Name  Color                 SUBD CNTR Name
  2    SO    Red     ------------- 10   10   /ACK
  3    SI    Orange  ------------- 14   14   /AUTOLF
  5    SC    Green   ------------- 1    1    /STROBE
  6    GND   Blue    ------------- 19   19   GND
</TD></TR></TABLE>
Optionally, also connect the following signals (see notes below):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4    SD    Brown   ------------- 17   36   /SELECT  (double speed burst)
  3    SI    Orange  ----[===]---- 2..9 2..9 D0..7    (pull-up, 560 Ohm)
  5    SC    Green   ----[===]---- 2..9 2..9 D0..7    (pull-up, 560 Ohm)
  4    SD    Brown   ----[===]---- 2..9 2..9 D0..7    (pull-up, 560 Ohm)
  START  (mainboard) -----|&gt;|----- 16   31   /INIT    (auto-reset, 1N4148)
  SELECT (mainboard) -----|&gt;|----- 16   31   /INIT    (auto-reset, 1N4148)
  RESET  (mainboard) -----||------ 16   31   /INIT    (auto-reset, 300nF)
</TD></TR></TABLE>
Notes: The GBA Pins are arranged from left to right as 2,4,6 in upper row, and
1,3,5 in lower row; outside view of GBA socket; flat side of socket upside. The
above "Colors" are as used in most or all standard Nintendo link cables, note
that Red/Orange will be exchanged at one end in cables with crossed SO/SI
lines. At the PC side, use the SUBD pin numbers when connecting to a 25-pin
SUBD plug, or CNTR pin numbers for 36-pin Centronics plug.<BR>
<BR>
<B>Optional SD Connection (Double Speed Burst)</B><BR>
The SD line is used for Double Speed Burst transfers only, in case that you are
using a gameboy link plug for the connection, and if that plug does not have a
SD-pin (such like from older 8bit gameboy cables), then you may leave out this
connection. Burst Boot will then only work half as fast though.<BR>
<BR>
<B>Optional Pull-Ups (Improves Low-to-High Transition Speed)</B><BR>
If your parallel port works only with medium or slow delay settings, try to
connect 560 Ohm resistors to SI/SC/SD inputs each, and the other resistor pin
to any or all of the parallel port data lines (no$gba outputs high to pins
2..9).<BR>
<BR>
<B>Optional Reset Connection (CAUTION: Connection changed September 2004)</B><BR>
The Reset connection allows to automatically reset &amp; upload data even if a
program in the GBA has locked up (or if you've loaded a program that does not
support nocash burst boot), without having to reset the GBA manually by
switching it off and on (and without having to press Start+Select if a
cartridge is inserted).<BR>
The two diodes should be 1N4148 or similar, the capacitor should be 300nF (eg.
three 100nF capacitors in parallel). The signals are labeled on the mainboard,
and can be found at following names / CPU pin numbers: RESET/CPU.125,
SELECT/TP2/CPU.126, START/TP3/CPU.127.<BR>
<BR>
<B>Optional Power Supply Connection</B><BR>
Also, you may want to connect the power supply to parallel port data lines, see
chapter Power Supply for details.<BR>
<BR>
<B>Transmission Speed</B><BR>
The first transfer will be very slow, and the GBA BIOS will display the boot
logo for at least 4 seconds, even if the transfer has completed in less time.
Once when you have uploaded a program with burst boot backdoor, further
transfers will be ways faster. The table below shows transfer times for 0KByte
- 256KByte files:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Boot Mode_____Delay 0_______Delay 1_______Delay 2_____
  Double Burst  0.1s - 1.8s   0.1s - 3.7s   0.1s - 5.3s
  Single Burst  0.1s - 3.6s   0.1s - 7.1s   0.1s - 10.6s
  Normal Bios   4.0s - 9.0s   4.0s - 12.7s  4.0s - 16.3s
</TD></TR></TABLE>
All timings measured on a 66MHz computer, best possible transmission speed
should be 150KBytes/second. Timings might slightly vary depending on the CPU
speed and/or operating system. Synchronization is done by I/O waitstates, that
should work even on faster computers. Non-zero delays are eventually required
for cables without pull-ups.<BR>
<BR>
<B>Requirements</B><BR>
Beside for the cable and plugs, no special requirements.<BR>
The cable should work with all parallel ports, including old-fashioned
one-directional printer ports, as well as modern bi-directional EPP ports.
Transfer timings should work stable regardless of the PCs CPU speed (see above
though), and regardless of multitasking interruptions.<BR>
Both no$gba and the actual transmission procedure are using some 32bit code, so
that either one currently requires 80386SX CPUs or above.<BR>
<BR>
<B>Connection Examples</B><BR>
As far as I can imagine, there are four possible methods how to connect the
cable to the GBA. The first two methods don't require to open the GBA, and the
other methods also allow to connect optional power supply and reset signal.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1) Connect it to the GBA link port. Advantage: No need to
     open/modify the GBA. Disadvantage: You need a special plug,
     (typically gained by removing it from a gameboy link cable).
  2) Solder the cable directly to the GBA link port pins. Advantages:
     No plug required &amp; no need to open the GBA. Disadvantages:
     You can't remove the cable, and the link port becomes unusable.
  3) Solder the cable directly to the GBA mainboard. Advantage: No
     plug required at the GBA side. Disadvantage: You'll always
     have a cable leaping out of the GBA even when not using it,
     unless you put a small standard plug between GBA and cable.
  4) Install a Centronics socket in the GBA (between power switch
     and headphone socket). Advantage: You can use a standard
     printer cable. Disadvantages: You need to cut a big hole into
     the GBAs battery box (which cannot be used anymore), the big
     cable might be a bit uncomfortable when holding the GBA.
</TD></TR></TABLE>
Personally, I've decided to use the lastmost method as I don't like ending up
with hundreds of special cables for different purposes, and asides, it's been
fun to damage the GAB as much as possible.<BR>
<BR>
<B>Note</B><BR>
The above used PC parallel port signals are typically using 5V=HIGH while GBA
link ports deal with 3V=HIGH. From my experiences, the different voltages do
not cause communication problems (and do not damage the GBA and/or PC
hardware), and after all real men don't care about a handful of volts, however,
use at own risk.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="auxxbooflashcardupload"></A>&nbsp;
  AUX Xboo Flashcard Upload
</FONT></TD></TR></TABLE><BR>
<B>Flashcard Upload</B><BR>
Allows to write data to flashcards which are plugged into GBA cartridge slot,
cartridge is automatically started after writing. On initial power-up, hold
down START+SELECT to prevent the GBA from booting the old program in the
flashcard.<BR>
The Upload function in Utility menu uses flashcard mode for files bigger than
256KB (otherwise uses multiboot mode automatically). Also, there's a separate
Upload to Flashcard function in Remote Access submenu, allowing to write files
of 256KB or less to flashcard if that should be desired.<BR>
<BR>
<B>Supported Flashcards</B><BR>
Function currently tested with Visoly Flash Advance (FA) 256Mbit (32MB) Turbo
cartridge. Should also work with older FA versions. Please let me know if you
are using other flashcards which aren't yet supported.<BR>
<BR>
<B>Flashcard Performance</B><BR>
Writing to flashcards may become potentially slow because of chip erase/write
times, cable transmission time, and the sheer size of larger ROM-images.
However, developers whom are testing different builts of their project usually
won't need to rewrite the complete flashcard, Xboo uses a highspeed checksum
mechanism (16MB/sec) to determine which flashcard sector(s) have changed, and
does then re-write only these sector(s).<BR>
To eliminate transmission time, data transfer takes place in the erase phases.
Erase/write time depends on the flashcard type, should be circa 1-2 seconds per
256KB sector. Because the cartridge is programmed directly in the GBA there's
no need to remove it from the GBA when writing to it.<BR>
<BR>
<B>Developers Advice</B><BR>
Locate your program fragments at fixed addresses, for example, code and data
blocks each aligned to 64K memory boundaries, so that data remains at the same
location even when the size of code changes. Fill any blank spaces by value FFh
for faster write time. Reduce the size of your ROM-image by efficient memory
use (except for above alignment trick). Include the burst boot backdoor in your
program, allowing to re-write the flashcard directly without resetting the GBA.<BR>
<BR>
<B>Lamers Advice</B><BR>
Xboo Flashcard support does not mean to get lame &amp; to drop normal multiboot
support, if your program fits into 256KB then make it &lt;both&gt; flashcard
&lt;and&gt; multiboot compatible - multiboot reduces upload time, increases
your flashcard lifetime, and will also work for people whom don't own
flashcards.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="auxxbooburstbootbackdoor"></A>&nbsp;
  AUX Xboo Burst Boot Backdoor
</FONT></TD></TR></TABLE><BR>
When writing Xboo compatible programs, always include a burst boot "backdoor",
this will allow yourself (and other people) to upload programs much faster as
when using the normal GBA BIOS multiboot function. Aside from the improved
transmission speed, there's no need to reset the GBA each time (eventually
manually if you do not have reset connect), without having to press
Start+Select (if cartridge inserted), and, most important, the time-consuming
nintendo-logo intro is bypassed.<BR>
<BR>
<B>The Burst Boot Protocol</B><BR>
In your programs IRQ handler, add some code that watches out for burst boot IRQ
requests. When sensing a burst boot request, download the actual boot
procedure, and pass control to that procedure.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Send (PC)    Reply (GBA)
  "BRST"       "BOOT"        ;request burst, and reply &lt;prepared&gt; for boot
  &lt;wait 1/16s&gt; &lt;process IRQ&gt; ;long delay, allow slave to enter IRQ handler
  llllllll     "OKAY"        ;send length in bytes, reply &lt;ready&gt; to boot
  dddddddd     --------      ;send data in 32bit units, reply don't care
  cccccccc     cccccccc      ;exchange crc (all data units added together)
</TD></TR></TABLE>
Use normal mode, 32bit, external clock for all transfers. The received
highspeed loader (currently approx. 180h bytes) is to be loaded to and started
at 3000000h, which will then handle the actual download operation.<BR>
<BR>
Below is an example program which works with multiboot, burstboot, and as
normal rom/flashcard. The source can be assembled with a22i (the no$gba
built-in assembler, see no$gba utility menu). When using other/mainstream
assemblers, you'll eventually have to change some directives, convert numbers
from NNNh into 0xNNN format, and define the origin somewhere in linker/makefile
instead of in source code.<BR>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 .arm            ;select 32bit ARM instruction set
 .gba            ;indicate that it's a gameboy advance program
 .fix            ;automatically fix the cartridge header checksum
 org 2000000h    ;origin in RAM for multiboot-cable/no$gba-cutdown programs
 ;------------------
 ;cartridge header/multiboot header
  b     rom_start                ;-rom entry point
  dcb   ...insert logo here...   ;-nintento logo (156 bytes)
  dcb   'XBOO SAMPLE '           ;-title (12 bytes)
  dcb   0,0,0,0,  0,0            ;-game code (4 bytes), maker code (2 bytes)
  dcb   96h,0,0                  ;-fixed value 96h, main unit code, device type
  dcb   0,0,0,0,0,0,0            ;-reserved (7 bytes)
  dcb   0                        ;-software version number
  dcb   0                        ;-header checksum (set by .fix)
  dcb   0,0                      ;-reserved (2 bytes)
  b     ram_start                ;-multiboot ram entry point
  dcb   0,0                      ;-multiboot reserved bytes (destroyed by BIOS)
  dcb   0,0                      ;-blank padded (32bit alignment)
 ;------------------
 irq_handler:  ;interrupt handler (note: r0-r3 are pushed by BIOS)
  mov    r1,4000000h             ;\get I/O base address,
  ldr    r0,[r1,200h] ;IE/IF     ; read IE and IF,
  and    r0,r0,r0,lsr 16         ; isolate occurred AND enabled irqs,
  add    r3,r1,200h   ;IF        ; and acknowledge these in IF
  strh   r0,[r3,2]               ;/
  ldrh   r3,[r1,-8]              ;\mix up with BIOS irq flags at 3007FF8h,
  orr    r3,r3,r0                ; aka mirrored at 3FFFFF8h, this is required
  strh   r3,[r1,-8]              ;/when using the (VBlank-)IntrWait functions
  and    r3,r0,80h ;IE/IF.7 SIO  ;\
  cmp    r3,80h                  ; check if it's a burst boot interrupt
  ldreq  r2,[r1,120h] ;SIODATA32 ; (if interrupt caused by serial transfer,
  ldreq  r3,[msg_brst]           ; and if received data is "BRST",
  cmpeq  r2,r3                   ; then jump to burst boot)
  beq    burst_boot              ;/
  ;... insert your own interrupt handler code here ...
  bx     lr                      ;-return to the BIOS interrupt handler
 ;------------------
 burst_boot:     ;requires incoming r1=4000000h
  ;... if your program uses DMA, disable any active DMA transfers here ...
  ldr   r4,[msg_okay]            ;\
  bl    sio_transfer             ; receive transfer length/bytes &amp; reply "OKAY"
  mov   r2,r0 ;len               ;/
  mov   r3,3000000h   ;dst       ;\
  mov   r4,0  ;crc               ;
 @@lop:                          ;
  bl    sio_transfer             ; download burst loader to 3000000h and up
  stmia [r3]!,r0      ;dst       ;
  add   r4,r4,r0      ;crc       ;
  subs  r2,r2,4       ;len       ;
  bhi   @@lop                    ;/
  bl    sio_transfer             ;-send crc value to master
  b     3000000h  ;ARM state!    ;-launch actual transfer / start the loader
 ;------------------
 sio_transfer:  ;serial transfer subroutine, 32bit normal mode, external clock
  str   r4,[r1,120h]  ;siodata32 ;-set reply/send data
  ldr   r0,[r1,128h]  ;siocnt    ;\
  orr   r0,r0,80h                ; activate slave transfer
  str   r0,[r1,128h]  ;siocnt    ;/
 @@wait:                         ;\
  ldr   r0,[r1,128h]  ;siocnt    ; wait until transfer completed
  tst   r0,80h                   ;
  bne   @@wait                   ;/
  ldr   r0,[r1,120h]  ;siodata32 ;-get received data
  bx    lr
 ;---
 msg_boot dcb 'BOOT'     ;\
 msg_okay dcb "OKAY"     ; ID codes for the burstboot protocol
 msg_brst dcb "BRST"     ;/
 ;------------------
 download_rom_to_ram:
  mov  r0,8000000h  ;src/rom     ;\
  mov  r1,2000000h  ;dst/ram     ;
  mov  r2,40000h/16 ;length      ; transfer the ROM content
 @@lop:                          ; into RAM (done in units of 4 words/16 bytes)
  ldmia [r0]!,r4,r5,r6,r7        ; currently fills whole 256K of RAM,
  stmia [r1]!,r4,r5,r6,r7        ; even though the proggy is smaller
  subs  r2,r2,1                  ;
  bne   @@lop                    ;/
  sub   r15,lr,8000000h-2000000h ;-return (retadr rom/8000XXXh -&gt; ram/2000XXXh)
 ;------------------
 init_interrupts:
  mov  r4,4000000h               ;-base address for below I/O registers
  ldr  r0,=irq_handler           ;\install IRQ handler address
  str  r0,[r4,-4]   ;IRQ HANDLER ;/at 3FFFFFC aka 3007FFC
  mov  r0,0008h                  ;\enable generating vblank irqs
  strh r0,[r4,4h]   ;DISPSTAT    ;/
  mrs  r0,cpsr                   ;\
  bic  r0,r0,80h                 ; cpu interrupt enable (clear i-flag)
  msr  cpsr,r0                   ;/
  mov  r0,0                      ;\
  str  r0,[r4,134h] ;RCNT        ; init SIO normal mode, external clock,
  ldr  r0,=5080h                 ; 32bit, IRQ enable, transfer started
  str  r0,[r4,128h] ;SIOCNT      ; output "BOOT" (indicate burst boot prepared)
  ldr  r0,[msg_boot]             ;
  str  r0,[r4,120h] ;SIODATA32   ;/
  mov  r0,1                      ;\interrupt master enable
  str  r0,[r4,208h] ;IME=1       ;/
  mov  r0,81h                    ;\enable execution of vblank IRQs,
  str  r0,[r4,200h] ;IE=81h      ;/and of SIO IRQs (burst boot)
  bx   lr
 ;------------------
 rom_start:   ;entry point when booted from flashcart/rom
  bl   download_rom_to_ram       ;-download ROM to RAM (returns to ram_start)
 ram_start:   ;entry point for multiboot/burstboot
  mov  r0,0feh                   ;\reset all registers, and clear all memory
  swi  10000h ;RegisterRamReset  ;/(except program code in wram at 2000000h)
  bl   init_interrupts           ;-install burst boot irq handler
  mov  r4,4000000h               ;\enable video,
  strh r4,[r4,000h] ;DISPCNT     ;/by clearing the forced blank bit
 @@mainloop:
  swi  50000h ;VBlankIntrWait    ;-wait one frame (cpu in low power mode)
  mov  r5,5000000h               ;\increment the backdrop palette color
  str  r8,[r5]                   ; (ie. display a blinking screen)
  add  r8,r8,1                   ;/
  b    @@mainloop
 ;------------------
 .pool
 end
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="aboutthisdocument"></A>&nbsp;
  About this Document
</FONT></TD></TR></TABLE><BR>
<B>About</B><BR>
GBATEK written 2001-2014 by Martin Korth, programming specs for the GBA and NDS
hardware, I've been trying to keep the specs both as short as possible, and as
complete as possible. The document is part of the no$gba debuggers built-in
help text.<BR>
<BR>
<B>Updates</B><BR>
The standalone docs in TXT and HTM format are updated when having added any
major changes to the document. The no$gba built-in version will be updated more
regularly, including for minor changes, along with all no$gba updates.<BR>
<BR>
<B>Homepage</B><BR>
http://problemkaputt.de/gba.htm - no$gba emulator homepage (freeware)<BR>
http://problemkaputt.de/gba-dev.htm - no$gba debugger homepage<BR>
http://problemkaputt.de/gbapics.htm - no$gba debugger screenshots<BR>
http://problemkaputt.de/gbatek.htm - gbatek html version<BR>
http://problemkaputt.de/gbatek.txt - gbatek text version<BR>
<BR>
<B>Feedback</B><BR>
If you find any information in this document to be misleading, incomplete, or
incorrect, please say something! My spam-shielded email address is found at:<BR>
http://problemkaputt.de/email.htm - contact<BR>
Mail from programmers only, please. No gaming questions, thanks.<BR>
<BR>
<B>Credits</B><BR>
Thanks for GBATEK fixes, and for info about GBA and NDS hardware,<BR>
- Jasper Vijn<BR>
- Remi Veilleux (DS video details)<BR>
- Randy Linden<BR>
- Sebastian Rasmussen<BR>
- Stephen Stair (DS Wifi)<BR>
- Cue (DS Firmware bits and bytes)<BR>
- Tim Seidel (DS Wifi RF2958 datasheet)<BR>
- Damien Good (DS Bios Dumping, and lots of e-Reader info)<BR>
- Kenobi and Dualscreenman (lots of ARDS/CBDS cheat info)<BR>
- Flubba (GBA X/Y-Axis tilt sensor, and GBA Gameboy Player info)<BR>
- DarkFader (DS Key2)<BR>
- Dstek by neimod (DS Sound)<BR>
- Christian Auby<BR>
- Jeff Frohwein<BR>
- NDSTech Wiki, http://www.bottledlight.com/ds/ (lots of DS info)<BR>
<BR>
<B>Formatting</B><BR>
TXT is 80 columns, TXT is 80 columns, TXT is 80 columns.<BR>
Don't trust anything else. Never.<BR>
<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR bgcolor="#cccccc"><TD><FONT SIZE=+2>
  <A NAME="index"></A>&nbsp;
  Index
</FONT></TD></TR></TABLE><BR>
<A HREF="#contents">Contents</A><BR>
<A HREF="#gbareference">GBA Reference</A><BR>
<A HREF="#gbatechnicaldata">GBA Technical Data</A><BR>
<A HREF="#gbamemorymap">GBA Memory Map</A><BR>
<A HREF="#gbaiomap">GBA I/O Map</A><BR>
<A HREF="#gbalcdvideocontroller">GBA LCD Video Controller</A><BR>
<A HREF="#lcdiodisplaycontrol">LCD I/O Display Control</A><BR>
<A HREF="#lcdiointerruptsandstatus">LCD I/O Interrupts and Status</A><BR>
<A HREF="#lcdiobgcontrol">LCD I/O BG Control</A><BR>
<A HREF="#lcdiobgscrolling">LCD I/O BG Scrolling</A><BR>
<A HREF="#lcdiobgrotationscaling">LCD I/O BG Rotation/Scaling</A><BR>
<A HREF="#lcdiowindowfeature">LCD I/O Window Feature</A><BR>
<A HREF="#lcdiomosaicfunction">LCD I/O Mosaic Function</A><BR>
<A HREF="#lcdiocolorspecialeffects">LCD I/O Color Special Effects</A><BR>
<A HREF="#lcdvramoverview">LCD VRAM Overview</A><BR>
<A HREF="#lcdvramcharacterdata">LCD VRAM Character Data</A><BR>
<A HREF="#lcdvrambgscreendataformatbgmap">LCD VRAM BG Screen Data Format (BG Map)</A><BR>
<A HREF="#lcdvrambitmapbgmodes">LCD VRAM Bitmap BG Modes</A><BR>
<A HREF="#lcdobjoverview">LCD OBJ - Overview</A><BR>
<A HREF="#lcdobjoamattributes">LCD OBJ - OAM Attributes</A><BR>
<A HREF="#lcdobjoamrotationscalingparameters">LCD OBJ - OAM Rotation/Scaling Parameters</A><BR>
<A HREF="#lcdobjvramcharactertilemapping">LCD OBJ - VRAM Character (Tile) Mapping</A><BR>
<A HREF="#lcdcolorpalettes">LCD Color Palettes</A><BR>
<A HREF="#lcddimensionsandtimings">LCD Dimensions and Timings</A><BR>
<A HREF="#gbasoundcontroller">GBA Sound Controller</A><BR>
<A HREF="#gbasoundchannel1tonesweep">GBA Sound Channel 1 - Tone &amp; Sweep</A><BR>
<A HREF="#gbasoundchannel2tone">GBA Sound Channel 2 - Tone</A><BR>
<A HREF="#gbasoundchannel3waveoutput">GBA Sound Channel 3 - Wave Output</A><BR>
<A HREF="#gbasoundchannel4noise">GBA Sound Channel 4 - Noise</A><BR>
<A HREF="#gbasoundchannelaandbdmasound">GBA Sound Channel A and B - DMA Sound</A><BR>
<A HREF="#gbasoundcontrolregisters">GBA Sound Control Registers</A><BR>
<A HREF="#gbacomparisonofcgbandgbasound">GBA Comparison of CGB and GBA Sound</A><BR>
<A HREF="#gbatimers">GBA Timers</A><BR>
<A HREF="#gbadmatransfers">GBA DMA Transfers</A><BR>
<A HREF="#gbacommunicationports">GBA Communication Ports</A><BR>
<A HREF="#sionormalmode">SIO Normal Mode</A><BR>
<A HREF="#siomultiplayermode">SIO Multi-Player Mode</A><BR>
<A HREF="#siouartmode">SIO UART Mode</A><BR>
<A HREF="#siojoybusmode">SIO JOY BUS Mode</A><BR>
<A HREF="#siogeneralpurposemode">SIO General-Purpose Mode</A><BR>
<A HREF="#siocontrolregisterssummary">SIO Control Registers Summary</A><BR>
<A HREF="#gbawirelessadapter">GBA Wireless Adapter</A><BR>
<A HREF="#gbawirelessadaptergames">GBA Wireless Adapter Games</A><BR>
<A HREF="#gbawirelessadapterlogin">GBA Wireless Adapter Login</A><BR>
<A HREF="#gbawirelessadaptercommands">GBA Wireless Adapter Commands</A><BR>
<A HREF="#gbawirelessadaptercomponentlists">GBA Wireless Adapter Component Lists</A><BR>
<A HREF="#gbainfraredcommunication">GBA Infrared Communication</A><BR>
<A HREF="#gbakeypadinput">GBA Keypad Input</A><BR>
<A HREF="#gbainterruptcontrol">GBA Interrupt Control</A><BR>
<A HREF="#gbasystemcontrol">GBA System Control</A><BR>
<A HREF="#gbagamepakprefetch">GBA GamePak Prefetch</A><BR>
<A HREF="#gbacartridges">GBA Cartridges</A><BR>
<A HREF="#gbacartridgeheader">GBA Cartridge Header</A><BR>
<A HREF="#gbacartridgerom">GBA Cartridge ROM</A><BR>
<A HREF="#gbacartbackupids">GBA Cart Backup IDs</A><BR>
<A HREF="#gbacartbackupsramfram">GBA Cart Backup SRAM/FRAM</A><BR>
<A HREF="#gbacartbackupeeprom">GBA Cart Backup EEPROM</A><BR>
<A HREF="#gbacartbackupflashrom">GBA Cart Backup Flash ROM</A><BR>
<A HREF="#gbacartbackupdacs">GBA Cart Backup DACS</A><BR>
<A HREF="#gbacartioportgpio">GBA Cart I/O Port (GPIO)</A><BR>
<A HREF="#gbacartrealtimeclockrtc">GBA Cart Real-Time Clock (RTC)</A><BR>
<A HREF="#gbacartsolarsensor">GBA Cart Solar Sensor</A><BR>
<A HREF="#gbacarttiltsensor">GBA Cart Tilt Sensor</A><BR>
<A HREF="#gbacartgyrosensor">GBA Cart Gyro Sensor</A><BR>
<A HREF="#gbacartrumble">GBA Cart Rumble</A><BR>
<A HREF="#gbacartereader">GBA Cart e-Reader</A><BR>
<A HREF="#gbacartereaderoverview">GBA Cart e-Reader Overview</A><BR>
<A HREF="#gbacartereaderioports">GBA Cart e-Reader I/O Ports</A><BR>
<A HREF="#gbacartereaderdotcodeformat">GBA Cart e-Reader Dotcode Format</A><BR>
<A HREF="#gbacartereaderdataformat">GBA Cart e-Reader Data Format</A><BR>
<A HREF="#gbacartereaderprogramcode">GBA Cart e-Reader Program Code</A><BR>
<A HREF="#gbacartereaderapifunctions">GBA Cart e-Reader API Functions</A><BR>
<A HREF="#gbacartereadervpkdecompression">GBA Cart e-Reader VPK Decompression</A><BR>
<A HREF="#gbacartereadererrorcorrection">GBA Cart e-Reader Error Correction</A><BR>
<A HREF="#gbacartereaderfileformats">GBA Cart e-Reader File Formats</A><BR>
<A HREF="#gbacartunknowndevices">GBA Cart Unknown Devices</A><BR>
<A HREF="#gbacartprotections">GBA Cart Protections</A><BR>
<A HREF="#gbaflashcards">GBA Flashcards</A><BR>
<A HREF="#gbacheatdevices">GBA Cheat Devices</A><BR>
<A HREF="#gbacheatcodesgeneralinfo">GBA Cheat Codes - General Info</A><BR>
<A HREF="#gbacheatcodescodebreakerxploder">GBA Cheat Codes - Codebreaker/Xploder</A><BR>
<A HREF="#gbacheatcodesgamesharkactionreplayv1v2">GBA Cheat Codes - Gameshark/Action Replay V1/V2</A><BR>
<A HREF="#gbacheatcodesproactionreplayv3">GBA Cheat Codes - Pro Action Replay V3</A><BR>
<A HREF="#gbagameboyplayer">GBA Gameboy Player</A><BR>
<A HREF="#gbaunpredictablethings">GBA Unpredictable Things</A><BR>
<A HREF="#ndsreference">NDS Reference</A><BR>
<A HREF="#dstechnicaldata">DS Technical Data</A><BR>
<A HREF="#dsiomaps">DS I/O Maps</A><BR>
<A HREF="#dsmemorymaps">DS Memory Maps</A><BR>
<A HREF="#dsmemorycontrol">DS Memory Control</A><BR>
<A HREF="#dsmemorycontrolcacheandtcm">DS Memory Control - Cache and TCM</A><BR>
<A HREF="#dsmemorycontrolcartridgesandmainram">DS Memory Control - Cartridges and Main RAM</A><BR>
<A HREF="#dsmemorycontrolwram">DS Memory Control - WRAM</A><BR>
<A HREF="#dsmemorycontrolvram">DS Memory Control - VRAM</A><BR>
<A HREF="#dsmemorycontrolbios">DS Memory Control - BIOS</A><BR>
<A HREF="#dsmemorytimings">DS Memory Timings</A><BR>
<A HREF="#dsvideo">DS Video</A><BR>
<A HREF="#dsvideostuff">DS Video Stuff</A><BR>
<A HREF="#dsvideobgmodescontrol">DS Video BG Modes / Control</A><BR>
<A HREF="#dsvideoobjs">DS Video OBJs</A><BR>
<A HREF="#dsvideoextendedpalettes">DS Video Extended Palettes</A><BR>
<A HREF="#dsvideocaptureandmainmemorydisplaymode">DS Video Capture and Main Memory Display Mode</A><BR>
<A HREF="#dsvideodisplaysystemblockdiagram">DS Video Display System Block Diagram</A><BR>
<A HREF="#ds3dvideo">DS 3D Video</A><BR>
<A HREF="#ds3doverview">DS 3D Overview</A><BR>
<A HREF="#ds3diomap">DS 3D I/O Map</A><BR>
<A HREF="#ds3ddisplaycontrol">DS 3D Display Control</A><BR>
<A HREF="#ds3dgeometrycommands">DS 3D Geometry Commands</A><BR>
<A HREF="#ds3dmatrixloadmultiply">DS 3D Matrix Load/Multiply</A><BR>
<A HREF="#ds3dmatrixtypes">DS 3D Matrix Types</A><BR>
<A HREF="#ds3dmatrixstack">DS 3D Matrix Stack</A><BR>
<A HREF="#ds3dmatrixexamplesprojection">DS 3D Matrix Examples (Projection)</A><BR>
<A HREF="#ds3dmatrixexamplesrotatescaletranslate">DS 3D Matrix Examples (Rotate/Scale/Translate)</A><BR>
<A HREF="#ds3dmatrixexamplesmathsbasics">DS 3D Matrix Examples (Maths Basics)</A><BR>
<A HREF="#ds3dpolygonattributes">DS 3D Polygon Attributes</A><BR>
<A HREF="#ds3dpolygondefinitionsbyvertices">DS 3D Polygon Definitions by Vertices</A><BR>
<A HREF="#ds3dpolygonlightparameters">DS 3D Polygon Light Parameters</A><BR>
<A HREF="#ds3dshadowpolygons">DS 3D Shadow Polygons</A><BR>
<A HREF="#ds3dtextureattributes">DS 3D Texture Attributes</A><BR>
<A HREF="#ds3dtextureformats">DS 3D Texture Formats</A><BR>
<A HREF="#ds3dtexturecoordinates">DS 3D Texture Coordinates</A><BR>
<A HREF="#ds3dtextureblending">DS 3D Texture Blending</A><BR>
<A HREF="#ds3dtoonedgefogalphablendingantialiasing">DS 3D Toon, Edge, Fog, Alpha-Blending, Anti-Aliasing</A><BR>
<A HREF="#ds3dstatus">DS 3D Status</A><BR>
<A HREF="#ds3dtests">DS 3D Tests</A><BR>
<A HREF="#ds3drearplane">DS 3D Rear-Plane</A><BR>
<A HREF="#ds3dfinal2doutput">DS 3D Final 2D Output</A><BR>
<A HREF="#dssound">DS Sound</A><BR>
<A HREF="#dssoundchannels015">DS Sound Channels 0..15</A><BR>
<A HREF="#dssoundcontrolregisters">DS Sound Control Registers</A><BR>
<A HREF="#dssoundcapture">DS Sound Capture</A><BR>
<A HREF="#dssoundblockdiagrams">DS Sound Block Diagrams</A><BR>
<A HREF="#dssoundnotes">DS Sound Notes</A><BR>
<A HREF="#dssystemandbuiltinperipherals">DS System and Built-in Peripherals</A><BR>
<A HREF="#dsdmatransfers">DS DMA Transfers</A><BR>
<A HREF="#dstimers">DS Timers</A><BR>
<A HREF="#dsinterrupts">DS Interrupts</A><BR>
<A HREF="#dsmaths">DS Maths</A><BR>
<A HREF="#dsinterprocesscommunicationipc">DS Inter Process Communication (IPC)</A><BR>
<A HREF="#dskeypad">DS Keypad</A><BR>
<A HREF="#dsabsentlinkport">DS Absent Link Port</A><BR>
<A HREF="#dsrealtimeclockrtc">DS Real-Time Clock (RTC)</A><BR>
<A HREF="#dsserialperipheralinterfacebusspi">DS Serial Peripheral Interface Bus (SPI)</A><BR>
<A HREF="#dstouchscreencontrollertsc">DS Touch Screen Controller (TSC)</A><BR>
<A HREF="#dspowermanagement">DS Power Management</A><BR>
<A HREF="#dsmainmemorycontrol">DS Main Memory Control</A><BR>
<A HREF="#dsbackwardscompatiblegbamode">DS Backwards-compatible GBA-Mode</A><BR>
<A HREF="#dsdebugregistersemulatordevkits">DS Debug Registers (Emulator/Devkits)</A><BR>
<A HREF="#dscartridgesencryptionfirmware">DS Cartridges, Encryption, Firmware</A><BR>
<A HREF="#dscartridgeheader">DS Cartridge Header</A><BR>
<A HREF="#dscartridgesecurearea">DS Cartridge Secure Area</A><BR>
<A HREF="#dscartridgeicontitle">DS Cartridge Icon/Title</A><BR>
<A HREF="#dscartridgeprotocol">DS Cartridge Protocol</A><BR>
<A HREF="#dscartridgebackup">DS Cartridge Backup</A><BR>
<A HREF="#dscartridgeioports">DS Cartridge I/O Ports</A><BR>
<A HREF="#dscartridgenitroromandnitroarcfilesystems">DS Cartridge NitroROM and NitroARC File Systems</A><BR>
<A HREF="#dscartridgepassmepassthrough">DS Cartridge PassMe/PassThrough</A><BR>
<A HREF="#dscartridgegbaslot">DS Cartridge GBA Slot</A><BR>
<A HREF="#dscartrumblepak">DS Cart Rumble Pak</A><BR>
<A HREF="#dscartsliderwithrumble">DS Cart Slider with Rumble</A><BR>
<A HREF="#dscartexpansionram">DS Cart Expansion RAM</A><BR>
<A HREF="#dscartunknownextras">DS Cart Unknown Extras</A><BR>
<A HREF="#dscartcheatactionreplayds">DS Cart Cheat Action Replay DS</A><BR>
<A HREF="#dscartcheatcodebreakerds">DS Cart Cheat Codebreaker DS</A><BR>
<A HREF="#dsencryptionbygamecodeidcodekey1">DS Encryption by Gamecode/Idcode (KEY1)</A><BR>
<A HREF="#dsencryptionbyrandomseedkey2">DS Encryption by Random Seed (KEY2)</A><BR>
<A HREF="#dsfirmwareserialflashmemory">DS Firmware Serial Flash Memory</A><BR>
<A HREF="#dsfirmwareheader">DS Firmware Header</A><BR>
<A HREF="#dsfirmwarewificalibrationdata">DS Firmware Wifi Calibration Data</A><BR>
<A HREF="#dsfirmwarewifiinternetaccesspoints">DS Firmware Wifi Internet Access Points</A><BR>
<A HREF="#dsfirmwareusersettings">DS Firmware User Settings</A><BR>
<A HREF="#dsfirmwareextendedsettings">DS Firmware Extended Settings</A><BR>
<A HREF="#dswirelesscommunications">DS Wireless Communications</A><BR>
<A HREF="#dswifiiomap">DS Wifi I/O Map</A><BR>
<A HREF="#dswificontrol">DS Wifi Control</A><BR>
<A HREF="#dswifiinterrupts">DS Wifi Interrupts</A><BR>
<A HREF="#dswifipowerdownregisters">DS Wifi Power-Down Registers</A><BR>
<A HREF="#dswifireceivecontrol">DS Wifi Receive Control</A><BR>
<A HREF="#dswifireceivebuffer">DS Wifi Receive Buffer</A><BR>
<A HREF="#dswifireceivestatistics">DS Wifi Receive Statistics</A><BR>
<A HREF="#dswifitransmitcontrol">DS Wifi Transmit Control</A><BR>
<A HREF="#dswifitransmitbuffers">DS Wifi Transmit Buffers</A><BR>
<A HREF="#dswifitransmiterrors">DS Wifi Transmit Errors</A><BR>
<A HREF="#dswifistatus">DS Wifi Status</A><BR>
<A HREF="#dswifitimers">DS Wifi Timers</A><BR>
<A HREF="#dswifimultiplaymaster">DS Wifi Multiplay Master</A><BR>
<A HREF="#dswifimultiplayslave">DS Wifi Multiplay Slave</A><BR>
<A HREF="#dswificonfigurationports">DS Wifi Configuration Ports</A><BR>
<A HREF="#dswifibasebandchipbb">DS Wifi Baseband Chip (BB)</A><BR>
<A HREF="#dswifirfchip">DS Wifi RF Chip</A><BR>
<A HREF="#dswifirf9008registers">DS Wifi RF9008 Registers</A><BR>
<A HREF="#dswifiunknownregisters">DS Wifi Unknown Registers</A><BR>
<A HREF="#dswifiunusedregisters">DS Wifi Unused Registers</A><BR>
<A HREF="#dswifiinitialization">DS Wifi Initialization</A><BR>
<A HREF="#dswififlowcharts">DS Wifi Flowcharts</A><BR>
<A HREF="#dswifihardwareheaders">DS Wifi Hardware Headers</A><BR>
<A HREF="#dswifimultiboot">DS Wifi Multiboot</A><BR>
<A HREF="#dswifiieee80211frames">DS Wifi IEEE802.11 Frames</A><BR>
<A HREF="#dswifiieee80211managmentframestype0">DS Wifi IEEE802.11 Managment Frames (Type=0)</A><BR>
<A HREF="#dswifiieee80211controlanddataframestype1and2">DS Wifi IEEE802.11 Control and Data Frames (Type=1 and 2)</A><BR>
<A HREF="#dsxboo">DS Xboo</A><BR>
<A HREF="#dsireference">DSi Reference</A><BR>
<A HREF="#dsibasicdifferencestonds">DSi Basic Differences to NDS</A><BR>
<A HREF="#dsiiomap">DSi I/O Map</A><BR>
<A HREF="#dsicontrolregistersscfg">DSi Control Registers (SCFG)</A><BR>
<A HREF="#dsixpertteakdsp">DSi XpertTeak (DSP)</A><BR>
<A HREF="#dsinewsharedwramforarm7arm9dsp">DSi New Shared WRAM (for ARM7, ARM9, DSP)</A><BR>
<A HREF="#dsinewdma">DSi New DMA</A><BR>
<A HREF="#dsisoundext">DSi SoundExt</A><BR>
<A HREF="#dsiadvancedencryptionstandardaes">DSi Advanced Encryption Standard (AES)</A><BR>
<A HREF="#dsiaesioports">DSi AES I/O Ports</A><BR>
<A HREF="#dsiaeslittleendianhighlevelfunctions">DSi AES Little-Endian High Level Functions</A><BR>
<A HREF="#dsiaeslittleendiancorefunctionandkeyschedule">DSi AES Little-Endian Core Function and Key Schedule</A><BR>
<A HREF="#dsiaeslittleendiantablesandtestvalues">DSi AES Little-Endian Tables and Test Values</A><BR>
<A HREF="#dsiaesbigendianhighlevelfunctions">DSi AES Big-Endian High Level Functions</A><BR>
<A HREF="#dsiaesbigendiancorefunctionandkeyschedule">DSi AES Big-Endian Core Function and Key Schedule</A><BR>
<A HREF="#dsiaesbigendiantablesandtestvalues">DSi AES Big-Endian Tables and Test Values</A><BR>
<A HREF="#dsiesblockencryption">DSi ES Block Encryption</A><BR>
<A HREF="#dsicartridgeheader">DSi Cartridge Header</A><BR>
<A HREF="#dsitouchscreensoundcontroller">DSi Touchscreen/Sound Controller</A><BR>
<A HREF="#dsitouchscreenaccess">DSi Touchscreen Access</A><BR>
<A HREF="#dsitscregistersummary">DSi TSC, Register Summary</A><BR>
<A HREF="#dsitsc000h1ahbasicpllandtimingcontrol">DSi TSC[0:00h..1Ah], Basic PLL and Timing Control</A><BR>
<A HREF="#dsitsc01bh23hcodeccontrol">DSi TSC[0:1Bh..23h], Codec Control</A><BR>
<A HREF="#dsitsc024h32hstatusandinterruptflags">DSi TSC[0:24h..32h], Status and Interrupt Flags</A><BR>
<A HREF="#dsitsc033h3bhpincontrol">DSi TSC[0:33h..3Bh], Pin Control</A><BR>
<A HREF="#dsitsc03ch55hdacadcandbeep">DSi TSC[0:3Ch..55h], DAC/ADC and Beep</A><BR>
<A HREF="#dsitsc056h7fhagcandadc">DSi TSC[0:56h..7Fh], AGC and ADC</A><BR>
<A HREF="#dsitsc1xxhdacandadcroutingpgapowercontrolsandmisclogic">DSi TSC[1:xxh], DAC and ADC Routing, PGA, Power-Controls and MISC Logic</A><BR>
<A HREF="#dsitsc3xxhtouchscreensarcontrolandtscfchxxhbuffer">DSi TSC[3:xxh], Touchscreen/SAR Control and TSC[FCh:xxh], Buffer</A><BR>
<A HREF="#dsitsc04h05hxxhadcdigitalfiltercoefficientram">DSi TSC[04h..05h:xxh], ADC Digital Filter Coefficient RAM</A><BR>
<A HREF="#dsitsc08h0fhxxhdacdigitalfiltercoefficientram">DSi TSC[08h..0Fh:xxh], DAC Digital Filter Coefficient RAM</A><BR>
<A HREF="#dsitsc20h2bhxxhtsc40h5fhxxhadcdacinstructionram">DSi TSC[20h..2Bh:xxh], TSC[40h..5Fh:xxh] ADC/DAC Instruction RAM</A><BR>
<A HREF="#dsii2cbus">DSi I2C Bus</A><BR>
<A HREF="#dsii2cioports">DSi I2C I/O Ports</A><BR>
<A HREF="#dsii2csignals">DSi I2C Signals</A><BR>
<A HREF="#dsii2cdevice4ahbptwlchip">DSi I2C Device 4Ah (BPTWL chip)</A><BR>
<A HREF="#dsiaptinacamerainitialization">DSi Aptina Camera Initialization</A><BR>
<A HREF="#dsiaptinacameraregisterssysctl0000h0051h">DSi Aptina Camera Registers: SYSCTL (0000h-0051h)</A><BR>
<A HREF="#dsiaptinacameraregistersrxssfusexdma0100h099fh">DSi Aptina Camera Registers: RX_SS, FUSE, XDMA (0100h-099Fh)</A><BR>
<A HREF="#dsiaptinacameraregisterscore3000h31ffh38xxh">DSi Aptina Camera Registers: CORE (3000h-31FFh, 38xxh)</A><BR>
<A HREF="#dsiaptinacameraregisterssoc13210h33fdh">DSi Aptina Camera Registers: SOC1 (3210h-33FDh)</A><BR>
<A HREF="#dsiaptinacameraregisterssoc23400h3729h">DSi Aptina Camera Registers: SOC2 (3400h-3729h)</A><BR>
<A HREF="#dsiaptinacameravariablesramsfrmongpiomonitormcu0000h20xxh">DSi Aptina Camera Variables: RAM/SFR/MON (GPIO/Monitor) (MCU:0000h-20xxh)</A><BR>
<A HREF="#dsiaptinacameravariablesseqsequencermcu21xxh">DSi Aptina Camera Variables: SEQ (Sequencer) (MCU:21xxh)</A><BR>
<A HREF="#dsiaptinacameravariablesaeautoexposuremcu22xxh">DSi Aptina Camera Variables: AE (Auto Exposure) (MCU:22xxh)</A><BR>
<A HREF="#dsiaptinacameravariablesawbautowhitebalancemcu23xxh">DSi Aptina Camera Variables: AWB (Auto White Balance) (MCU:23xxh)</A><BR>
<A HREF="#dsiaptinacameravariablesfdantiflickermcu24xxh">DSi Aptina Camera Variables: FD (Anti-Flicker) (MCU:24xxh)</A><BR>
<A HREF="#dsiaptinacameravariablesmodemodecontextmcu27xxh">DSi Aptina Camera Variables: MODE (Mode/Context) (MCU:27xxh)</A><BR>
<A HREF="#dsiaptinacameravariableshghistogrammcu2bxxh">DSi Aptina Camera Variables: HG (Histogram) (MCU:2Bxxh)</A><BR>
<A HREF="#dsialternatecamerasfromunknownmanufacturer">DSi Alternate Cameras from Unknown Manufacturer</A><BR>
<A HREF="#dsicameras">DSi Cameras</A><BR>
<A HREF="#dsisdmmcprotocolandioports">DSi SD/MMC Protocol and I/O Ports</A><BR>
<A HREF="#dsisdmmcioportscommandparamresponsedata">DSi SD/MMC I/O Ports: Command/Param/Response/Data</A><BR>
<A HREF="#dsisdmmcioportscontrol">DSi SD/MMC I/O Ports: Control</A><BR>
<A HREF="#dsisdmmcioportsinterruptstatus">DSi SD/MMC I/O Ports: Interrupt/Status</A><BR>
<A HREF="#dsisdmmcioportsmisc">DSi SD/MMC I/O Ports: Misc</A><BR>
<A HREF="#dsisdmmcprotocolcommandresponseregistersummary">DSi SD/MMC Protocol: Command/Response/Register Summary</A><BR>
<A HREF="#dsisdmmcprotocolgeneralcommands">DSi SD/MMC Protocol: General Commands</A><BR>
<A HREF="#dsisdmmcprotocolblockreadwritecommands">DSi SD/MMC Protocol: Block Read/Write Commands</A><BR>
<A HREF="#dsisdmmcprotocolspecialextracommands">DSi SD/MMC Protocol: Special Extra Commands</A><BR>
<A HREF="#dsisdmmcprotocolcsrregister32bitcardstatusregister">DSi SD/MMC Protocol: CSR Register (32bit Card Status Register)</A><BR>
<A HREF="#dsisdmmcprotocolssrregister512bitsdstatusregister">DSi SD/MMC Protocol: SSR Register (512bit SD Status Register)</A><BR>
<A HREF="#dsisdmmcprotocolocrregister32bitoperationconditionsregister">DSi SD/MMC Protocol: OCR Register (32bit Operation Conditions Register)</A><BR>
<A HREF="#dsisdmmcprotocolcidregister128bitcardidentification">DSi SD/MMC Protocol: CID Register (128bit Card Identification)</A><BR>
<A HREF="#dsisdmmcprotocolcsdregister128bitcardspecificdata">DSi SD/MMC Protocol: CSD Register (128bit Card-Specific Data)</A><BR>
<A HREF="#dsisdmmcprotocolcsdregister128bitcardspecificdataversion20">DSi SD/MMC Protocol: CSD Register (128bit Card-Specific Data) Version 2.0</A><BR>
<A HREF="#dsisdmmcprotocolextcsdregister4096bitextendedcsdregistermmc">DSi SD/MMC Protocol: EXT_CSD Register (4096bit Extended CSD Register) (MMC)</A><BR>
<A HREF="#dsisdmmcprotocolrcaregister16bitrelativecardaddress">DSi SD/MMC Protocol: RCA Register (16bit Relative Card Address)</A><BR>
<A HREF="#dsisdmmcprotocoldsrregister16bitdriverstageregisteroptional">DSi SD/MMC Protocol: DSR Register (16bit Driver Stage Register) (Optional)</A><BR>
<A HREF="#dsisdmmcprotocolscrregister64bitsdcardconfigurationregister">DSi SD/MMC Protocol: SCR Register (64bit SD Card Configuration Register)</A><BR>
<A HREF="#dsisdmmcprotocolpwdregister128bitpasswordplus8bitpasswordlen">DSi SD/MMC Protocol: PWD Register (128bit Password plus 8bit Password len)</A><BR>
<A HREF="#dsisdmmcprotocolsignals">DSi SD/MMC Protocol: Signals</A><BR>
<A HREF="#dsisdmmcfilesystem">DSi SD/MMC Filesystem</A><BR>
<A HREF="#dsisdmmcpartitiontableakamasterbootrecordakambr">DSi SD/MMC Partition Table (aka Master Boot Record aka MBR)</A><BR>
<A HREF="#dsisdmmcfilesystemfat">DSi SD/MMC Filesystem (FAT)</A><BR>
<A HREF="#dsisdmmcinternalnandlayout">DSi SD/MMC Internal NAND Layout</A><BR>
<A HREF="#dsisdmmcbootloader">DSi SD/MMC Bootloader</A><BR>
<A HREF="#dsisdmmccompletelistofsdmmcfilesfolders">DSi SD/MMC Complete List of SD/MMC Files/Folders</A><BR>
<A HREF="#dsisdmmcsummaryofsdmmcfilesfolders">DSi SD/MMC Summary of SD/MMC Files/Folders</A><BR>
<A HREF="#dsisdmmcimages">DSi SD/MMC Images</A><BR>
<A HREF="#dsisdmmctadfilesonsdcards">DSi SD/MMC Tad Files on SD Cards</A><BR>
<A HREF="#dsisdmmcfirmwaredevkpandcertsyscertificatefiles">DSi SD/MMC Firmware dev.kp and cert.sys Certificate Files</A><BR>
<A HREF="#dsisdmmcfirmwarefontfile">DSi SD/MMC Firmware Font File</A><BR>
<A HREF="#dsisdmmcfirmwarelogfiles">DSi SD/MMC Firmware Log Files</A><BR>
<A HREF="#dsisdmmcfirmwaremiscfiles">DSi SD/MMC Firmware Misc Files</A><BR>
<A HREF="#dsisdmmcfirmwarewififirmware">DSi SD/MMC Firmware Wifi Firmware</A><BR>
<A HREF="#dsisdmmcfirmwaresystemsettingsdatafiles">DSi SD/MMC Firmware System Settings Data Files</A><BR>
<A HREF="#dsisdmmcfirmwaretitlemetadatatmdfiles">DSi SD/MMC Firmware Title metadata (.tmd) Files</A><BR>
<A HREF="#dsisdmmcfirmwareversiondatafile">DSi SD/MMC Firmware Version Data File</A><BR>
<A HREF="#dsisdmmcfirmwarenintendodscartwhitelistfile">DSi SD/MMC Firmware Nintendo DS Cart Whitelist File</A><BR>
<A HREF="#dsisdmmccamerafilesoverview">DSi SD/MMC Camera Files - Overview</A><BR>
<A HREF="#dsisdmmccamerafilesjpegs">DSi SD/MMC Camera Files - JPEG's</A><BR>
<A HREF="#dsisdmmccamerafilespitbin">DSi SD/MMC Camera Files - pit.bin</A><BR>
<A HREF="#dsigpioregisters">DSi GPIO Registers</A><BR>
<A HREF="#dsiconsoleids">DSi Console IDs</A><BR>
<A HREF="#dsiunknownregisters">DSi Unknown Registers</A><BR>
<A HREF="#dsinotes">DSi Notes</A><BR>
<A HREF="#dsiexploits">DSi Exploits</A><BR>
<A HREF="#dsiregions">DSi Regions</A><BR>
<A HREF="#armcpureference">ARM CPU Reference</A><BR>
<A HREF="#armcpuoverview">ARM CPU Overview</A><BR>
<A HREF="#armcpuregisterset">ARM CPU Register Set</A><BR>
<A HREF="#armcpuflagsconditionfieldcond">ARM CPU Flags &amp; Condition Field (cond)</A><BR>
<A HREF="#armcpu26bitmemoryinterface">ARM CPU 26bit Memory Interface</A><BR>
<A HREF="#armcpuexceptions">ARM CPU Exceptions</A><BR>
<A HREF="#armcpumemoryalignments">ARM CPU Memory Alignments</A><BR>
<A HREF="#arminstructionsummary">ARM Instruction Summary</A><BR>
<A HREF="#armopcodesbranchandbranchwithlinkbblbxblxswibkpt">ARM Opcodes: Branch and Branch with Link (B, BL, BX, BLX, SWI, BKPT)</A><BR>
<A HREF="#armopcodesdataprocessingalu">ARM Opcodes: Data Processing (ALU)</A><BR>
<A HREF="#armopcodesmultiplyandmultiplyaccumulatemulmla">ARM Opcodes: Multiply and Multiply-Accumulate (MUL, MLA)</A><BR>
<A HREF="#armopcodesspecialarm9instructionsclzqaddqsub">ARM Opcodes: Special ARM9 Instructions (CLZ, QADD/QSUB)</A><BR>
<A HREF="#armopcodespsrtransfermrsmsr">ARM Opcodes: PSR Transfer (MRS, MSR)</A><BR>
<A HREF="#armopcodesmemorysingledatatransferldrstrpld">ARM Opcodes: Memory: Single Data Transfer (LDR, STR, PLD)</A><BR>
<A HREF="#armopcodesmemoryhalfworddoublewordandsigneddatatransfer">ARM Opcodes: Memory: Halfword, Doubleword, and Signed Data Transfer</A><BR>
<A HREF="#armopcodesmemoryblockdatatransferldmstm">ARM Opcodes: Memory: Block Data Transfer (LDM, STM)</A><BR>
<A HREF="#armopcodesmemorysingledataswapswp">ARM Opcodes: Memory: Single Data Swap (SWP)</A><BR>
<A HREF="#armopcodescoprocessorinstructionsmrcmcrldcstccdpmcrrmrrc">ARM Opcodes: Coprocessor Instructions (MRC/MCR, LDC/STC, CDP, MCRR/MRRC)</A><BR>
<A HREF="#thumbinstructionsummary">THUMB Instruction Summary</A><BR>
<A HREF="#thumbopcodesregisteroperationsalubx">THUMB Opcodes: Register Operations (ALU, BX)</A><BR>
<A HREF="#thumbopcodesmemoryloadstoreldrstr">THUMB Opcodes: Memory Load/Store (LDR/STR)</A><BR>
<A HREF="#thumbopcodesmemoryaddressingaddpcsp">THUMB Opcodes: Memory Addressing (ADD PC/SP)</A><BR>
<A HREF="#thumbopcodesmemorymultipleloadstorepushpopandldmstm">THUMB Opcodes: Memory Multiple Load/Store (PUSH/POP and LDM/STM)</A><BR>
<A HREF="#thumbopcodesjumpsandcalls">THUMB Opcodes: Jumps and Calls</A><BR>
<A HREF="#armpseudoinstructionsanddirectives">ARM Pseudo Instructions and Directives</A><BR>
<A HREF="#armcp14icebreakerdebugcommunicationschannel">ARM CP14 ICEbreaker Debug Communications Channel</A><BR>
<A HREF="#armcp15systemcontrolcoprocessor">ARM CP15 System Control Coprocessor</A><BR>
<A HREF="#armcp15overview">ARM CP15 Overview</A><BR>
<A HREF="#armcp15idcodes">ARM CP15 ID Codes</A><BR>
<A HREF="#armcp15controlregister">ARM CP15 Control Register</A><BR>
<A HREF="#armcp15memorymanagmentunitmmu">ARM CP15 Memory Managment Unit (MMU)</A><BR>
<A HREF="#armcp15protectionunitpu">ARM CP15 Protection Unit (PU)</A><BR>
<A HREF="#armcp15cachecontrol">ARM CP15 Cache Control</A><BR>
<A HREF="#armcp15tightlycoupledmemorytcm">ARM CP15 Tightly Coupled Memory (TCM)</A><BR>
<A HREF="#armcp15misc">ARM CP15 Misc</A><BR>
<A HREF="#armcpuinstructioncycletimes">ARM CPU Instruction Cycle Times</A><BR>
<A HREF="#armcpuversions">ARM CPU Versions</A><BR>
<A HREF="#armcpudatasheet">ARM CPU Data Sheet</A><BR>
<A HREF="#biosfunctions">BIOS Functions</A><BR>
<A HREF="#biosfunctionsummary">BIOS Function Summary</A><BR>
<A HREF="#biosdifferencesbetweengbaandndsfunctions">BIOS Differences between GBA and NDS functions</A><BR>
<A HREF="#biosarithmeticfunctions">BIOS Arithmetic Functions</A><BR>
<A HREF="#biosrotationscalingfunctions">BIOS Rotation/Scaling Functions</A><BR>
<A HREF="#biosdecompressionfunctions">BIOS Decompression Functions</A><BR>
<A HREF="#biosmemorycopy">BIOS Memory Copy</A><BR>
<A HREF="#bioshaltfunctions">BIOS Halt Functions</A><BR>
<A HREF="#biosresetfunctions">BIOS Reset Functions</A><BR>
<A HREF="#biosmiscfunctions">BIOS Misc Functions</A><BR>
<A HREF="#biosmultibootsinglegamepak">BIOS Multi Boot (Single Game Pak)</A><BR>
<A HREF="#biossoundfunctions">BIOS Sound Functions</A><BR>
<A HREF="#biossha1functionsdsionly">BIOS SHA1 Functions (DSi only)</A><BR>
<A HREF="#biosrsafunctionsdsionly">BIOS RSA Functions (DSi only)</A><BR>
<A HREF="#biosramusage">BIOS RAM Usage</A><BR>
<A HREF="#biosdumping">BIOS Dumping</A><BR>
<A HREF="#externalconnectors">External Connectors</A><BR>
<A HREF="#auxgbagamepakbus">AUX GBA Game Pak Bus</A><BR>
<A HREF="#auxdsgamecardslot">AUX DS Game Card Slot</A><BR>
<A HREF="#auxlinkport">AUX Link Port</A><BR>
<A HREF="#auxsoundheadphonesocketandbatterypowersupply">AUX Sound/Headphone Socket and Battery/Power Supply</A><BR>
<A HREF="#auxdsisdmmcpinouts">AUX DSi SD/MMC Pin-Outs</A><BR>
<A HREF="#auxopeningthegba">AUX Opening the GBA</A><BR>
<A HREF="#auxmainboard">AUX Mainboard</A><BR>
<A HREF="#auxdsicomponentlists">AUX DSi Component Lists</A><BR>
<A HREF="#auxdsiinternalconnectors">AUX DSi Internal Connectors</A><BR>
<A HREF="#auxdsichipsetpinouts">AUX DSi Chipset Pinouts</A><BR>
<A HREF="#pinoutscpusignalsummary">Pinouts - CPU - Signal Summary</A><BR>
<A HREF="#pinoutscpupinouts">Pinouts - CPU - Pinouts</A><BR>
<A HREF="#pinoutsaudioamplifiers">Pinouts - Audio Amplifiers</A><BR>
<A HREF="#pinoutslcdcables">Pinouts - LCD Cables</A><BR>
<A HREF="#pinoutspowerswitchesdcdcconvertersresetgenerators">Pinouts - Power Switches, DC/DC Converters, Reset Generators</A><BR>
<A HREF="#pinoutswifi">Pinouts - Wifi</A><BR>
<A HREF="#pinoutsvarious">Pinouts - Various</A><BR>
<A HREF="#auxxboopctogbamultibootcable">AUX Xboo PC-to-GBA Multiboot Cable</A><BR>
<A HREF="#auxxbooflashcardupload">AUX Xboo Flashcard Upload</A><BR>
<A HREF="#auxxbooburstbootbackdoor">AUX Xboo Burst Boot Backdoor</A><BR>
<A HREF="#aboutthisdocument">About this Document</A><BR>
<BR>
[extracted from no$gba v2.8a documentation]<BR>
</BODY></HTML>
